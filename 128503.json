{"path":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n      \n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.getPayloadLength() != 0) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5c4531fadbecf73a7716fdf5cd742463e866e84e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5c4531fadbecf73a7716fdf5cd742463e866e84e","date":1273851662,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n      \n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n      \n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.getPayloadLength() != 0) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6267e1ce56c2eec111425690cd04e251b6f14952","date":1275222352,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n      \n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n      \n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08932c793647a36953d1816b1060121f48820d3f","date":1277386540,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n      \n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n      \n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n      \n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n      \n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba8cd9ac7a0f3ad09c6c94f53c4c415d13e72723","date":1286186570,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          termCount = status.termCount;\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n      \n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea279fca7799054e31e74cff05202634ebd91281","date":1286992274,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          termCount = status.termCount;\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          termCount = status.termCount;\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a493e6d0c3ad86bd55c0a1360d110142e948f2bd","date":1289406991,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85a883878c0af761245ab048babc63d099f835f3","date":1289553330,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n      \n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6ecd298fdc085e7eba27afa7fae58df1ba1a2808","date":1295102557,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16843358872ed92ba92888ab99df297550b9a36a","date":1295144724,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1add9ddc0005b07550d4350720aac22dc9886b3","date":1295549635,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n\n          // Now count how many deleted docs occurred in\n          // this term:\n\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            int count = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            if (count != docFreq) {\n              throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + count);\n            }\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d161ff99970d1d549046fbc7aee3290d4f996cb","date":1301757574,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(delDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45669a651c970812a680841b97a77cce06af559f","date":1301922222,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(delDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a653ca3bb595a9c1f775fc44684e6ba7daafd3f5","date":1302211592,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(delDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(delDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(delDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":["e7f7a53951c27f2ba1fb2e176e6e7b9e86e33ee8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"962d04139994fce5193143ef35615499a9a96d78","date":1302693744,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(delDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(delDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(delDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(delDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(delDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(delDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(delDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          if (postings != null) {\n            docs2 = postings;\n          } else {\n            docs2 = docs;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd9cc9d77712aba3662f24632df7539ab75e3667","date":1309095238,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(delDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(delDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(delDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(delDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(delDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(delDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(delDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(delDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","date":1309960478,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(liveDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(liveDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(delDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(delDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(liveDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(liveDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(delDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(delDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(liveDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(liveDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits delDocs = reader.getDeletedDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(delDocs, docs);\n          postings = terms.docsAndPositions(delDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(delDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(delDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seek(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(delDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4f2f9fd0a641ccc0cc6a4fb4e53d7ec1ab14a94","date":1310159023,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(liveDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(liveDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n        \n        if (sumDocFreq != 0) {\n          final long v = fields.terms(field).getSumDocFreq();\n          if (v != -1 && sumDocFreq != v) {\n            throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(liveDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(liveDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"63639dd66fd5bd9b90bc24dd596ae01575f27cc4","date":1310237454,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(liveDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(liveDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n        \n        if (sumDocFreq != 0) {\n          final long v = fields.terms(field).getSumDocFreq();\n          if (v != -1 && sumDocFreq != v) {\n            throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(liveDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(liveDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7f7a53951c27f2ba1fb2e176e6e7b9e86e33ee8","date":1310900031,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(liveDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos < lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(liveDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n        \n        if (sumDocFreq != 0) {\n          final long v = fields.terms(field).getSumDocFreq();\n          if (v != -1 && sumDocFreq != v) {\n            throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(liveDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos <= lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is <= lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(liveDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n        \n        if (sumDocFreq != 0) {\n          final long v = fields.terms(field).getSumDocFreq();\n          if (v != -1 && sumDocFreq != v) {\n            throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":["a653ca3bb595a9c1f775fc44684e6ba7daafd3f5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c746cc69ff433a2c55683bedfeb889359b0d2808","date":1310904161,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = terms.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n        \n        if (sumDocFreq != 0) {\n          final long v = fields.terms(field).getSumDocFreq();\n          if (v != -1 && sumDocFreq != v) {\n            throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (docFreq >= 16) {\n            if (hasPositions) {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                postings = terms.docsAndPositions(liveDocs, postings);\n                final int docID = postings.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int freq = postings.freq();\n                  if (freq <= 0) {\n                    throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                  }\n                  int lastPosition = -1;\n                  for(int posUpto=0;posUpto<freq;posUpto++) {\n                    final int pos = postings.nextPosition();\n                    if (pos < 0) {\n                      throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                    }\n                    if (pos < lastPosition) {\n                      throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                    }\n                    lastPosition = pos;\n                  } \n\n                  final int nextDocID = postings.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            } else {\n              for(int idx=0;idx<7;idx++) {\n                final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n                docs = terms.docs(liveDocs, docs);\n                final int docID = docs.advance(skipDocID);\n                if (docID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                } else {\n                  if (docID < skipDocID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                  }\n                  final int nextDocID = docs.nextDoc();\n                  if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                    break;\n                  }\n                  if (nextDocID <= docID) {\n                    throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n        \n        if (sumDocFreq != 0) {\n          final long v = fields.terms(field).getSumDocFreq();\n          if (v != -1 && sumDocFreq != v) {\n            throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = terms.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n          final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n          assert stats != null;\n          if (status.blockTreeStats == null) {\n            status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n          }\n          status.blockTreeStats.put(field, stats);\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n        \n        if (sumDocFreq != 0) {\n          final long v = fields.terms(field).getSumDocFreq();\n          if (v != -1 && sumDocFreq != v) {\n            throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = terms.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n        \n        if (sumDocFreq != 0) {\n          final long v = fields.terms(field).getSumDocFreq();\n          if (v != -1 && sumDocFreq != v) {\n            throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) {\n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"156c553d9c7f34542f151684a6d2bfa3889d62da","date":1315520680,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = terms.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          if (fieldsEnum.terms().next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n\n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            long termCount;\n            try {\n              termCount = fields.terms(field).getUniqueTermCount();\n            } catch (UnsupportedOperationException uoe) {\n              termCount = -1;\n            }\n\n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                terms.seekExact(ord);\n                seekTerms[i] = new BytesRef(terms.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = terms.docs(liveDocs, docs);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = terms.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n          final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n          assert stats != null;\n          if (status.blockTreeStats == null) {\n            status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n          }\n          status.blockTreeStats.put(field, stats);\n        }\n\n        if (sumTotalTermFreq != 0) {\n          final long v = fields.terms(field).getSumTotalTermFreq();\n          if (v != -1 && sumTotalTermFreq != v) {\n            throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n          }\n        }\n        \n        if (sumDocFreq != 0) {\n          final long v = fields.terms(field).getSumDocFreq();\n          if (v != -1 && sumDocFreq != v) {\n            throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n          }\n        }\n\n        // Test seek to last term:\n        if (lastTerm != null) {\n          if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n            throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n          }\n\n          is.search(new TermQuery(new Term(field, lastTerm)), 1);\n        }\n\n        // Test seeking by ord\n        if (hasOrd && status.termCount-termCountStart > 0) {\n          long termCount;\n          try {\n            termCount = fields.terms(field).getUniqueTermCount();\n          } catch (UnsupportedOperationException uoe) {\n            termCount = -1;\n          }\n\n          if (termCount != -1 && termCount != status.termCount - termCountStart) {\n            throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n          }\n\n          int seekCount = (int) Math.min(10000L, termCount);\n          if (seekCount > 0) {\n            BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n            // Seek by ord\n            for(int i=seekCount-1;i>=0;i--) {\n              long ord = i*(termCount/seekCount);\n              terms.seekExact(ord);\n              seekTerms[i] = new BytesRef(terms.term());\n            }\n\n            // Seek by term\n            long totDocCount = 0;\n            for(int i=seekCount-1;i>=0;i--) {\n              if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n              }\n              \n              docs = terms.docs(liveDocs, docs);\n              if (docs == null) {\n                throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n              }\n\n              while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                totDocCount++;\n              }\n            }\n\n            // TermQuery\n            long totDocCount2 = 0;\n            for(int i=0;i<seekCount;i++) {\n              totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n            }\n\n            if (totDocCount != totDocCount2) {\n              throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25433c5cacacb7a2055d62d4d36b0daf210e0a10","date":1315747522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              visitedDocs.set(docsNoDel.docID());\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = terms.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          if (fieldsEnum.terms().next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n        if (fieldTerms != null) {\n          final int v = fieldTerms.getDocCount();\n          if (v != -1 && visitedDocs.cardinality() != v) {\n            throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n          }\n        }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n\n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            long termCount;\n            try {\n              termCount = fields.terms(field).getUniqueTermCount();\n            } catch (UnsupportedOperationException uoe) {\n              termCount = -1;\n            }\n\n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                terms.seekExact(ord);\n                seekTerms[i] = new BytesRef(terms.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = terms.docs(liveDocs, docs);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = terms.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          if (fieldsEnum.terms().next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n\n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            long termCount;\n            try {\n              termCount = fields.terms(field).getUniqueTermCount();\n            } catch (UnsupportedOperationException uoe) {\n              termCount = -1;\n            }\n\n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                terms.seekExact(ord);\n                seekTerms[i] = new BytesRef(terms.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = terms.docs(liveDocs, docs);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5145e7af5e55022ec6ba083c0aef480e49e0d3b","date":1319475599,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          if (docFreq <= 0) {\n            throw new RuntimeException(\"docfreq: \" + docFreq + \" is out of bounds\");\n          }\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              visitedDocs.set(docsNoDel.docID());\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            if (totalTermFreq2 <= 0) {\n              throw new RuntimeException(\"totalTermFreq: \" + totalTermFreq2 + \" is out of bounds\");\n            }\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = terms.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          if (fieldsEnum.terms().next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n        if (fieldTerms != null) {\n          final int v = fieldTerms.getDocCount();\n          if (v != -1 && visitedDocs.cardinality() != v) {\n            throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n          }\n        }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n\n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            long termCount;\n            try {\n              termCount = fields.terms(field).getUniqueTermCount();\n            } catch (UnsupportedOperationException uoe) {\n              termCount = -1;\n            }\n\n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                terms.seekExact(ord);\n                seekTerms[i] = new BytesRef(terms.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = terms.docs(liveDocs, docs);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              visitedDocs.set(docsNoDel.docID());\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = terms.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          if (fieldsEnum.terms().next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n        if (fieldTerms != null) {\n          final int v = fieldTerms.getDocCount();\n          if (v != -1 && visitedDocs.cardinality() != v) {\n            throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n          }\n        }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n\n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            long termCount;\n            try {\n              termCount = fields.terms(field).getUniqueTermCount();\n            } catch (UnsupportedOperationException uoe) {\n              termCount = -1;\n            }\n\n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                terms.seekExact(ord);\n                seekTerms[i] = new BytesRef(terms.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = terms.docs(liveDocs, docs);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f458fcb817a740e7906774b7ca2c54d37b34f24f","date":1319501743,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          if (docFreq <= 0) {\n            throw new RuntimeException(\"docfreq: \" + docFreq + \" is out of bounds\");\n          }\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              visitedDocs.set(docsNoDel.docID());\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            if (totalTermFreq2 <= 0) {\n              throw new RuntimeException(\"totalTermFreq: \" + totalTermFreq2 + \" is out of bounds\");\n            }\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = terms.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          if (fieldsEnum.terms().next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n        if (fieldTerms != null) {\n          final int v = fieldTerms.getDocCount();\n          if (v != -1 && visitedDocs.cardinality() != v) {\n            throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n          }\n        }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n          \n          // check unique term count\n          long termCount = -1;\n          \n          if (status.termCount-termCountStart > 0) {\n            termCount = fields.terms(field).getUniqueTermCount();\n            \n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n          }\n          \n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                terms.seekExact(ord);\n                seekTerms[i] = new BytesRef(terms.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = terms.docs(liveDocs, docs);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n\n      // for most implementations, this is boring (just the sum across all fields)\n      // but codecs that don't work per-field like preflex actually implement this,\n      // but don't implement it on Terms, so the check isn't redundant.\n      long uniqueTermCountAllFields = reader.getUniqueTermCount();\n      \n      // this means something is seriously screwed, e.g. we are somehow getting enclosed in PFCW!!!!!!\n      \n      if (uniqueTermCountAllFields == -1) {\n        throw new RuntimeException(\"invalid termCount: -1\");\n     }\n\n      if (status.termCount != uniqueTermCountAllFields) {\n        throw new RuntimeException(\"termCount mismatch \" + uniqueTermCountAllFields + \" vs \" + (status.termCount));\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          if (docFreq <= 0) {\n            throw new RuntimeException(\"docfreq: \" + docFreq + \" is out of bounds\");\n          }\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              visitedDocs.set(docsNoDel.docID());\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            if (totalTermFreq2 <= 0) {\n              throw new RuntimeException(\"totalTermFreq: \" + totalTermFreq2 + \" is out of bounds\");\n            }\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = terms.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          if (fieldsEnum.terms().next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n        if (fieldTerms != null) {\n          final int v = fieldTerms.getDocCount();\n          if (v != -1 && visitedDocs.cardinality() != v) {\n            throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n          }\n        }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n\n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            long termCount;\n            try {\n              termCount = fields.terms(field).getUniqueTermCount();\n            } catch (UnsupportedOperationException uoe) {\n              termCount = -1;\n            }\n\n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                terms.seekExact(ord);\n                seekTerms[i] = new BytesRef(terms.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = terms.docs(liveDocs, docs);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      int computedFieldCount = 0;\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n\n        // TODO: really the codec should not return a field\n        // from FieldsEnum if it has to Terms... but we do\n        // this today:\n        // assert fields.terms(field) != null;\n        computedFieldCount++;\n        \n        final Terms terms = fieldsEnum.terms();\n        if (terms == null) {\n          continue;\n        }\n\n        final TermsEnum termsEnum = terms.iterator(null);\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = termsEnum.docFreq();\n          if (docFreq <= 0) {\n            throw new RuntimeException(\"docfreq: \" + docFreq + \" is out of bounds\");\n          }\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = termsEnum.docs(liveDocs, docs);\n          postings = termsEnum.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = termsEnum.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = termsEnum.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = termsEnum.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              visitedDocs.set(docsNoDel.docID());\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            if (totalTermFreq2 <= 0) {\n              throw new RuntimeException(\"totalTermFreq: \" + totalTermFreq2 + \" is out of bounds\");\n            }\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = termsEnum.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = termsEnum.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          final Terms fieldTerms2 = fieldsEnum.terms();\n          if (fieldTerms2 != null && fieldTerms2.iterator(null).next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n          if (fieldTerms != null) {\n            final int v = fieldTerms.getDocCount();\n            if (v != -1 && visitedDocs.cardinality() != v) {\n              throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n            }\n          }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (termsEnum.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n          \n          // check unique term count\n          long termCount = -1;\n          \n          if (status.termCount-termCountStart > 0) {\n            termCount = fields.terms(field).getUniqueTermCount();\n            \n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n          }\n          \n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                termsEnum.seekExact(ord);\n                seekTerms[i] = new BytesRef(termsEnum.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (termsEnum.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = termsEnum.docs(liveDocs, docs);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n      \n      int fieldCount = fields.getUniqueFieldCount();\n      \n      if (fieldCount != -1) {\n        if (fieldCount < 0) {\n          throw new RuntimeException(\"invalid fieldCount: \" + fieldCount);\n        }\n        if (fieldCount != computedFieldCount) {\n          throw new RuntimeException(\"fieldCount mismatch \" + fieldCount + \" vs recomputed field count \" + computedFieldCount);\n        }\n      }\n\n      // for most implementations, this is boring (just the sum across all fields)\n      // but codecs that don't work per-field like preflex actually implement this,\n      // but don't implement it on Terms, so the check isn't redundant.\n      long uniqueTermCountAllFields = reader.getUniqueTermCount();\n      \n      // this means something is seriously screwed, e.g. we are somehow getting enclosed in PFCW!!!!!!\n      \n      if (uniqueTermCountAllFields == -1) {\n        throw new RuntimeException(\"invalid termCount: -1\");\n     }\n\n      if (status.termCount != uniqueTermCountAllFields) {\n        throw new RuntimeException(\"termCount mismatch \" + uniqueTermCountAllFields + \" vs \" + (status.termCount));\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n        \n        final TermsEnum terms = fieldsEnum.terms();\n        assert terms != null;\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = terms.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = terms.docFreq();\n          if (docFreq <= 0) {\n            throw new RuntimeException(\"docfreq: \" + docFreq + \" is out of bounds\");\n          }\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = terms.docs(liveDocs, docs);\n          postings = terms.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = terms.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = terms.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = terms.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              visitedDocs.set(docsNoDel.docID());\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            if (totalTermFreq2 <= 0) {\n              throw new RuntimeException(\"totalTermFreq: \" + totalTermFreq2 + \" is out of bounds\");\n            }\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = terms.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = terms.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          if (fieldsEnum.terms().next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n        if (fieldTerms != null) {\n          final int v = fieldTerms.getDocCount();\n          if (v != -1 && visitedDocs.cardinality() != v) {\n            throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n          }\n        }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n          \n          // check unique term count\n          long termCount = -1;\n          \n          if (status.termCount-termCountStart > 0) {\n            termCount = fields.terms(field).getUniqueTermCount();\n            \n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n          }\n          \n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                terms.seekExact(ord);\n                seekTerms[i] = new BytesRef(terms.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = terms.docs(liveDocs, docs);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n\n      // for most implementations, this is boring (just the sum across all fields)\n      // but codecs that don't work per-field like preflex actually implement this,\n      // but don't implement it on Terms, so the check isn't redundant.\n      long uniqueTermCountAllFields = reader.getUniqueTermCount();\n      \n      // this means something is seriously screwed, e.g. we are somehow getting enclosed in PFCW!!!!!!\n      \n      if (uniqueTermCountAllFields == -1) {\n        throw new RuntimeException(\"invalid termCount: -1\");\n     }\n\n      if (status.termCount != uniqueTermCountAllFields) {\n        throw new RuntimeException(\"termCount mismatch \" + uniqueTermCountAllFields + \" vs \" + (status.termCount));\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6e919043fa85ee891123768dd655a98edbbf63c","date":1322225413,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      int computedFieldCount = 0;\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n\n        // TODO: really the codec should not return a field\n        // from FieldsEnum if it has to Terms... but we do\n        // this today:\n        // assert fields.terms(field) != null;\n        computedFieldCount++;\n        \n        final Terms terms = fieldsEnum.terms();\n        if (terms == null) {\n          continue;\n        }\n\n        final TermsEnum termsEnum = terms.iterator(null);\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = BytesRef.deepCopyOf(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copyBytes(term);\n          }\n\n          final int docFreq = termsEnum.docFreq();\n          if (docFreq <= 0) {\n            throw new RuntimeException(\"docfreq: \" + docFreq + \" is out of bounds\");\n          }\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = termsEnum.docs(liveDocs, docs);\n          postings = termsEnum.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = termsEnum.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = termsEnum.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = termsEnum.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              visitedDocs.set(docsNoDel.docID());\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            if (totalTermFreq2 <= 0) {\n              throw new RuntimeException(\"totalTermFreq: \" + totalTermFreq2 + \" is out of bounds\");\n            }\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = termsEnum.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = termsEnum.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          final Terms fieldTerms2 = fieldsEnum.terms();\n          if (fieldTerms2 != null && fieldTerms2.iterator(null).next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n          if (fieldTerms != null) {\n            final int v = fieldTerms.getDocCount();\n            if (v != -1 && visitedDocs.cardinality() != v) {\n              throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n            }\n          }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (termsEnum.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n          \n          // check unique term count\n          long termCount = -1;\n          \n          if (status.termCount-termCountStart > 0) {\n            termCount = fields.terms(field).getUniqueTermCount();\n            \n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n          }\n          \n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                termsEnum.seekExact(ord);\n                seekTerms[i] = BytesRef.deepCopyOf(termsEnum.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (termsEnum.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = termsEnum.docs(liveDocs, docs);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n      \n      int fieldCount = fields.getUniqueFieldCount();\n      \n      if (fieldCount != -1) {\n        if (fieldCount < 0) {\n          throw new RuntimeException(\"invalid fieldCount: \" + fieldCount);\n        }\n        if (fieldCount != computedFieldCount) {\n          throw new RuntimeException(\"fieldCount mismatch \" + fieldCount + \" vs recomputed field count \" + computedFieldCount);\n        }\n      }\n\n      // for most implementations, this is boring (just the sum across all fields)\n      // but codecs that don't work per-field like preflex actually implement this,\n      // but don't implement it on Terms, so the check isn't redundant.\n      long uniqueTermCountAllFields = reader.getUniqueTermCount();\n      \n      // this means something is seriously screwed, e.g. we are somehow getting enclosed in PFCW!!!!!!\n      \n      if (uniqueTermCountAllFields == -1) {\n        throw new RuntimeException(\"invalid termCount: -1\");\n     }\n\n      if (status.termCount != uniqueTermCountAllFields) {\n        throw new RuntimeException(\"termCount mismatch \" + uniqueTermCountAllFields + \" vs \" + (status.termCount));\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      int computedFieldCount = 0;\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n\n        // TODO: really the codec should not return a field\n        // from FieldsEnum if it has to Terms... but we do\n        // this today:\n        // assert fields.terms(field) != null;\n        computedFieldCount++;\n        \n        final Terms terms = fieldsEnum.terms();\n        if (terms == null) {\n          continue;\n        }\n\n        final TermsEnum termsEnum = terms.iterator(null);\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = new BytesRef(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copy(term);\n          }\n\n          final int docFreq = termsEnum.docFreq();\n          if (docFreq <= 0) {\n            throw new RuntimeException(\"docfreq: \" + docFreq + \" is out of bounds\");\n          }\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = termsEnum.docs(liveDocs, docs);\n          postings = termsEnum.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = termsEnum.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = termsEnum.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = termsEnum.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              visitedDocs.set(docsNoDel.docID());\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            if (totalTermFreq2 <= 0) {\n              throw new RuntimeException(\"totalTermFreq: \" + totalTermFreq2 + \" is out of bounds\");\n            }\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = termsEnum.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = termsEnum.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          final Terms fieldTerms2 = fieldsEnum.terms();\n          if (fieldTerms2 != null && fieldTerms2.iterator(null).next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n          if (fieldTerms != null) {\n            final int v = fieldTerms.getDocCount();\n            if (v != -1 && visitedDocs.cardinality() != v) {\n              throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n            }\n          }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (termsEnum.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n          \n          // check unique term count\n          long termCount = -1;\n          \n          if (status.termCount-termCountStart > 0) {\n            termCount = fields.terms(field).getUniqueTermCount();\n            \n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n          }\n          \n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                termsEnum.seekExact(ord);\n                seekTerms[i] = new BytesRef(termsEnum.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (termsEnum.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = termsEnum.docs(liveDocs, docs);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n      \n      int fieldCount = fields.getUniqueFieldCount();\n      \n      if (fieldCount != -1) {\n        if (fieldCount < 0) {\n          throw new RuntimeException(\"invalid fieldCount: \" + fieldCount);\n        }\n        if (fieldCount != computedFieldCount) {\n          throw new RuntimeException(\"fieldCount mismatch \" + fieldCount + \" vs recomputed field count \" + computedFieldCount);\n        }\n      }\n\n      // for most implementations, this is boring (just the sum across all fields)\n      // but codecs that don't work per-field like preflex actually implement this,\n      // but don't implement it on Terms, so the check isn't redundant.\n      long uniqueTermCountAllFields = reader.getUniqueTermCount();\n      \n      // this means something is seriously screwed, e.g. we are somehow getting enclosed in PFCW!!!!!!\n      \n      if (uniqueTermCountAllFields == -1) {\n        throw new RuntimeException(\"invalid termCount: -1\");\n     }\n\n      if (status.termCount != uniqueTermCountAllFields) {\n        throw new RuntimeException(\"termCount mismatch \" + uniqueTermCountAllFields + \" vs \" + (status.termCount));\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"872cff1d3a554e0cd64014cd97f88d3002b0f491","date":1323024658,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      int computedFieldCount = 0;\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsEnum docsAndFreqs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n\n        // TODO: really the codec should not return a field\n        // from FieldsEnum if it has to Terms... but we do\n        // this today:\n        // assert fields.terms(field) != null;\n        computedFieldCount++;\n        \n        final Terms terms = fieldsEnum.terms();\n        if (terms == null) {\n          continue;\n        }\n\n        final TermsEnum termsEnum = terms.iterator(null);\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = BytesRef.deepCopyOf(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copyBytes(term);\n          }\n\n          final int docFreq = termsEnum.docFreq();\n          if (docFreq <= 0) {\n            throw new RuntimeException(\"docfreq: \" + docFreq + \" is out of bounds\");\n          }\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = termsEnum.docs(liveDocs, docs, false);\n          docsAndFreqs = termsEnum.docs(liveDocs, docsAndFreqs, true);\n          postings = termsEnum.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = termsEnum.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final DocsEnum docsAndFreqs2;\n          final boolean hasPositions;\n          final boolean hasFreqs;\n          if (postings != null) {\n            docs2 = postings;\n            docsAndFreqs2 = postings;\n            hasPositions = true;\n            hasFreqs = true;\n          } else if (docsAndFreqs != null) {\n            docs2 = docsAndFreqs;\n            docsAndFreqs2 = docsAndFreqs;\n            hasPositions = false;\n            hasFreqs = true;\n          } else {\n            docs2 = docs;\n            docsAndFreqs2 = null;\n            hasPositions = false;\n            hasFreqs = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            int freq = -1;\n            if (hasFreqs) {\n              freq = docsAndFreqs2.freq();\n              if (freq <= 0) {\n                throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n              }\n              status.totPos += freq;\n              totalTermFreq += freq;\n            }\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            \n            int lastPos = -1;\n            if (hasPositions) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = termsEnum.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            if (hasFreqs) {\n              final DocsEnum docsNoDel = termsEnum.docs(null, docsAndFreqs, true);\n              docCount = 0;\n              totalTermFreq = 0;\n              while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n                visitedDocs.set(docsNoDel.docID());\n                docCount++;\n                totalTermFreq += docsNoDel.freq();\n              }\n            } else {\n              final DocsEnum docsNoDel = termsEnum.docs(null, docs, false);\n              docCount = 0;\n              totalTermFreq = -1;\n              while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n                visitedDocs.set(docsNoDel.docID());\n                docCount++;\n              }\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            if (totalTermFreq2 <= 0) {\n              throw new RuntimeException(\"totalTermFreq: \" + totalTermFreq2 + \" is out of bounds\");\n            }\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = termsEnum.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = termsEnum.docs(liveDocs, docs, false);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          final Terms fieldTerms2 = fieldsEnum.terms();\n          if (fieldTerms2 != null && fieldTerms2.iterator(null).next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n          if (fieldTerms != null) {\n            final int v = fieldTerms.getDocCount();\n            if (v != -1 && visitedDocs.cardinality() != v) {\n              throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n            }\n          }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (termsEnum.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n          \n          // check unique term count\n          long termCount = -1;\n          \n          if (status.termCount-termCountStart > 0) {\n            termCount = fields.terms(field).getUniqueTermCount();\n            \n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n          }\n          \n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                termsEnum.seekExact(ord);\n                seekTerms[i] = BytesRef.deepCopyOf(termsEnum.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (termsEnum.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = termsEnum.docs(liveDocs, docs, false);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n      \n      int fieldCount = fields.getUniqueFieldCount();\n      \n      if (fieldCount != -1) {\n        if (fieldCount < 0) {\n          throw new RuntimeException(\"invalid fieldCount: \" + fieldCount);\n        }\n        if (fieldCount != computedFieldCount) {\n          throw new RuntimeException(\"fieldCount mismatch \" + fieldCount + \" vs recomputed field count \" + computedFieldCount);\n        }\n      }\n\n      // for most implementations, this is boring (just the sum across all fields)\n      // but codecs that don't work per-field like preflex actually implement this,\n      // but don't implement it on Terms, so the check isn't redundant.\n      long uniqueTermCountAllFields = reader.getUniqueTermCount();\n      \n      // this means something is seriously screwed, e.g. we are somehow getting enclosed in PFCW!!!!!!\n      \n      if (uniqueTermCountAllFields == -1) {\n        throw new RuntimeException(\"invalid termCount: -1\");\n     }\n\n      if (status.termCount != uniqueTermCountAllFields) {\n        throw new RuntimeException(\"termCount mismatch \" + uniqueTermCountAllFields + \" vs \" + (status.termCount));\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      int computedFieldCount = 0;\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n\n        // TODO: really the codec should not return a field\n        // from FieldsEnum if it has to Terms... but we do\n        // this today:\n        // assert fields.terms(field) != null;\n        computedFieldCount++;\n        \n        final Terms terms = fieldsEnum.terms();\n        if (terms == null) {\n          continue;\n        }\n\n        final TermsEnum termsEnum = terms.iterator(null);\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = BytesRef.deepCopyOf(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copyBytes(term);\n          }\n\n          final int docFreq = termsEnum.docFreq();\n          if (docFreq <= 0) {\n            throw new RuntimeException(\"docfreq: \" + docFreq + \" is out of bounds\");\n          }\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = termsEnum.docs(liveDocs, docs);\n          postings = termsEnum.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = termsEnum.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = termsEnum.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = termsEnum.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              visitedDocs.set(docsNoDel.docID());\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            if (totalTermFreq2 <= 0) {\n              throw new RuntimeException(\"totalTermFreq: \" + totalTermFreq2 + \" is out of bounds\");\n            }\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = termsEnum.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = termsEnum.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          final Terms fieldTerms2 = fieldsEnum.terms();\n          if (fieldTerms2 != null && fieldTerms2.iterator(null).next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n          if (fieldTerms != null) {\n            final int v = fieldTerms.getDocCount();\n            if (v != -1 && visitedDocs.cardinality() != v) {\n              throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n            }\n          }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (termsEnum.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n          \n          // check unique term count\n          long termCount = -1;\n          \n          if (status.termCount-termCountStart > 0) {\n            termCount = fields.terms(field).getUniqueTermCount();\n            \n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n          }\n          \n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                termsEnum.seekExact(ord);\n                seekTerms[i] = BytesRef.deepCopyOf(termsEnum.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (termsEnum.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = termsEnum.docs(liveDocs, docs);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n      \n      int fieldCount = fields.getUniqueFieldCount();\n      \n      if (fieldCount != -1) {\n        if (fieldCount < 0) {\n          throw new RuntimeException(\"invalid fieldCount: \" + fieldCount);\n        }\n        if (fieldCount != computedFieldCount) {\n          throw new RuntimeException(\"fieldCount mismatch \" + fieldCount + \" vs recomputed field count \" + computedFieldCount);\n        }\n      }\n\n      // for most implementations, this is boring (just the sum across all fields)\n      // but codecs that don't work per-field like preflex actually implement this,\n      // but don't implement it on Terms, so the check isn't redundant.\n      long uniqueTermCountAllFields = reader.getUniqueTermCount();\n      \n      // this means something is seriously screwed, e.g. we are somehow getting enclosed in PFCW!!!!!!\n      \n      if (uniqueTermCountAllFields == -1) {\n        throw new RuntimeException(\"invalid termCount: -1\");\n     }\n\n      if (status.termCount != uniqueTermCountAllFields) {\n        throw new RuntimeException(\"termCount mismatch \" + uniqueTermCountAllFields + \" vs \" + (status.termCount));\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b65b350ca9588f9fc76ce7d6804160d06c45ff42","date":1323026297,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      int computedFieldCount = 0;\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsEnum docsAndFreqs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n\n        // TODO: really the codec should not return a field\n        // from FieldsEnum if it has to Terms... but we do\n        // this today:\n        // assert fields.terms(field) != null;\n        computedFieldCount++;\n        \n        final Terms terms = fieldsEnum.terms();\n        if (terms == null) {\n          continue;\n        }\n\n        final TermsEnum termsEnum = terms.iterator(null);\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = BytesRef.deepCopyOf(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copyBytes(term);\n          }\n\n          final int docFreq = termsEnum.docFreq();\n          if (docFreq <= 0) {\n            throw new RuntimeException(\"docfreq: \" + docFreq + \" is out of bounds\");\n          }\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = termsEnum.docs(liveDocs, docs, false);\n          docsAndFreqs = termsEnum.docs(liveDocs, docsAndFreqs, true);\n          postings = termsEnum.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = termsEnum.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final DocsEnum docsAndFreqs2;\n          final boolean hasPositions;\n          final boolean hasFreqs;\n          if (postings != null) {\n            docs2 = postings;\n            docsAndFreqs2 = postings;\n            hasPositions = true;\n            hasFreqs = true;\n          } else if (docsAndFreqs != null) {\n            docs2 = docsAndFreqs;\n            docsAndFreqs2 = docsAndFreqs;\n            hasPositions = false;\n            hasFreqs = true;\n          } else {\n            docs2 = docs;\n            docsAndFreqs2 = null;\n            hasPositions = false;\n            hasFreqs = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            int freq = -1;\n            if (hasFreqs) {\n              freq = docsAndFreqs2.freq();\n              if (freq <= 0) {\n                throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n              }\n              status.totPos += freq;\n              totalTermFreq += freq;\n            }\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            \n            int lastPos = -1;\n            if (hasPositions) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = termsEnum.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            if (hasFreqs) {\n              final DocsEnum docsNoDel = termsEnum.docs(null, docsAndFreqs, true);\n              docCount = 0;\n              totalTermFreq = 0;\n              while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n                visitedDocs.set(docsNoDel.docID());\n                docCount++;\n                totalTermFreq += docsNoDel.freq();\n              }\n            } else {\n              final DocsEnum docsNoDel = termsEnum.docs(null, docs, false);\n              docCount = 0;\n              totalTermFreq = -1;\n              while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n                visitedDocs.set(docsNoDel.docID());\n                docCount++;\n              }\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            if (totalTermFreq2 <= 0) {\n              throw new RuntimeException(\"totalTermFreq: \" + totalTermFreq2 + \" is out of bounds\");\n            }\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = termsEnum.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = termsEnum.docs(liveDocs, docs, false);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          final Terms fieldTerms2 = fieldsEnum.terms();\n          if (fieldTerms2 != null && fieldTerms2.iterator(null).next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n          if (fieldTerms != null) {\n            final int v = fieldTerms.getDocCount();\n            if (v != -1 && visitedDocs.cardinality() != v) {\n              throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n            }\n          }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (termsEnum.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n          \n          // check unique term count\n          long termCount = -1;\n          \n          if (status.termCount-termCountStart > 0) {\n            termCount = fields.terms(field).getUniqueTermCount();\n            \n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n          }\n          \n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                termsEnum.seekExact(ord);\n                seekTerms[i] = BytesRef.deepCopyOf(termsEnum.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (termsEnum.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = termsEnum.docs(liveDocs, docs, false);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n      \n      int fieldCount = fields.getUniqueFieldCount();\n      \n      if (fieldCount != -1) {\n        if (fieldCount < 0) {\n          throw new RuntimeException(\"invalid fieldCount: \" + fieldCount);\n        }\n        if (fieldCount != computedFieldCount) {\n          throw new RuntimeException(\"fieldCount mismatch \" + fieldCount + \" vs recomputed field count \" + computedFieldCount);\n        }\n      }\n\n      // for most implementations, this is boring (just the sum across all fields)\n      // but codecs that don't work per-field like preflex actually implement this,\n      // but don't implement it on Terms, so the check isn't redundant.\n      long uniqueTermCountAllFields = reader.getUniqueTermCount();\n      \n      // this means something is seriously screwed, e.g. we are somehow getting enclosed in PFCW!!!!!!\n      \n      if (uniqueTermCountAllFields == -1) {\n        throw new RuntimeException(\"invalid termCount: -1\");\n     }\n\n      if (status.termCount != uniqueTermCountAllFields) {\n        throw new RuntimeException(\"termCount mismatch \" + uniqueTermCountAllFields + \" vs \" + (status.termCount));\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      int computedFieldCount = 0;\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n\n        // TODO: really the codec should not return a field\n        // from FieldsEnum if it has to Terms... but we do\n        // this today:\n        // assert fields.terms(field) != null;\n        computedFieldCount++;\n        \n        final Terms terms = fieldsEnum.terms();\n        if (terms == null) {\n          continue;\n        }\n\n        final TermsEnum termsEnum = terms.iterator(null);\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = BytesRef.deepCopyOf(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copyBytes(term);\n          }\n\n          final int docFreq = termsEnum.docFreq();\n          if (docFreq <= 0) {\n            throw new RuntimeException(\"docfreq: \" + docFreq + \" is out of bounds\");\n          }\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = termsEnum.docs(liveDocs, docs);\n          postings = termsEnum.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = termsEnum.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final boolean hasPositions;\n          if (postings != null) {\n            docs2 = postings;\n            hasPositions = true;\n          } else {\n            docs2 = docs;\n            hasPositions = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            final int freq = docs2.freq();\n            status.totPos += freq;\n            totalTermFreq += freq;\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            if (freq <= 0) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            }\n            \n            int lastPos = -1;\n            if (postings != null) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = termsEnum.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            final DocsEnum docsNoDel = termsEnum.docs(null, docs);\n            docCount = 0;\n            totalTermFreq = 0;\n            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              visitedDocs.set(docsNoDel.docID());\n              docCount++;\n              totalTermFreq += docsNoDel.freq();\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            if (totalTermFreq2 <= 0) {\n              throw new RuntimeException(\"totalTermFreq: \" + totalTermFreq2 + \" is out of bounds\");\n            }\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = termsEnum.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = termsEnum.docs(liveDocs, docs);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          final Terms fieldTerms2 = fieldsEnum.terms();\n          if (fieldTerms2 != null && fieldTerms2.iterator(null).next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n          if (fieldTerms != null) {\n            final int v = fieldTerms.getDocCount();\n            if (v != -1 && visitedDocs.cardinality() != v) {\n              throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n            }\n          }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (termsEnum.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n          \n          // check unique term count\n          long termCount = -1;\n          \n          if (status.termCount-termCountStart > 0) {\n            termCount = fields.terms(field).getUniqueTermCount();\n            \n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n          }\n          \n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                termsEnum.seekExact(ord);\n                seekTerms[i] = BytesRef.deepCopyOf(termsEnum.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (termsEnum.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = termsEnum.docs(liveDocs, docs);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n      \n      int fieldCount = fields.getUniqueFieldCount();\n      \n      if (fieldCount != -1) {\n        if (fieldCount < 0) {\n          throw new RuntimeException(\"invalid fieldCount: \" + fieldCount);\n        }\n        if (fieldCount != computedFieldCount) {\n          throw new RuntimeException(\"fieldCount mismatch \" + fieldCount + \" vs recomputed field count \" + computedFieldCount);\n        }\n      }\n\n      // for most implementations, this is boring (just the sum across all fields)\n      // but codecs that don't work per-field like preflex actually implement this,\n      // but don't implement it on Terms, so the check isn't redundant.\n      long uniqueTermCountAllFields = reader.getUniqueTermCount();\n      \n      // this means something is seriously screwed, e.g. we are somehow getting enclosed in PFCW!!!!!!\n      \n      if (uniqueTermCountAllFields == -1) {\n        throw new RuntimeException(\"invalid termCount: -1\");\n     }\n\n      if (status.termCount != uniqueTermCountAllFields) {\n        throw new RuntimeException(\"termCount mismatch \" + uniqueTermCountAllFields + \" vs \" + (status.termCount));\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31f025ae60076ae95274433f3fe8e6ace2857a87","date":1326669465,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testPostings(SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testTermIndex(SegmentReader).mjava","sourceNew":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testPostings(SegmentReader reader) {\n\n    // TODO: we should go and verify term vectors match, if\n    // crossCheckTermVectors is on...\n\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      int computedFieldCount = 0;\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsEnum docsAndFreqs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n\n        // TODO: really the codec should not return a field\n        // from FieldsEnum if it has to Terms... but we do\n        // this today:\n        // assert fields.terms(field) != null;\n        computedFieldCount++;\n        \n        final Terms terms = fieldsEnum.terms();\n        if (terms == null) {\n          continue;\n        }\n\n        final TermsEnum termsEnum = terms.iterator(null);\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = BytesRef.deepCopyOf(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copyBytes(term);\n          }\n\n          final int docFreq = termsEnum.docFreq();\n          if (docFreq <= 0) {\n            throw new RuntimeException(\"docfreq: \" + docFreq + \" is out of bounds\");\n          }\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = termsEnum.docs(liveDocs, docs, false);\n          docsAndFreqs = termsEnum.docs(liveDocs, docsAndFreqs, true);\n          postings = termsEnum.docsAndPositions(liveDocs, postings, false);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = termsEnum.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final DocsEnum docsAndFreqs2;\n          final boolean hasPositions;\n          final boolean hasFreqs;\n          if (postings != null) {\n            docs2 = postings;\n            docsAndFreqs2 = postings;\n            hasPositions = true;\n            hasFreqs = true;\n          } else if (docsAndFreqs != null) {\n            docs2 = docsAndFreqs;\n            docsAndFreqs2 = docsAndFreqs;\n            hasPositions = false;\n            hasFreqs = true;\n          } else {\n            docs2 = docs;\n            docsAndFreqs2 = null;\n            hasPositions = false;\n            hasFreqs = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            int freq = -1;\n            if (hasFreqs) {\n              freq = docsAndFreqs2.freq();\n              if (freq <= 0) {\n                throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n              }\n              status.totPos += freq;\n              totalTermFreq += freq;\n            }\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            \n            int lastPos = -1;\n            if (hasPositions) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = termsEnum.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            if (hasFreqs) {\n              final DocsEnum docsNoDel = termsEnum.docs(null, docsAndFreqs, true);\n              docCount = 0;\n              totalTermFreq = 0;\n              while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n                visitedDocs.set(docsNoDel.docID());\n                docCount++;\n                totalTermFreq += docsNoDel.freq();\n              }\n            } else {\n              final DocsEnum docsNoDel = termsEnum.docs(null, docs, false);\n              docCount = 0;\n              totalTermFreq = -1;\n              while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n                visitedDocs.set(docsNoDel.docID());\n                docCount++;\n              }\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            if (totalTermFreq2 <= 0) {\n              throw new RuntimeException(\"totalTermFreq: \" + totalTermFreq2 + \" is out of bounds\");\n            }\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = termsEnum.docsAndPositions(liveDocs, postings, false);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = termsEnum.docs(liveDocs, docs, false);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          final Terms fieldTerms2 = fieldsEnum.terms();\n          if (fieldTerms2 != null && fieldTerms2.iterator(null).next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n          if (fieldTerms != null) {\n            final int v = fieldTerms.getDocCount();\n            if (v != -1 && visitedDocs.cardinality() != v) {\n              throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n            }\n          }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (termsEnum.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n          \n          // check unique term count\n          long termCount = -1;\n          \n          if (status.termCount-termCountStart > 0) {\n            termCount = fields.terms(field).getUniqueTermCount();\n            \n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n          }\n          \n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                termsEnum.seekExact(ord);\n                seekTerms[i] = BytesRef.deepCopyOf(termsEnum.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (termsEnum.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = termsEnum.docs(liveDocs, docs, false);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n      \n      int fieldCount = fields.getUniqueFieldCount();\n      \n      if (fieldCount != -1) {\n        if (fieldCount < 0) {\n          throw new RuntimeException(\"invalid fieldCount: \" + fieldCount);\n        }\n        if (fieldCount != computedFieldCount) {\n          throw new RuntimeException(\"fieldCount mismatch \" + fieldCount + \" vs recomputed field count \" + computedFieldCount);\n        }\n      }\n\n      // for most implementations, this is boring (just the sum across all fields)\n      // but codecs that don't work per-field like preflex actually implement this,\n      // but don't implement it on Terms, so the check isn't redundant.\n      long uniqueTermCountAllFields = reader.getUniqueTermCount();\n      \n      // this means something is seriously screwed, e.g. we are somehow getting enclosed in PFCW!!!!!!\n      \n      if (uniqueTermCountAllFields == -1) {\n        throw new RuntimeException(\"invalid termCount: -1\");\n     }\n\n      if (status.termCount != uniqueTermCountAllFields) {\n        throw new RuntimeException(\"termCount mismatch \" + uniqueTermCountAllFields + \" vs \" + (status.termCount));\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test the term index.\n   */\n  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {\n    final Status.TermIndexStatus status = new Status.TermIndexStatus();\n\n    final int maxDoc = reader.maxDoc();\n    final Bits liveDocs = reader.getLiveDocs();\n\n    final IndexSearcher is = new IndexSearcher(reader);\n\n    try {\n\n      if (infoStream != null) {\n        infoStream.print(\"    test: terms, freq, prox...\");\n      }\n\n      int computedFieldCount = 0;\n      final Fields fields = reader.fields();\n      if (fields == null) {\n        msg(\"OK [no fields/terms]\");\n        return status;\n      }\n     \n      DocsEnum docs = null;\n      DocsEnum docsAndFreqs = null;\n      DocsAndPositionsEnum postings = null;\n\n      final FieldsEnum fieldsEnum = fields.iterator();\n      while(true) {\n        final String field = fieldsEnum.next();\n        if (field == null) {\n          break;\n        }\n\n        // TODO: really the codec should not return a field\n        // from FieldsEnum if it has to Terms... but we do\n        // this today:\n        // assert fields.terms(field) != null;\n        computedFieldCount++;\n        \n        final Terms terms = fieldsEnum.terms();\n        if (terms == null) {\n          continue;\n        }\n\n        final TermsEnum termsEnum = terms.iterator(null);\n\n        boolean hasOrd = true;\n        final long termCountStart = status.termCount;\n\n        BytesRef lastTerm = null;\n\n        Comparator<BytesRef> termComp = terms.getComparator();\n\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());\n        while(true) {\n\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n\n          // make sure terms arrive in order according to\n          // the comp\n          if (lastTerm == null) {\n            lastTerm = BytesRef.deepCopyOf(term);\n          } else {\n            if (termComp.compare(lastTerm, term) >= 0) {\n              throw new RuntimeException(\"terms out of order: lastTerm=\" + lastTerm + \" term=\" + term);\n            }\n            lastTerm.copyBytes(term);\n          }\n\n          final int docFreq = termsEnum.docFreq();\n          if (docFreq <= 0) {\n            throw new RuntimeException(\"docfreq: \" + docFreq + \" is out of bounds\");\n          }\n          status.totFreq += docFreq;\n          sumDocFreq += docFreq;\n\n          docs = termsEnum.docs(liveDocs, docs, false);\n          docsAndFreqs = termsEnum.docs(liveDocs, docsAndFreqs, true);\n          postings = termsEnum.docsAndPositions(liveDocs, postings);\n\n          if (hasOrd) {\n            long ord = -1;\n            try {\n              ord = termsEnum.ord();\n            } catch (UnsupportedOperationException uoe) {\n              hasOrd = false;\n            }\n\n            if (hasOrd) {\n              final long ordExpected = status.termCount - termCountStart;\n              if (ord != ordExpected) {\n                throw new RuntimeException(\"ord mismatch: TermsEnum has ord=\" + ord + \" vs actual=\" + ordExpected);\n              }\n            }\n          }\n\n          status.termCount++;\n\n          final DocsEnum docs2;\n          final DocsEnum docsAndFreqs2;\n          final boolean hasPositions;\n          final boolean hasFreqs;\n          if (postings != null) {\n            docs2 = postings;\n            docsAndFreqs2 = postings;\n            hasPositions = true;\n            hasFreqs = true;\n          } else if (docsAndFreqs != null) {\n            docs2 = docsAndFreqs;\n            docsAndFreqs2 = docsAndFreqs;\n            hasPositions = false;\n            hasFreqs = true;\n          } else {\n            docs2 = docs;\n            docsAndFreqs2 = null;\n            hasPositions = false;\n            hasFreqs = false;\n          }\n\n          int lastDoc = -1;\n          int docCount = 0;\n          long totalTermFreq = 0;\n          while(true) {\n            final int doc = docs2.nextDoc();\n            if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            visitedDocs.set(doc);\n            int freq = -1;\n            if (hasFreqs) {\n              freq = docsAndFreqs2.freq();\n              if (freq <= 0) {\n                throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n              }\n              status.totPos += freq;\n              totalTermFreq += freq;\n            }\n            docCount++;\n\n            if (doc <= lastDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" <= lastDoc \" + lastDoc);\n            }\n            if (doc >= maxDoc) {\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" >= maxDoc \" + maxDoc);\n            }\n\n            lastDoc = doc;\n            \n            int lastPos = -1;\n            if (hasPositions) {\n              for(int j=0;j<freq;j++) {\n                final int pos = postings.nextPosition();\n                if (pos < -1) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n                }\n                if (pos < lastPos) {\n                  throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n                }\n                lastPos = pos;\n                if (postings.hasPayload()) {\n                  postings.getPayload();\n                }\n              }\n            }\n          }\n          \n          final long totalTermFreq2 = termsEnum.totalTermFreq();\n          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;\n\n          // Re-count if there are deleted docs:\n          if (reader.hasDeletions()) {\n            if (hasFreqs) {\n              final DocsEnum docsNoDel = termsEnum.docs(null, docsAndFreqs, true);\n              docCount = 0;\n              totalTermFreq = 0;\n              while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n                visitedDocs.set(docsNoDel.docID());\n                docCount++;\n                totalTermFreq += docsNoDel.freq();\n              }\n            } else {\n              final DocsEnum docsNoDel = termsEnum.docs(null, docs, false);\n              docCount = 0;\n              totalTermFreq = -1;\n              while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n                visitedDocs.set(docsNoDel.docID());\n                docCount++;\n              }\n            }\n          }\n\n          if (docCount != docFreq) {\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != tot docs w/o deletions \" + docCount);\n          }\n          if (hasTotalTermFreq) {\n            if (totalTermFreq2 <= 0) {\n              throw new RuntimeException(\"totalTermFreq: \" + totalTermFreq2 + \" is out of bounds\");\n            }\n            sumTotalTermFreq += totalTermFreq;\n            if (totalTermFreq != totalTermFreq2) {\n              throw new RuntimeException(\"term \" + term + \" totalTermFreq=\" + totalTermFreq2 + \" != recomputed totalTermFreq=\" + totalTermFreq);\n            }\n          }\n\n          // Test skipping\n          if (hasPositions) {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              postings = termsEnum.docsAndPositions(liveDocs, postings);\n              final int docID = postings.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int freq = postings.freq();\n                if (freq <= 0) {\n                  throw new RuntimeException(\"termFreq \" + freq + \" is out of bounds\");\n                }\n                int lastPosition = -1;\n                for(int posUpto=0;posUpto<freq;posUpto++) {\n                  final int pos = postings.nextPosition();\n                  if (pos < 0) {\n                    throw new RuntimeException(\"position \" + pos + \" is out of bounds\");\n                  }\n                  if (pos < lastPosition) {\n                    throw new RuntimeException(\"position \" + pos + \" is < lastPosition \" + lastPosition);\n                  }\n                  lastPosition = pos;\n                } \n\n                final int nextDocID = postings.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          } else {\n            for(int idx=0;idx<7;idx++) {\n              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);\n              docs = termsEnum.docs(liveDocs, docs, false);\n              final int docID = docs.advance(skipDocID);\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              } else {\n                if (docID < skipDocID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \") returned docID=\" + docID);\n                }\n                final int nextDocID = docs.nextDoc();\n                if (nextDocID == DocsEnum.NO_MORE_DOCS) {\n                  break;\n                }\n                if (nextDocID <= docID) {\n                  throw new RuntimeException(\"term \" + term + \": advance(docID=\" + skipDocID + \"), then .next() returned docID=\" + nextDocID + \" vs prev docID=\" + docID);\n                }\n              }\n            }\n          }\n        }\n        \n        final Terms fieldTerms = fields.terms(field);\n        if (fieldTerms == null) {\n          // Unusual: the FieldsEnum returned a field but\n          // the Terms for that field is null; this should\n          // only happen if it's a ghost field (field with\n          // no terms, eg there used to be terms but all\n          // docs got deleted and then merged away):\n          // make sure TermsEnum is empty:\n          final Terms fieldTerms2 = fieldsEnum.terms();\n          if (fieldTerms2 != null && fieldTerms2.iterator(null).next() != null) {\n            throw new RuntimeException(\"Fields.terms(field=\" + field + \") returned null yet the field appears to have terms\");\n          }\n        } else {\n          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {\n            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();\n            assert stats != null;\n            if (status.blockTreeStats == null) {\n              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();\n            }\n            status.blockTreeStats.put(field, stats);\n          }\n\n          if (sumTotalTermFreq != 0) {\n            final long v = fields.terms(field).getSumTotalTermFreq();\n            if (v != -1 && sumTotalTermFreq != v) {\n              throw new RuntimeException(\"sumTotalTermFreq for field \" + field + \"=\" + v + \" != recomputed sumTotalTermFreq=\" + sumTotalTermFreq);\n            }\n          }\n        \n          if (sumDocFreq != 0) {\n            final long v = fields.terms(field).getSumDocFreq();\n            if (v != -1 && sumDocFreq != v) {\n              throw new RuntimeException(\"sumDocFreq for field \" + field + \"=\" + v + \" != recomputed sumDocFreq=\" + sumDocFreq);\n            }\n          }\n        \n          if (fieldTerms != null) {\n            final int v = fieldTerms.getDocCount();\n            if (v != -1 && visitedDocs.cardinality() != v) {\n              throw new RuntimeException(\"docCount for field \" + field + \"=\" + v + \" != recomputed docCount=\" + visitedDocs.cardinality());\n            }\n          }\n\n          // Test seek to last term:\n          if (lastTerm != null) {\n            if (termsEnum.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { \n              throw new RuntimeException(\"seek to last term \" + lastTerm + \" failed\");\n            }\n\n            is.search(new TermQuery(new Term(field, lastTerm)), 1);\n          }\n          \n          // check unique term count\n          long termCount = -1;\n          \n          if (status.termCount-termCountStart > 0) {\n            termCount = fields.terms(field).getUniqueTermCount();\n            \n            if (termCount != -1 && termCount != status.termCount - termCountStart) {\n              throw new RuntimeException(\"termCount mismatch \" + termCount + \" vs \" + (status.termCount - termCountStart));\n            }\n          }\n          \n          // Test seeking by ord\n          if (hasOrd && status.termCount-termCountStart > 0) {\n            int seekCount = (int) Math.min(10000L, termCount);\n            if (seekCount > 0) {\n              BytesRef[] seekTerms = new BytesRef[seekCount];\n            \n              // Seek by ord\n              for(int i=seekCount-1;i>=0;i--) {\n                long ord = i*(termCount/seekCount);\n                termsEnum.seekExact(ord);\n                seekTerms[i] = BytesRef.deepCopyOf(termsEnum.term());\n              }\n\n              // Seek by term\n              long totDocCount = 0;\n              for(int i=seekCount-1;i>=0;i--) {\n                if (termsEnum.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {\n                  throw new RuntimeException(\"seek to existing term \" + seekTerms[i] + \" failed\");\n                }\n              \n                docs = termsEnum.docs(liveDocs, docs, false);\n                if (docs == null) {\n                  throw new RuntimeException(\"null DocsEnum from to existing term \" + seekTerms[i]);\n                }\n\n                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {\n                  totDocCount++;\n                }\n              }\n\n              // TermQuery\n              long totDocCount2 = 0;\n              for(int i=0;i<seekCount;i++) {\n                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;\n              }\n\n              if (totDocCount != totDocCount2) {\n                throw new RuntimeException(\"search to seek terms produced wrong number of hits: \" + totDocCount + \" vs \" + totDocCount2);\n              }\n            }\n          }\n        }\n      }\n      \n      int fieldCount = fields.getUniqueFieldCount();\n      \n      if (fieldCount != -1) {\n        if (fieldCount < 0) {\n          throw new RuntimeException(\"invalid fieldCount: \" + fieldCount);\n        }\n        if (fieldCount != computedFieldCount) {\n          throw new RuntimeException(\"fieldCount mismatch \" + fieldCount + \" vs recomputed field count \" + computedFieldCount);\n        }\n      }\n\n      // for most implementations, this is boring (just the sum across all fields)\n      // but codecs that don't work per-field like preflex actually implement this,\n      // but don't implement it on Terms, so the check isn't redundant.\n      long uniqueTermCountAllFields = reader.getUniqueTermCount();\n      \n      // this means something is seriously screwed, e.g. we are somehow getting enclosed in PFCW!!!!!!\n      \n      if (uniqueTermCountAllFields == -1) {\n        throw new RuntimeException(\"invalid termCount: -1\");\n     }\n\n      if (status.termCount != uniqueTermCountAllFields) {\n        throw new RuntimeException(\"termCount mismatch \" + uniqueTermCountAllFields + \" vs \" + (status.termCount));\n      }\n\n      msg(\"OK [\" + status.termCount + \" terms; \" + status.totFreq + \" terms/docs pairs; \" + status.totPos + \" tokens]\");\n\n      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {\n        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {\n          infoStream.println(\"      field \\\"\" + ent.getKey() + \"\\\":\");\n          infoStream.println(\"      \" + ent.getValue().toString().replace(\"\\n\", \"\\n      \"));\n        }\n      }\n\n    } catch (Throwable e) {\n      msg(\"ERROR: \" + e);\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c746cc69ff433a2c55683bedfeb889359b0d2808":["e7f7a53951c27f2ba1fb2e176e6e7b9e86e33ee8"],"25433c5cacacb7a2055d62d4d36b0daf210e0a10":["156c553d9c7f34542f151684a6d2bfa3889d62da"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["fd9cc9d77712aba3662f24632df7539ab75e3667"],"a493e6d0c3ad86bd55c0a1360d110142e948f2bd":["ea279fca7799054e31e74cff05202634ebd91281"],"16843358872ed92ba92888ab99df297550b9a36a":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","6ecd298fdc085e7eba27afa7fae58df1ba1a2808"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4f2f9fd0a641ccc0cc6a4fb4e53d7ec1ab14a94":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"b1add9ddc0005b07550d4350720aac22dc9886b3":["6ecd298fdc085e7eba27afa7fae58df1ba1a2808"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","a493e6d0c3ad86bd55c0a1360d110142e948f2bd"],"e7f7a53951c27f2ba1fb2e176e6e7b9e86e33ee8":["f4f2f9fd0a641ccc0cc6a4fb4e53d7ec1ab14a94"],"6d161ff99970d1d549046fbc7aee3290d4f996cb":["b1add9ddc0005b07550d4350720aac22dc9886b3"],"a653ca3bb595a9c1f775fc44684e6ba7daafd3f5":["6d161ff99970d1d549046fbc7aee3290d4f996cb"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["85a883878c0af761245ab048babc63d099f835f3","b1add9ddc0005b07550d4350720aac22dc9886b3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fd9cc9d77712aba3662f24632df7539ab75e3667":["a653ca3bb595a9c1f775fc44684e6ba7daafd3f5"],"e6e919043fa85ee891123768dd655a98edbbf63c":["3cc749c053615f5871f3b95715fe292f34e70a53"],"31f025ae60076ae95274433f3fe8e6ace2857a87":["872cff1d3a554e0cd64014cd97f88d3002b0f491"],"c5145e7af5e55022ec6ba083c0aef480e49e0d3b":["25433c5cacacb7a2055d62d4d36b0daf210e0a10"],"156c553d9c7f34542f151684a6d2bfa3889d62da":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"85a883878c0af761245ab048babc63d099f835f3":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","a493e6d0c3ad86bd55c0a1360d110142e948f2bd"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["29ef99d61cda9641b6250bf9567329a6e65f901d","a653ca3bb595a9c1f775fc44684e6ba7daafd3f5"],"3cc749c053615f5871f3b95715fe292f34e70a53":["f458fcb817a740e7906774b7ca2c54d37b34f24f"],"872cff1d3a554e0cd64014cd97f88d3002b0f491":["e6e919043fa85ee891123768dd655a98edbbf63c"],"5f4e87790277826a2aea119328600dfb07761f32":["6267e1ce56c2eec111425690cd04e251b6f14952","08932c793647a36953d1816b1060121f48820d3f"],"962d04139994fce5193143ef35615499a9a96d78":["45669a651c970812a680841b97a77cce06af559f","a653ca3bb595a9c1f775fc44684e6ba7daafd3f5"],"2553b00f699380c64959ccb27991289aae87be2e":["a3776dccca01c11e7046323cfad46a3b4a471233","fd9cc9d77712aba3662f24632df7539ab75e3667"],"ea279fca7799054e31e74cff05202634ebd91281":["ba8cd9ac7a0f3ad09c6c94f53c4c415d13e72723"],"63639dd66fd5bd9b90bc24dd596ae01575f27cc4":["817d8435e9135b756f08ce6710ab0baac51bdf88","f4f2f9fd0a641ccc0cc6a4fb4e53d7ec1ab14a94"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a653ca3bb595a9c1f775fc44684e6ba7daafd3f5","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["16843358872ed92ba92888ab99df297550b9a36a","b1add9ddc0005b07550d4350720aac22dc9886b3"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["2553b00f699380c64959ccb27991289aae87be2e","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"60ba444201d2570214b6fcf1d15600dc1a01f548":["c746cc69ff433a2c55683bedfeb889359b0d2808"],"6267e1ce56c2eec111425690cd04e251b6f14952":["5c4531fadbecf73a7716fdf5cd742463e866e84e"],"08932c793647a36953d1816b1060121f48820d3f":["6267e1ce56c2eec111425690cd04e251b6f14952"],"b65b350ca9588f9fc76ce7d6804160d06c45ff42":["e6e919043fa85ee891123768dd655a98edbbf63c","872cff1d3a554e0cd64014cd97f88d3002b0f491"],"a3776dccca01c11e7046323cfad46a3b4a471233":["b1add9ddc0005b07550d4350720aac22dc9886b3","a653ca3bb595a9c1f775fc44684e6ba7daafd3f5"],"f458fcb817a740e7906774b7ca2c54d37b34f24f":["c5145e7af5e55022ec6ba083c0aef480e49e0d3b"],"5c4531fadbecf73a7716fdf5cd742463e866e84e":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["ba8cd9ac7a0f3ad09c6c94f53c4c415d13e72723","ea279fca7799054e31e74cff05202634ebd91281"],"45669a651c970812a680841b97a77cce06af559f":["e79a6d080bdd5b2a8f56342cf571b5476de04180","6d161ff99970d1d549046fbc7aee3290d4f996cb"],"6ecd298fdc085e7eba27afa7fae58df1ba1a2808":["a493e6d0c3ad86bd55c0a1360d110142e948f2bd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["31f025ae60076ae95274433f3fe8e6ace2857a87"],"ba8cd9ac7a0f3ad09c6c94f53c4c415d13e72723":["08932c793647a36953d1816b1060121f48820d3f"]},"commit2Childs":{"c746cc69ff433a2c55683bedfeb889359b0d2808":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"25433c5cacacb7a2055d62d4d36b0daf210e0a10":["c5145e7af5e55022ec6ba083c0aef480e49e0d3b"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["f4f2f9fd0a641ccc0cc6a4fb4e53d7ec1ab14a94","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"a493e6d0c3ad86bd55c0a1360d110142e948f2bd":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","85a883878c0af761245ab048babc63d099f835f3","6ecd298fdc085e7eba27afa7fae58df1ba1a2808"],"16843358872ed92ba92888ab99df297550b9a36a":["e79a6d080bdd5b2a8f56342cf571b5476de04180"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5c4531fadbecf73a7716fdf5cd742463e866e84e"],"f4f2f9fd0a641ccc0cc6a4fb4e53d7ec1ab14a94":["e7f7a53951c27f2ba1fb2e176e6e7b9e86e33ee8","63639dd66fd5bd9b90bc24dd596ae01575f27cc4"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["16843358872ed92ba92888ab99df297550b9a36a"],"b1add9ddc0005b07550d4350720aac22dc9886b3":["6d161ff99970d1d549046fbc7aee3290d4f996cb","29ef99d61cda9641b6250bf9567329a6e65f901d","e79a6d080bdd5b2a8f56342cf571b5476de04180","a3776dccca01c11e7046323cfad46a3b4a471233"],"e7f7a53951c27f2ba1fb2e176e6e7b9e86e33ee8":["c746cc69ff433a2c55683bedfeb889359b0d2808"],"6d161ff99970d1d549046fbc7aee3290d4f996cb":["a653ca3bb595a9c1f775fc44684e6ba7daafd3f5","45669a651c970812a680841b97a77cce06af559f"],"a653ca3bb595a9c1f775fc44684e6ba7daafd3f5":["fd9cc9d77712aba3662f24632df7539ab75e3667","135621f3a0670a9394eb563224a3b76cc4dddc0f","962d04139994fce5193143ef35615499a9a96d78","d083e83f225b11e5fdd900e83d26ddb385b6955c","a3776dccca01c11e7046323cfad46a3b4a471233"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"fd9cc9d77712aba3662f24632df7539ab75e3667":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","2553b00f699380c64959ccb27991289aae87be2e"],"e6e919043fa85ee891123768dd655a98edbbf63c":["872cff1d3a554e0cd64014cd97f88d3002b0f491","b65b350ca9588f9fc76ce7d6804160d06c45ff42"],"31f025ae60076ae95274433f3fe8e6ace2857a87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c5145e7af5e55022ec6ba083c0aef480e49e0d3b":["f458fcb817a740e7906774b7ca2c54d37b34f24f"],"156c553d9c7f34542f151684a6d2bfa3889d62da":["25433c5cacacb7a2055d62d4d36b0daf210e0a10"],"85a883878c0af761245ab048babc63d099f835f3":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"3cc749c053615f5871f3b95715fe292f34e70a53":["e6e919043fa85ee891123768dd655a98edbbf63c"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"872cff1d3a554e0cd64014cd97f88d3002b0f491":["31f025ae60076ae95274433f3fe8e6ace2857a87","b65b350ca9588f9fc76ce7d6804160d06c45ff42"],"962d04139994fce5193143ef35615499a9a96d78":[],"2553b00f699380c64959ccb27991289aae87be2e":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"ea279fca7799054e31e74cff05202634ebd91281":["a493e6d0c3ad86bd55c0a1360d110142e948f2bd","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"63639dd66fd5bd9b90bc24dd596ae01575f27cc4":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["45669a651c970812a680841b97a77cce06af559f"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["63639dd66fd5bd9b90bc24dd596ae01575f27cc4"],"60ba444201d2570214b6fcf1d15600dc1a01f548":["156c553d9c7f34542f151684a6d2bfa3889d62da"],"6267e1ce56c2eec111425690cd04e251b6f14952":["5f4e87790277826a2aea119328600dfb07761f32","08932c793647a36953d1816b1060121f48820d3f"],"08932c793647a36953d1816b1060121f48820d3f":["5f4e87790277826a2aea119328600dfb07761f32","ba8cd9ac7a0f3ad09c6c94f53c4c415d13e72723"],"b65b350ca9588f9fc76ce7d6804160d06c45ff42":[],"a3776dccca01c11e7046323cfad46a3b4a471233":["2553b00f699380c64959ccb27991289aae87be2e"],"f458fcb817a740e7906774b7ca2c54d37b34f24f":["3cc749c053615f5871f3b95715fe292f34e70a53"],"5c4531fadbecf73a7716fdf5cd742463e866e84e":["6267e1ce56c2eec111425690cd04e251b6f14952"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["85a883878c0af761245ab048babc63d099f835f3"],"45669a651c970812a680841b97a77cce06af559f":["962d04139994fce5193143ef35615499a9a96d78"],"6ecd298fdc085e7eba27afa7fae58df1ba1a2808":["16843358872ed92ba92888ab99df297550b9a36a","b1add9ddc0005b07550d4350720aac22dc9886b3"],"ba8cd9ac7a0f3ad09c6c94f53c4c415d13e72723":["ea279fca7799054e31e74cff05202634ebd91281","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["135621f3a0670a9394eb563224a3b76cc4dddc0f","962d04139994fce5193143ef35615499a9a96d78","63639dd66fd5bd9b90bc24dd596ae01575f27cc4","d083e83f225b11e5fdd900e83d26ddb385b6955c","b65b350ca9588f9fc76ce7d6804160d06c45ff42","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}