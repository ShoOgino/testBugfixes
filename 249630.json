{"path":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#collectTerms(LeafReaderContext,TermsEnum,List[TermAndState]).mjava","commits":[{"id":"16b25963ad38ed289ebf0f7af31269fa1ce80a11","date":1442083896,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#collectTerms(LeafReaderContext,TermsEnum,List[TermAndState]).mjava","pathOld":"/dev/null","sourceNew":"    /** Try to collect terms from the given terms enum and return count=sum(df) for terms visited so far\n     *  or (-count - 1) if this should be rewritten into a boolean query.\n     *  The termEnum will already be positioned on the next term if not exhausted.\n     */\n    private long collectTerms(LeafReaderContext context, TermsEnum termsEnum, List<TermAndState> terms) throws IOException {\n      long count = 0;\n      final int threshold = Math.min(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD, BooleanQuery.getMaxClauseCount());\n      for (int i = 0; i < threshold; ++i) {\n        final BytesRef term = termsEnum.next();\n        if (term == null) {\n          return -count - 1;\n        }\n        TermState state = termsEnum.termState();\n        if (state.isRealTerm() == false) {\n          // TermQuery does not accept fake terms for now\n          return count;\n        }\n        int df = termsEnum.docFreq();\n        count += df;\n        terms.add(new TermAndState(BytesRef.deepCopyOf(term), state, df, termsEnum.totalTermFreq()));\n      }\n      return termsEnum.next() == null ? (-count - 1) : count;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","date":1466407389,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#collectTerms(LeafReaderContext,TermsEnum,List[TermAndState]).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#collectTerms(LeafReaderContext,TermsEnum,List[TermAndState]).mjava","sourceNew":"    /** Try to collect terms from the given terms enum and return count=sum(df) for terms visited so far\n     *  or (-count - 1) if this should be rewritten into a boolean query.\n     *  The termEnum will already be positioned on the next term if not exhausted.\n     */\n    private long collectTerms(LeafReaderContext context, TermsEnum termsEnum, List<TermAndState> terms) throws IOException {\n      long count = 0;\n      final int threshold = Math.min(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD, BooleanQuery.getMaxClauseCount());\n      for (int i = 0; i < threshold; ++i) {\n        final BytesRef term = termsEnum.next();\n        if (term == null) {\n          return -count - 1;\n        }\n        TermState state = termsEnum.termState();\n        int df = termsEnum.docFreq();\n        count += df;\n        terms.add(new TermAndState(BytesRef.deepCopyOf(term), state, df, termsEnum.totalTermFreq()));\n      }\n      return termsEnum.next() == null ? (-count - 1) : count;\n    }\n\n","sourceOld":"    /** Try to collect terms from the given terms enum and return count=sum(df) for terms visited so far\n     *  or (-count - 1) if this should be rewritten into a boolean query.\n     *  The termEnum will already be positioned on the next term if not exhausted.\n     */\n    private long collectTerms(LeafReaderContext context, TermsEnum termsEnum, List<TermAndState> terms) throws IOException {\n      long count = 0;\n      final int threshold = Math.min(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD, BooleanQuery.getMaxClauseCount());\n      for (int i = 0; i < threshold; ++i) {\n        final BytesRef term = termsEnum.next();\n        if (term == null) {\n          return -count - 1;\n        }\n        TermState state = termsEnum.termState();\n        if (state.isRealTerm() == false) {\n          // TermQuery does not accept fake terms for now\n          return count;\n        }\n        int df = termsEnum.docFreq();\n        count += df;\n        terms.add(new TermAndState(BytesRef.deepCopyOf(term), state, df, termsEnum.totalTermFreq()));\n      }\n      return termsEnum.next() == null ? (-count - 1) : count;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6aaba221b22442bdf0ef28770c25fe259dfb3f55","date":1466496193,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#collectTerms(LeafReaderContext,TermsEnum,List[TermAndState]).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#collectTerms(LeafReaderContext,TermsEnum,List[TermAndState]).mjava","sourceNew":"    /** Try to collect terms from the given terms enum and return count=sum(df) for terms visited so far\n     *  or (-count - 1) if this should be rewritten into a boolean query.\n     *  The termEnum will already be positioned on the next term if not exhausted.\n     */\n    private long collectTerms(LeafReaderContext context, TermsEnum termsEnum, List<TermAndState> terms) throws IOException {\n      long count = 0;\n      final int threshold = Math.min(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD, BooleanQuery.getMaxClauseCount());\n      for (int i = 0; i < threshold; ++i) {\n        final BytesRef term = termsEnum.next();\n        if (term == null) {\n          return -count - 1;\n        }\n        TermState state = termsEnum.termState();\n        int df = termsEnum.docFreq();\n        count += df;\n        terms.add(new TermAndState(BytesRef.deepCopyOf(term), state, df, termsEnum.totalTermFreq()));\n      }\n      return termsEnum.next() == null ? (-count - 1) : count;\n    }\n\n","sourceOld":"    /** Try to collect terms from the given terms enum and return count=sum(df) for terms visited so far\n     *  or (-count - 1) if this should be rewritten into a boolean query.\n     *  The termEnum will already be positioned on the next term if not exhausted.\n     */\n    private long collectTerms(LeafReaderContext context, TermsEnum termsEnum, List<TermAndState> terms) throws IOException {\n      long count = 0;\n      final int threshold = Math.min(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD, BooleanQuery.getMaxClauseCount());\n      for (int i = 0; i < threshold; ++i) {\n        final BytesRef term = termsEnum.next();\n        if (term == null) {\n          return -count - 1;\n        }\n        TermState state = termsEnum.termState();\n        if (state.isRealTerm() == false) {\n          // TermQuery does not accept fake terms for now\n          return count;\n        }\n        int df = termsEnum.docFreq();\n        count += df;\n        terms.add(new TermAndState(BytesRef.deepCopyOf(term), state, df, termsEnum.totalTermFreq()));\n      }\n      return termsEnum.next() == null ? (-count - 1) : count;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#collectTerms(LeafReaderContext,TermsEnum,List[TermAndState]).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#collectTerms(LeafReaderContext,TermsEnum,List[TermAndState]).mjava","sourceNew":"    /** Try to collect terms from the given terms enum and return count=sum(df) for terms visited so far\n     *  or (-count - 1) if this should be rewritten into a boolean query.\n     *  The termEnum will already be positioned on the next term if not exhausted.\n     */\n    private long collectTerms(LeafReaderContext context, TermsEnum termsEnum, List<TermAndState> terms) throws IOException {\n      long count = 0;\n      final int threshold = Math.min(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD, BooleanQuery.getMaxClauseCount());\n      for (int i = 0; i < threshold; ++i) {\n        final BytesRef term = termsEnum.next();\n        if (term == null) {\n          return -count - 1;\n        }\n        TermState state = termsEnum.termState();\n        int df = termsEnum.docFreq();\n        count += df;\n        terms.add(new TermAndState(BytesRef.deepCopyOf(term), state, df, termsEnum.totalTermFreq()));\n      }\n      return termsEnum.next() == null ? (-count - 1) : count;\n    }\n\n","sourceOld":"    /** Try to collect terms from the given terms enum and return count=sum(df) for terms visited so far\n     *  or (-count - 1) if this should be rewritten into a boolean query.\n     *  The termEnum will already be positioned on the next term if not exhausted.\n     */\n    private long collectTerms(LeafReaderContext context, TermsEnum termsEnum, List<TermAndState> terms) throws IOException {\n      long count = 0;\n      final int threshold = Math.min(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD, BooleanQuery.getMaxClauseCount());\n      for (int i = 0; i < threshold; ++i) {\n        final BytesRef term = termsEnum.next();\n        if (term == null) {\n          return -count - 1;\n        }\n        TermState state = termsEnum.termState();\n        if (state.isRealTerm() == false) {\n          // TermQuery does not accept fake terms for now\n          return count;\n        }\n        int df = termsEnum.docFreq();\n        count += df;\n        terms.add(new TermAndState(BytesRef.deepCopyOf(term), state, df, termsEnum.totalTermFreq()));\n      }\n      return termsEnum.next() == null ? (-count - 1) : count;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36c70eb3b44de4355a7168b762cadc0f1cf194bc","date":1561542955,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#collectTerms(LeafReaderContext,TermsEnum,List[TermAndState]).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#collectTerms(LeafReaderContext,TermsEnum,List[TermAndState]).mjava","sourceNew":"    /** Try to collect terms from the given terms enum and return count=sum(df) for terms visited so far\n     *  or (-count - 1) if this should be rewritten into a boolean query.\n     *  The termEnum will already be positioned on the next term if not exhausted.\n     */\n    private long collectTerms(LeafReaderContext context, TermsEnum termsEnum, List<TermAndState> terms) throws IOException {\n      long count = 0;\n      final int threshold = Math.min(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD, IndexSearcher.getMaxClauseCount());\n      for (int i = 0; i < threshold; ++i) {\n        final BytesRef term = termsEnum.next();\n        if (term == null) {\n          return -count - 1;\n        }\n        TermState state = termsEnum.termState();\n        int df = termsEnum.docFreq();\n        count += df;\n        terms.add(new TermAndState(BytesRef.deepCopyOf(term), state, df, termsEnum.totalTermFreq()));\n      }\n      return termsEnum.next() == null ? (-count - 1) : count;\n    }\n\n","sourceOld":"    /** Try to collect terms from the given terms enum and return count=sum(df) for terms visited so far\n     *  or (-count - 1) if this should be rewritten into a boolean query.\n     *  The termEnum will already be positioned on the next term if not exhausted.\n     */\n    private long collectTerms(LeafReaderContext context, TermsEnum termsEnum, List<TermAndState> terms) throws IOException {\n      long count = 0;\n      final int threshold = Math.min(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD, BooleanQuery.getMaxClauseCount());\n      for (int i = 0; i < threshold; ++i) {\n        final BytesRef term = termsEnum.next();\n        if (term == null) {\n          return -count - 1;\n        }\n        TermState state = termsEnum.termState();\n        int df = termsEnum.docFreq();\n        count += df;\n        terms.add(new TermAndState(BytesRef.deepCopyOf(term), state, df, termsEnum.totalTermFreq()));\n      }\n      return termsEnum.next() == null ? (-count - 1) : count;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"16b25963ad38ed289ebf0f7af31269fa1ce80a11":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["16b25963ad38ed289ebf0f7af31269fa1ce80a11","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["16b25963ad38ed289ebf0f7af31269fa1ce80a11"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"36c70eb3b44de4355a7168b762cadc0f1cf194bc":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["16b25963ad38ed289ebf0f7af31269fa1ce80a11","6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["36c70eb3b44de4355a7168b762cadc0f1cf194bc"]},"commit2Childs":{"16b25963ad38ed289ebf0f7af31269fa1ce80a11":["6aaba221b22442bdf0ef28770c25fe259dfb3f55","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["36c70eb3b44de4355a7168b762cadc0f1cf194bc","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["16b25963ad38ed289ebf0f7af31269fa1ce80a11"],"36c70eb3b44de4355a7168b762cadc0f1cf194bc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}