{"path":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","commits":[{"id":"f70d4e80f48b98103c2ab0940c74e1aec1d28b63","date":1343175095,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * kind of an absurd tests because if there is an inifnite loop, it \n   * would ver finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_sf\", \n                                      \"foo_d\", \"foo_sd\",\n                                      \"foo_i\", \"foo_si\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    for (String field : new String[] {\"foo_pdt\", \"foo_dt\"}) {\n      for (String type : new String[] {\"date\", \"range\"}) {\n      assertQEx(\"no zero gap error for facet.\" + type + \": \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.\" + type, field,\n                    \"facet.\"+type+\".start\", \"NOW\",\n                    \"facet.\"+type+\".gap\", \"+0DAYS\",\n                    \"facet.\"+type+\".end\", \"NOW+10DAY\"),\n                400);\n      }\n    }\n    \n    for (String field : new String[] {\"foo_f\", \"foo_sf\"}) {\n      assertQEx(\"no float underflow error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"100000000000\",\n                    \"facet.range.end\", \"100000086200\",\n                    \"facet.range.gap\", \"2160\"),\n                400);\n    }\n\n    for (String field : new String[] {\"foo_d\", \"foo_sd\"}) {\n      assertQEx(\"no double underflow error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"9900000000000\",\n                    \"facet.range.end\", \"9900000086200\",\n                    \"facet.range.gap\", \"0.0003\"),\n                400);\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","date":1343203827,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * kind of an absurd tests because if there is an inifnite loop, it \n   * would ver finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_sf\", \n                                      \"foo_d\", \"foo_sd\",\n                                      \"foo_i\", \"foo_si\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    for (String field : new String[] {\"foo_pdt\", \"foo_dt\"}) {\n      for (String type : new String[] {\"date\", \"range\"}) {\n      assertQEx(\"no zero gap error for facet.\" + type + \": \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.\" + type, field,\n                    \"facet.\"+type+\".start\", \"NOW\",\n                    \"facet.\"+type+\".gap\", \"+0DAYS\",\n                    \"facet.\"+type+\".end\", \"NOW+10DAY\"),\n                400);\n      }\n    }\n    \n    for (String field : new String[] {\"foo_f\", \"foo_sf\"}) {\n      assertQEx(\"no float underflow error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"100000000000\",\n                    \"facet.range.end\", \"100000086200\",\n                    \"facet.range.gap\", \"2160\"),\n                400);\n    }\n\n    for (String field : new String[] {\"foo_d\", \"foo_sd\"}) {\n      assertQEx(\"no double underflow error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"9900000000000\",\n                    \"facet.range.end\", \"9900000086200\",\n                    \"facet.range.gap\", \"0.0003\"),\n                400);\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * kind of an absurd tests because if there is an inifnite loop, it \n   * would ver finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_sf\", \n                                      \"foo_d\", \"foo_sd\",\n                                      \"foo_i\", \"foo_si\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    for (String field : new String[] {\"foo_pdt\", \"foo_dt\"}) {\n      for (String type : new String[] {\"date\", \"range\"}) {\n      assertQEx(\"no zero gap error for facet.\" + type + \": \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.\" + type, field,\n                    \"facet.\"+type+\".start\", \"NOW\",\n                    \"facet.\"+type+\".gap\", \"+0DAYS\",\n                    \"facet.\"+type+\".end\", \"NOW+10DAY\"),\n                400);\n      }\n    }\n    \n    for (String field : new String[] {\"foo_f\", \"foo_sf\"}) {\n      assertQEx(\"no float underflow error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"100000000000\",\n                    \"facet.range.end\", \"100000086200\",\n                    \"facet.range.gap\", \"2160\"),\n                400);\n    }\n\n    for (String field : new String[] {\"foo_d\", \"foo_sd\"}) {\n      assertQEx(\"no double underflow error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"9900000000000\",\n                    \"facet.range.end\", \"9900000086200\",\n                    \"facet.range.gap\", \"0.0003\"),\n                400);\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * kind of an absurd tests because if there is an inifnite loop, it \n   * would ver finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_sf\", \n                                      \"foo_d\", \"foo_sd\",\n                                      \"foo_i\", \"foo_si\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    for (String field : new String[] {\"foo_pdt\", \"foo_dt\"}) {\n      for (String type : new String[] {\"date\", \"range\"}) {\n      assertQEx(\"no zero gap error for facet.\" + type + \": \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.\" + type, field,\n                    \"facet.\"+type+\".start\", \"NOW\",\n                    \"facet.\"+type+\".gap\", \"+0DAYS\",\n                    \"facet.\"+type+\".end\", \"NOW+10DAY\"),\n                400);\n      }\n    }\n    \n    for (String field : new String[] {\"foo_f\", \"foo_sf\"}) {\n      assertQEx(\"no float underflow error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"100000000000\",\n                    \"facet.range.end\", \"100000086200\",\n                    \"facet.range.gap\", \"2160\"),\n                400);\n    }\n\n    for (String field : new String[] {\"foo_d\", \"foo_sd\"}) {\n      assertQEx(\"no double underflow error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"9900000000000\",\n                    \"facet.range.end\", \"9900000086200\",\n                    \"facet.range.gap\", \"0.0003\"),\n                400);\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2106271e380c198349e0f6eac0395bb462913fab","date":1397072894,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","sourceNew":"  /** \n   * kind of an absurd tests because if there is an inifnite loop, it \n   * would ver finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_d\", \"foo_i\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    String field = \"foo_dt\";\n    for (String type : new String[]{\"date\", \"range\"}) {\n      assertQEx(\"no zero gap error for facet.\" + type + \": \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.\" + type, field,\n                    \"facet.\"+type+\".start\", \"NOW\",\n                    \"facet.\"+type+\".gap\", \"+0DAYS\",\n                    \"facet.\"+type+\".end\", \"NOW+10DAY\"),\n                400);\n    }\n    field = \"foo_f\";\n    assertQEx(\"no float underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"100000000000\",\n                  \"facet.range.end\", \"100000086200\",\n                  \"facet.range.gap\", \"2160\"),\n              400);\n\n    field = \"foo_d\";\n    assertQEx(\"no double underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"9900000000000\",\n                  \"facet.range.end\", \"9900000086200\",\n                  \"facet.range.gap\", \"0.0003\"),\n              400);\n  }\n\n","sourceOld":"  /** \n   * kind of an absurd tests because if there is an inifnite loop, it \n   * would ver finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_sf\", \n                                      \"foo_d\", \"foo_sd\",\n                                      \"foo_i\", \"foo_si\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    for (String field : new String[] {\"foo_pdt\", \"foo_dt\"}) {\n      for (String type : new String[] {\"date\", \"range\"}) {\n      assertQEx(\"no zero gap error for facet.\" + type + \": \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.\" + type, field,\n                    \"facet.\"+type+\".start\", \"NOW\",\n                    \"facet.\"+type+\".gap\", \"+0DAYS\",\n                    \"facet.\"+type+\".end\", \"NOW+10DAY\"),\n                400);\n      }\n    }\n    \n    for (String field : new String[] {\"foo_f\", \"foo_sf\"}) {\n      assertQEx(\"no float underflow error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"100000000000\",\n                    \"facet.range.end\", \"100000086200\",\n                    \"facet.range.gap\", \"2160\"),\n                400);\n    }\n\n    for (String field : new String[] {\"foo_d\", \"foo_sd\"}) {\n      assertQEx(\"no double underflow error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"9900000000000\",\n                    \"facet.range.end\", \"9900000086200\",\n                    \"facet.range.gap\", \"0.0003\"),\n                400);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"52c5280f6286c7546ab75b72c663f7bb1dc10e96","date":1427372570,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","sourceNew":"  /** \n   * kind of an absurd test because if there is an infinite loop, it \n   * would never finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_d\", \"foo_i\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    String field = \"foo_dt\";\n    for (String type : new String[]{\"date\", \"range\"}) {\n      assertQEx(\"no zero gap error for facet.\" + type + \": \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.\" + type, field,\n                    \"facet.\"+type+\".start\", \"NOW\",\n                    \"facet.\"+type+\".gap\", \"+0DAYS\",\n                    \"facet.\"+type+\".end\", \"NOW+10DAY\"),\n                400);\n    }\n    field = \"foo_f\";\n    assertQEx(\"no float underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"100000000000\",\n                  \"facet.range.end\", \"100000086200\",\n                  \"facet.range.gap\", \"2160\"),\n              400);\n\n    field = \"foo_d\";\n    assertQEx(\"no double underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"9900000000000\",\n                  \"facet.range.end\", \"9900000086200\",\n                  \"facet.range.gap\", \"0.0003\"),\n              400);\n  }\n\n","sourceOld":"  /** \n   * kind of an absurd tests because if there is an inifnite loop, it \n   * would ver finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_d\", \"foo_i\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    String field = \"foo_dt\";\n    for (String type : new String[]{\"date\", \"range\"}) {\n      assertQEx(\"no zero gap error for facet.\" + type + \": \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.\" + type, field,\n                    \"facet.\"+type+\".start\", \"NOW\",\n                    \"facet.\"+type+\".gap\", \"+0DAYS\",\n                    \"facet.\"+type+\".end\", \"NOW+10DAY\"),\n                400);\n    }\n    field = \"foo_f\";\n    assertQEx(\"no float underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"100000000000\",\n                  \"facet.range.end\", \"100000086200\",\n                  \"facet.range.gap\", \"2160\"),\n              400);\n\n    field = \"foo_d\";\n    assertQEx(\"no double underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"9900000000000\",\n                  \"facet.range.end\", \"9900000086200\",\n                  \"facet.range.gap\", \"0.0003\"),\n              400);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","sourceNew":"  /** \n   * kind of an absurd test because if there is an infinite loop, it \n   * would never finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_d\", \"foo_i\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    String field = \"foo_dt\";\n    for (String type : new String[]{\"date\", \"range\"}) {\n      assertQEx(\"no zero gap error for facet.\" + type + \": \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.\" + type, field,\n                    \"facet.\"+type+\".start\", \"NOW\",\n                    \"facet.\"+type+\".gap\", \"+0DAYS\",\n                    \"facet.\"+type+\".end\", \"NOW+10DAY\"),\n                400);\n    }\n    field = \"foo_f\";\n    assertQEx(\"no float underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"100000000000\",\n                  \"facet.range.end\", \"100000086200\",\n                  \"facet.range.gap\", \"2160\"),\n              400);\n\n    field = \"foo_d\";\n    assertQEx(\"no double underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"9900000000000\",\n                  \"facet.range.end\", \"9900000086200\",\n                  \"facet.range.gap\", \"0.0003\"),\n              400);\n  }\n\n","sourceOld":"  /** \n   * kind of an absurd tests because if there is an inifnite loop, it \n   * would ver finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_d\", \"foo_i\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    String field = \"foo_dt\";\n    for (String type : new String[]{\"date\", \"range\"}) {\n      assertQEx(\"no zero gap error for facet.\" + type + \": \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.\" + type, field,\n                    \"facet.\"+type+\".start\", \"NOW\",\n                    \"facet.\"+type+\".gap\", \"+0DAYS\",\n                    \"facet.\"+type+\".end\", \"NOW+10DAY\"),\n                400);\n    }\n    field = \"foo_f\";\n    assertQEx(\"no float underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"100000000000\",\n                  \"facet.range.end\", \"100000086200\",\n                  \"facet.range.gap\", \"2160\"),\n              400);\n\n    field = \"foo_d\";\n    assertQEx(\"no double underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"9900000000000\",\n                  \"facet.range.end\", \"9900000086200\",\n                  \"facet.range.gap\", \"0.0003\"),\n              400);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15cb24c5fa70ba12290e43b3aa0feab5582863ee","date":1457033685,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","sourceNew":"  /** \n   * kind of an absurd test because if there is an infinite loop, it \n   * would never finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_d\", \"foo_i\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    String field = \"foo_dt\";\n    assertQEx(\"no zero gap error for facet.range: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"NOW\",\n                    \"facet.range.gap\", \"+0DAYS\",\n                    \"facet.range.end\", \"NOW+10DAY\"),\n                400);\n    field = \"foo_f\";\n    assertQEx(\"no float underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"100000000000\",\n                  \"facet.range.end\", \"100000086200\",\n                  \"facet.range.gap\", \"2160\"),\n              400);\n\n    field = \"foo_d\";\n    assertQEx(\"no double underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"9900000000000\",\n                  \"facet.range.end\", \"9900000086200\",\n                  \"facet.range.gap\", \"0.0003\"),\n              400);\n  }\n\n","sourceOld":"  /** \n   * kind of an absurd test because if there is an infinite loop, it \n   * would never finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_d\", \"foo_i\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    String field = \"foo_dt\";\n    for (String type : new String[]{\"date\", \"range\"}) {\n      assertQEx(\"no zero gap error for facet.\" + type + \": \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.\" + type, field,\n                    \"facet.\"+type+\".start\", \"NOW\",\n                    \"facet.\"+type+\".gap\", \"+0DAYS\",\n                    \"facet.\"+type+\".end\", \"NOW+10DAY\"),\n                400);\n    }\n    field = \"foo_f\";\n    assertQEx(\"no float underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"100000000000\",\n                  \"facet.range.end\", \"100000086200\",\n                  \"facet.range.gap\", \"2160\"),\n              400);\n\n    field = \"foo_d\";\n    assertQEx(\"no double underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"9900000000000\",\n                  \"facet.range.end\", \"9900000086200\",\n                  \"facet.range.gap\", \"0.0003\"),\n              400);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/SimpleFacetsTest#testRangeFacetInfiniteLoopDetection().mjava","sourceNew":"  /** \n   * kind of an absurd test because if there is an infinite loop, it \n   * would never finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_d\", \"foo_i\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    String field = \"foo_dt\";\n    assertQEx(\"no zero gap error for facet.range: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"NOW\",\n                    \"facet.range.gap\", \"+0DAYS\",\n                    \"facet.range.end\", \"NOW+10DAY\"),\n                400);\n    field = \"foo_f\";\n    assertQEx(\"no float underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"100000000000\",\n                  \"facet.range.end\", \"100000086200\",\n                  \"facet.range.gap\", \"2160\"),\n              400);\n\n    field = \"foo_d\";\n    assertQEx(\"no double underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"9900000000000\",\n                  \"facet.range.end\", \"9900000086200\",\n                  \"facet.range.gap\", \"0.0003\"),\n              400);\n  }\n\n","sourceOld":"  /** \n   * kind of an absurd test because if there is an infinite loop, it \n   * would never finish -- but at least it ensures that <i>if</i> one of \n   * these requests return, they return an error \n   */\n  public void testRangeFacetInfiniteLoopDetection() {\n\n    for (String field : new String[] {\"foo_f\", \"foo_d\", \"foo_i\"}) {\n      assertQEx(\"no zero gap error: \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.range\", field,\n                    \"facet.range.start\", \"23\",\n                    \"facet.range.gap\", \"0\",\n                    \"facet.range.end\", \"100\"),\n                400);\n    }\n    String field = \"foo_dt\";\n    for (String type : new String[]{\"date\", \"range\"}) {\n      assertQEx(\"no zero gap error for facet.\" + type + \": \" + field,\n                req(\"q\", \"*:*\",\n                    \"facet\", \"true\",\n                    \"facet.\" + type, field,\n                    \"facet.\"+type+\".start\", \"NOW\",\n                    \"facet.\"+type+\".gap\", \"+0DAYS\",\n                    \"facet.\"+type+\".end\", \"NOW+10DAY\"),\n                400);\n    }\n    field = \"foo_f\";\n    assertQEx(\"no float underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"100000000000\",\n                  \"facet.range.end\", \"100000086200\",\n                  \"facet.range.gap\", \"2160\"),\n              400);\n\n    field = \"foo_d\";\n    assertQEx(\"no double underflow error: \" + field,\n              req(\"q\", \"*:*\",\n                  \"facet\", \"true\",\n                  \"facet.range\", field,\n                  \"facet.range.start\", \"9900000000000\",\n                  \"facet.range.end\", \"9900000086200\",\n                  \"facet.range.gap\", \"0.0003\"),\n              400);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"15cb24c5fa70ba12290e43b3aa0feab5582863ee":["52c5280f6286c7546ab75b72c663f7bb1dc10e96"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["2106271e380c198349e0f6eac0395bb462913fab","52c5280f6286c7546ab75b72c663f7bb1dc10e96"],"f70d4e80f48b98103c2ab0940c74e1aec1d28b63":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f70d4e80f48b98103c2ab0940c74e1aec1d28b63"],"52c5280f6286c7546ab75b72c663f7bb1dc10e96":["2106271e380c198349e0f6eac0395bb462913fab"],"2106271e380c198349e0f6eac0395bb462913fab":["f70d4e80f48b98103c2ab0940c74e1aec1d28b63"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f70d4e80f48b98103c2ab0940c74e1aec1d28b63"],"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f70d4e80f48b98103c2ab0940c74e1aec1d28b63"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["52c5280f6286c7546ab75b72c663f7bb1dc10e96","15cb24c5fa70ba12290e43b3aa0feab5582863ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"]},"commit2Childs":{"15cb24c5fa70ba12290e43b3aa0feab5582863ee":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"f70d4e80f48b98103c2ab0940c74e1aec1d28b63":["aba371508186796cc6151d8223a5b4e16d02e26e","2106271e380c198349e0f6eac0395bb462913fab","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"52c5280f6286c7546ab75b72c663f7bb1dc10e96":["15cb24c5fa70ba12290e43b3aa0feab5582863ee","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"2106271e380c198349e0f6eac0395bb462913fab":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","52c5280f6286c7546ab75b72c663f7bb1dc10e96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f70d4e80f48b98103c2ab0940c74e1aec1d28b63","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b":[],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}