{"path":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/ParentArray#refresh(IndexReader).mjava","commits":[{"id":"89f15687f60bd49cd3d9de427e85c17fd9397d61","date":1309381327,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/ParentArray#refresh(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits deletedDocs = MultiFields.getDeletedDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, deletedDocs,\n        Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT));\n      if ((positions == null || positions.advance(first) == DocsAndPositionsEnum.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocsAndPositionsEnum.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","date":1309960478,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/ParentArray#refresh(IndexReader).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/ParentArray#refresh(IndexReader).mjava","sourceNew":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n        Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT));\n      if ((positions == null || positions.advance(first) == DocsAndPositionsEnum.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocsAndPositionsEnum.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits deletedDocs = MultiFields.getDeletedDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, deletedDocs,\n        Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT));\n      if ((positions == null || positions.advance(first) == DocsAndPositionsEnum.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocsAndPositionsEnum.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/ParentArray#refresh(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n        Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT));\n      if ((positions == null || positions.advance(first) == DocsAndPositionsEnum.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocsAndPositionsEnum.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/ParentArray#refresh(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n        Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT));\n      if ((positions == null || positions.advance(first) == DocsAndPositionsEnum.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocsAndPositionsEnum.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea469eab8fd0f3032f4fcde1c644a721e8309d3b","date":1320301582,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/ParentArray#refresh(IndexReader).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/ParentArray#refresh(IndexReader).mjava","sourceNew":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n        Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT));\n      if ((positions == null || positions.advance(first) == DocsAndPositionsEnum.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocsAndPositionsEnum.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n        Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT));\n      if ((positions == null || positions.advance(first) == DocsAndPositionsEnum.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocsAndPositionsEnum.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ea469eab8fd0f3032f4fcde1c644a721e8309d3b":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["89f15687f60bd49cd3d9de427e85c17fd9397d61"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"89f15687f60bd49cd3d9de427e85c17fd9397d61":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ea469eab8fd0f3032f4fcde1c644a721e8309d3b"]},"commit2Childs":{"ea469eab8fd0f3032f4fcde1c644a721e8309d3b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["ea469eab8fd0f3032f4fcde1c644a721e8309d3b","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d083e83f225b11e5fdd900e83d26ddb385b6955c","89f15687f60bd49cd3d9de427e85c17fd9397d61","817d8435e9135b756f08ce6710ab0baac51bdf88"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"89f15687f60bd49cd3d9de427e85c17fd9397d61":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}