{"path":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","commits":[{"id":"d5bc8e25f59990525f5beb14afe9c96240dcf4a2","date":1389042945,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given a list of fieldNames, builds up a random sort string which is guaranteed to\n   * have at least 3 clauses, ending with the \"id\" field for tie breaking\n   */\n  public static String buildRandomSort(final Collection<String> fieldNames) {\n\n    ArrayList<String> shuffledNames = new ArrayList<String>(fieldNames);\n    Collections.replaceAll(shuffledNames, \"id\", \"score\");\n    Collections.shuffle(shuffledNames, random());\n\n    final StringBuilder result = new StringBuilder();\n    final int numClauses = atLeast(2);\n\n    for (int i = 0; i < numClauses; i++) {\n      String field = shuffledNames.get(i);\n\n      // wrap in a function sometimes\n      if ( (!\"score\".equals(field))\n           && \n           (0 == _TestUtil.nextInt(random(), 0, 7)) ) {\n        // specific function doesn't matter, just proving that we can handle the concept.\n        // but we do have to be careful with non numeric fields\n        if (field.startsWith(\"str\") || field.startsWith(\"bin\")) {\n          field = \"if(exists(\" + field + \"),47,83)\";\n        } else {\n          field = \"abs(\" + field + \")\";\n        }\n      }\n      result.append(field).append(random().nextBoolean() ? \" asc, \" : \" desc, \");\n    }\n    result.append(\"id\").append(random().nextBoolean() ? \" asc\" : \" desc\");\n    return result.toString();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","sourceNew":"  /**\n   * Given a list of fieldNames, builds up a random sort string which is guaranteed to\n   * have at least 3 clauses, ending with the \"id\" field for tie breaking\n   */\n  public static String buildRandomSort(final Collection<String> fieldNames) {\n\n    ArrayList<String> shuffledNames = new ArrayList<String>(fieldNames);\n    Collections.replaceAll(shuffledNames, \"id\", \"score\");\n    Collections.shuffle(shuffledNames, random());\n\n    final StringBuilder result = new StringBuilder();\n    final int numClauses = atLeast(2);\n\n    for (int i = 0; i < numClauses; i++) {\n      String field = shuffledNames.get(i);\n\n      // wrap in a function sometimes\n      if ( (!\"score\".equals(field))\n           && \n           (0 == TestUtil.nextInt(random(), 0, 7)) ) {\n        // specific function doesn't matter, just proving that we can handle the concept.\n        // but we do have to be careful with non numeric fields\n        if (field.startsWith(\"str\") || field.startsWith(\"bin\")) {\n          field = \"if(exists(\" + field + \"),47,83)\";\n        } else {\n          field = \"abs(\" + field + \")\";\n        }\n      }\n      result.append(field).append(random().nextBoolean() ? \" asc, \" : \" desc, \");\n    }\n    result.append(\"id\").append(random().nextBoolean() ? \" asc\" : \" desc\");\n    return result.toString();\n  }\n\n","sourceOld":"  /**\n   * Given a list of fieldNames, builds up a random sort string which is guaranteed to\n   * have at least 3 clauses, ending with the \"id\" field for tie breaking\n   */\n  public static String buildRandomSort(final Collection<String> fieldNames) {\n\n    ArrayList<String> shuffledNames = new ArrayList<String>(fieldNames);\n    Collections.replaceAll(shuffledNames, \"id\", \"score\");\n    Collections.shuffle(shuffledNames, random());\n\n    final StringBuilder result = new StringBuilder();\n    final int numClauses = atLeast(2);\n\n    for (int i = 0; i < numClauses; i++) {\n      String field = shuffledNames.get(i);\n\n      // wrap in a function sometimes\n      if ( (!\"score\".equals(field))\n           && \n           (0 == _TestUtil.nextInt(random(), 0, 7)) ) {\n        // specific function doesn't matter, just proving that we can handle the concept.\n        // but we do have to be careful with non numeric fields\n        if (field.startsWith(\"str\") || field.startsWith(\"bin\")) {\n          field = \"if(exists(\" + field + \"),47,83)\";\n        } else {\n          field = \"abs(\" + field + \")\";\n        }\n      }\n      result.append(field).append(random().nextBoolean() ? \" asc, \" : \" desc, \");\n    }\n    result.append(\"id\").append(random().nextBoolean() ? \" asc\" : \" desc\");\n    return result.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d0814e12c6e2b86cf23048e6310a3715a8f6ea5","date":1393541825,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","sourceNew":"  /**\n   * Given a list of fieldNames, builds up a random sort string which is guaranteed to\n   * have at least 3 clauses, ending with the \"id\" field for tie breaking\n   */\n  public static String buildRandomSort(final Collection<String> fieldNames) {\n\n    ArrayList<String> shuffledNames = new ArrayList<String>(fieldNames);\n    Collections.replaceAll(shuffledNames, \"id\", \"score\");\n    Collections.shuffle(shuffledNames, random());\n\n    final StringBuilder result = new StringBuilder();\n    final int numClauses = TestUtil.nextInt(random(), 2, 5);\n\n    for (int i = 0; i < numClauses; i++) {\n      String field = shuffledNames.get(i);\n\n      // wrap in a function sometimes\n      if ( (!\"score\".equals(field))\n           && \n           (0 == TestUtil.nextInt(random(), 0, 7)) ) {\n        // specific function doesn't matter, just proving that we can handle the concept.\n        // but we do have to be careful with non numeric fields\n        if (field.startsWith(\"str\") || field.startsWith(\"bin\")) {\n          field = \"if(exists(\" + field + \"),47,83)\";\n        } else {\n          field = \"abs(\" + field + \")\";\n        }\n      }\n      result.append(field).append(random().nextBoolean() ? \" asc, \" : \" desc, \");\n    }\n    result.append(\"id\").append(random().nextBoolean() ? \" asc\" : \" desc\");\n    return result.toString();\n  }\n\n","sourceOld":"  /**\n   * Given a list of fieldNames, builds up a random sort string which is guaranteed to\n   * have at least 3 clauses, ending with the \"id\" field for tie breaking\n   */\n  public static String buildRandomSort(final Collection<String> fieldNames) {\n\n    ArrayList<String> shuffledNames = new ArrayList<String>(fieldNames);\n    Collections.replaceAll(shuffledNames, \"id\", \"score\");\n    Collections.shuffle(shuffledNames, random());\n\n    final StringBuilder result = new StringBuilder();\n    final int numClauses = atLeast(2);\n\n    for (int i = 0; i < numClauses; i++) {\n      String field = shuffledNames.get(i);\n\n      // wrap in a function sometimes\n      if ( (!\"score\".equals(field))\n           && \n           (0 == TestUtil.nextInt(random(), 0, 7)) ) {\n        // specific function doesn't matter, just proving that we can handle the concept.\n        // but we do have to be careful with non numeric fields\n        if (field.startsWith(\"str\") || field.startsWith(\"bin\")) {\n          field = \"if(exists(\" + field + \"),47,83)\";\n        } else {\n          field = \"abs(\" + field + \")\";\n        }\n      }\n      result.append(field).append(random().nextBoolean() ? \" asc, \" : \" desc, \");\n    }\n    result.append(\"id\").append(random().nextBoolean() ? \" asc\" : \" desc\");\n    return result.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","sourceNew":"  /**\n   * Given a list of fieldNames, builds up a random sort string which is guaranteed to\n   * have at least 3 clauses, ending with the \"id\" field for tie breaking\n   */\n  public static String buildRandomSort(final Collection<String> fieldNames) {\n\n    ArrayList<String> shuffledNames = new ArrayList<>(fieldNames);\n    Collections.replaceAll(shuffledNames, \"id\", \"score\");\n    Collections.shuffle(shuffledNames, random());\n\n    final StringBuilder result = new StringBuilder();\n    final int numClauses = TestUtil.nextInt(random(), 2, 5);\n\n    for (int i = 0; i < numClauses; i++) {\n      String field = shuffledNames.get(i);\n\n      // wrap in a function sometimes\n      if ( (!\"score\".equals(field))\n           && \n           (0 == TestUtil.nextInt(random(), 0, 7)) ) {\n        // specific function doesn't matter, just proving that we can handle the concept.\n        // but we do have to be careful with non numeric fields\n        if (field.startsWith(\"str\") || field.startsWith(\"bin\")) {\n          field = \"if(exists(\" + field + \"),47,83)\";\n        } else {\n          field = \"abs(\" + field + \")\";\n        }\n      }\n      result.append(field).append(random().nextBoolean() ? \" asc, \" : \" desc, \");\n    }\n    result.append(\"id\").append(random().nextBoolean() ? \" asc\" : \" desc\");\n    return result.toString();\n  }\n\n","sourceOld":"  /**\n   * Given a list of fieldNames, builds up a random sort string which is guaranteed to\n   * have at least 3 clauses, ending with the \"id\" field for tie breaking\n   */\n  public static String buildRandomSort(final Collection<String> fieldNames) {\n\n    ArrayList<String> shuffledNames = new ArrayList<String>(fieldNames);\n    Collections.replaceAll(shuffledNames, \"id\", \"score\");\n    Collections.shuffle(shuffledNames, random());\n\n    final StringBuilder result = new StringBuilder();\n    final int numClauses = TestUtil.nextInt(random(), 2, 5);\n\n    for (int i = 0; i < numClauses; i++) {\n      String field = shuffledNames.get(i);\n\n      // wrap in a function sometimes\n      if ( (!\"score\".equals(field))\n           && \n           (0 == TestUtil.nextInt(random(), 0, 7)) ) {\n        // specific function doesn't matter, just proving that we can handle the concept.\n        // but we do have to be careful with non numeric fields\n        if (field.startsWith(\"str\") || field.startsWith(\"bin\")) {\n          field = \"if(exists(\" + field + \"),47,83)\";\n        } else {\n          field = \"abs(\" + field + \")\";\n        }\n      }\n      result.append(field).append(random().nextBoolean() ? \" asc, \" : \" desc, \");\n    }\n    result.append(\"id\").append(random().nextBoolean() ? \" asc\" : \" desc\");\n    return result.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd3693b696a64d987bf4b3a14399d2105f16b05e","date":1396054865,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","sourceNew":"  /**\n   * Given a list of fieldNames, builds up a random sort string which is guaranteed to\n   * have at least 3 clauses, ending with the \"id\" field for tie breaking\n   */\n  public static String buildRandomSort(final Collection<String> fieldNames) {\n\n    ArrayList<String> shuffledNames = new ArrayList<>(fieldNames);\n    Collections.replaceAll(shuffledNames, \"id\", \"score\");\n    Collections.shuffle(shuffledNames, random());\n\n    final StringBuilder result = new StringBuilder();\n    final int numClauses = TestUtil.nextInt(random(), 2, 5);\n\n    for (int i = 0; i < numClauses; i++) {\n      String field = shuffledNames.get(i);\n\n      // wrap in a function sometimes\n      if ( (!\"score\".equals(field) && !field.contains(\"bcd\"))\n           && \n           (0 == TestUtil.nextInt(random(), 0, 7)) ) {\n        // specific function doesn't matter, just proving that we can handle the concept.\n        // but we do have to be careful with non numeric fields\n        if (field.contains(\"float\") || field.contains(\"double\")\n            || field.contains(\"int\") || field.contains(\"long\")) {\n          field = \"abs(\" + field + \")\";\n        } else {\n          field = \"if(exists(\" + field + \"),47,83)\";\n        }\n      }\n      result.append(field).append(random().nextBoolean() ? \" asc, \" : \" desc, \");\n    }\n    result.append(\"id\").append(random().nextBoolean() ? \" asc\" : \" desc\");\n    return result.toString();\n  }\n\n","sourceOld":"  /**\n   * Given a list of fieldNames, builds up a random sort string which is guaranteed to\n   * have at least 3 clauses, ending with the \"id\" field for tie breaking\n   */\n  public static String buildRandomSort(final Collection<String> fieldNames) {\n\n    ArrayList<String> shuffledNames = new ArrayList<>(fieldNames);\n    Collections.replaceAll(shuffledNames, \"id\", \"score\");\n    Collections.shuffle(shuffledNames, random());\n\n    final StringBuilder result = new StringBuilder();\n    final int numClauses = TestUtil.nextInt(random(), 2, 5);\n\n    for (int i = 0; i < numClauses; i++) {\n      String field = shuffledNames.get(i);\n\n      // wrap in a function sometimes\n      if ( (!\"score\".equals(field))\n           && \n           (0 == TestUtil.nextInt(random(), 0, 7)) ) {\n        // specific function doesn't matter, just proving that we can handle the concept.\n        // but we do have to be careful with non numeric fields\n        if (field.startsWith(\"str\") || field.startsWith(\"bin\")) {\n          field = \"if(exists(\" + field + \"),47,83)\";\n        } else {\n          field = \"abs(\" + field + \")\";\n        }\n      }\n      result.append(field).append(random().nextBoolean() ? \" asc, \" : \" desc, \");\n    }\n    result.append(\"id\").append(random().nextBoolean() ? \" asc\" : \" desc\");\n    return result.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","sourceNew":"  /**\n   * Given a list of fieldNames, builds up a random sort string which is guaranteed to\n   * have at least 3 clauses, ending with the \"id\" field for tie breaking\n   */\n  public static String buildRandomSort(final Collection<String> fieldNames) {\n\n    ArrayList<String> shuffledNames = new ArrayList<>(fieldNames);\n    Collections.replaceAll(shuffledNames, \"id\", \"score\");\n    Collections.shuffle(shuffledNames, random());\n\n    final StringBuilder result = new StringBuilder();\n    final int numClauses = TestUtil.nextInt(random(), 2, 5);\n\n    for (int i = 0; i < numClauses; i++) {\n      String field = shuffledNames.get(i);\n\n      // wrap in a function sometimes\n      if ( (!\"score\".equals(field) && !field.contains(\"bcd\"))\n           && \n           (0 == TestUtil.nextInt(random(), 0, 7)) ) {\n        // specific function doesn't matter, just proving that we can handle the concept.\n        // but we do have to be careful with non numeric fields\n        if (field.contains(\"float\") || field.contains(\"double\")\n            || field.contains(\"int\") || field.contains(\"long\")) {\n          field = \"abs(\" + field + \")\";\n        } else {\n          field = \"if(exists(\" + field + \"),47,83)\";\n        }\n      }\n      result.append(field).append(random().nextBoolean() ? \" asc, \" : \" desc, \");\n    }\n    result.append(\"id\").append(random().nextBoolean() ? \" asc\" : \" desc\");\n    return result.toString();\n  }\n\n","sourceOld":"  /**\n   * Given a list of fieldNames, builds up a random sort string which is guaranteed to\n   * have at least 3 clauses, ending with the \"id\" field for tie breaking\n   */\n  public static String buildRandomSort(final Collection<String> fieldNames) {\n\n    ArrayList<String> shuffledNames = new ArrayList<>(fieldNames);\n    Collections.replaceAll(shuffledNames, \"id\", \"score\");\n    Collections.shuffle(shuffledNames, random());\n\n    final StringBuilder result = new StringBuilder();\n    final int numClauses = TestUtil.nextInt(random(), 2, 5);\n\n    for (int i = 0; i < numClauses; i++) {\n      String field = shuffledNames.get(i);\n\n      // wrap in a function sometimes\n      if ( (!\"score\".equals(field))\n           && \n           (0 == TestUtil.nextInt(random(), 0, 7)) ) {\n        // specific function doesn't matter, just proving that we can handle the concept.\n        // but we do have to be careful with non numeric fields\n        if (field.startsWith(\"str\") || field.startsWith(\"bin\")) {\n          field = \"if(exists(\" + field + \"),47,83)\";\n        } else {\n          field = \"abs(\" + field + \")\";\n        }\n      }\n      result.append(field).append(random().nextBoolean() ? \" asc, \" : \" desc, \");\n    }\n    result.append(\"id\").append(random().nextBoolean() ? \" asc\" : \" desc\");\n    return result.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2106271e380c198349e0f6eac0395bb462913fab","date":1397072894,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomSort(Collection[String]).mjava","sourceNew":"  /**\n   * Given a list of fieldNames, builds up a random sort string which is guaranteed to\n   * have at least 3 clauses, ending with the \"id\" field for tie breaking\n   */\n  public static String buildRandomSort(final Collection<String> fieldNames) {\n\n    ArrayList<String> shuffledNames = new ArrayList<>(fieldNames);\n    Collections.replaceAll(shuffledNames, \"id\", \"score\");\n    Collections.shuffle(shuffledNames, random());\n\n    final StringBuilder result = new StringBuilder();\n    final int numClauses = TestUtil.nextInt(random(), 2, 5);\n\n    for (int i = 0; i < numClauses; i++) {\n      String field = shuffledNames.get(i);\n\n      // wrap in a function sometimes\n      if ( ! \"score\".equals(field) && 0 == TestUtil.nextInt(random(), 0, 7)) {\n        // specific function doesn't matter, just proving that we can handle the concept.\n        // but we do have to be careful with non numeric fields\n        if (field.contains(\"float\") || field.contains(\"double\")\n            || field.contains(\"int\") || field.contains(\"long\")) {\n          field = \"abs(\" + field + \")\";\n        } else {\n          field = \"if(exists(\" + field + \"),47,83)\";\n        }\n      }\n      result.append(field).append(random().nextBoolean() ? \" asc, \" : \" desc, \");\n    }\n    result.append(\"id\").append(random().nextBoolean() ? \" asc\" : \" desc\");\n    return result.toString();\n  }\n\n","sourceOld":"  /**\n   * Given a list of fieldNames, builds up a random sort string which is guaranteed to\n   * have at least 3 clauses, ending with the \"id\" field for tie breaking\n   */\n  public static String buildRandomSort(final Collection<String> fieldNames) {\n\n    ArrayList<String> shuffledNames = new ArrayList<>(fieldNames);\n    Collections.replaceAll(shuffledNames, \"id\", \"score\");\n    Collections.shuffle(shuffledNames, random());\n\n    final StringBuilder result = new StringBuilder();\n    final int numClauses = TestUtil.nextInt(random(), 2, 5);\n\n    for (int i = 0; i < numClauses; i++) {\n      String field = shuffledNames.get(i);\n\n      // wrap in a function sometimes\n      if ( (!\"score\".equals(field) && !field.contains(\"bcd\"))\n           && \n           (0 == TestUtil.nextInt(random(), 0, 7)) ) {\n        // specific function doesn't matter, just proving that we can handle the concept.\n        // but we do have to be careful with non numeric fields\n        if (field.contains(\"float\") || field.contains(\"double\")\n            || field.contains(\"int\") || field.contains(\"long\")) {\n          field = \"abs(\" + field + \")\";\n        } else {\n          field = \"if(exists(\" + field + \"),47,83)\";\n        }\n      }\n      result.append(field).append(random().nextBoolean() ? \" asc, \" : \" desc, \");\n    }\n    result.append(\"id\").append(random().nextBoolean() ? \" asc\" : \" desc\");\n    return result.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3d0814e12c6e2b86cf23048e6310a3715a8f6ea5":["6613659748fe4411a7dcf85266e55db1f95f7315"],"5eb2511ababf862ea11e10761c70ee560cd84510":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","cd3693b696a64d987bf4b3a14399d2105f16b05e"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3d0814e12c6e2b86cf23048e6310a3715a8f6ea5"],"2106271e380c198349e0f6eac0395bb462913fab":["cd3693b696a64d987bf4b3a14399d2105f16b05e"],"6613659748fe4411a7dcf85266e55db1f95f7315":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd3693b696a64d987bf4b3a14399d2105f16b05e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2106271e380c198349e0f6eac0395bb462913fab"]},"commit2Childs":{"3d0814e12c6e2b86cf23048e6310a3715a8f6ea5":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5eb2511ababf862ea11e10761c70ee560cd84510","cd3693b696a64d987bf4b3a14399d2105f16b05e"],"6613659748fe4411a7dcf85266e55db1f95f7315":["3d0814e12c6e2b86cf23048e6310a3715a8f6ea5"],"2106271e380c198349e0f6eac0395bb462913fab":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["6613659748fe4411a7dcf85266e55db1f95f7315"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"cd3693b696a64d987bf4b3a14399d2105f16b05e":["5eb2511ababf862ea11e10761c70ee560cd84510","2106271e380c198349e0f6eac0395bb462913fab"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}