{"path":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","commits":[{"id":"58c36d634c9789cb739fbd175c1a8d50b3303f6b","date":1478022614,"type":0,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.min(topN, firstPassTopDocs.totalHits);\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    final SolrIndexSearcher solrIndexSearch = (SolrIndexSearcher) searcher;\n    scoreFeatures(solrIndexSearch, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9720b151fde2073f4e401450f4574e5f31c2d0ff","date":1478184029,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.min(topN, firstPassTopDocs.totalHits);\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    final SolrIndexSearcher solrIndexSearch = (SolrIndexSearcher) searcher;\n    scoreFeatures(solrIndexSearch, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","date":1498031702,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    final SolrIndexSearcher solrIndexSearch = (SolrIndexSearcher) searcher;\n    scoreFeatures(solrIndexSearch, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","sourceOld":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.min(topN, firstPassTopDocs.totalHits);\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    final SolrIndexSearcher solrIndexSearch = (SolrIndexSearcher) searcher;\n    scoreFeatures(solrIndexSearch, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","bugFix":["58c36d634c9789cb739fbd175c1a8d50b3303f6b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    final SolrIndexSearcher solrIndexSearch = (SolrIndexSearcher) searcher;\n    scoreFeatures(solrIndexSearch, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","sourceOld":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.min(topN, firstPassTopDocs.totalHits);\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    final SolrIndexSearcher solrIndexSearch = (SolrIndexSearcher) searcher;\n    scoreFeatures(solrIndexSearch, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    final SolrIndexSearcher solrIndexSearch = (SolrIndexSearcher) searcher;\n    scoreFeatures(solrIndexSearch, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","sourceOld":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.min(topN, firstPassTopDocs.totalHits);\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    final SolrIndexSearcher solrIndexSearch = (SolrIndexSearcher) searcher;\n    scoreFeatures(solrIndexSearch, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2534504cc6a6ab3301865de897422111495e0aad","date":1499445439,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","sourceOld":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    final SolrIndexSearcher solrIndexSearch = (SolrIndexSearcher) searcher;\n    scoreFeatures(solrIndexSearch, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9a989a32a073c55e3aef6f807a3474184bbcf49","date":1499930209,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","sourceOld":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    final SolrIndexSearcher solrIndexSearch = (SolrIndexSearcher) searcher;\n    scoreFeatures(solrIndexSearch, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb569fd721c41eafc2a2d788499a7df490c7f1a5","date":1499930871,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","sourceOld":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    final SolrIndexSearcher solrIndexSearch = (SolrIndexSearcher) searcher;\n    scoreFeatures(solrIndexSearch, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, ScoreMode.COMPLETE);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","sourceOld":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, ScoreMode.COMPLETE);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","sourceOld":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, true);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"475584d5e08a22ad3fc7babefe006d77bc744567","date":1523282824,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createWeight(searcher.rewrite(scoringQuery), ScoreMode.COMPLETE, 1);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","sourceOld":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, ScoreMode.COMPLETE);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58e44159788900f4a2113b84463dc3fbbf80f20","date":1523319203,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createWeight(searcher.rewrite(scoringQuery), ScoreMode.COMPLETE, 1);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","sourceOld":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createNormalizedWeight(scoringQuery, ScoreMode.COMPLETE);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createWeight(searcher.rewrite(scoringQuery), ScoreMode.COMPLETE, 1);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked);\n  }\n\n","sourceOld":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createWeight(searcher.rewrite(scoringQuery), ScoreMode.COMPLETE, 1);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createWeight(searcher.rewrite(scoringQuery), ScoreMode.COMPLETE, 1);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked);\n  }\n\n","sourceOld":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createWeight(searcher.rewrite(scoringQuery), ScoreMode.COMPLETE, 1);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.scoreDocs.length == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    assert firstPassTopDocs.totalHits.relation == TotalHits.Relation.EQUAL_TO;\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits.value));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createWeight(searcher.rewrite(scoringQuery), ScoreMode.COMPLETE, 1);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked);\n  }\n\n","sourceOld":"  /**\n   * rescores the documents:\n   *\n   * @param searcher\n   *          current IndexSearcher\n   * @param firstPassTopDocs\n   *          documents to rerank;\n   * @param topN\n   *          documents to return;\n   */\n  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs,\n      int topN) throws IOException {\n    if ((topN == 0) || (firstPassTopDocs.totalHits == 0)) {\n      return firstPassTopDocs;\n    }\n    final ScoreDoc[] hits = firstPassTopDocs.scoreDocs;\n    Arrays.sort(hits, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        return a.doc - b.doc;\n      }\n    });\n\n    topN = Math.toIntExact(Math.min(topN, firstPassTopDocs.totalHits));\n    final ScoreDoc[] reranked = new ScoreDoc[topN];\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final LTRScoringQuery.ModelWeight modelWeight = (LTRScoringQuery.ModelWeight) searcher\n        .createWeight(searcher.rewrite(scoringQuery), ScoreMode.COMPLETE, 1);\n\n    scoreFeatures(searcher, firstPassTopDocs,topN, modelWeight, hits, leaves, reranked);\n    // Must sort all documents that we reranked, and then select the top\n    Arrays.sort(reranked, new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    });\n\n    return new TopDocs(firstPassTopDocs.totalHits, reranked);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"475584d5e08a22ad3fc7babefe006d77bc744567":["417142ff08fda9cf0b72d5133e63097a166c6458"],"58c36d634c9789cb739fbd175c1a8d50b3303f6b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["58c36d634c9789cb739fbd175c1a8d50b3303f6b"],"9720b151fde2073f4e401450f4574e5f31c2d0ff":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","58c36d634c9789cb739fbd175c1a8d50b3303f6b"],"fb569fd721c41eafc2a2d788499a7df490c7f1a5":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","f9a989a32a073c55e3aef6f807a3474184bbcf49"],"2534504cc6a6ab3301865de897422111495e0aad":["28288370235ed02234a64753cdbf0c6ec096304a"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["58c36d634c9789cb739fbd175c1a8d50b3303f6b","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"28288370235ed02234a64753cdbf0c6ec096304a":["58c36d634c9789cb739fbd175c1a8d50b3303f6b","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"f9a989a32a073c55e3aef6f807a3474184bbcf49":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","2534504cc6a6ab3301865de897422111495e0aad"],"417142ff08fda9cf0b72d5133e63097a166c6458":["2534504cc6a6ab3301865de897422111495e0aad","9fc47cb7b4346802411bb432f501ed0673d7119e"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["417142ff08fda9cf0b72d5133e63097a166c6458","475584d5e08a22ad3fc7babefe006d77bc744567"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["d58e44159788900f4a2113b84463dc3fbbf80f20","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"83788ad129a5154d5c6562c4e8ce3db48793aada":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["2534504cc6a6ab3301865de897422111495e0aad"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83788ad129a5154d5c6562c4e8ce3db48793aada"]},"commit2Childs":{"475584d5e08a22ad3fc7babefe006d77bc744567":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"58c36d634c9789cb739fbd175c1a8d50b3303f6b":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","9720b151fde2073f4e401450f4574e5f31c2d0ff","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"9720b151fde2073f4e401450f4574e5f31c2d0ff":[],"fb569fd721c41eafc2a2d788499a7df490c7f1a5":[],"2534504cc6a6ab3301865de897422111495e0aad":["f9a989a32a073c55e3aef6f807a3474184bbcf49","417142ff08fda9cf0b72d5133e63097a166c6458","9fc47cb7b4346802411bb432f501ed0673d7119e"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["fb569fd721c41eafc2a2d788499a7df490c7f1a5","f9a989a32a073c55e3aef6f807a3474184bbcf49"],"f9a989a32a073c55e3aef6f807a3474184bbcf49":["fb569fd721c41eafc2a2d788499a7df490c7f1a5"],"28288370235ed02234a64753cdbf0c6ec096304a":["2534504cc6a6ab3301865de897422111495e0aad"],"417142ff08fda9cf0b72d5133e63097a166c6458":["475584d5e08a22ad3fc7babefe006d77bc744567","d58e44159788900f4a2113b84463dc3fbbf80f20"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["58c36d634c9789cb739fbd175c1a8d50b3303f6b","9720b151fde2073f4e401450f4574e5f31c2d0ff"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","83788ad129a5154d5c6562c4e8ce3db48793aada"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9720b151fde2073f4e401450f4574e5f31c2d0ff","fb569fd721c41eafc2a2d788499a7df490c7f1a5","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}