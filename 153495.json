{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TermVectorsEvaluator#doWork(Object...).mjava","commits":[{"id":"21cc21dac328d94dbc79c104b8e626fca70b3f79","date":1515458383,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TermVectorsEvaluator#doWork(Object...).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Object doWork(Object... objects) throws IOException {\n\n    if (objects.length == 1) {\n      //Just docs\n      List<Tuple> tuples = (List<Tuple>) objects[0];\n      TreeMap<String, Integer> docFreqs = new TreeMap();\n      List<String> features = new ArrayList();\n      List<String> rowLabels = new ArrayList();\n\n      for (Tuple tuple : tuples) {\n\n        Set<String> docTerms = new HashSet();\n\n        if (tuple.get(\"terms\") == null) {\n          throw new IOException(\"The document tuples must contain a terms field\");\n        }\n\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n\n        String id = tuple.getString(\"id\");\n        rowLabels.add(id);\n\n        for (String term : terms) {\n\n          if (term.length() < minTermLength) {\n            //Eliminate terms due to length\n            continue;\n          }\n\n          if (!docTerms.contains(term)) {\n            docTerms.add(term);\n            if (docFreqs.containsKey(term)) {\n              int count = docFreqs.get(term).intValue();\n              docFreqs.put(term, ++count);\n            } else {\n              docFreqs.put(term, 1);\n            }\n          }\n        }\n      }\n\n      //Eliminate terms based on frequency\n\n      int min = (int) (tuples.size() * minDocFreq);\n      int max = (int) (tuples.size() * maxDocFreq);\n\n      Set<Map.Entry<String, Integer>> entries = docFreqs.entrySet();\n      Iterator<Map.Entry<String, Integer>> it = entries.iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, Integer> entry = it.next();\n        int count = entry.getValue().intValue();\n\n        if (count < min || count > max) {\n          it.remove();\n        }\n      }\n\n      int totalTerms = docFreqs.size();\n      Set<String> keys = docFreqs.keySet();\n      features.addAll(keys);\n      double[][] docVec = new double[tuples.size()][];\n      for (int t = 0; t < tuples.size(); t++) {\n        Tuple tuple = tuples.get(t);\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n        Map<String, Integer> termFreq = new HashMap();\n\n        for (String term : terms) {\n          if (docFreqs.containsKey(term)) {\n            if (termFreq.containsKey(term)) {\n              int count = termFreq.get(term).intValue();\n              termFreq.put(term, ++count);\n            } else {\n              termFreq.put(term, 1);\n            }\n          }\n        }\n\n        double[] termVec = new double[totalTerms];\n        for (int i = 0; i < totalTerms; i++) {\n          String feature = features.get(i);\n          int df = docFreqs.get(feature);\n          int tf = termFreq.containsKey(feature) ? termFreq.get(feature) : 0;\n          termVec[i] = Math.sqrt(tf) * (double) (Math.log((tuples.size() + 1) / (double) (df + 1)) + 1.0);\n        }\n        docVec[t] = termVec;\n      }\n\n      Matrix matrix = new Matrix(docVec);\n      matrix.setColumnLabels(features);\n      matrix.setRowLabels(rowLabels);\n      matrix.setAttribute(\"docFreqs\", docFreqs);\n      return matrix;\n    } else {\n      throw new IOException(\"The termVectors function a single positional parameter.\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"542e93518aa56b94e3263948f3c7b7ebe229b9dd","date":1515460363,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TermVectorsEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TermVectorsEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object... objects) throws IOException {\n\n    if (objects.length == 1) {\n      //Just docs\n      if(!(objects[0] instanceof List)) {\n        throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n      } else {\n        List list = (List)objects[0];\n        if(list.size() > 0) {\n          Object o = list.get(0);\n          if(!(o instanceof Tuple)) {\n            throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n          }\n        } else {\n          throw new IOException(\"Empty list was passed as a parameter to termVectors function.\");\n        }\n      }\n\n      List<Tuple> tuples = (List<Tuple>) objects[0];\n      TreeMap<String, Integer> docFreqs = new TreeMap();\n      List<String> features = new ArrayList();\n      List<String> rowLabels = new ArrayList();\n\n      for (Tuple tuple : tuples) {\n\n        Set<String> docTerms = new HashSet();\n\n        if (tuple.get(\"terms\") == null) {\n          throw new IOException(\"The document tuples must contain a terms field\");\n        }\n\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n\n        String id = tuple.getString(\"id\");\n        rowLabels.add(id);\n\n        for (String term : terms) {\n\n          if (term.length() < minTermLength) {\n            //Eliminate terms due to length\n            continue;\n          }\n\n          if (!docTerms.contains(term)) {\n            docTerms.add(term);\n            if (docFreqs.containsKey(term)) {\n              int count = docFreqs.get(term).intValue();\n              docFreqs.put(term, ++count);\n            } else {\n              docFreqs.put(term, 1);\n            }\n          }\n        }\n      }\n\n      //Eliminate terms based on frequency\n\n      int min = (int) (tuples.size() * minDocFreq);\n      int max = (int) (tuples.size() * maxDocFreq);\n\n      Set<Map.Entry<String, Integer>> entries = docFreqs.entrySet();\n      Iterator<Map.Entry<String, Integer>> it = entries.iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, Integer> entry = it.next();\n        int count = entry.getValue().intValue();\n\n        if (count < min || count > max) {\n          it.remove();\n        }\n      }\n\n      int totalTerms = docFreqs.size();\n      Set<String> keys = docFreqs.keySet();\n      features.addAll(keys);\n      double[][] docVec = new double[tuples.size()][];\n      for (int t = 0; t < tuples.size(); t++) {\n        Tuple tuple = tuples.get(t);\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n        Map<String, Integer> termFreq = new HashMap();\n\n        for (String term : terms) {\n          if (docFreqs.containsKey(term)) {\n            if (termFreq.containsKey(term)) {\n              int count = termFreq.get(term).intValue();\n              termFreq.put(term, ++count);\n            } else {\n              termFreq.put(term, 1);\n            }\n          }\n        }\n\n        double[] termVec = new double[totalTerms];\n        for (int i = 0; i < totalTerms; i++) {\n          String feature = features.get(i);\n          int df = docFreqs.get(feature);\n          int tf = termFreq.containsKey(feature) ? termFreq.get(feature) : 0;\n          termVec[i] = Math.sqrt(tf) * (double) (Math.log((tuples.size() + 1) / (double) (df + 1)) + 1.0);\n        }\n        docVec[t] = termVec;\n      }\n\n      Matrix matrix = new Matrix(docVec);\n      matrix.setColumnLabels(features);\n      matrix.setRowLabels(rowLabels);\n      matrix.setAttribute(\"docFreqs\", docFreqs);\n      return matrix;\n    } else {\n      throw new IOException(\"The termVectors function takes a single positional parameter.\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object... objects) throws IOException {\n\n    if (objects.length == 1) {\n      //Just docs\n      List<Tuple> tuples = (List<Tuple>) objects[0];\n      TreeMap<String, Integer> docFreqs = new TreeMap();\n      List<String> features = new ArrayList();\n      List<String> rowLabels = new ArrayList();\n\n      for (Tuple tuple : tuples) {\n\n        Set<String> docTerms = new HashSet();\n\n        if (tuple.get(\"terms\") == null) {\n          throw new IOException(\"The document tuples must contain a terms field\");\n        }\n\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n\n        String id = tuple.getString(\"id\");\n        rowLabels.add(id);\n\n        for (String term : terms) {\n\n          if (term.length() < minTermLength) {\n            //Eliminate terms due to length\n            continue;\n          }\n\n          if (!docTerms.contains(term)) {\n            docTerms.add(term);\n            if (docFreqs.containsKey(term)) {\n              int count = docFreqs.get(term).intValue();\n              docFreqs.put(term, ++count);\n            } else {\n              docFreqs.put(term, 1);\n            }\n          }\n        }\n      }\n\n      //Eliminate terms based on frequency\n\n      int min = (int) (tuples.size() * minDocFreq);\n      int max = (int) (tuples.size() * maxDocFreq);\n\n      Set<Map.Entry<String, Integer>> entries = docFreqs.entrySet();\n      Iterator<Map.Entry<String, Integer>> it = entries.iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, Integer> entry = it.next();\n        int count = entry.getValue().intValue();\n\n        if (count < min || count > max) {\n          it.remove();\n        }\n      }\n\n      int totalTerms = docFreqs.size();\n      Set<String> keys = docFreqs.keySet();\n      features.addAll(keys);\n      double[][] docVec = new double[tuples.size()][];\n      for (int t = 0; t < tuples.size(); t++) {\n        Tuple tuple = tuples.get(t);\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n        Map<String, Integer> termFreq = new HashMap();\n\n        for (String term : terms) {\n          if (docFreqs.containsKey(term)) {\n            if (termFreq.containsKey(term)) {\n              int count = termFreq.get(term).intValue();\n              termFreq.put(term, ++count);\n            } else {\n              termFreq.put(term, 1);\n            }\n          }\n        }\n\n        double[] termVec = new double[totalTerms];\n        for (int i = 0; i < totalTerms; i++) {\n          String feature = features.get(i);\n          int df = docFreqs.get(feature);\n          int tf = termFreq.containsKey(feature) ? termFreq.get(feature) : 0;\n          termVec[i] = Math.sqrt(tf) * (double) (Math.log((tuples.size() + 1) / (double) (df + 1)) + 1.0);\n        }\n        docVec[t] = termVec;\n      }\n\n      Matrix matrix = new Matrix(docVec);\n      matrix.setColumnLabels(features);\n      matrix.setRowLabels(rowLabels);\n      matrix.setAttribute(\"docFreqs\", docFreqs);\n      return matrix;\n    } else {\n      throw new IOException(\"The termVectors function a single positional parameter.\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f0ec25ba9bff9e87e402c4fe0afe87f877bccd6","date":1516045834,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TermVectorsEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TermVectorsEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object... objects) throws IOException {\n\n    if (objects.length == 1) {\n      //Just docs\n      if(!(objects[0] instanceof List)) {\n        throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n      } else {\n        List list = (List)objects[0];\n        if(list.size() > 0) {\n          Object o = list.get(0);\n          if(!(o instanceof Tuple)) {\n            throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n          }\n        } else {\n          throw new IOException(\"Empty list was passed as a parameter to termVectors function.\");\n        }\n      }\n\n      List<Tuple> tuples = (List<Tuple>) objects[0];\n      TreeMap<String, Integer> docFreqs = new TreeMap();\n      List<String> features = new ArrayList();\n      List<String> rowLabels = new ArrayList();\n\n      for (Tuple tuple : tuples) {\n\n        Set<String> docTerms = new HashSet();\n\n        if (tuple.get(\"terms\") == null) {\n          throw new IOException(\"The document tuples must contain a terms field\");\n        }\n\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n\n        String id = tuple.getString(\"id\");\n        rowLabels.add(id);\n\n        OUTER:\n        for (String term : terms) {\n\n          if (term.length() < minTermLength) {\n            //Eliminate terms due to length\n            continue;\n          }\n\n          if(excludes != null) {\n            for (String exclude : excludes) {\n              if (term.indexOf(exclude) > -1) {\n                continue OUTER;\n              }\n            }\n          }\n\n          if (!docTerms.contains(term)) {\n            docTerms.add(term);\n            if (docFreqs.containsKey(term)) {\n              int count = docFreqs.get(term).intValue();\n              docFreqs.put(term, ++count);\n            } else {\n              docFreqs.put(term, 1);\n            }\n          }\n        }\n      }\n\n      //Eliminate terms based on frequency\n\n      int min = (int) (tuples.size() * minDocFreq);\n      int max = (int) (tuples.size() * maxDocFreq);\n\n      Set<Map.Entry<String, Integer>> entries = docFreqs.entrySet();\n      Iterator<Map.Entry<String, Integer>> it = entries.iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, Integer> entry = it.next();\n        int count = entry.getValue().intValue();\n\n        if (count < min || count > max) {\n          it.remove();\n        }\n      }\n      int totalTerms = docFreqs.size();\n      Set<String> keys = docFreqs.keySet();\n      features.addAll(keys);\n      double[][] docVec = new double[tuples.size()][];\n      for (int t = 0; t < tuples.size(); t++) {\n        Tuple tuple = tuples.get(t);\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n        Map<String, Integer> termFreq = new HashMap();\n\n        for (String term : terms) {\n          if (docFreqs.containsKey(term)) {\n            if (termFreq.containsKey(term)) {\n              int count = termFreq.get(term).intValue();\n              termFreq.put(term, ++count);\n            } else {\n              termFreq.put(term, 1);\n            }\n          }\n        }\n\n        double[] termVec = new double[totalTerms];\n        for (int i = 0; i < totalTerms; i++) {\n          String feature = features.get(i);\n          int df = docFreqs.get(feature);\n          int tf = termFreq.containsKey(feature) ? termFreq.get(feature) : 0;\n          termVec[i] = Math.sqrt(tf) * (double) (Math.log((tuples.size() + 1) / (double) (df + 1)) + 1.0);\n        }\n        docVec[t] = termVec;\n      }\n\n      Matrix matrix = new Matrix(docVec);\n      matrix.setColumnLabels(features);\n      matrix.setRowLabels(rowLabels);\n      matrix.setAttribute(\"docFreqs\", docFreqs);\n      return matrix;\n    } else {\n      throw new IOException(\"The termVectors function takes a single positional parameter.\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object... objects) throws IOException {\n\n    if (objects.length == 1) {\n      //Just docs\n      if(!(objects[0] instanceof List)) {\n        throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n      } else {\n        List list = (List)objects[0];\n        if(list.size() > 0) {\n          Object o = list.get(0);\n          if(!(o instanceof Tuple)) {\n            throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n          }\n        } else {\n          throw new IOException(\"Empty list was passed as a parameter to termVectors function.\");\n        }\n      }\n\n      List<Tuple> tuples = (List<Tuple>) objects[0];\n      TreeMap<String, Integer> docFreqs = new TreeMap();\n      List<String> features = new ArrayList();\n      List<String> rowLabels = new ArrayList();\n\n      for (Tuple tuple : tuples) {\n\n        Set<String> docTerms = new HashSet();\n\n        if (tuple.get(\"terms\") == null) {\n          throw new IOException(\"The document tuples must contain a terms field\");\n        }\n\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n\n        String id = tuple.getString(\"id\");\n        rowLabels.add(id);\n\n        for (String term : terms) {\n\n          if (term.length() < minTermLength) {\n            //Eliminate terms due to length\n            continue;\n          }\n\n          if (!docTerms.contains(term)) {\n            docTerms.add(term);\n            if (docFreqs.containsKey(term)) {\n              int count = docFreqs.get(term).intValue();\n              docFreqs.put(term, ++count);\n            } else {\n              docFreqs.put(term, 1);\n            }\n          }\n        }\n      }\n\n      //Eliminate terms based on frequency\n\n      int min = (int) (tuples.size() * minDocFreq);\n      int max = (int) (tuples.size() * maxDocFreq);\n\n      Set<Map.Entry<String, Integer>> entries = docFreqs.entrySet();\n      Iterator<Map.Entry<String, Integer>> it = entries.iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, Integer> entry = it.next();\n        int count = entry.getValue().intValue();\n\n        if (count < min || count > max) {\n          it.remove();\n        }\n      }\n\n      int totalTerms = docFreqs.size();\n      Set<String> keys = docFreqs.keySet();\n      features.addAll(keys);\n      double[][] docVec = new double[tuples.size()][];\n      for (int t = 0; t < tuples.size(); t++) {\n        Tuple tuple = tuples.get(t);\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n        Map<String, Integer> termFreq = new HashMap();\n\n        for (String term : terms) {\n          if (docFreqs.containsKey(term)) {\n            if (termFreq.containsKey(term)) {\n              int count = termFreq.get(term).intValue();\n              termFreq.put(term, ++count);\n            } else {\n              termFreq.put(term, 1);\n            }\n          }\n        }\n\n        double[] termVec = new double[totalTerms];\n        for (int i = 0; i < totalTerms; i++) {\n          String feature = features.get(i);\n          int df = docFreqs.get(feature);\n          int tf = termFreq.containsKey(feature) ? termFreq.get(feature) : 0;\n          termVec[i] = Math.sqrt(tf) * (double) (Math.log((tuples.size() + 1) / (double) (df + 1)) + 1.0);\n        }\n        docVec[t] = termVec;\n      }\n\n      Matrix matrix = new Matrix(docVec);\n      matrix.setColumnLabels(features);\n      matrix.setRowLabels(rowLabels);\n      matrix.setAttribute(\"docFreqs\", docFreqs);\n      return matrix;\n    } else {\n      throw new IOException(\"The termVectors function takes a single positional parameter.\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TermVectorsEvaluator#doWork(Object...).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Object doWork(Object... objects) throws IOException {\n\n    if (objects.length == 1) {\n      //Just docs\n      if(!(objects[0] instanceof List)) {\n        throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n      } else {\n        List list = (List)objects[0];\n        if(list.size() > 0) {\n          Object o = list.get(0);\n          if(!(o instanceof Tuple)) {\n            throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n          }\n        } else {\n          throw new IOException(\"Empty list was passed as a parameter to termVectors function.\");\n        }\n      }\n\n      List<Tuple> tuples = (List<Tuple>) objects[0];\n      TreeMap<String, Integer> docFreqs = new TreeMap();\n      List<String> features = new ArrayList();\n      List<String> rowLabels = new ArrayList();\n\n      for (Tuple tuple : tuples) {\n\n        Set<String> docTerms = new HashSet();\n\n        if (tuple.get(\"terms\") == null) {\n          throw new IOException(\"The document tuples must contain a terms field\");\n        }\n\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n\n        String id = tuple.getString(\"id\");\n        rowLabels.add(id);\n\n        OUTER:\n        for (String term : terms) {\n\n          if (term.length() < minTermLength) {\n            //Eliminate terms due to length\n            continue;\n          }\n\n          if(excludes != null) {\n            for (String exclude : excludes) {\n              if (term.indexOf(exclude) > -1) {\n                continue OUTER;\n              }\n            }\n          }\n\n          if (!docTerms.contains(term)) {\n            docTerms.add(term);\n            if (docFreqs.containsKey(term)) {\n              int count = docFreqs.get(term).intValue();\n              docFreqs.put(term, ++count);\n            } else {\n              docFreqs.put(term, 1);\n            }\n          }\n        }\n      }\n\n      //Eliminate terms based on frequency\n\n      int min = (int) (tuples.size() * minDocFreq);\n      int max = (int) (tuples.size() * maxDocFreq);\n\n      Set<Map.Entry<String, Integer>> entries = docFreqs.entrySet();\n      Iterator<Map.Entry<String, Integer>> it = entries.iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, Integer> entry = it.next();\n        int count = entry.getValue().intValue();\n\n        if (count < min || count > max) {\n          it.remove();\n        }\n      }\n      int totalTerms = docFreqs.size();\n      Set<String> keys = docFreqs.keySet();\n      features.addAll(keys);\n      double[][] docVec = new double[tuples.size()][];\n      for (int t = 0; t < tuples.size(); t++) {\n        Tuple tuple = tuples.get(t);\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n        Map<String, Integer> termFreq = new HashMap();\n\n        for (String term : terms) {\n          if (docFreqs.containsKey(term)) {\n            if (termFreq.containsKey(term)) {\n              int count = termFreq.get(term).intValue();\n              termFreq.put(term, ++count);\n            } else {\n              termFreq.put(term, 1);\n            }\n          }\n        }\n\n        double[] termVec = new double[totalTerms];\n        for (int i = 0; i < totalTerms; i++) {\n          String feature = features.get(i);\n          int df = docFreqs.get(feature);\n          int tf = termFreq.containsKey(feature) ? termFreq.get(feature) : 0;\n          termVec[i] = Math.sqrt(tf) * (double) (Math.log((tuples.size() + 1) / (double) (df + 1)) + 1.0);\n        }\n        docVec[t] = termVec;\n      }\n\n      Matrix matrix = new Matrix(docVec);\n      matrix.setColumnLabels(features);\n      matrix.setRowLabels(rowLabels);\n      matrix.setAttribute(\"docFreqs\", docFreqs);\n      return matrix;\n    } else {\n      throw new IOException(\"The termVectors function takes a single positional parameter.\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e","date":1571071547,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TermVectorsEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TermVectorsEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object... objects) throws IOException {\n\n    if (objects.length == 1) {\n      //Just docs\n      if(!(objects[0] instanceof List)) {\n        throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n      } else {\n        List list = (List)objects[0];\n        if(list.size() > 0) {\n          Object o = list.get(0);\n          if(!(o instanceof Tuple)) {\n            throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n          }\n        } else {\n          throw new IOException(\"Empty list was passed as a parameter to termVectors function.\");\n        }\n      }\n\n      List<Tuple> tuples = (List<Tuple>) objects[0];\n      TreeMap<String, Integer> docFreqs = new TreeMap();\n      List<String> rowLabels = new ArrayList();\n\n      for (Tuple tuple : tuples) {\n\n        Set<String> docTerms = new HashSet();\n\n        if (tuple.get(\"terms\") == null) {\n          throw new IOException(\"The document tuples must contain a terms field\");\n        }\n\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n\n        String id = tuple.getString(\"id\");\n        rowLabels.add(id);\n\n        OUTER:\n        for (String term : terms) {\n\n          if (term.length() < minTermLength) {\n            //Eliminate terms due to length\n            continue;\n          }\n\n          if(excludes != null) {\n            for (String exclude : excludes) {\n              if (term.indexOf(exclude) > -1) {\n                continue OUTER;\n              }\n            }\n          }\n\n          if (!docTerms.contains(term)) {\n            docTerms.add(term);\n            if (docFreqs.containsKey(term)) {\n              int count = docFreqs.get(term).intValue();\n              docFreqs.put(term, ++count);\n            } else {\n              docFreqs.put(term, 1);\n            }\n          }\n        }\n      }\n\n      //Eliminate terms based on frequency\n\n      int min = (int) (tuples.size() * minDocFreq);\n      int max = (int) (tuples.size() * maxDocFreq);\n\n      Set<Map.Entry<String, Integer>> entries = docFreqs.entrySet();\n      Iterator<Map.Entry<String, Integer>> it = entries.iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, Integer> entry = it.next();\n        int count = entry.getValue().intValue();\n\n        if (count < min || count > max) {\n          it.remove();\n        }\n      }\n      int totalTerms = docFreqs.size();\n      Set<String> keys = docFreqs.keySet();\n      List<String> features = new ArrayList(keys);\n      double[][] docVec = new double[tuples.size()][];\n      for (int t = 0; t < tuples.size(); t++) {\n        Tuple tuple = tuples.get(t);\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n        Map<String, Integer> termFreq = new HashMap();\n\n        for (String term : terms) {\n          if (docFreqs.containsKey(term)) {\n            if (termFreq.containsKey(term)) {\n              int count = termFreq.get(term).intValue();\n              termFreq.put(term, ++count);\n            } else {\n              termFreq.put(term, 1);\n            }\n          }\n        }\n\n        double[] termVec = new double[totalTerms];\n        for (int i = 0; i < totalTerms; i++) {\n          String feature = features.get(i);\n          int df = docFreqs.get(feature);\n          int tf = termFreq.containsKey(feature) ? termFreq.get(feature) : 0;\n          termVec[i] = Math.sqrt(tf) * (double) (Math.log((tuples.size() + 1) / (double) (df + 1)) + 1.0);\n        }\n        docVec[t] = termVec;\n      }\n\n      Matrix matrix = new Matrix(docVec);\n      matrix.setColumnLabels(features);\n      matrix.setRowLabels(rowLabels);\n      matrix.setAttribute(\"docFreqs\", docFreqs);\n      return matrix;\n    } else {\n      throw new IOException(\"The termVectors function takes a single positional parameter.\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object... objects) throws IOException {\n\n    if (objects.length == 1) {\n      //Just docs\n      if(!(objects[0] instanceof List)) {\n        throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n      } else {\n        List list = (List)objects[0];\n        if(list.size() > 0) {\n          Object o = list.get(0);\n          if(!(o instanceof Tuple)) {\n            throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n          }\n        } else {\n          throw new IOException(\"Empty list was passed as a parameter to termVectors function.\");\n        }\n      }\n\n      List<Tuple> tuples = (List<Tuple>) objects[0];\n      TreeMap<String, Integer> docFreqs = new TreeMap();\n      List<String> features = new ArrayList();\n      List<String> rowLabels = new ArrayList();\n\n      for (Tuple tuple : tuples) {\n\n        Set<String> docTerms = new HashSet();\n\n        if (tuple.get(\"terms\") == null) {\n          throw new IOException(\"The document tuples must contain a terms field\");\n        }\n\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n\n        String id = tuple.getString(\"id\");\n        rowLabels.add(id);\n\n        OUTER:\n        for (String term : terms) {\n\n          if (term.length() < minTermLength) {\n            //Eliminate terms due to length\n            continue;\n          }\n\n          if(excludes != null) {\n            for (String exclude : excludes) {\n              if (term.indexOf(exclude) > -1) {\n                continue OUTER;\n              }\n            }\n          }\n\n          if (!docTerms.contains(term)) {\n            docTerms.add(term);\n            if (docFreqs.containsKey(term)) {\n              int count = docFreqs.get(term).intValue();\n              docFreqs.put(term, ++count);\n            } else {\n              docFreqs.put(term, 1);\n            }\n          }\n        }\n      }\n\n      //Eliminate terms based on frequency\n\n      int min = (int) (tuples.size() * minDocFreq);\n      int max = (int) (tuples.size() * maxDocFreq);\n\n      Set<Map.Entry<String, Integer>> entries = docFreqs.entrySet();\n      Iterator<Map.Entry<String, Integer>> it = entries.iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, Integer> entry = it.next();\n        int count = entry.getValue().intValue();\n\n        if (count < min || count > max) {\n          it.remove();\n        }\n      }\n      int totalTerms = docFreqs.size();\n      Set<String> keys = docFreqs.keySet();\n      features.addAll(keys);\n      double[][] docVec = new double[tuples.size()][];\n      for (int t = 0; t < tuples.size(); t++) {\n        Tuple tuple = tuples.get(t);\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n        Map<String, Integer> termFreq = new HashMap();\n\n        for (String term : terms) {\n          if (docFreqs.containsKey(term)) {\n            if (termFreq.containsKey(term)) {\n              int count = termFreq.get(term).intValue();\n              termFreq.put(term, ++count);\n            } else {\n              termFreq.put(term, 1);\n            }\n          }\n        }\n\n        double[] termVec = new double[totalTerms];\n        for (int i = 0; i < totalTerms; i++) {\n          String feature = features.get(i);\n          int df = docFreqs.get(feature);\n          int tf = termFreq.containsKey(feature) ? termFreq.get(feature) : 0;\n          termVec[i] = Math.sqrt(tf) * (double) (Math.log((tuples.size() + 1) / (double) (df + 1)) + 1.0);\n        }\n        docVec[t] = termVec;\n      }\n\n      Matrix matrix = new Matrix(docVec);\n      matrix.setColumnLabels(features);\n      matrix.setRowLabels(rowLabels);\n      matrix.setAttribute(\"docFreqs\", docFreqs);\n      return matrix;\n    } else {\n      throw new IOException(\"The termVectors function takes a single positional parameter.\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TermVectorsEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TermVectorsEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object... objects) throws IOException {\n\n    if (objects.length == 1) {\n      //Just docs\n      if(!(objects[0] instanceof List)) {\n        throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n      } else {\n        List list = (List)objects[0];\n        if(list.size() > 0) {\n          Object o = list.get(0);\n          if(!(o instanceof Tuple)) {\n            throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n          }\n        } else {\n          throw new IOException(\"Empty list was passed as a parameter to termVectors function.\");\n        }\n      }\n\n      List<Tuple> tuples = (List<Tuple>) objects[0];\n      TreeMap<String, Integer> docFreqs = new TreeMap();\n      List<String> rowLabels = new ArrayList();\n\n      for (Tuple tuple : tuples) {\n\n        Set<String> docTerms = new HashSet();\n\n        if (tuple.get(\"terms\") == null) {\n          throw new IOException(\"The document tuples must contain a terms field\");\n        }\n\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n\n        String id = tuple.getString(\"id\");\n        rowLabels.add(id);\n\n        OUTER:\n        for (String term : terms) {\n\n          if (term.length() < minTermLength) {\n            //Eliminate terms due to length\n            continue;\n          }\n\n          if(excludes != null) {\n            for (String exclude : excludes) {\n              if (term.indexOf(exclude) > -1) {\n                continue OUTER;\n              }\n            }\n          }\n\n          if (!docTerms.contains(term)) {\n            docTerms.add(term);\n            if (docFreqs.containsKey(term)) {\n              int count = docFreqs.get(term).intValue();\n              docFreqs.put(term, ++count);\n            } else {\n              docFreqs.put(term, 1);\n            }\n          }\n        }\n      }\n\n      //Eliminate terms based on frequency\n\n      int min = (int) (tuples.size() * minDocFreq);\n      int max = (int) (tuples.size() * maxDocFreq);\n\n      Set<Map.Entry<String, Integer>> entries = docFreqs.entrySet();\n      Iterator<Map.Entry<String, Integer>> it = entries.iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, Integer> entry = it.next();\n        int count = entry.getValue().intValue();\n\n        if (count < min || count > max) {\n          it.remove();\n        }\n      }\n      int totalTerms = docFreqs.size();\n      Set<String> keys = docFreqs.keySet();\n      List<String> features = new ArrayList(keys);\n      double[][] docVec = new double[tuples.size()][];\n      for (int t = 0; t < tuples.size(); t++) {\n        Tuple tuple = tuples.get(t);\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n        Map<String, Integer> termFreq = new HashMap();\n\n        for (String term : terms) {\n          if (docFreqs.containsKey(term)) {\n            if (termFreq.containsKey(term)) {\n              int count = termFreq.get(term).intValue();\n              termFreq.put(term, ++count);\n            } else {\n              termFreq.put(term, 1);\n            }\n          }\n        }\n\n        double[] termVec = new double[totalTerms];\n        for (int i = 0; i < totalTerms; i++) {\n          String feature = features.get(i);\n          int df = docFreqs.get(feature);\n          int tf = termFreq.containsKey(feature) ? termFreq.get(feature) : 0;\n          termVec[i] = Math.sqrt(tf) * (double) (Math.log((tuples.size() + 1) / (double) (df + 1)) + 1.0);\n        }\n        docVec[t] = termVec;\n      }\n\n      Matrix matrix = new Matrix(docVec);\n      matrix.setColumnLabels(features);\n      matrix.setRowLabels(rowLabels);\n      matrix.setAttribute(\"docFreqs\", docFreqs);\n      return matrix;\n    } else {\n      throw new IOException(\"The termVectors function takes a single positional parameter.\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object... objects) throws IOException {\n\n    if (objects.length == 1) {\n      //Just docs\n      if(!(objects[0] instanceof List)) {\n        throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n      } else {\n        List list = (List)objects[0];\n        if(list.size() > 0) {\n          Object o = list.get(0);\n          if(!(o instanceof Tuple)) {\n            throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n          }\n        } else {\n          throw new IOException(\"Empty list was passed as a parameter to termVectors function.\");\n        }\n      }\n\n      List<Tuple> tuples = (List<Tuple>) objects[0];\n      TreeMap<String, Integer> docFreqs = new TreeMap();\n      List<String> features = new ArrayList();\n      List<String> rowLabels = new ArrayList();\n\n      for (Tuple tuple : tuples) {\n\n        Set<String> docTerms = new HashSet();\n\n        if (tuple.get(\"terms\") == null) {\n          throw new IOException(\"The document tuples must contain a terms field\");\n        }\n\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n\n        String id = tuple.getString(\"id\");\n        rowLabels.add(id);\n\n        OUTER:\n        for (String term : terms) {\n\n          if (term.length() < minTermLength) {\n            //Eliminate terms due to length\n            continue;\n          }\n\n          if(excludes != null) {\n            for (String exclude : excludes) {\n              if (term.indexOf(exclude) > -1) {\n                continue OUTER;\n              }\n            }\n          }\n\n          if (!docTerms.contains(term)) {\n            docTerms.add(term);\n            if (docFreqs.containsKey(term)) {\n              int count = docFreqs.get(term).intValue();\n              docFreqs.put(term, ++count);\n            } else {\n              docFreqs.put(term, 1);\n            }\n          }\n        }\n      }\n\n      //Eliminate terms based on frequency\n\n      int min = (int) (tuples.size() * minDocFreq);\n      int max = (int) (tuples.size() * maxDocFreq);\n\n      Set<Map.Entry<String, Integer>> entries = docFreqs.entrySet();\n      Iterator<Map.Entry<String, Integer>> it = entries.iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, Integer> entry = it.next();\n        int count = entry.getValue().intValue();\n\n        if (count < min || count > max) {\n          it.remove();\n        }\n      }\n      int totalTerms = docFreqs.size();\n      Set<String> keys = docFreqs.keySet();\n      features.addAll(keys);\n      double[][] docVec = new double[tuples.size()][];\n      for (int t = 0; t < tuples.size(); t++) {\n        Tuple tuple = tuples.get(t);\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n        Map<String, Integer> termFreq = new HashMap();\n\n        for (String term : terms) {\n          if (docFreqs.containsKey(term)) {\n            if (termFreq.containsKey(term)) {\n              int count = termFreq.get(term).intValue();\n              termFreq.put(term, ++count);\n            } else {\n              termFreq.put(term, 1);\n            }\n          }\n        }\n\n        double[] termVec = new double[totalTerms];\n        for (int i = 0; i < totalTerms; i++) {\n          String feature = features.get(i);\n          int df = docFreqs.get(feature);\n          int tf = termFreq.containsKey(feature) ? termFreq.get(feature) : 0;\n          termVec[i] = Math.sqrt(tf) * (double) (Math.log((tuples.size() + 1) / (double) (df + 1)) + 1.0);\n        }\n        docVec[t] = termVec;\n      }\n\n      Matrix matrix = new Matrix(docVec);\n      matrix.setColumnLabels(features);\n      matrix.setRowLabels(rowLabels);\n      matrix.setAttribute(\"docFreqs\", docFreqs);\n      return matrix;\n    } else {\n      throw new IOException(\"The termVectors function takes a single positional parameter.\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885","date":1591579911,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TermVectorsEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TermVectorsEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object... objects) throws IOException {\n\n    if (objects.length == 1) {\n      //Just docs\n      if(!(objects[0] instanceof List)) {\n        throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n      } else {\n        @SuppressWarnings({\"rawtypes\"})\n        List list = (List)objects[0];\n        if(list.size() > 0) {\n          Object o = list.get(0);\n          if(!(o instanceof Tuple)) {\n            throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n          }\n        } else {\n          throw new IOException(\"Empty list was passed as a parameter to termVectors function.\");\n        }\n      }\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Tuple> tuples = (List<Tuple>) objects[0];\n      TreeMap<String, Integer> docFreqs = new TreeMap<>();\n      List<String> rowLabels = new ArrayList<>();\n\n      for (Tuple tuple : tuples) {\n\n        Set<String> docTerms = new HashSet<>();\n\n        if (tuple.get(\"terms\") == null) {\n          throw new IOException(\"The document tuples must contain a terms field\");\n        }\n\n        @SuppressWarnings({\"unchecked\"})\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n\n        String id = tuple.getString(\"id\");\n        rowLabels.add(id);\n\n        OUTER:\n        for (String term : terms) {\n\n          if (term.length() < minTermLength) {\n            //Eliminate terms due to length\n            continue;\n          }\n\n          if(excludes != null) {\n            for (String exclude : excludes) {\n              if (term.indexOf(exclude) > -1) {\n                continue OUTER;\n              }\n            }\n          }\n\n          if (!docTerms.contains(term)) {\n            docTerms.add(term);\n            if (docFreqs.containsKey(term)) {\n              int count = docFreqs.get(term).intValue();\n              docFreqs.put(term, ++count);\n            } else {\n              docFreqs.put(term, 1);\n            }\n          }\n        }\n      }\n\n      //Eliminate terms based on frequency\n\n      int min = (int) (tuples.size() * minDocFreq);\n      int max = (int) (tuples.size() * maxDocFreq);\n\n      Set<Map.Entry<String, Integer>> entries = docFreqs.entrySet();\n      Iterator<Map.Entry<String, Integer>> it = entries.iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, Integer> entry = it.next();\n        int count = entry.getValue().intValue();\n\n        if (count < min || count > max) {\n          it.remove();\n        }\n      }\n      int totalTerms = docFreqs.size();\n      Set<String> keys = docFreqs.keySet();\n      List<String> features = new ArrayList<>(keys);\n      double[][] docVec = new double[tuples.size()][];\n      for (int t = 0; t < tuples.size(); t++) {\n        Tuple tuple = tuples.get(t);\n        @SuppressWarnings({\"unchecked\"})\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n        Map<String, Integer> termFreq = new HashMap<>();\n\n        for (String term : terms) {\n          if (docFreqs.containsKey(term)) {\n            if (termFreq.containsKey(term)) {\n              int count = termFreq.get(term).intValue();\n              termFreq.put(term, ++count);\n            } else {\n              termFreq.put(term, 1);\n            }\n          }\n        }\n\n        double[] termVec = new double[totalTerms];\n        for (int i = 0; i < totalTerms; i++) {\n          String feature = features.get(i);\n          int df = docFreqs.get(feature);\n          int tf = termFreq.containsKey(feature) ? termFreq.get(feature) : 0;\n          termVec[i] = Math.sqrt(tf) * (Math.log((tuples.size() + 1) / (double) (df + 1)) + 1.0);\n        }\n        docVec[t] = termVec;\n      }\n\n      Matrix matrix = new Matrix(docVec);\n      matrix.setColumnLabels(features);\n      matrix.setRowLabels(rowLabels);\n      matrix.setAttribute(\"docFreqs\", docFreqs);\n      return matrix;\n    } else {\n      throw new IOException(\"The termVectors function takes a single positional parameter.\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object... objects) throws IOException {\n\n    if (objects.length == 1) {\n      //Just docs\n      if(!(objects[0] instanceof List)) {\n        throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n      } else {\n        List list = (List)objects[0];\n        if(list.size() > 0) {\n          Object o = list.get(0);\n          if(!(o instanceof Tuple)) {\n            throw new IOException(\"The termVectors function expects a list of Tuples as a parameter.\");\n          }\n        } else {\n          throw new IOException(\"Empty list was passed as a parameter to termVectors function.\");\n        }\n      }\n\n      List<Tuple> tuples = (List<Tuple>) objects[0];\n      TreeMap<String, Integer> docFreqs = new TreeMap();\n      List<String> rowLabels = new ArrayList();\n\n      for (Tuple tuple : tuples) {\n\n        Set<String> docTerms = new HashSet();\n\n        if (tuple.get(\"terms\") == null) {\n          throw new IOException(\"The document tuples must contain a terms field\");\n        }\n\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n\n        String id = tuple.getString(\"id\");\n        rowLabels.add(id);\n\n        OUTER:\n        for (String term : terms) {\n\n          if (term.length() < minTermLength) {\n            //Eliminate terms due to length\n            continue;\n          }\n\n          if(excludes != null) {\n            for (String exclude : excludes) {\n              if (term.indexOf(exclude) > -1) {\n                continue OUTER;\n              }\n            }\n          }\n\n          if (!docTerms.contains(term)) {\n            docTerms.add(term);\n            if (docFreqs.containsKey(term)) {\n              int count = docFreqs.get(term).intValue();\n              docFreqs.put(term, ++count);\n            } else {\n              docFreqs.put(term, 1);\n            }\n          }\n        }\n      }\n\n      //Eliminate terms based on frequency\n\n      int min = (int) (tuples.size() * minDocFreq);\n      int max = (int) (tuples.size() * maxDocFreq);\n\n      Set<Map.Entry<String, Integer>> entries = docFreqs.entrySet();\n      Iterator<Map.Entry<String, Integer>> it = entries.iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, Integer> entry = it.next();\n        int count = entry.getValue().intValue();\n\n        if (count < min || count > max) {\n          it.remove();\n        }\n      }\n      int totalTerms = docFreqs.size();\n      Set<String> keys = docFreqs.keySet();\n      List<String> features = new ArrayList(keys);\n      double[][] docVec = new double[tuples.size()][];\n      for (int t = 0; t < tuples.size(); t++) {\n        Tuple tuple = tuples.get(t);\n        List<String> terms = (List<String>) tuple.get(\"terms\");\n        Map<String, Integer> termFreq = new HashMap();\n\n        for (String term : terms) {\n          if (docFreqs.containsKey(term)) {\n            if (termFreq.containsKey(term)) {\n              int count = termFreq.get(term).intValue();\n              termFreq.put(term, ++count);\n            } else {\n              termFreq.put(term, 1);\n            }\n          }\n        }\n\n        double[] termVec = new double[totalTerms];\n        for (int i = 0; i < totalTerms; i++) {\n          String feature = features.get(i);\n          int df = docFreqs.get(feature);\n          int tf = termFreq.containsKey(feature) ? termFreq.get(feature) : 0;\n          termVec[i] = Math.sqrt(tf) * (double) (Math.log((tuples.size() + 1) / (double) (df + 1)) + 1.0);\n        }\n        docVec[t] = termVec;\n      }\n\n      Matrix matrix = new Matrix(docVec);\n      matrix.setColumnLabels(features);\n      matrix.setRowLabels(rowLabels);\n      matrix.setAttribute(\"docFreqs\", docFreqs);\n      return matrix;\n    } else {\n      throw new IOException(\"The termVectors function takes a single positional parameter.\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e":["b94236357aaa22b76c10629851fe4e376e0cea82"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5f0ec25ba9bff9e87e402c4fe0afe87f877bccd6"],"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885":["23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e"],"542e93518aa56b94e3263948f3c7b7ebe229b9dd":["21cc21dac328d94dbc79c104b8e626fca70b3f79"],"21cc21dac328d94dbc79c104b8e626fca70b3f79":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5f0ec25ba9bff9e87e402c4fe0afe87f877bccd6":["542e93518aa56b94e3263948f3c7b7ebe229b9dd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885"],"b0b597c65628ca9e73913a07e81691f8229bae35":["b94236357aaa22b76c10629851fe4e376e0cea82","23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e"]},"commit2Childs":{"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e":["df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885","b0b597c65628ca9e73913a07e81691f8229bae35"],"b94236357aaa22b76c10629851fe4e376e0cea82":["23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e","b0b597c65628ca9e73913a07e81691f8229bae35"],"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"542e93518aa56b94e3263948f3c7b7ebe229b9dd":["5f0ec25ba9bff9e87e402c4fe0afe87f877bccd6"],"21cc21dac328d94dbc79c104b8e626fca70b3f79":["542e93518aa56b94e3263948f3c7b7ebe229b9dd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","21cc21dac328d94dbc79c104b8e626fca70b3f79"],"5f0ec25ba9bff9e87e402c4fe0afe87f877bccd6":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}