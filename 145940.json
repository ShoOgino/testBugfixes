{"path":"solr/core/src/java/org/apache/solr/request/SimpleFacets#selectFacetMethod(SchemaField,FacetMethod,Integer).mjava","commits":[{"id":"275f40e1400de0b5ab5e33051ac11e8973813a2c","date":1465569625,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#selectFacetMethod(SchemaField,FacetMethod,Integer).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method will force the appropriate facet method even if the user provided a different one as a request parameter\n   *\n   * N.B. this method could overwrite what you passed as request parameter. Be Extra careful\n   *\n   * @param field field we are faceting\n   * @param method the facet method passed as a request parameter\n   * @param mincount the minimum value a facet should have to be returned\n   * @return the FacetMethod to use\n   */\n   static FacetMethod selectFacetMethod(SchemaField field, FacetMethod method, Integer mincount) {\n\n     FieldType type = field.getType();\n\n     /*The user did not specify any preference*/\n     if (method == null) {\n      /* Always use filters for booleans... we know the number of values is very small. */\n       if (type instanceof BoolField) {\n         method = FacetMethod.ENUM;\n       } else if (type.getNumericType() != null && !field.multiValued()) {\n        /* the per-segment approach is optimal for numeric field types since there\n           are no global ords to merge and no need to create an expensive\n           top-level reader */\n         method = FacetMethod.FCS;\n       } else {\n         // TODO: default to per-segment or not?\n         method = FacetMethod.FC;\n       }\n     }\n\n     /* FC without docValues does not support single valued numeric facets */\n     if (method == FacetMethod.FC\n         && type.getNumericType() != null && !field.multiValued()) {\n       method = FacetMethod.FCS;\n     }\n\n     /* UIF without DocValues can't deal with mincount=0, the reason is because\n         we create the buckets based on the values present in the result set.\n         So we are not going to see facet values which are not in the result set */\n     if (method == FacetMethod.UIF\n         && !field.hasDocValues() && mincount == 0) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* ENUM can't deal with trie fields that index several terms per value */\n     if (method == FacetMethod.ENUM\n         && TrieField.getMainValuePrefix(type) != null) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* FCS can't deal with multi token fields */\n     final boolean multiToken = field.multiValued() || type.multiValuedFieldCache();\n     if (method == FacetMethod.FCS\n         && multiToken) {\n       method = FacetMethod.FC;\n     }\n\n     return method;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5","date":1465691899,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#selectFacetMethod(SchemaField,FacetMethod,Integer).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#selectFacetMethod(SchemaField,FacetMethod,Integer).mjava","sourceNew":"  /**\n   * This method will force the appropriate facet method even if the user provided a different one as a request parameter\n   *\n   * N.B. this method could overwrite what you passed as request parameter. Be Extra careful\n   *\n   * @param field field we are faceting\n   * @param method the facet method passed as a request parameter\n   * @param mincount the minimum value a facet should have to be returned\n   * @return the FacetMethod to use\n   */\n   static FacetMethod selectFacetMethod(SchemaField field, FacetMethod method, Integer mincount) {\n\n     FieldType type = field.getType();\n\n     /*The user did not specify any preference*/\n     if (method == null) {\n       /* Always use filters for booleans if not DocValues only... we know the number of values is very small. */\n       if (type instanceof BoolField && (field.indexed() == true || field.hasDocValues() == false)) {\n         method = FacetMethod.ENUM;\n       } else if (type.getNumericType() != null && !field.multiValued()) {\n        /* the per-segment approach is optimal for numeric field types since there\n           are no global ords to merge and no need to create an expensive\n           top-level reader */\n         method = FacetMethod.FCS;\n       } else {\n         // TODO: default to per-segment or not?\n         method = FacetMethod.FC;\n       }\n     }\n\n     /* FC without docValues does not support single valued numeric facets */\n     if (method == FacetMethod.FC\n         && type.getNumericType() != null && !field.multiValued()) {\n       method = FacetMethod.FCS;\n     }\n\n     /* UIF without DocValues can't deal with mincount=0, the reason is because\n         we create the buckets based on the values present in the result set.\n         So we are not going to see facet values which are not in the result set */\n     if (method == FacetMethod.UIF\n         && !field.hasDocValues() && mincount == 0) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* ENUM can't deal with trie fields that index several terms per value */\n     if (method == FacetMethod.ENUM\n         && TrieField.getMainValuePrefix(type) != null) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* FCS can't deal with multi token fields */\n     final boolean multiToken = field.multiValued() || type.multiValuedFieldCache();\n     if (method == FacetMethod.FCS\n         && multiToken) {\n       method = FacetMethod.FC;\n     }\n\n     return method;\n  }\n\n","sourceOld":"  /**\n   * This method will force the appropriate facet method even if the user provided a different one as a request parameter\n   *\n   * N.B. this method could overwrite what you passed as request parameter. Be Extra careful\n   *\n   * @param field field we are faceting\n   * @param method the facet method passed as a request parameter\n   * @param mincount the minimum value a facet should have to be returned\n   * @return the FacetMethod to use\n   */\n   static FacetMethod selectFacetMethod(SchemaField field, FacetMethod method, Integer mincount) {\n\n     FieldType type = field.getType();\n\n     /*The user did not specify any preference*/\n     if (method == null) {\n      /* Always use filters for booleans... we know the number of values is very small. */\n       if (type instanceof BoolField) {\n         method = FacetMethod.ENUM;\n       } else if (type.getNumericType() != null && !field.multiValued()) {\n        /* the per-segment approach is optimal for numeric field types since there\n           are no global ords to merge and no need to create an expensive\n           top-level reader */\n         method = FacetMethod.FCS;\n       } else {\n         // TODO: default to per-segment or not?\n         method = FacetMethod.FC;\n       }\n     }\n\n     /* FC without docValues does not support single valued numeric facets */\n     if (method == FacetMethod.FC\n         && type.getNumericType() != null && !field.multiValued()) {\n       method = FacetMethod.FCS;\n     }\n\n     /* UIF without DocValues can't deal with mincount=0, the reason is because\n         we create the buckets based on the values present in the result set.\n         So we are not going to see facet values which are not in the result set */\n     if (method == FacetMethod.UIF\n         && !field.hasDocValues() && mincount == 0) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* ENUM can't deal with trie fields that index several terms per value */\n     if (method == FacetMethod.ENUM\n         && TrieField.getMainValuePrefix(type) != null) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* FCS can't deal with multi token fields */\n     final boolean multiToken = field.multiValued() || type.multiValuedFieldCache();\n     if (method == FacetMethod.FCS\n         && multiToken) {\n       method = FacetMethod.FC;\n     }\n\n     return method;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#selectFacetMethod(SchemaField,FacetMethod,Integer).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method will force the appropriate facet method even if the user provided a different one as a request parameter\n   *\n   * N.B. this method could overwrite what you passed as request parameter. Be Extra careful\n   *\n   * @param field field we are faceting\n   * @param method the facet method passed as a request parameter\n   * @param mincount the minimum value a facet should have to be returned\n   * @return the FacetMethod to use\n   */\n   static FacetMethod selectFacetMethod(SchemaField field, FacetMethod method, Integer mincount) {\n\n     FieldType type = field.getType();\n\n     /*The user did not specify any preference*/\n     if (method == null) {\n       /* Always use filters for booleans if not DocValues only... we know the number of values is very small. */\n       if (type instanceof BoolField && (field.indexed() == true || field.hasDocValues() == false)) {\n         method = FacetMethod.ENUM;\n       } else if (type.getNumericType() != null && !field.multiValued()) {\n        /* the per-segment approach is optimal for numeric field types since there\n           are no global ords to merge and no need to create an expensive\n           top-level reader */\n         method = FacetMethod.FCS;\n       } else {\n         // TODO: default to per-segment or not?\n         method = FacetMethod.FC;\n       }\n     }\n\n     /* FC without docValues does not support single valued numeric facets */\n     if (method == FacetMethod.FC\n         && type.getNumericType() != null && !field.multiValued()) {\n       method = FacetMethod.FCS;\n     }\n\n     /* UIF without DocValues can't deal with mincount=0, the reason is because\n         we create the buckets based on the values present in the result set.\n         So we are not going to see facet values which are not in the result set */\n     if (method == FacetMethod.UIF\n         && !field.hasDocValues() && mincount == 0) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* ENUM can't deal with trie fields that index several terms per value */\n     if (method == FacetMethod.ENUM\n         && TrieField.getMainValuePrefix(type) != null) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* FCS can't deal with multi token fields */\n     final boolean multiToken = field.multiValued() || type.multiValuedFieldCache();\n     if (method == FacetMethod.FCS\n         && multiToken) {\n       method = FacetMethod.FC;\n     }\n\n     return method;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46dc9ac8b3e748407baaef82453138ff3974480c","date":1484789241,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#selectFacetMethod(SchemaField,FacetMethod,Integer).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#selectFacetMethod(SchemaField,FacetMethod,Integer).mjava","sourceNew":"  /**\n   * This method will force the appropriate facet method even if the user provided a different one as a request parameter\n   *\n   * N.B. this method could overwrite what you passed as request parameter. Be Extra careful\n   *\n   * @param field field we are faceting\n   * @param method the facet method passed as a request parameter\n   * @param mincount the minimum value a facet should have to be returned\n   * @return the FacetMethod to use\n   */\n   static FacetMethod selectFacetMethod(SchemaField field, FacetMethod method, Integer mincount) {\n\n     FieldType type = field.getType();\n     if (type.isPointField()) {\n       // Only FCS is supported for PointFields for now\n       return FacetMethod.FCS;\n     }\n\n     /*The user did not specify any preference*/\n     if (method == null) {\n       /* Always use filters for booleans if not DocValues only... we know the number of values is very small. */\n       if (type instanceof BoolField && (field.indexed() == true || field.hasDocValues() == false)) {\n         method = FacetMethod.ENUM;\n       } else if (type.getNumericType() != null && !field.multiValued()) {\n        /* the per-segment approach is optimal for numeric field types since there\n           are no global ords to merge and no need to create an expensive\n           top-level reader */\n         method = FacetMethod.FCS;\n       } else {\n         // TODO: default to per-segment or not?\n         method = FacetMethod.FC;\n       }\n     }\n\n     /* FC without docValues does not support single valued numeric facets */\n     if (method == FacetMethod.FC\n         && type.getNumericType() != null && !field.multiValued()) {\n       method = FacetMethod.FCS;\n     }\n\n     /* UIF without DocValues can't deal with mincount=0, the reason is because\n         we create the buckets based on the values present in the result set.\n         So we are not going to see facet values which are not in the result set */\n     if (method == FacetMethod.UIF\n         && !field.hasDocValues() && mincount == 0) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* ENUM can't deal with trie fields that index several terms per value */\n     if (method == FacetMethod.ENUM\n         && TrieField.getMainValuePrefix(type) != null) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* FCS can't deal with multi token fields */\n     final boolean multiToken = field.multiValued() || type.multiValuedFieldCache();\n     if (method == FacetMethod.FCS\n         && multiToken) {\n       method = FacetMethod.FC;\n     }\n\n     return method;\n  }\n\n","sourceOld":"  /**\n   * This method will force the appropriate facet method even if the user provided a different one as a request parameter\n   *\n   * N.B. this method could overwrite what you passed as request parameter. Be Extra careful\n   *\n   * @param field field we are faceting\n   * @param method the facet method passed as a request parameter\n   * @param mincount the minimum value a facet should have to be returned\n   * @return the FacetMethod to use\n   */\n   static FacetMethod selectFacetMethod(SchemaField field, FacetMethod method, Integer mincount) {\n\n     FieldType type = field.getType();\n\n     /*The user did not specify any preference*/\n     if (method == null) {\n       /* Always use filters for booleans if not DocValues only... we know the number of values is very small. */\n       if (type instanceof BoolField && (field.indexed() == true || field.hasDocValues() == false)) {\n         method = FacetMethod.ENUM;\n       } else if (type.getNumericType() != null && !field.multiValued()) {\n        /* the per-segment approach is optimal for numeric field types since there\n           are no global ords to merge and no need to create an expensive\n           top-level reader */\n         method = FacetMethod.FCS;\n       } else {\n         // TODO: default to per-segment or not?\n         method = FacetMethod.FC;\n       }\n     }\n\n     /* FC without docValues does not support single valued numeric facets */\n     if (method == FacetMethod.FC\n         && type.getNumericType() != null && !field.multiValued()) {\n       method = FacetMethod.FCS;\n     }\n\n     /* UIF without DocValues can't deal with mincount=0, the reason is because\n         we create the buckets based on the values present in the result set.\n         So we are not going to see facet values which are not in the result set */\n     if (method == FacetMethod.UIF\n         && !field.hasDocValues() && mincount == 0) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* ENUM can't deal with trie fields that index several terms per value */\n     if (method == FacetMethod.ENUM\n         && TrieField.getMainValuePrefix(type) != null) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* FCS can't deal with multi token fields */\n     final boolean multiToken = field.multiValued() || type.multiValuedFieldCache();\n     if (method == FacetMethod.FCS\n         && multiToken) {\n       method = FacetMethod.FC;\n     }\n\n     return method;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#selectFacetMethod(SchemaField,FacetMethod,Integer).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#selectFacetMethod(SchemaField,FacetMethod,Integer).mjava","sourceNew":"  /**\n   * This method will force the appropriate facet method even if the user provided a different one as a request parameter\n   *\n   * N.B. this method could overwrite what you passed as request parameter. Be Extra careful\n   *\n   * @param field field we are faceting\n   * @param method the facet method passed as a request parameter\n   * @param mincount the minimum value a facet should have to be returned\n   * @return the FacetMethod to use\n   */\n   static FacetMethod selectFacetMethod(SchemaField field, FacetMethod method, Integer mincount) {\n\n     FieldType type = field.getType();\n     if (type.isPointField()) {\n       // Only FCS is supported for PointFields for now\n       return FacetMethod.FCS;\n     }\n\n     /*The user did not specify any preference*/\n     if (method == null) {\n       /* Always use filters for booleans if not DocValues only... we know the number of values is very small. */\n       if (type instanceof BoolField && (field.indexed() == true || field.hasDocValues() == false)) {\n         method = FacetMethod.ENUM;\n       } else if (type.getNumericType() != null && !field.multiValued()) {\n        /* the per-segment approach is optimal for numeric field types since there\n           are no global ords to merge and no need to create an expensive\n           top-level reader */\n         method = FacetMethod.FCS;\n       } else {\n         // TODO: default to per-segment or not?\n         method = FacetMethod.FC;\n       }\n     }\n\n     /* FC without docValues does not support single valued numeric facets */\n     if (method == FacetMethod.FC\n         && type.getNumericType() != null && !field.multiValued()) {\n       method = FacetMethod.FCS;\n     }\n\n     /* UIF without DocValues can't deal with mincount=0, the reason is because\n         we create the buckets based on the values present in the result set.\n         So we are not going to see facet values which are not in the result set */\n     if (method == FacetMethod.UIF\n         && !field.hasDocValues() && mincount == 0) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* ENUM can't deal with trie fields that index several terms per value */\n     if (method == FacetMethod.ENUM\n         && TrieField.getMainValuePrefix(type) != null) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* FCS can't deal with multi token fields */\n     final boolean multiToken = field.multiValued() || type.multiValuedFieldCache();\n     if (method == FacetMethod.FCS\n         && multiToken) {\n       method = FacetMethod.FC;\n     }\n\n     return method;\n  }\n\n","sourceOld":"  /**\n   * This method will force the appropriate facet method even if the user provided a different one as a request parameter\n   *\n   * N.B. this method could overwrite what you passed as request parameter. Be Extra careful\n   *\n   * @param field field we are faceting\n   * @param method the facet method passed as a request parameter\n   * @param mincount the minimum value a facet should have to be returned\n   * @return the FacetMethod to use\n   */\n   static FacetMethod selectFacetMethod(SchemaField field, FacetMethod method, Integer mincount) {\n\n     FieldType type = field.getType();\n\n     /*The user did not specify any preference*/\n     if (method == null) {\n       /* Always use filters for booleans if not DocValues only... we know the number of values is very small. */\n       if (type instanceof BoolField && (field.indexed() == true || field.hasDocValues() == false)) {\n         method = FacetMethod.ENUM;\n       } else if (type.getNumericType() != null && !field.multiValued()) {\n        /* the per-segment approach is optimal for numeric field types since there\n           are no global ords to merge and no need to create an expensive\n           top-level reader */\n         method = FacetMethod.FCS;\n       } else {\n         // TODO: default to per-segment or not?\n         method = FacetMethod.FC;\n       }\n     }\n\n     /* FC without docValues does not support single valued numeric facets */\n     if (method == FacetMethod.FC\n         && type.getNumericType() != null && !field.multiValued()) {\n       method = FacetMethod.FCS;\n     }\n\n     /* UIF without DocValues can't deal with mincount=0, the reason is because\n         we create the buckets based on the values present in the result set.\n         So we are not going to see facet values which are not in the result set */\n     if (method == FacetMethod.UIF\n         && !field.hasDocValues() && mincount == 0) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* ENUM can't deal with trie fields that index several terms per value */\n     if (method == FacetMethod.ENUM\n         && TrieField.getMainValuePrefix(type) != null) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* FCS can't deal with multi token fields */\n     final boolean multiToken = field.multiValued() || type.multiValuedFieldCache();\n     if (method == FacetMethod.FCS\n         && multiToken) {\n       method = FacetMethod.FC;\n     }\n\n     return method;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d81baa64023bbb9b43f6d929ee168b105940d30","date":1486492702,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#selectFacetMethod(SchemaField,FacetMethod,Integer).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#selectFacetMethod(SchemaField,FacetMethod,Integer).mjava","sourceNew":"  /**\n   * This method will force the appropriate facet method even if the user provided a different one as a request parameter\n   *\n   * N.B. this method could overwrite what you passed as request parameter. Be Extra careful\n   *\n   * @param field field we are faceting\n   * @param method the facet method passed as a request parameter\n   * @param mincount the minimum value a facet should have to be returned\n   * @return the FacetMethod to use\n   */\n   static FacetMethod selectFacetMethod(SchemaField field, FacetMethod method, Integer mincount) {\n\n     FieldType type = field.getType();\n     if (type.isPointField()) {\n       // Only FCS is supported for PointFields for now\n       return FacetMethod.FCS;\n     }\n\n     /*The user did not specify any preference*/\n     if (method == null) {\n       /* Always use filters for booleans if not DocValues only... we know the number of values is very small. */\n       if (type instanceof BoolField && (field.indexed() == true || field.hasDocValues() == false)) {\n         method = FacetMethod.ENUM;\n       } else if (type.getNumberType() != null && !field.multiValued()) {\n        /* the per-segment approach is optimal for numeric field types since there\n           are no global ords to merge and no need to create an expensive\n           top-level reader */\n         method = FacetMethod.FCS;\n       } else {\n         // TODO: default to per-segment or not?\n         method = FacetMethod.FC;\n       }\n     }\n\n     /* FC without docValues does not support single valued numeric facets */\n     if (method == FacetMethod.FC\n         && type.getNumberType() != null && !field.multiValued()) {\n       method = FacetMethod.FCS;\n     }\n\n     /* UIF without DocValues can't deal with mincount=0, the reason is because\n         we create the buckets based on the values present in the result set.\n         So we are not going to see facet values which are not in the result set */\n     if (method == FacetMethod.UIF\n         && !field.hasDocValues() && mincount == 0) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* ENUM can't deal with trie fields that index several terms per value */\n     if (method == FacetMethod.ENUM\n         && TrieField.getMainValuePrefix(type) != null) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* FCS can't deal with multi token fields */\n     final boolean multiToken = field.multiValued() || type.multiValuedFieldCache();\n     if (method == FacetMethod.FCS\n         && multiToken) {\n       method = FacetMethod.FC;\n     }\n\n     return method;\n  }\n\n","sourceOld":"  /**\n   * This method will force the appropriate facet method even if the user provided a different one as a request parameter\n   *\n   * N.B. this method could overwrite what you passed as request parameter. Be Extra careful\n   *\n   * @param field field we are faceting\n   * @param method the facet method passed as a request parameter\n   * @param mincount the minimum value a facet should have to be returned\n   * @return the FacetMethod to use\n   */\n   static FacetMethod selectFacetMethod(SchemaField field, FacetMethod method, Integer mincount) {\n\n     FieldType type = field.getType();\n     if (type.isPointField()) {\n       // Only FCS is supported for PointFields for now\n       return FacetMethod.FCS;\n     }\n\n     /*The user did not specify any preference*/\n     if (method == null) {\n       /* Always use filters for booleans if not DocValues only... we know the number of values is very small. */\n       if (type instanceof BoolField && (field.indexed() == true || field.hasDocValues() == false)) {\n         method = FacetMethod.ENUM;\n       } else if (type.getNumericType() != null && !field.multiValued()) {\n        /* the per-segment approach is optimal for numeric field types since there\n           are no global ords to merge and no need to create an expensive\n           top-level reader */\n         method = FacetMethod.FCS;\n       } else {\n         // TODO: default to per-segment or not?\n         method = FacetMethod.FC;\n       }\n     }\n\n     /* FC without docValues does not support single valued numeric facets */\n     if (method == FacetMethod.FC\n         && type.getNumericType() != null && !field.multiValued()) {\n       method = FacetMethod.FCS;\n     }\n\n     /* UIF without DocValues can't deal with mincount=0, the reason is because\n         we create the buckets based on the values present in the result set.\n         So we are not going to see facet values which are not in the result set */\n     if (method == FacetMethod.UIF\n         && !field.hasDocValues() && mincount == 0) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* ENUM can't deal with trie fields that index several terms per value */\n     if (method == FacetMethod.ENUM\n         && TrieField.getMainValuePrefix(type) != null) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* FCS can't deal with multi token fields */\n     final boolean multiToken = field.multiValued() || type.multiValuedFieldCache();\n     if (method == FacetMethod.FCS\n         && multiToken) {\n       method = FacetMethod.FC;\n     }\n\n     return method;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e","date":1541777404,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#selectFacetMethod(SchemaField,FacetMethod,Integer).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#selectFacetMethod(SchemaField,FacetMethod,Integer).mjava","sourceNew":"  /**\n   * This method will force the appropriate facet method even if the user provided a different one as a request parameter\n   *\n   * N.B. this method could overwrite what you passed as request parameter. Be Extra careful\n   *\n   * @param field field we are faceting\n   * @param method the facet method passed as a request parameter\n   * @param mincount the minimum value a facet should have to be returned\n   * @return the FacetMethod to use\n   */\n   static FacetMethod selectFacetMethod(SchemaField field, FacetMethod method, Integer mincount) {\n\n     FieldType type = field.getType();\n     if (type.isPointField()) {\n       // Only FCS is supported for PointFields for now\n       return FacetMethod.FCS;\n     }\n\n     /*The user did not specify any preference*/\n     if (method == null) {\n       /* Always use filters for booleans if not DocValues only... we know the number of values is very small. */\n       if (type instanceof BoolField && (field.indexed() == true || field.hasDocValues() == false)) {\n         method = FacetMethod.ENUM;\n       } else if (type.getNumberType() != null && !field.multiValued()) {\n        /* the per-segment approach is optimal for numeric field types since there\n           are no global ords to merge and no need to create an expensive\n           top-level reader */\n         method = FacetMethod.FCS;\n       } else {\n         // TODO: default to per-segment or not?\n         method = FacetMethod.FC;\n       }\n     }\n\n     /* FC without docValues does not support single valued numeric facets */\n     if (method == FacetMethod.FC\n         && type.getNumberType() != null && !field.multiValued()) {\n       method = FacetMethod.FCS;\n     }\n\n     /* UIF without DocValues can't deal with mincount=0, the reason is because\n         we create the buckets based on the values present in the result set.\n         So we are not going to see facet values which are not in the result set */\n     if (method == FacetMethod.UIF\n         && !field.hasDocValues() && mincount == 0) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* Unless isUninvertible() is true, we prohibit any use of UIF...\n        Here we just force FC(S) instead, and trust that the DocValues faceting logic will\n        do the right thing either way (with or w/o docvalues) */\n     if (FacetMethod.UIF == method && ! field.isUninvertible()) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n     \n     /* ENUM can't deal with trie fields that index several terms per value */\n     if (method == FacetMethod.ENUM\n         && TrieField.getMainValuePrefix(type) != null) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* FCS can't deal with multi token fields */\n     final boolean multiToken = field.multiValued() || type.multiValuedFieldCache();\n     if (method == FacetMethod.FCS\n         && multiToken) {\n       method = FacetMethod.FC;\n     }\n\n     return method;\n  }\n\n","sourceOld":"  /**\n   * This method will force the appropriate facet method even if the user provided a different one as a request parameter\n   *\n   * N.B. this method could overwrite what you passed as request parameter. Be Extra careful\n   *\n   * @param field field we are faceting\n   * @param method the facet method passed as a request parameter\n   * @param mincount the minimum value a facet should have to be returned\n   * @return the FacetMethod to use\n   */\n   static FacetMethod selectFacetMethod(SchemaField field, FacetMethod method, Integer mincount) {\n\n     FieldType type = field.getType();\n     if (type.isPointField()) {\n       // Only FCS is supported for PointFields for now\n       return FacetMethod.FCS;\n     }\n\n     /*The user did not specify any preference*/\n     if (method == null) {\n       /* Always use filters for booleans if not DocValues only... we know the number of values is very small. */\n       if (type instanceof BoolField && (field.indexed() == true || field.hasDocValues() == false)) {\n         method = FacetMethod.ENUM;\n       } else if (type.getNumberType() != null && !field.multiValued()) {\n        /* the per-segment approach is optimal for numeric field types since there\n           are no global ords to merge and no need to create an expensive\n           top-level reader */\n         method = FacetMethod.FCS;\n       } else {\n         // TODO: default to per-segment or not?\n         method = FacetMethod.FC;\n       }\n     }\n\n     /* FC without docValues does not support single valued numeric facets */\n     if (method == FacetMethod.FC\n         && type.getNumberType() != null && !field.multiValued()) {\n       method = FacetMethod.FCS;\n     }\n\n     /* UIF without DocValues can't deal with mincount=0, the reason is because\n         we create the buckets based on the values present in the result set.\n         So we are not going to see facet values which are not in the result set */\n     if (method == FacetMethod.UIF\n         && !field.hasDocValues() && mincount == 0) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* ENUM can't deal with trie fields that index several terms per value */\n     if (method == FacetMethod.ENUM\n         && TrieField.getMainValuePrefix(type) != null) {\n       method = field.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n     }\n\n     /* FCS can't deal with multi token fields */\n     final boolean multiToken = field.multiValued() || type.multiValuedFieldCache();\n     if (method == FacetMethod.FCS\n         && multiToken) {\n       method = FacetMethod.FC;\n     }\n\n     return method;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3d81baa64023bbb9b43f6d929ee168b105940d30":["46dc9ac8b3e748407baaef82453138ff3974480c"],"46dc9ac8b3e748407baaef82453138ff3974480c":["7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5"],"7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5":["275f40e1400de0b5ab5e33051ac11e8973813a2c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e":["3d81baa64023bbb9b43f6d929ee168b105940d30"],"275f40e1400de0b5ab5e33051ac11e8973813a2c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","46dc9ac8b3e748407baaef82453138ff3974480c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e"]},"commit2Childs":{"3d81baa64023bbb9b43f6d929ee168b105940d30":["0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e"],"46dc9ac8b3e748407baaef82453138ff3974480c":["3d81baa64023bbb9b43f6d929ee168b105940d30","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5":["46dc9ac8b3e748407baaef82453138ff3974480c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["275f40e1400de0b5ab5e33051ac11e8973813a2c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"275f40e1400de0b5ab5e33051ac11e8973813a2c":["7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5"],"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}