{"path":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","commits":[{"id":"8106bc60c7452250f84c65cdb43ab6b1d8eb1534","date":1401906364,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a random-access slice of this index input, with the given offset and length. \n   * <p>\n   * The default implementation calls {@link #slice}, and implements absolute reads as\n   * seek+read.\n   */\n  public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {\n    final IndexInput slice = slice(\"randomaccess\", offset, length);\n    return new RandomAccessInput() {\n      @Override\n      public byte readByte(long pos) throws IOException {\n        slice.seek(pos);\n        return slice.readByte();\n      }\n\n      @Override\n      public short readShort(long pos) throws IOException {\n        slice.seek(pos);\n        return slice.readShort();\n      }\n\n      @Override\n      public int readInt(long pos) throws IOException {\n        slice.seek(pos);\n        return slice.readInt();\n      }\n\n      @Override\n      public long readLong(long pos) throws IOException {\n        slice.seek(pos);\n        return slice.readLong();\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa","date":1402696520,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","sourceNew":"  /**\n   * Creates a random-access slice of this index input, with the given offset and length. \n   * <p>\n   * The default implementation calls {@link #slice}, and it doesn't support random access,\n   * it implements absolute reads as seek+read.\n   */\n  public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {\n    final IndexInput slice = slice(\"randomaccess\", offset, length);\n    if (slice instanceof RandomAccessInput) {\n      // slice() already supports random access\n      return (RandomAccessInput) slice;\n    } else {\n      // return default impl\n      return new RandomAccessInput() {\n        @Override\n        public byte readByte(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readByte();\n        }\n        \n        @Override\n        public short readShort(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readShort();\n        }\n        \n        @Override\n        public int readInt(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readInt();\n        }\n        \n        @Override\n        public long readLong(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readLong();\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a random-access slice of this index input, with the given offset and length. \n   * <p>\n   * The default implementation calls {@link #slice}, and implements absolute reads as\n   * seek+read.\n   */\n  public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {\n    final IndexInput slice = slice(\"randomaccess\", offset, length);\n    return new RandomAccessInput() {\n      @Override\n      public byte readByte(long pos) throws IOException {\n        slice.seek(pos);\n        return slice.readByte();\n      }\n\n      @Override\n      public short readShort(long pos) throws IOException {\n        slice.seek(pos);\n        return slice.readShort();\n      }\n\n      @Override\n      public int readInt(long pos) throws IOException {\n        slice.seek(pos);\n        return slice.readInt();\n      }\n\n      @Override\n      public long readLong(long pos) throws IOException {\n        slice.seek(pos);\n        return slice.readLong();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","sourceNew":"  /**\n   * Creates a random-access slice of this index input, with the given offset and length. \n   * <p>\n   * The default implementation calls {@link #slice}, and it doesn't support random access,\n   * it implements absolute reads as seek+read.\n   */\n  public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {\n    final IndexInput slice = slice(\"randomaccess\", offset, length);\n    if (slice instanceof RandomAccessInput) {\n      // slice() already supports random access\n      return (RandomAccessInput) slice;\n    } else {\n      // return default impl\n      return new RandomAccessInput() {\n        @Override\n        public byte readByte(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readByte();\n        }\n        \n        @Override\n        public short readShort(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readShort();\n        }\n        \n        @Override\n        public int readInt(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readInt();\n        }\n        \n        @Override\n        public long readLong(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readLong();\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a random-access slice of this index input, with the given offset and length. \n   * <p>\n   * The default implementation calls {@link #slice}, and implements absolute reads as\n   * seek+read.\n   */\n  public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {\n    final IndexInput slice = slice(\"randomaccess\", offset, length);\n    return new RandomAccessInput() {\n      @Override\n      public byte readByte(long pos) throws IOException {\n        slice.seek(pos);\n        return slice.readByte();\n      }\n\n      @Override\n      public short readShort(long pos) throws IOException {\n        slice.seek(pos);\n        return slice.readShort();\n      }\n\n      @Override\n      public int readInt(long pos) throws IOException {\n        slice.seek(pos);\n        return slice.readInt();\n      }\n\n      @Override\n      public long readLong(long pos) throws IOException {\n        slice.seek(pos);\n        return slice.readLong();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3246b951f8c3c2cda6e42d6cf58af30b8100c73","date":1465063897,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","sourceNew":"  /**\n   * Creates a random-access slice of this index input, with the given offset and length. \n   * <p>\n   * The default implementation calls {@link #slice}, and it doesn't support random access,\n   * it implements absolute reads as seek+read.\n   */\n  public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {\n    final IndexInput slice = slice(\"randomaccess\", offset, length);\n    if (slice instanceof RandomAccessInput) {\n      // slice() already supports random access\n      return (RandomAccessInput) slice;\n    } else {\n      // return default impl\n      return new RandomAccessInput() {\n        @Override\n        public byte readByte(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readByte();\n        }\n        \n        @Override\n        public short readShort(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readShort();\n        }\n        \n        @Override\n        public int readInt(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readInt();\n        }\n        \n        @Override\n        public long readLong(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readLong();\n        }\n\n        @Override\n        public String toString() {\n          return \"RandomAccessInput(\" + IndexInput.this.toString() + \")\";\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a random-access slice of this index input, with the given offset and length. \n   * <p>\n   * The default implementation calls {@link #slice}, and it doesn't support random access,\n   * it implements absolute reads as seek+read.\n   */\n  public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {\n    final IndexInput slice = slice(\"randomaccess\", offset, length);\n    if (slice instanceof RandomAccessInput) {\n      // slice() already supports random access\n      return (RandomAccessInput) slice;\n    } else {\n      // return default impl\n      return new RandomAccessInput() {\n        @Override\n        public byte readByte(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readByte();\n        }\n        \n        @Override\n        public short readShort(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readShort();\n        }\n        \n        @Override\n        public int readInt(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readInt();\n        }\n        \n        @Override\n        public long readLong(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readLong();\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","sourceNew":"  /**\n   * Creates a random-access slice of this index input, with the given offset and length. \n   * <p>\n   * The default implementation calls {@link #slice}, and it doesn't support random access,\n   * it implements absolute reads as seek+read.\n   */\n  public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {\n    final IndexInput slice = slice(\"randomaccess\", offset, length);\n    if (slice instanceof RandomAccessInput) {\n      // slice() already supports random access\n      return (RandomAccessInput) slice;\n    } else {\n      // return default impl\n      return new RandomAccessInput() {\n        @Override\n        public byte readByte(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readByte();\n        }\n        \n        @Override\n        public short readShort(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readShort();\n        }\n        \n        @Override\n        public int readInt(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readInt();\n        }\n        \n        @Override\n        public long readLong(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readLong();\n        }\n\n        @Override\n        public String toString() {\n          return \"RandomAccessInput(\" + IndexInput.this.toString() + \")\";\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a random-access slice of this index input, with the given offset and length. \n   * <p>\n   * The default implementation calls {@link #slice}, and it doesn't support random access,\n   * it implements absolute reads as seek+read.\n   */\n  public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {\n    final IndexInput slice = slice(\"randomaccess\", offset, length);\n    if (slice instanceof RandomAccessInput) {\n      // slice() already supports random access\n      return (RandomAccessInput) slice;\n    } else {\n      // return default impl\n      return new RandomAccessInput() {\n        @Override\n        public byte readByte(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readByte();\n        }\n        \n        @Override\n        public short readShort(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readShort();\n        }\n        \n        @Override\n        public int readInt(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readInt();\n        }\n        \n        @Override\n        public long readLong(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readLong();\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","sourceNew":"  /**\n   * Creates a random-access slice of this index input, with the given offset and length. \n   * <p>\n   * The default implementation calls {@link #slice}, and it doesn't support random access,\n   * it implements absolute reads as seek+read.\n   */\n  public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {\n    final IndexInput slice = slice(\"randomaccess\", offset, length);\n    if (slice instanceof RandomAccessInput) {\n      // slice() already supports random access\n      return (RandomAccessInput) slice;\n    } else {\n      // return default impl\n      return new RandomAccessInput() {\n        @Override\n        public byte readByte(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readByte();\n        }\n        \n        @Override\n        public short readShort(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readShort();\n        }\n        \n        @Override\n        public int readInt(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readInt();\n        }\n        \n        @Override\n        public long readLong(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readLong();\n        }\n\n        @Override\n        public String toString() {\n          return \"RandomAccessInput(\" + IndexInput.this.toString() + \")\";\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a random-access slice of this index input, with the given offset and length. \n   * <p>\n   * The default implementation calls {@link #slice}, and it doesn't support random access,\n   * it implements absolute reads as seek+read.\n   */\n  public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {\n    final IndexInput slice = slice(\"randomaccess\", offset, length);\n    if (slice instanceof RandomAccessInput) {\n      // slice() already supports random access\n      return (RandomAccessInput) slice;\n    } else {\n      // return default impl\n      return new RandomAccessInput() {\n        @Override\n        public byte readByte(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readByte();\n        }\n        \n        @Override\n        public short readShort(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readShort();\n        }\n        \n        @Override\n        public int readInt(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readInt();\n        }\n        \n        @Override\n        public long readLong(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readLong();\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/IndexInput#randomAccessSlice(long,long).mjava","sourceNew":"  /**\n   * Creates a random-access slice of this index input, with the given offset and length. \n   * <p>\n   * The default implementation calls {@link #slice}, and it doesn't support random access,\n   * it implements absolute reads as seek+read.\n   */\n  public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {\n    final IndexInput slice = slice(\"randomaccess\", offset, length);\n    if (slice instanceof RandomAccessInput) {\n      // slice() already supports random access\n      return (RandomAccessInput) slice;\n    } else {\n      // return default impl\n      return new RandomAccessInput() {\n        @Override\n        public byte readByte(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readByte();\n        }\n        \n        @Override\n        public short readShort(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readShort();\n        }\n        \n        @Override\n        public int readInt(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readInt();\n        }\n        \n        @Override\n        public long readLong(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readLong();\n        }\n\n        @Override\n        public String toString() {\n          return \"RandomAccessInput(\" + IndexInput.this.toString() + \")\";\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a random-access slice of this index input, with the given offset and length. \n   * <p>\n   * The default implementation calls {@link #slice}, and it doesn't support random access,\n   * it implements absolute reads as seek+read.\n   */\n  public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {\n    final IndexInput slice = slice(\"randomaccess\", offset, length);\n    if (slice instanceof RandomAccessInput) {\n      // slice() already supports random access\n      return (RandomAccessInput) slice;\n    } else {\n      // return default impl\n      return new RandomAccessInput() {\n        @Override\n        public byte readByte(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readByte();\n        }\n        \n        @Override\n        public short readShort(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readShort();\n        }\n        \n        @Override\n        public int readInt(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readInt();\n        }\n        \n        @Override\n        public long readLong(long pos) throws IOException {\n          slice.seek(pos);\n          return slice.readLong();\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b3246b951f8c3c2cda6e42d6cf58af30b8100c73":["c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8106bc60c7452250f84c65cdb43ab6b1d8eb1534":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6483e4260c08168709c02238ae083a51519a28dd":["c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa","b3246b951f8c3c2cda6e42d6cf58af30b8100c73"],"191128ac5b85671b1671e2c857437694283b6ebf":["c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa","6483e4260c08168709c02238ae083a51519a28dd"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534","c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa"],"c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa","191128ac5b85671b1671e2c857437694283b6ebf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["191128ac5b85671b1671e2c857437694283b6ebf"]},"commit2Childs":{"b3246b951f8c3c2cda6e42d6cf58af30b8100c73":["6483e4260c08168709c02238ae083a51519a28dd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"8106bc60c7452250f84c65cdb43ab6b1d8eb1534":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa"],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa":["b3246b951f8c3c2cda6e42d6cf58af30b8100c73","6483e4260c08168709c02238ae083a51519a28dd","191128ac5b85671b1671e2c857437694283b6ebf","c6f080a2ab37c464dd98db173f6cbf10dc74f211","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}