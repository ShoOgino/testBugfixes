{"path":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    for (int i=0; i<10; i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    for (int i=0; i<10; i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    for (int i=0; i<10; i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    for (int i=0; i<10; i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2aafd88401639311b0404e67c94e829e123a0e45","date":1273477632,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    for (int i=0; i<10*_TestUtil.getRandomMultiplier(); i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    for (int i=0; i<10; i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c084e47df29de3330311d69dabf515ceaa989512","date":1279030906,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    for (int i=0; i<10*_TestUtil.getRandomMultiplier(); i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    for (int i=0; i<10*_TestUtil.getRandomMultiplier(); i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    for (int i=0; i<10*_TestUtil.getRandomMultiplier(); i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    for (int i=0; i<10*_TestUtil.getRandomMultiplier(); i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0e45742e10e8e3b98e854babe6dbb07a4197b71","date":1280230285,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    for (int i=0; i<10*_TestUtil.getRandomMultiplier(); i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    for (int i=0; i<10*_TestUtil.getRandomMultiplier(); i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"052d5ce692feb1c8a4bc039b75bf9eacaf505c49","date":1281122758,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1f653cfcf159baeaafe5d01682a911e95bba4012","date":1284122058,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    final Random rnd=newRandom();\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(rnd.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(10*4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(10*4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e492fb0f2bb0b4b47208286f9331ff55963c656","date":1298870150,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n      // TODO: when new TermRange ctors with BytesRef available, use them and do not convert to string!\n      final String lowerString = lowerBytes.utf8ToString(), upperString = upperBytes.utf8ToString();\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerString, upperString, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerString, upperString, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerString, upperString, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1bb50752d43a65ef1b623eabdb8e865983d3cd6","date":1304257984,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && \n        (searcher.getIndexReader().getSequentialSubReaders() == null || \n         searcher.getIndexReader().getSequentialSubReaders().length == 1)) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && \n        (searcher.getIndexReader().getSequentialSubReaders() == null || \n         searcher.getIndexReader().getSequentialSubReaders().length == 1)) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && \n        (searcher.getIndexReader().getSequentialSubReaders() == null || \n         searcher.getIndexReader().getSequentialSubReaders().length == 1)) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && searcher.getIndexReader().getSequentialSubReaders().length == 1) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f83af14a2a8131b14d7aee6274c740334e0363d3","date":1307579822,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = atLeast(10);\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && \n        (searcher.getIndexReader().getSequentialSubReaders() == null || \n         searcher.getIndexReader().getSequentialSubReaders().length == 1)) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && \n        (searcher.getIndexReader().getSequentialSubReaders() == null || \n         searcher.getIndexReader().getSequentialSubReaders().length == 1)) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = atLeast(10);\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && \n        (searcher.getIndexReader().getSequentialSubReaders() == null || \n         searcher.getIndexReader().getSequentialSubReaders().length == 1)) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && \n        (searcher.getIndexReader().getSequentialSubReaders() == null || \n         searcher.getIndexReader().getSequentialSubReaders().length == 1)) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = atLeast(10);\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && \n        (searcher.getIndexReader().getSequentialSubReaders() == null || \n         searcher.getIndexReader().getSequentialSubReaders().length == 1)) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = 10 * RANDOM_MULTIPLIER;\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && \n        (searcher.getIndexReader().getSequentialSubReaders() == null || \n         searcher.getIndexReader().getSequentialSubReaders().length == 1)) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"459280d4c73660ea582f38afce7968563068fe49","date":1311128716,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = _TestUtil.nextInt(random, 10, 20);\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && \n        (searcher.getIndexReader().getSequentialSubReaders() == null || \n         searcher.getIndexReader().getSequentialSubReaders().length == 1)) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = atLeast(10);\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && \n        (searcher.getIndexReader().getSequentialSubReaders() == null || \n         searcher.getIndexReader().getSequentialSubReaders().length == 1)) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a4965b25e439626b575c2281b39ad875f89d891","date":1321132400,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int totalTermCountT=0,totalTermCountC=0,termCountT,termCountC;\n    int num = _TestUtil.nextInt(random, 10, 20);\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      totalTermCountT += termCountT = countTerms(tq);\n      totalTermCountC += termCountC = countTerms(cq);\n      checkTermCounts(precisionStep, termCountT, termCountC);\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      totalTermCountT += termCountT = countTerms(tq);\n      totalTermCountC += termCountC = countTerms(cq);\n      checkTermCounts(precisionStep, termCountT, termCountC);\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      totalTermCountT += termCountT = countTerms(tq);\n      totalTermCountC += termCountC = countTerms(cq);\n      checkTermCounts(precisionStep, termCountT, termCountC);\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      totalTermCountT += termCountT = countTerms(tq);\n      totalTermCountC += termCountC = countTerms(cq);\n      checkTermCounts(precisionStep, termCountT, termCountC);\n    }\n    \n    checkTermCounts(precisionStep, totalTermCountT, totalTermCountC);\n    if (VERBOSE && precisionStep != Integer.MAX_VALUE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Numeric query: \" + (((double)totalTermCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)totalTermCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int termCountT=0,termCountC=0;\n    int num = _TestUtil.nextInt(random, 10, 20);\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      termCountT += tq.getTotalNumberOfTerms();\n      termCountC += cq.getTotalNumberOfTerms();\n    }\n    if (precisionStep == Integer.MAX_VALUE && \n        (searcher.getIndexReader().getSequentialSubReaders() == null || \n         searcher.getIndexReader().getSequentialSubReaders().length == 1)) {\n      assertEquals(\"Total number of terms should be equal for unlimited precStep\", termCountT, termCountC);\n    } else if (VERBOSE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Trie query: \" + (((double)termCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)termCountC)/(num * 4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32#testRandomTrieAndClassicRangeQuery(int).mjava","sourceNew":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int totalTermCountT=0,totalTermCountC=0,termCountT,termCountC;\n    int num = _TestUtil.nextInt(random, 10, 20);\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      totalTermCountT += termCountT = countTerms(tq);\n      totalTermCountC += termCountC = countTerms(cq);\n      checkTermCounts(precisionStep, termCountT, termCountC);\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      totalTermCountT += termCountT = countTerms(tq);\n      totalTermCountC += termCountC = countTerms(cq);\n      checkTermCounts(precisionStep, termCountT, termCountC);\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      totalTermCountT += termCountT = countTerms(tq);\n      totalTermCountC += termCountC = countTerms(cq);\n      checkTermCounts(precisionStep, termCountT, termCountC);\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      totalTermCountT += termCountT = countTerms(tq);\n      totalTermCountC += termCountC = countTerms(cq);\n      checkTermCounts(precisionStep, termCountT, termCountC);\n    }\n    \n    checkTermCounts(precisionStep, totalTermCountT, totalTermCountC);\n    if (VERBOSE && precisionStep != Integer.MAX_VALUE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Numeric query: \" + (((double)totalTermCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)totalTermCountC)/(num * 4)));\n    }\n  }\n\n","sourceOld":"  private void testRandomTrieAndClassicRangeQuery(int precisionStep) throws Exception {\n    String field=\"field\"+precisionStep;\n    int totalTermCountT=0,totalTermCountC=0,termCountT,termCountC;\n    int num = _TestUtil.nextInt(random, 10, 20);\n    for (int i = 0; i < num; i++) {\n      int lower=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      int upper=(int)(random.nextDouble()*noDocs*distance)+startOffset;\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      final BytesRef lowerBytes = new BytesRef(NumericUtils.BUF_SIZE_INT), upperBytes = new BytesRef(NumericUtils.BUF_SIZE_INT);\n      NumericUtils.intToPrefixCoded(lower, 0, lowerBytes);\n      NumericUtils.intToPrefixCoded(upper, 0, upperBytes);\n\n      // test inclusive range\n      NumericRangeQuery<Integer> tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);\n      TermRangeQuery cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, true);\n      TopDocs tTopDocs = searcher.search(tq, 1);\n      TopDocs cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      totalTermCountT += termCountT = countTerms(tq);\n      totalTermCountC += termCountC = countTerms(cq);\n      checkTermCounts(precisionStep, termCountT, termCountC);\n      // test exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      totalTermCountT += termCountT = countTerms(tq);\n      totalTermCountC += termCountC = countTerms(cq);\n      checkTermCounts(precisionStep, termCountT, termCountC);\n      // test left exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, false, true);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, false, true);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      totalTermCountT += termCountT = countTerms(tq);\n      totalTermCountC += termCountC = countTerms(cq);\n      checkTermCounts(precisionStep, termCountT, termCountC);\n      // test right exclusive range\n      tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, false);\n      cq=new TermRangeQuery(field, lowerBytes, upperBytes, true, false);\n      tTopDocs = searcher.search(tq, 1);\n      cTopDocs = searcher.search(cq, 1);\n      assertEquals(\"Returned count for NumericRangeQuery and TermRangeQuery must be equal\", cTopDocs.totalHits, tTopDocs.totalHits );\n      totalTermCountT += termCountT = countTerms(tq);\n      totalTermCountC += termCountC = countTerms(cq);\n      checkTermCounts(precisionStep, termCountT, termCountC);\n    }\n    \n    checkTermCounts(precisionStep, totalTermCountT, totalTermCountC);\n    if (VERBOSE && precisionStep != Integer.MAX_VALUE) {\n      System.out.println(\"Average number of terms during random search on '\" + field + \"':\");\n      System.out.println(\" Numeric query: \" + (((double)totalTermCountT)/(num * 4)));\n      System.out.println(\" Classical query: \" + (((double)totalTermCountC)/(num * 4)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e45742e10e8e3b98e854babe6dbb07a4197b71":["c084e47df29de3330311d69dabf515ceaa989512"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["a3776dccca01c11e7046323cfad46a3b4a471233","f83af14a2a8131b14d7aee6274c740334e0363d3"],"f83af14a2a8131b14d7aee6274c740334e0363d3":["c1bb50752d43a65ef1b623eabdb8e865983d3cd6"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["5f4e87790277826a2aea119328600dfb07761f32","a0e45742e10e8e3b98e854babe6dbb07a4197b71"],"459280d4c73660ea582f38afce7968563068fe49":["f83af14a2a8131b14d7aee6274c740334e0363d3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["2a4965b25e439626b575c2281b39ad875f89d891"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["d619839baa8ce5503e496b94a9e42ad6f079293f","c1bb50752d43a65ef1b623eabdb8e865983d3cd6"],"052d5ce692feb1c8a4bc039b75bf9eacaf505c49":["a0e45742e10e8e3b98e854babe6dbb07a4197b71"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"2aafd88401639311b0404e67c94e829e123a0e45":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"5f4e87790277826a2aea119328600dfb07761f32":["2aafd88401639311b0404e67c94e829e123a0e45","c084e47df29de3330311d69dabf515ceaa989512"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["3242a09f703274d3b9283f2064a1a33064b53a1b","1f653cfcf159baeaafe5d01682a911e95bba4012"],"c1bb50752d43a65ef1b623eabdb8e865983d3cd6":["3e492fb0f2bb0b4b47208286f9331ff55963c656"],"c084e47df29de3330311d69dabf515ceaa989512":["2aafd88401639311b0404e67c94e829e123a0e45"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","3e492fb0f2bb0b4b47208286f9331ff55963c656"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["1f653cfcf159baeaafe5d01682a911e95bba4012","3e492fb0f2bb0b4b47208286f9331ff55963c656"],"1f653cfcf159baeaafe5d01682a911e95bba4012":["052d5ce692feb1c8a4bc039b75bf9eacaf505c49"],"a3776dccca01c11e7046323cfad46a3b4a471233":["3e492fb0f2bb0b4b47208286f9331ff55963c656","c1bb50752d43a65ef1b623eabdb8e865983d3cd6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2a4965b25e439626b575c2281b39ad875f89d891":["459280d4c73660ea582f38afce7968563068fe49"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["135621f3a0670a9394eb563224a3b76cc4dddc0f","f83af14a2a8131b14d7aee6274c740334e0363d3"],"3e492fb0f2bb0b4b47208286f9331ff55963c656":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e45742e10e8e3b98e854babe6dbb07a4197b71":["3242a09f703274d3b9283f2064a1a33064b53a1b","052d5ce692feb1c8a4bc039b75bf9eacaf505c49"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":[],"f83af14a2a8131b14d7aee6274c740334e0363d3":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","459280d4c73660ea582f38afce7968563068fe49","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"459280d4c73660ea582f38afce7968563068fe49":["2a4965b25e439626b575c2281b39ad875f89d891"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"052d5ce692feb1c8a4bc039b75bf9eacaf505c49":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["2aafd88401639311b0404e67c94e829e123a0e45"],"5f4e87790277826a2aea119328600dfb07761f32":["3242a09f703274d3b9283f2064a1a33064b53a1b"],"2aafd88401639311b0404e67c94e829e123a0e45":["5f4e87790277826a2aea119328600dfb07761f32","c084e47df29de3330311d69dabf515ceaa989512"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"c1bb50752d43a65ef1b623eabdb8e865983d3cd6":["f83af14a2a8131b14d7aee6274c740334e0363d3","135621f3a0670a9394eb563224a3b76cc4dddc0f","a3776dccca01c11e7046323cfad46a3b4a471233"],"c084e47df29de3330311d69dabf515ceaa989512":["a0e45742e10e8e3b98e854babe6dbb07a4197b71","5f4e87790277826a2aea119328600dfb07761f32"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"d619839baa8ce5503e496b94a9e42ad6f079293f":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"a3776dccca01c11e7046323cfad46a3b4a471233":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655"],"1f653cfcf159baeaafe5d01682a911e95bba4012":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d619839baa8ce5503e496b94a9e42ad6f079293f","3e492fb0f2bb0b4b47208286f9331ff55963c656"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"2a4965b25e439626b575c2281b39ad875f89d891":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"3e492fb0f2bb0b4b47208286f9331ff55963c656":["c1bb50752d43a65ef1b623eabdb8e865983d3cd6","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f","a3776dccca01c11e7046323cfad46a3b4a471233"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}