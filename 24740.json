{"path":"lucene/src/java/org/apache/lucene/index/values/SortedBytesMergeUtils#createOrdMapping(MergeState,SortedSourceSlice).mjava","commits":[{"id":"1346e81f172438a4f28d91266cdd03851f94b831","date":1318404834,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/SortedBytesMergeUtils#createOrdMapping(MergeState,SortedSourceSlice).mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(MergeState mergeState,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = mergeState.docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == mergeState.docBase[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final IndexReaderAndLiveDocs indexReaderAndLiveDocs = mergeState.readers\n          .get(readerIdx);\n      final int numDocs = indexReaderAndLiveDocs.reader.numDocs();\n      assert indexReaderAndLiveDocs.liveDocs == null;\n      assert currentSlice.docToOrdEnd - currentSlice.docToOrdStart == numDocs;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9efc72acdea22f5285be0a808f8bba51bb8e367","date":1323217280,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene40/values/SortedBytesMergeUtils#createOrdMapping(MergeState,SortedSourceSlice).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/SortedBytesMergeUtils#createOrdMapping(MergeState,SortedSourceSlice).mjava","sourceNew":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(MergeState mergeState,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = mergeState.docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == mergeState.docBase[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final IndexReaderAndLiveDocs indexReaderAndLiveDocs = mergeState.readers\n          .get(readerIdx);\n      final int numDocs = indexReaderAndLiveDocs.reader.numDocs();\n      assert indexReaderAndLiveDocs.liveDocs == null;\n      assert currentSlice.docToOrdEnd - currentSlice.docToOrdStart == numDocs;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(MergeState mergeState,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = mergeState.docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == mergeState.docBase[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final IndexReaderAndLiveDocs indexReaderAndLiveDocs = mergeState.readers\n          .get(readerIdx);\n      final int numDocs = indexReaderAndLiveDocs.reader.numDocs();\n      assert indexReaderAndLiveDocs.liveDocs == null;\n      assert currentSlice.docToOrdEnd - currentSlice.docToOrdStart == numDocs;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d638301ad1cfcae567b681b893bc8781f0ee48a5","date":1323801546,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(MergeState,SortedSourceSlice).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/SortedBytesMergeUtils#createOrdMapping(MergeState,SortedSourceSlice).mjava","sourceNew":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(MergeState mergeState,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = mergeState.docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == mergeState.docBase[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final IndexReaderAndLiveDocs indexReaderAndLiveDocs = mergeState.readers\n          .get(readerIdx);\n      final int numDocs = indexReaderAndLiveDocs.reader.numDocs();\n      assert indexReaderAndLiveDocs.liveDocs == null;\n      assert currentSlice.docToOrdEnd - currentSlice.docToOrdStart == numDocs;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(MergeState mergeState,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = mergeState.docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == mergeState.docBase[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final IndexReaderAndLiveDocs indexReaderAndLiveDocs = mergeState.readers\n          .get(readerIdx);\n      final int numDocs = indexReaderAndLiveDocs.reader.numDocs();\n      assert indexReaderAndLiveDocs.liveDocs == null;\n      assert currentSlice.docToOrdEnd - currentSlice.docToOrdStart == numDocs;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1346e81f172438a4f28d91266cdd03851f94b831":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f9efc72acdea22f5285be0a808f8bba51bb8e367":["1346e81f172438a4f28d91266cdd03851f94b831"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["1346e81f172438a4f28d91266cdd03851f94b831","f9efc72acdea22f5285be0a808f8bba51bb8e367"]},"commit2Childs":{"1346e81f172438a4f28d91266cdd03851f94b831":["f9efc72acdea22f5285be0a808f8bba51bb8e367","d638301ad1cfcae567b681b893bc8781f0ee48a5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1346e81f172438a4f28d91266cdd03851f94b831"],"f9efc72acdea22f5285be0a808f8bba51bb8e367":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}