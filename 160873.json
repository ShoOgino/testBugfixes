{"path":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre>\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   * @throws IOException\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre>\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   * @throws IOException\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd9ddb59e9d33950773d186a8b726b5610ae3aad","date":1341258232,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre>\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre>\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   * @throws IOException\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre>\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre>\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   * @throws IOException\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8471c0f357621e859602d44e1af230581b739319","date":1347468766,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre>\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91","date":1429620941,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return Explanation.match(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a259cdf9917ec38c8a812cc053f533b6e697a4a","date":1439487435,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf(docFreq=\" + df + \", docCount=\" + docCount + \")\");\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return Explanation.match(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46","date":1508899684,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf(docFreq, docCount)\", \n        Explanation.match(df, \"docFreq, number of documents containing term\"),\n        Explanation.match(docCount, \"docCount, total number of documents with field\"));\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf(docFreq=\" + df + \", docCount=\" + docCount + \")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"086ffe31d8fba0110227db122974163709ecc1b4","date":1509678141,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf(docFreq, docCount)\", \n        Explanation.match(df, \"docFreq, number of documents containing term\"),\n        Explanation.match(docCount, \"docCount, total number of documents with field\"));\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf(docFreq, docCount)\", \n        Explanation.match(df, \"docFreq, number of documents containing term\"),\n        Explanation.match(docCount, \"docCount, total number of documents with field\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d523b8189b211dd1630166aa77b8c88bb48b3fcc","date":1510144168,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf(docFreq, docCount)\", \n        Explanation.match(df, \"docFreq, number of documents containing term\"),\n        Explanation.match(docCount, \"docCount, total number of documents with field\"));\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf(docFreq, docCount)\", \n        Explanation.match(df, \"docFreq, number of documents containing term\"),\n        Explanation.match(docCount, \"docCount, total number of documents with field\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46":["5a259cdf9917ec38c8a812cc053f533b6e697a4a"],"086ffe31d8fba0110227db122974163709ecc1b4":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46"],"8471c0f357621e859602d44e1af230581b739319":["bd9ddb59e9d33950773d186a8b726b5610ae3aad"],"bd9ddb59e9d33950773d186a8b726b5610ae3aad":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"5a259cdf9917ec38c8a812cc053f533b6e697a4a":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46","086ffe31d8fba0110227db122974163709ecc1b4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","bd9ddb59e9d33950773d186a8b726b5610ae3aad"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91":["8471c0f357621e859602d44e1af230581b739319"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"]},"commit2Childs":{"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46":["086ffe31d8fba0110227db122974163709ecc1b4","d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"086ffe31d8fba0110227db122974163709ecc1b4":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"8471c0f357621e859602d44e1af230581b739319":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91"],"bd9ddb59e9d33950773d186a8b726b5610ae3aad":["8471c0f357621e859602d44e1af230581b739319","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"5a259cdf9917ec38c8a812cc053f533b6e697a4a":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["bd9ddb59e9d33950773d186a8b726b5610ae3aad","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91":["5a259cdf9917ec38c8a812cc053f533b6e697a4a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}