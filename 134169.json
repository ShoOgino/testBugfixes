{"path":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,boolean,String).mjava","commits":[{"id":"a837c064b67fa63a9394136e31218b908cdcf783","date":1362186072,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputSource).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, boolean isXmlFile, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    //TODO 5.0: Remove this confusing junk, the properties file is so fast to read that there's no good reason\n    //          to add this stuff. Furthermore, it would be good to persist comments when saving.....\n    try {\n      if (isXmlFile) {\n        cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);\n        this.cfg = new ConfigSolrXmlBackCompat(loader, (ConfigSolrXmlBackCompat)cfg);\n      } else {\n        cfg = new SolrProperties(this, is, fileName);\n        this.cfg = new SolrProperties(this, loader, (SolrProperties)cfg);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param cfgis the configuration file InputStream\n   */\n  public void load(String dir, InputSource cfgis)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n    \n    Config cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new Config(loader, null, cfgis, null, false);\n      this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n    \n    initShardHandler(cfg);\n    \n    allocateLazyCores(cfg);\n    \n    // Initialize Logging\n    if (cfg.getBool(\"solr/logging/@enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(\"solr/logging/watcher/@class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(\"solr/logging/watcher/@size\", 50);\n          v.threshold = cfg.get(\"solr/logging/watcher/@threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(\"solr/cores/@defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(\"solr/@persistent\", false);\n    libDir = cfg.get(\"solr/@sharedLib\", null);\n    zkHost = cfg.get(\"solr/@zkHost\", null);\n    coreLoadThreads = cfg.getInt(\"solr/@coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(\"solr/cores/@adminPath\", null);\n    shareSchema = cfg.getBool(\"solr/cores/@shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(\"solr/cores/@zkClientTimeout\",\n        DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(\"solr/cores/@distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(\"solr/cores/@distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(\"solr/cores/@hostPort\", DEFAULT_HOST_PORT);\n    \n    hostContext = cfg.get(\"solr/cores/@hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(\"solr/cores/@host\", null);\n    \n    leaderVoteWait = cfg.get(\"solr/cores/@leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(\"solr/cores/@adminHandler\", null);\n    managementPath = cfg.get(\"solr/cores/@managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    \n    try {\n      containerProperties = readProperties(cfg, ((NodeList) cfg.evaluate(\n          DEFAULT_HOST_CONTEXT, XPathConstants.NODESET)).item(0));\n    } catch (Throwable e) {\n      SolrException.log(log, null, e);\n    }\n    \n    NodeList nodes = (NodeList) cfg.evaluate(\"solr/cores/core\",\n        XPathConstants.NODESET);\n    \n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n      \n      for (int i = 0; i < nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        try {\n          String rawName = DOMUtil.getAttr(node, CORE_NAME, null);\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              DOMUtil.getAttr(node, CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = DOMUtil.getAttr(node, CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = DOMUtil.getAttr(node, CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n            opt = DOMUtil.getAttr(node, CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = DOMUtil.getAttr(node, CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = DOMUtil.getAttr(node, CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(readProperties(cfg, node));\n          \n          opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = DOMUtil.getAttr(node, CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  if (p.isTransient()) {\n                    registerLazyCore(name, c, false);\n                  } else {\n                    register(name, c, false);\n                  }\n\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n\n\n            pending.add(completionService.submit(task));\n\n            \n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            dynamicDescriptors.put(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreToOrigName.put(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b6f42dee5a60f46a3fdf3ab93b39aefb356e245","date":1363106546,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,boolean,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, boolean isXmlFile, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    //TODO 5.0: Remove this confusing junk, the properties file is so fast to read that there's no good reason\n    //          to add this stuff. Furthermore, it would be good to persist comments when saving.....\n    try {\n      if (isXmlFile) {\n        cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);\n        this.cfg = new ConfigSolrXmlBackCompat(loader, (ConfigSolrXmlBackCompat)cfg);\n      } else {\n        cfg = new SolrProperties(this, is, fileName);\n        this.cfg = new SolrProperties(this, loader, (SolrProperties)cfg);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, boolean isXmlFile, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    //TODO 5.0: Remove this confusing junk, the properties file is so fast to read that there's no good reason\n    //          to add this stuff. Furthermore, it would be good to persist comments when saving.....\n    try {\n      if (isXmlFile) {\n        cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);\n        this.cfg = new ConfigSolrXmlBackCompat(loader, (ConfigSolrXmlBackCompat)cfg);\n      } else {\n        cfg = new SolrProperties(this, is, fileName);\n        this.cfg = new SolrProperties(this, loader, (SolrProperties)cfg);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n          \n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0937e467e3a2e44c636e2b022b816b21257acb26","date":1363268855,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,boolean,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, boolean isXmlFile, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    //TODO 5.0: Remove this confusing junk, the properties file is so fast to read that there's no good reason\n    //          to add this stuff. Furthermore, it would be good to persist comments when saving.....\n    try {\n      if (isXmlFile) {\n        cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);\n        this.cfg = new ConfigSolrXmlBackCompat(loader, (ConfigSolrXmlBackCompat)cfg);\n      } else {\n        cfg = new SolrProperties(this, loader, is, fileName);\n        this.cfg = new SolrProperties(this, loader, (SolrProperties)cfg);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, boolean isXmlFile, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    //TODO 5.0: Remove this confusing junk, the properties file is so fast to read that there's no good reason\n    //          to add this stuff. Furthermore, it would be good to persist comments when saving.....\n    try {\n      if (isXmlFile) {\n        cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);\n        this.cfg = new ConfigSolrXmlBackCompat(loader, (ConfigSolrXmlBackCompat)cfg);\n      } else {\n        cfg = new SolrProperties(this, is, fileName);\n        this.cfg = new SolrProperties(this, loader, (SolrProperties)cfg);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"005df777a3e106b1f8aa205b064c95a0c716a9e5","date":1364393378,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,boolean,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, boolean isXmlFile, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    //TODO 5.0: Remove this confusing junk, the properties file is so fast to read that there's no good reason\n    //          to add this stuff. Furthermore, it would be good to persist comments when saving.....\n    try {\n      if (isXmlFile) {\n        cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);\n        this.cfg = new ConfigSolrXmlBackCompat(loader, (ConfigSolrXmlBackCompat)cfg);\n      } else {\n        cfg = new SolrProperties(this, loader, is, fileName);\n        this.cfg = new SolrProperties(this, loader, (SolrProperties)cfg);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, boolean isXmlFile, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    //TODO 5.0: Remove this confusing junk, the properties file is so fast to read that there's no good reason\n    //          to add this stuff. Furthermore, it would be good to persist comments when saving.....\n    try {\n      if (isXmlFile) {\n        cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);\n        this.cfg = new ConfigSolrXmlBackCompat(loader, (ConfigSolrXmlBackCompat)cfg);\n      } else {\n        cfg = new SolrProperties(this, loader, is, fileName);\n        this.cfg = new SolrProperties(this, loader, (SolrProperties)cfg);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            log.warn(\"Log watching is not yet implemented for log4j\");\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \"\n            + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n//      else if( \"Log4j\".equals(fname) ) {\n//        logging = new Log4jWatcher(slf4jImpl);\n//      }\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe2d4d2624d8e786fe90cf705ac07befd5d8acfd","date":1364840870,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,boolean,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, boolean isXmlFile, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    //TODO 5.0: Remove this confusing junk, the properties file is so fast to read that there's no good reason\n    //          to add this stuff. Furthermore, it would be good to persist comments when saving.....\n    try {\n      if (isXmlFile) {\n        cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);\n        this.cfg = new ConfigSolrXmlBackCompat(loader, (ConfigSolrXmlBackCompat)cfg);\n      } else {\n        cfg = new SolrProperties(this, loader, is, fileName);\n        this.cfg = new SolrProperties(this, loader, (SolrProperties)cfg);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", null);\n\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, boolean isXmlFile, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    //TODO 5.0: Remove this confusing junk, the properties file is so fast to read that there's no good reason\n    //          to add this stuff. Furthermore, it would be good to persist comments when saving.....\n    try {\n      if (isXmlFile) {\n        cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);\n        this.cfg = new ConfigSolrXmlBackCompat(loader, (ConfigSolrXmlBackCompat)cfg);\n      } else {\n        cfg = new SolrProperties(this, loader, is, fileName);\n        this.cfg = new SolrProperties(this, loader, (SolrProperties)cfg);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n    \n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", DEFAULT_HOST_PORT);\n\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", DEFAULT_HOST_CONTEXT);\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9818efa55563ddfecdecafbdd43f4bee9f252e7d","date":1364853872,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,boolean,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new ConfigSolrXml(loader, null, is, null, false, this);\n      this.cfg = new ConfigSolrXml(loader, (ConfigSolrXml) cfg, this);\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", null);\n\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"transientCacheSize\", Integer.MAX_VALUE);\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, boolean isXmlFile, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    //TODO 5.0: Remove this confusing junk, the properties file is so fast to read that there's no good reason\n    //          to add this stuff. Furthermore, it would be good to persist comments when saving.....\n    try {\n      if (isXmlFile) {\n        cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);\n        this.cfg = new ConfigSolrXmlBackCompat(loader, (ConfigSolrXmlBackCompat)cfg);\n      } else {\n        cfg = new SolrProperties(this, loader, is, fileName);\n        this.cfg = new SolrProperties(this, loader, (SolrProperties)cfg);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", null);\n\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"8b6f42dee5a60f46a3fdf3ab93b39aefb356e245":["a837c064b67fa63a9394136e31218b908cdcf783"],"9818efa55563ddfecdecafbdd43f4bee9f252e7d":["fe2d4d2624d8e786fe90cf705ac07befd5d8acfd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fe2d4d2624d8e786fe90cf705ac07befd5d8acfd":["005df777a3e106b1f8aa205b064c95a0c716a9e5"],"005df777a3e106b1f8aa205b064c95a0c716a9e5":["0937e467e3a2e44c636e2b022b816b21257acb26"],"0937e467e3a2e44c636e2b022b816b21257acb26":["8b6f42dee5a60f46a3fdf3ab93b39aefb356e245"],"a837c064b67fa63a9394136e31218b908cdcf783":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9818efa55563ddfecdecafbdd43f4bee9f252e7d"]},"commit2Childs":{"8b6f42dee5a60f46a3fdf3ab93b39aefb356e245":["0937e467e3a2e44c636e2b022b816b21257acb26"],"9818efa55563ddfecdecafbdd43f4bee9f252e7d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a837c064b67fa63a9394136e31218b908cdcf783"],"fe2d4d2624d8e786fe90cf705ac07befd5d8acfd":["9818efa55563ddfecdecafbdd43f4bee9f252e7d"],"005df777a3e106b1f8aa205b064c95a0c716a9e5":["fe2d4d2624d8e786fe90cf705ac07befd5d8acfd"],"a837c064b67fa63a9394136e31218b908cdcf783":["8b6f42dee5a60f46a3fdf3ab93b39aefb356e245"],"0937e467e3a2e44c636e2b022b816b21257acb26":["005df777a3e106b1f8aa205b064c95a0c716a9e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}