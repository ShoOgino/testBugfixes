{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput,IndexInput,IndexInput).mjava","commits":[{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput,IndexInput,IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput metaIn, IndexInput indexIn, IndexInput dataIn) throws IOException {\n    this(metaIn, indexIn, dataIn, indexIn instanceof ByteBufferIndexInput);\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    this(in, in instanceof ByteBufferIndexInput);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6b1fd50f847900ca47783ea832846d60e81f990","date":1591769592,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput,IndexInput,IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput,IndexInput,IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned.\n   * BKD tree is always stored off-heap. */\n  public BKDReader(IndexInput metaIn, IndexInput indexIn, IndexInput dataIn) throws IOException {\n    version = CodecUtil.checkHeader(metaIn, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDataDims = metaIn.readVInt();\n    if (version >= BKDWriter.VERSION_SELECTIVE_INDEXING) {\n      numIndexDims = metaIn.readVInt();\n    } else {\n      numIndexDims = numDataDims;\n    }\n    maxPointsInLeafNode = metaIn.readVInt();\n    bytesPerDim = metaIn.readVInt();\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = metaIn.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    metaIn.readBytes(minPackedValue, 0, packedIndexBytesLength);\n    metaIn.readBytes(maxPackedValue, 0, packedIndexBytesLength);\n\n    for(int dim=0;dim<numIndexDims;dim++) {\n      if (Arrays.compareUnsigned(minPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim, maxPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, metaIn);\n      }\n    }\n    \n    pointCount = metaIn.readVLong();\n    docCount = metaIn.readVInt();\n\n    int numIndexBytes = metaIn.readVInt();\n    long indexStartPointer;\n    if (version >= BKDWriter.VERSION_META_FILE) {\n      minLeafBlockFP = metaIn.readLong();\n      indexStartPointer = metaIn.readLong();\n    } else {\n      indexStartPointer = indexIn.getFilePointer();\n      minLeafBlockFP = indexIn.readVLong();\n      indexIn.seek(indexStartPointer);\n    }\n    this.packedIndex = indexIn.slice(\"packedIndex\", indexStartPointer, numIndexBytes);\n    this.in = dataIn;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput metaIn, IndexInput indexIn, IndexInput dataIn) throws IOException {\n    this(metaIn, indexIn, dataIn, indexIn instanceof ByteBufferIndexInput);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput,IndexInput,IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput,IndexInput,IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned.\n   * BKD tree is always stored off-heap. */\n  public BKDReader(IndexInput metaIn, IndexInput indexIn, IndexInput dataIn) throws IOException {\n    version = CodecUtil.checkHeader(metaIn, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    final int numDims = metaIn.readVInt();\n    final int numIndexDims;\n    if (version >= BKDWriter.VERSION_SELECTIVE_INDEXING) {\n      numIndexDims = metaIn.readVInt();\n    } else {\n      numIndexDims = numDims;\n    }\n    final int maxPointsInLeafNode = metaIn.readVInt();\n    final int bytesPerDim = metaIn.readVInt();\n    config = new BKDConfig(numDims, numIndexDims, bytesPerDim, maxPointsInLeafNode);\n\n    // Read index:\n    numLeaves = metaIn.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[config.packedIndexBytesLength];\n    maxPackedValue = new byte[config.packedIndexBytesLength];\n\n    metaIn.readBytes(minPackedValue, 0, config.packedIndexBytesLength);\n    metaIn.readBytes(maxPackedValue, 0, config.packedIndexBytesLength);\n\n    for(int dim=0;dim<config.numIndexDims;dim++) {\n      if (Arrays.compareUnsigned(minPackedValue, dim * config.bytesPerDim, dim * config.bytesPerDim + config.bytesPerDim, maxPackedValue, dim * config.bytesPerDim, dim * config.bytesPerDim + config.bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, metaIn);\n      }\n    }\n    \n    pointCount = metaIn.readVLong();\n    docCount = metaIn.readVInt();\n\n    int numIndexBytes = metaIn.readVInt();\n    long indexStartPointer;\n    if (version >= BKDWriter.VERSION_META_FILE) {\n      minLeafBlockFP = metaIn.readLong();\n      indexStartPointer = metaIn.readLong();\n    } else {\n      indexStartPointer = indexIn.getFilePointer();\n      minLeafBlockFP = indexIn.readVLong();\n      indexIn.seek(indexStartPointer);\n    }\n    this.packedIndex = indexIn.slice(\"packedIndex\", indexStartPointer, numIndexBytes);\n    this.in = dataIn;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned.\n   * BKD tree is always stored off-heap. */\n  public BKDReader(IndexInput metaIn, IndexInput indexIn, IndexInput dataIn) throws IOException {\n    version = CodecUtil.checkHeader(metaIn, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDataDims = metaIn.readVInt();\n    if (version >= BKDWriter.VERSION_SELECTIVE_INDEXING) {\n      numIndexDims = metaIn.readVInt();\n    } else {\n      numIndexDims = numDataDims;\n    }\n    maxPointsInLeafNode = metaIn.readVInt();\n    bytesPerDim = metaIn.readVInt();\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = metaIn.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    metaIn.readBytes(minPackedValue, 0, packedIndexBytesLength);\n    metaIn.readBytes(maxPackedValue, 0, packedIndexBytesLength);\n\n    for(int dim=0;dim<numIndexDims;dim++) {\n      if (Arrays.compareUnsigned(minPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim, maxPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, metaIn);\n      }\n    }\n    \n    pointCount = metaIn.readVLong();\n    docCount = metaIn.readVInt();\n\n    int numIndexBytes = metaIn.readVInt();\n    long indexStartPointer;\n    if (version >= BKDWriter.VERSION_META_FILE) {\n      minLeafBlockFP = metaIn.readLong();\n      indexStartPointer = metaIn.readLong();\n    } else {\n      indexStartPointer = indexIn.getFilePointer();\n      minLeafBlockFP = indexIn.readVLong();\n      indexIn.seek(indexStartPointer);\n    }\n    this.packedIndex = indexIn.slice(\"packedIndex\", indexStartPointer, numIndexBytes);\n    this.in = dataIn;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["d6b1fd50f847900ca47783ea832846d60e81f990"],"d6b1fd50f847900ca47783ea832846d60e81f990":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d6b1fd50f847900ca47783ea832846d60e81f990":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["d6b1fd50f847900ca47783ea832846d60e81f990"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}