{"path":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","sourceNew":"  public void deletePendingFiles() throws IOException {\n    assert locked();\n    if (deletable != null) {\n      List<String> oldDeletable = deletable;\n      deletable = null;\n      int size = oldDeletable.size();\n      for(int i=0;i<size;i++) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete pending file \" + oldDeletable.get(i));\n        }\n        deleteFile(oldDeletable.get(i));\n      }\n    }\n  }\n\n","sourceOld":"  public void deletePendingFiles() throws IOException {\n    assert locked();\n    if (deletable != null) {\n      List<String> oldDeletable = deletable;\n      deletable = null;\n      int size = oldDeletable.size();\n      for(int i=0;i<size;i++) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete pending file \" + oldDeletable.get(i));\n        }\n        deleteFile(oldDeletable.get(i));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","sourceNew":"  public void deletePendingFiles() throws IOException {\n    assert locked();\n    if (deletable != null) {\n      List<String> oldDeletable = deletable;\n      deletable = null;\n      int size = oldDeletable.size();\n      for(int i=0;i<size;i++) {\n        String fileName = oldDeletable.get(i);\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete pending file \" + fileName);\n        }\n        RefCount rc = refCounts.get(fileName);\n        if (rc != null && rc.count > 0) {\n          // LUCENE-5904: should never happen!  This means we are about to pending-delete a referenced index file\n          assert false: \"fileName=\" + fileName + \" is in pending delete list but also has refCount=\" + rc.count;\n        } else {\n          deleteFile(fileName);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void deletePendingFiles() throws IOException {\n    assert locked();\n    if (deletable != null) {\n      List<String> oldDeletable = deletable;\n      deletable = null;\n      int size = oldDeletable.size();\n      for(int i=0;i<size;i++) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete pending file \" + oldDeletable.get(i));\n        }\n        deleteFile(oldDeletable.get(i));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7599427f762eb1b4265584fd6e96521e4a1a4f3c","date":1413100083,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","sourceNew":"  public void deletePendingFiles() {\n    assert locked();\n    if (deletable != null) {\n      Set<String> oldDeletable = deletable;\n      deletable = null;\n      for(String fileName : oldDeletable) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete pending file \" + fileName);\n        }\n        RefCount rc = refCounts.get(fileName);\n        if (rc != null && rc.count > 0) {\n          // LUCENE-5904: should never happen!  This means we are about to pending-delete a referenced index file\n          assert false: \"fileName=\" + fileName + \" is in pending delete list but also has refCount=\" + rc.count;\n        } else {\n          deleteFile(fileName);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void deletePendingFiles() throws IOException {\n    assert locked();\n    if (deletable != null) {\n      List<String> oldDeletable = deletable;\n      deletable = null;\n      int size = oldDeletable.size();\n      for(int i=0;i<size;i++) {\n        String fileName = oldDeletable.get(i);\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete pending file \" + fileName);\n        }\n        RefCount rc = refCounts.get(fileName);\n        if (rc != null && rc.count > 0) {\n          // LUCENE-5904: should never happen!  This means we are about to pending-delete a referenced index file\n          assert false: \"fileName=\" + fileName + \" is in pending delete list but also has refCount=\" + rc.count;\n        } else {\n          deleteFile(fileName);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","sourceNew":"  public void deletePendingFiles() {\n    assert locked();\n    if (deletable != null) {\n      Set<String> oldDeletable = deletable;\n      deletable = null;\n      for(String fileName : oldDeletable) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete pending file \" + fileName);\n        }\n        RefCount rc = refCounts.get(fileName);\n        if (rc != null && rc.count > 0) {\n          // LUCENE-5904: should never happen!  This means we are about to pending-delete a referenced index file\n          assert false: \"fileName=\" + fileName + \" is in pending delete list but also has refCount=\" + rc.count;\n        } else {\n          deleteFile(fileName);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void deletePendingFiles() throws IOException {\n    assert locked();\n    if (deletable != null) {\n      List<String> oldDeletable = deletable;\n      deletable = null;\n      int size = oldDeletable.size();\n      for(int i=0;i<size;i++) {\n        String fileName = oldDeletable.get(i);\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete pending file \" + fileName);\n        }\n        RefCount rc = refCounts.get(fileName);\n        if (rc != null && rc.count > 0) {\n          // LUCENE-5904: should never happen!  This means we are about to pending-delete a referenced index file\n          assert false: \"fileName=\" + fileName + \" is in pending delete list but also has refCount=\" + rc.count;\n        } else {\n          deleteFile(fileName);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"950882a2bd2a5f9dc16a154871584eaa643d882a","date":1436366563,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","sourceNew":"  public void deletePendingFiles() {\n    assert locked();\n\n    // Clone the set because it will change as we iterate:\n    List<String> toDelete = new ArrayList<>(deletable);\n    \n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files\n    // undeleted so index is never in a corrupt state:\n    for (String fileName : toDelete) {\n      RefCount rc = refCounts.get(fileName);\n      if (rc != null && rc.count > 0) {\n        // LUCENE-5904: should never happen!  This means we are about to pending-delete a referenced index file\n        throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" is in pending delete set but has non-zero refCount=\" + rc.count);\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        if (deleteFile(fileName) == false) {\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"failed to remove commit point \\\"\" + fileName + \"\\\"; skipping deletion of all other pending files\");\n          }\n          return;\n        }\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        deleteFile(fileName);\n      }\n    }\n  }\n\n","sourceOld":"  public void deletePendingFiles() {\n    assert locked();\n    if (deletable != null) {\n      Set<String> oldDeletable = deletable;\n      deletable = null;\n      for(String fileName : oldDeletable) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete pending file \" + fileName);\n        }\n        RefCount rc = refCounts.get(fileName);\n        if (rc != null && rc.count > 0) {\n          // LUCENE-5904: should never happen!  This means we are about to pending-delete a referenced index file\n          assert false: \"fileName=\" + fileName + \" is in pending delete list but also has refCount=\" + rc.count;\n        } else {\n          deleteFile(fileName);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","sourceNew":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still\n   *  held open. */\n  public void deletePendingFiles() throws IOException {\n    // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n    // Clone the set because it will change as we iterate:\n    List<String> toDelete = new ArrayList<>(pendingDeletes);\n\n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files\n    // undeleted so index is never in a corrupt state:\n    for (String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        if (deleteFile(fileName) == false) {\n          return;\n        }\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        deleteFile(fileName);\n      }\n    }\n  }\n\n","sourceOld":"  public void deletePendingFiles() {\n    assert locked();\n\n    // Clone the set because it will change as we iterate:\n    List<String> toDelete = new ArrayList<>(deletable);\n    \n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files\n    // undeleted so index is never in a corrupt state:\n    for (String fileName : toDelete) {\n      RefCount rc = refCounts.get(fileName);\n      if (rc != null && rc.count > 0) {\n        // LUCENE-5904: should never happen!  This means we are about to pending-delete a referenced index file\n        throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" is in pending delete set but has non-zero refCount=\" + rc.count);\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        if (deleteFile(fileName) == false) {\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"failed to remove commit point \\\"\" + fileName + \"\\\"; skipping deletion of all other pending files\");\n          }\n          return;\n        }\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        deleteFile(fileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":4,"author":"Mike McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","sourceNew":null,"sourceOld":"  public void deletePendingFiles() {\n    assert locked();\n\n    // Clone the set because it will change as we iterate:\n    List<String> toDelete = new ArrayList<>(deletable);\n    \n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files\n    // undeleted so index is never in a corrupt state:\n    for (String fileName : toDelete) {\n      RefCount rc = refCounts.get(fileName);\n      if (rc != null && rc.count > 0) {\n        // LUCENE-5904: should never happen!  This means we are about to pending-delete a referenced index file\n        throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" is in pending delete set but has non-zero refCount=\" + rc.count);\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        if (deleteFile(fileName) == false) {\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"failed to remove commit point \\\"\" + fileName + \"\\\"; skipping deletion of all other pending files\");\n          }\n          return;\n        }\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        deleteFile(fileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":4,"author":"Mike McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","sourceNew":null,"sourceOld":"  public void deletePendingFiles() {\n    assert locked();\n\n    // Clone the set because it will change as we iterate:\n    List<String> toDelete = new ArrayList<>(deletable);\n    \n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files\n    // undeleted so index is never in a corrupt state:\n    for (String fileName : toDelete) {\n      RefCount rc = refCounts.get(fileName);\n      if (rc != null && rc.count > 0) {\n        // LUCENE-5904: should never happen!  This means we are about to pending-delete a referenced index file\n        throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" is in pending delete set but has non-zero refCount=\" + rc.count);\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        if (deleteFile(fileName) == false) {\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"failed to remove commit point \\\"\" + fileName + \"\\\"; skipping deletion of all other pending files\");\n          }\n          return;\n        }\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        deleteFile(fileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":4,"author":"Erick Erickson","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","sourceNew":null,"sourceOld":"  public void deletePendingFiles() {\n    assert locked();\n\n    // Clone the set because it will change as we iterate:\n    List<String> toDelete = new ArrayList<>(deletable);\n    \n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files\n    // undeleted so index is never in a corrupt state:\n    for (String fileName : toDelete) {\n      RefCount rc = refCounts.get(fileName);\n      if (rc != null && rc.count > 0) {\n        // LUCENE-5904: should never happen!  This means we are about to pending-delete a referenced index file\n        throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" is in pending delete set but has non-zero refCount=\" + rc.count);\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        if (deleteFile(fileName) == false) {\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"failed to remove commit point \\\"\" + fileName + \"\\\"; skipping deletion of all other pending files\");\n          }\n          return;\n        }\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        deleteFile(fileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7599427f762eb1b4265584fd6e96521e4a1a4f3c":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"55980207f1977bd1463465de1659b821347e2fa8":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","7599427f762eb1b4265584fd6e96521e4a1a4f3c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5a207d19eac354d649c3f0e2cce070017c78125e":["950882a2bd2a5f9dc16a154871584eaa643d882a","b470f36a9372c97283360b1304eacbde22df6c0d"],"b470f36a9372c97283360b1304eacbde22df6c0d":["950882a2bd2a5f9dc16a154871584eaa643d882a","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["950882a2bd2a5f9dc16a154871584eaa643d882a","b470f36a9372c97283360b1304eacbde22df6c0d"],"950882a2bd2a5f9dc16a154871584eaa643d882a":["7599427f762eb1b4265584fd6e96521e4a1a4f3c"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["950882a2bd2a5f9dc16a154871584eaa643d882a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5a207d19eac354d649c3f0e2cce070017c78125e"]},"commit2Childs":{"7599427f762eb1b4265584fd6e96521e4a1a4f3c":["55980207f1977bd1463465de1659b821347e2fa8","950882a2bd2a5f9dc16a154871584eaa643d882a"],"55980207f1977bd1463465de1659b821347e2fa8":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"5a207d19eac354d649c3f0e2cce070017c78125e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"950882a2bd2a5f9dc16a154871584eaa643d882a":["5a207d19eac354d649c3f0e2cce070017c78125e","b470f36a9372c97283360b1304eacbde22df6c0d","1e6acbaae7af722f17204ceccf0f7db5753eccf3","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["7599427f762eb1b4265584fd6e96521e4a1a4f3c","55980207f1977bd1463465de1659b821347e2fa8"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["b470f36a9372c97283360b1304eacbde22df6c0d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}