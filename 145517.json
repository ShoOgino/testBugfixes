{"path":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/NGramDistance#getDistance(String,String).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/NGramDistance#getDistance(String,String).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/NGramDistance#getDistance(String,String).mjava","sourceNew":"  public float getDistance(String source, String target) {\n    final int sl = source.length();\n    final int tl = target.length();\n    \n    if (sl == 0 || tl == 0) {\n      if (sl == tl) {\n        return 1;\n      }\n      else {\n        return 0;\n      }\n    }\n\n    int cost = 0;\n    if (sl < n || tl < n) {\n      for (int i=0,ni=Math.min(sl,tl);i<ni;i++) {\n        if (source.charAt(i) == target.charAt(i)) {\n          cost++;\n        }\n      }\n      return (float) cost/Math.max(sl, tl);\n    }\n\n    char[] sa = new char[sl+n-1];\n    float p[]; //'previous' cost array, horizontally\n    float d[]; // cost array, horizontally\n    float _d[]; //placeholder to assist in swapping p and d\n    \n    //construct sa with prefix\n    for (int i=0;i<sa.length;i++) {\n      if (i < n-1) {\n        sa[i]=0; //add prefix\n      }\n      else {\n        sa[i] = source.charAt(i-n+1);\n      }\n    }\n    p = new float[sl+1]; \n    d = new float[sl+1]; \n  \n    // indexes into strings s and t\n    int i; // iterates through source\n    int j; // iterates through target\n\n    char[] t_j = new char[n]; // jth n-gram of t\n\n    for (i = 0; i<=sl; i++) {\n        p[i] = i;\n    }\n\n    for (j = 1; j<=tl; j++) {\n        //construct t_j n-gram \n        if (j < n) {\n          for (int ti=0;ti<n-j;ti++) {\n            t_j[ti]=0; //add prefix\n          }\n          for (int ti=n-j;ti<n;ti++) {\n            t_j[ti]=target.charAt(ti-(n-j));\n          }\n        }\n        else {\n          t_j = target.substring(j-n, j).toCharArray();\n        }\n        d[0] = j;\n        for (i=1; i<=sl; i++) {\n            cost = 0;\n            int tn=n;\n            //compare sa to t_j\n            for (int ni=0;ni<n;ni++) {\n              if (sa[i-1+ni] != t_j[ni]) {\n                cost++;\n              }\n              else if (sa[i-1+ni] == 0) { //discount matches on prefix\n                tn--;\n              }\n            }\n            float ec = (float) cost/tn;\n            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+ec);\n        }\n        // copy current distance counts to 'previous row' distance counts\n        _d = p;\n        p = d;\n        d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n    return 1.0f - (p[sl] / Math.max(tl, sl));\n  }\n\n","sourceOld":"  public float getDistance(String source, String target) {\n    final int sl = source.length();\n    final int tl = target.length();\n    \n    if (sl == 0 || tl == 0) {\n      if (sl == tl) {\n        return 1;\n      }\n      else {\n        return 0;\n      }\n    }\n\n    int cost = 0;\n    if (sl < n || tl < n) {\n      for (int i=0,ni=Math.min(sl,tl);i<ni;i++) {\n        if (source.charAt(i) == target.charAt(i)) {\n          cost++;\n        }\n      }\n      return (float) cost/Math.max(sl, tl);\n    }\n\n    char[] sa = new char[sl+n-1];\n    float p[]; //'previous' cost array, horizontally\n    float d[]; // cost array, horizontally\n    float _d[]; //placeholder to assist in swapping p and d\n    \n    //construct sa with prefix\n    for (int i=0;i<sa.length;i++) {\n      if (i < n-1) {\n        sa[i]=0; //add prefix\n      }\n      else {\n        sa[i] = source.charAt(i-n+1);\n      }\n    }\n    p = new float[sl+1]; \n    d = new float[sl+1]; \n  \n    // indexes into strings s and t\n    int i; // iterates through source\n    int j; // iterates through target\n\n    char[] t_j = new char[n]; // jth n-gram of t\n\n    for (i = 0; i<=sl; i++) {\n        p[i] = i;\n    }\n\n    for (j = 1; j<=tl; j++) {\n        //construct t_j n-gram \n        if (j < n) {\n          for (int ti=0;ti<n-j;ti++) {\n            t_j[ti]=0; //add prefix\n          }\n          for (int ti=n-j;ti<n;ti++) {\n            t_j[ti]=target.charAt(ti-(n-j));\n          }\n        }\n        else {\n          t_j = target.substring(j-n, j).toCharArray();\n        }\n        d[0] = j;\n        for (i=1; i<=sl; i++) {\n            cost = 0;\n            int tn=n;\n            //compare sa to t_j\n            for (int ni=0;ni<n;ni++) {\n              if (sa[i-1+ni] != t_j[ni]) {\n                cost++;\n              }\n              else if (sa[i-1+ni] == 0) { //discount matches on prefix\n                tn--;\n              }\n            }\n            float ec = (float) cost/tn;\n            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+ec);\n        }\n        // copy current distance counts to 'previous row' distance counts\n        _d = p;\n        p = d;\n        d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n    return 1.0f - (p[sl] / Math.max(tl, sl));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e230a61047bc041516c811baa08a7174d6f8322a","date":1306175633,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/NGramDistance#getDistance(String,String).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/NGramDistance#getDistance(String,String).mjava","sourceNew":"  public float getDistance(String source, String target) {\n    final int sl = source.length();\n    final int tl = target.length();\n    \n    if (sl == 0 || tl == 0) {\n      if (sl == tl) {\n        return 1;\n      }\n      else {\n        return 0;\n      }\n    }\n\n    int cost = 0;\n    if (sl < n || tl < n) {\n      for (int i=0,ni=Math.min(sl,tl);i<ni;i++) {\n        if (source.charAt(i) == target.charAt(i)) {\n          cost++;\n        }\n      }\n      return (float) cost/Math.max(sl, tl);\n    }\n\n    char[] sa = new char[sl+n-1];\n    float p[]; //'previous' cost array, horizontally\n    float d[]; // cost array, horizontally\n    float _d[]; //placeholder to assist in swapping p and d\n    \n    //construct sa with prefix\n    for (int i=0;i<sa.length;i++) {\n      if (i < n-1) {\n        sa[i]=0; //add prefix\n      }\n      else {\n        sa[i] = source.charAt(i-n+1);\n      }\n    }\n    p = new float[sl+1]; \n    d = new float[sl+1]; \n  \n    // indexes into strings s and t\n    int i; // iterates through source\n    int j; // iterates through target\n\n    char[] t_j = new char[n]; // jth n-gram of t\n\n    for (i = 0; i<=sl; i++) {\n        p[i] = i;\n    }\n\n    for (j = 1; j<=tl; j++) {\n        //construct t_j n-gram \n        if (j < n) {\n          for (int ti=0;ti<n-j;ti++) {\n            t_j[ti]=0; //add prefix\n          }\n          for (int ti=n-j;ti<n;ti++) {\n            t_j[ti]=target.charAt(ti-(n-j));\n          }\n        }\n        else {\n          t_j = target.substring(j-n, j).toCharArray();\n        }\n        d[0] = j;\n        for (i=1; i<=sl; i++) {\n            cost = 0;\n            int tn=n;\n            //compare sa to t_j\n            for (int ni=0;ni<n;ni++) {\n              if (sa[i-1+ni] != t_j[ni]) {\n                cost++;\n              }\n              else if (sa[i-1+ni] == 0) { //discount matches on prefix\n                tn--;\n              }\n            }\n            float ec = (float) cost/tn;\n            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+ec);\n        }\n        // copy current distance counts to 'previous row' distance counts\n        _d = p;\n        p = d;\n        d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n    return 1.0f - (p[sl] / Math.max(tl, sl));\n  }\n\n","sourceOld":"  public float getDistance(String source, String target) {\n    final int sl = source.length();\n    final int tl = target.length();\n    \n    if (sl == 0 || tl == 0) {\n      if (sl == tl) {\n        return 1;\n      }\n      else {\n        return 0;\n      }\n    }\n\n    int cost = 0;\n    if (sl < n || tl < n) {\n      for (int i=0,ni=Math.min(sl,tl);i<ni;i++) {\n        if (source.charAt(i) == target.charAt(i)) {\n          cost++;\n        }\n      }\n      return (float) cost/Math.max(sl, tl);\n    }\n\n    char[] sa = new char[sl+n-1];\n    float p[]; //'previous' cost array, horizontally\n    float d[]; // cost array, horizontally\n    float _d[]; //placeholder to assist in swapping p and d\n    \n    //construct sa with prefix\n    for (int i=0;i<sa.length;i++) {\n      if (i < n-1) {\n        sa[i]=0; //add prefix\n      }\n      else {\n        sa[i] = source.charAt(i-n+1);\n      }\n    }\n    p = new float[sl+1]; \n    d = new float[sl+1]; \n  \n    // indexes into strings s and t\n    int i; // iterates through source\n    int j; // iterates through target\n\n    char[] t_j = new char[n]; // jth n-gram of t\n\n    for (i = 0; i<=sl; i++) {\n        p[i] = i;\n    }\n\n    for (j = 1; j<=tl; j++) {\n        //construct t_j n-gram \n        if (j < n) {\n          for (int ti=0;ti<n-j;ti++) {\n            t_j[ti]=0; //add prefix\n          }\n          for (int ti=n-j;ti<n;ti++) {\n            t_j[ti]=target.charAt(ti-(n-j));\n          }\n        }\n        else {\n          t_j = target.substring(j-n, j).toCharArray();\n        }\n        d[0] = j;\n        for (i=1; i<=sl; i++) {\n            cost = 0;\n            int tn=n;\n            //compare sa to t_j\n            for (int ni=0;ni<n;ni++) {\n              if (sa[i-1+ni] != t_j[ni]) {\n                cost++;\n              }\n              else if (sa[i-1+ni] == 0) { //discount matches on prefix\n                tn--;\n              }\n            }\n            float ec = (float) cost/tn;\n            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+ec);\n        }\n        // copy current distance counts to 'previous row' distance counts\n        _d = p;\n        p = d;\n        d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n    return 1.0f - (p[sl] / Math.max(tl, sl));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/NGramDistance#getDistance(String,String).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/NGramDistance#getDistance(String,String).mjava","sourceNew":"  public float getDistance(String source, String target) {\n    final int sl = source.length();\n    final int tl = target.length();\n    \n    if (sl == 0 || tl == 0) {\n      if (sl == tl) {\n        return 1;\n      }\n      else {\n        return 0;\n      }\n    }\n\n    int cost = 0;\n    if (sl < n || tl < n) {\n      for (int i=0,ni=Math.min(sl,tl);i<ni;i++) {\n        if (source.charAt(i) == target.charAt(i)) {\n          cost++;\n        }\n      }\n      return (float) cost/Math.max(sl, tl);\n    }\n\n    char[] sa = new char[sl+n-1];\n    float p[]; //'previous' cost array, horizontally\n    float d[]; // cost array, horizontally\n    float _d[]; //placeholder to assist in swapping p and d\n    \n    //construct sa with prefix\n    for (int i=0;i<sa.length;i++) {\n      if (i < n-1) {\n        sa[i]=0; //add prefix\n      }\n      else {\n        sa[i] = source.charAt(i-n+1);\n      }\n    }\n    p = new float[sl+1]; \n    d = new float[sl+1]; \n  \n    // indexes into strings s and t\n    int i; // iterates through source\n    int j; // iterates through target\n\n    char[] t_j = new char[n]; // jth n-gram of t\n\n    for (i = 0; i<=sl; i++) {\n        p[i] = i;\n    }\n\n    for (j = 1; j<=tl; j++) {\n        //construct t_j n-gram \n        if (j < n) {\n          for (int ti=0;ti<n-j;ti++) {\n            t_j[ti]=0; //add prefix\n          }\n          for (int ti=n-j;ti<n;ti++) {\n            t_j[ti]=target.charAt(ti-(n-j));\n          }\n        }\n        else {\n          t_j = target.substring(j-n, j).toCharArray();\n        }\n        d[0] = j;\n        for (i=1; i<=sl; i++) {\n            cost = 0;\n            int tn=n;\n            //compare sa to t_j\n            for (int ni=0;ni<n;ni++) {\n              if (sa[i-1+ni] != t_j[ni]) {\n                cost++;\n              }\n              else if (sa[i-1+ni] == 0) { //discount matches on prefix\n                tn--;\n              }\n            }\n            float ec = (float) cost/tn;\n            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+ec);\n        }\n        // copy current distance counts to 'previous row' distance counts\n        _d = p;\n        p = d;\n        d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n    return 1.0f - (p[sl] / Math.max(tl, sl));\n  }\n\n","sourceOld":"  public float getDistance(String source, String target) {\n    final int sl = source.length();\n    final int tl = target.length();\n    \n    if (sl == 0 || tl == 0) {\n      if (sl == tl) {\n        return 1;\n      }\n      else {\n        return 0;\n      }\n    }\n\n    int cost = 0;\n    if (sl < n || tl < n) {\n      for (int i=0,ni=Math.min(sl,tl);i<ni;i++) {\n        if (source.charAt(i) == target.charAt(i)) {\n          cost++;\n        }\n      }\n      return (float) cost/Math.max(sl, tl);\n    }\n\n    char[] sa = new char[sl+n-1];\n    float p[]; //'previous' cost array, horizontally\n    float d[]; // cost array, horizontally\n    float _d[]; //placeholder to assist in swapping p and d\n    \n    //construct sa with prefix\n    for (int i=0;i<sa.length;i++) {\n      if (i < n-1) {\n        sa[i]=0; //add prefix\n      }\n      else {\n        sa[i] = source.charAt(i-n+1);\n      }\n    }\n    p = new float[sl+1]; \n    d = new float[sl+1]; \n  \n    // indexes into strings s and t\n    int i; // iterates through source\n    int j; // iterates through target\n\n    char[] t_j = new char[n]; // jth n-gram of t\n\n    for (i = 0; i<=sl; i++) {\n        p[i] = i;\n    }\n\n    for (j = 1; j<=tl; j++) {\n        //construct t_j n-gram \n        if (j < n) {\n          for (int ti=0;ti<n-j;ti++) {\n            t_j[ti]=0; //add prefix\n          }\n          for (int ti=n-j;ti<n;ti++) {\n            t_j[ti]=target.charAt(ti-(n-j));\n          }\n        }\n        else {\n          t_j = target.substring(j-n, j).toCharArray();\n        }\n        d[0] = j;\n        for (i=1; i<=sl; i++) {\n            cost = 0;\n            int tn=n;\n            //compare sa to t_j\n            for (int ni=0;ni<n;ni++) {\n              if (sa[i-1+ni] != t_j[ni]) {\n                cost++;\n              }\n              else if (sa[i-1+ni] == 0) { //discount matches on prefix\n                tn--;\n              }\n            }\n            float ec = (float) cost/tn;\n            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+ec);\n        }\n        // copy current distance counts to 'previous row' distance counts\n        _d = p;\n        p = d;\n        d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n    return 1.0f - (p[sl] / Math.max(tl, sl));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/NGramDistance#getDistance(String,String).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/NGramDistance#getDistance(String,String).mjava","sourceNew":"  public float getDistance(String source, String target) {\n    final int sl = source.length();\n    final int tl = target.length();\n    \n    if (sl == 0 || tl == 0) {\n      if (sl == tl) {\n        return 1;\n      }\n      else {\n        return 0;\n      }\n    }\n\n    int cost = 0;\n    if (sl < n || tl < n) {\n      for (int i=0,ni=Math.min(sl,tl);i<ni;i++) {\n        if (source.charAt(i) == target.charAt(i)) {\n          cost++;\n        }\n      }\n      return (float) cost/Math.max(sl, tl);\n    }\n\n    char[] sa = new char[sl+n-1];\n    float p[]; //'previous' cost array, horizontally\n    float d[]; // cost array, horizontally\n    float _d[]; //placeholder to assist in swapping p and d\n    \n    //construct sa with prefix\n    for (int i=0;i<sa.length;i++) {\n      if (i < n-1) {\n        sa[i]=0; //add prefix\n      }\n      else {\n        sa[i] = source.charAt(i-n+1);\n      }\n    }\n    p = new float[sl+1]; \n    d = new float[sl+1]; \n  \n    // indexes into strings s and t\n    int i; // iterates through source\n    int j; // iterates through target\n\n    char[] t_j = new char[n]; // jth n-gram of t\n\n    for (i = 0; i<=sl; i++) {\n        p[i] = i;\n    }\n\n    for (j = 1; j<=tl; j++) {\n        //construct t_j n-gram \n        if (j < n) {\n          for (int ti=0;ti<n-j;ti++) {\n            t_j[ti]=0; //add prefix\n          }\n          for (int ti=n-j;ti<n;ti++) {\n            t_j[ti]=target.charAt(ti-(n-j));\n          }\n        }\n        else {\n          t_j = target.substring(j-n, j).toCharArray();\n        }\n        d[0] = j;\n        for (i=1; i<=sl; i++) {\n            cost = 0;\n            int tn=n;\n            //compare sa to t_j\n            for (int ni=0;ni<n;ni++) {\n              if (sa[i-1+ni] != t_j[ni]) {\n                cost++;\n              }\n              else if (sa[i-1+ni] == 0) { //discount matches on prefix\n                tn--;\n              }\n            }\n            float ec = (float) cost/tn;\n            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+ec);\n        }\n        // copy current distance counts to 'previous row' distance counts\n        _d = p;\n        p = d;\n        d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n    return 1.0f - (p[sl] / Math.max(tl, sl));\n  }\n\n","sourceOld":"  public float getDistance(String source, String target) {\n    final int sl = source.length();\n    final int tl = target.length();\n    \n    if (sl == 0 || tl == 0) {\n      if (sl == tl) {\n        return 1;\n      }\n      else {\n        return 0;\n      }\n    }\n\n    int cost = 0;\n    if (sl < n || tl < n) {\n      for (int i=0,ni=Math.min(sl,tl);i<ni;i++) {\n        if (source.charAt(i) == target.charAt(i)) {\n          cost++;\n        }\n      }\n      return (float) cost/Math.max(sl, tl);\n    }\n\n    char[] sa = new char[sl+n-1];\n    float p[]; //'previous' cost array, horizontally\n    float d[]; // cost array, horizontally\n    float _d[]; //placeholder to assist in swapping p and d\n    \n    //construct sa with prefix\n    for (int i=0;i<sa.length;i++) {\n      if (i < n-1) {\n        sa[i]=0; //add prefix\n      }\n      else {\n        sa[i] = source.charAt(i-n+1);\n      }\n    }\n    p = new float[sl+1]; \n    d = new float[sl+1]; \n  \n    // indexes into strings s and t\n    int i; // iterates through source\n    int j; // iterates through target\n\n    char[] t_j = new char[n]; // jth n-gram of t\n\n    for (i = 0; i<=sl; i++) {\n        p[i] = i;\n    }\n\n    for (j = 1; j<=tl; j++) {\n        //construct t_j n-gram \n        if (j < n) {\n          for (int ti=0;ti<n-j;ti++) {\n            t_j[ti]=0; //add prefix\n          }\n          for (int ti=n-j;ti<n;ti++) {\n            t_j[ti]=target.charAt(ti-(n-j));\n          }\n        }\n        else {\n          t_j = target.substring(j-n, j).toCharArray();\n        }\n        d[0] = j;\n        for (i=1; i<=sl; i++) {\n            cost = 0;\n            int tn=n;\n            //compare sa to t_j\n            for (int ni=0;ni<n;ni++) {\n              if (sa[i-1+ni] != t_j[ni]) {\n                cost++;\n              }\n              else if (sa[i-1+ni] == 0) { //discount matches on prefix\n                tn--;\n              }\n            }\n            float ec = (float) cost/tn;\n            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+ec);\n        }\n        // copy current distance counts to 'previous row' distance counts\n        _d = p;\n        p = d;\n        d = _d;\n    }\n\n    // our last action in the above loop was to switch d and p, so p now\n    // actually has the most recent cost counts\n    return 1.0f - (p[sl] / Math.max(tl, sl));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e230a61047bc041516c811baa08a7174d6f8322a":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["9454a6510e2db155fb01faa5c049b06ece95fab9","e230a61047bc041516c811baa08a7174d6f8322a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e230a61047bc041516c811baa08a7174d6f8322a"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["9454a6510e2db155fb01faa5c049b06ece95fab9","e230a61047bc041516c811baa08a7174d6f8322a"]},"commit2Childs":{"e230a61047bc041516c811baa08a7174d6f8322a":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["e230a61047bc041516c811baa08a7174d6f8322a","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}