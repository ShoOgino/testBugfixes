{"path":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","commits":[{"id":"ddc1ae5ff40afa2c5136ee382632ebe602e050e6","date":1474097671,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \" + onlyIfLeaderActive);\n\n    int maxTries = 0;\n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      CoreContainer coreContainer = it.handler.coreContainer;\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["04ecf884544ff74add5faa452748f160c4af904b","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \" + onlyIfLeaderActive);\n\n    int maxTries = 0;\n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      CoreContainer coreContainer = it.handler.coreContainer;\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \" + onlyIfLeaderActive);\n\n    int maxTries = 0;\n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      CoreContainer coreContainer = it.handler.coreContainer;\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"970a667af41fa94f5b9e55f7d08c90b51daf989d","date":1478330202,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \" + onlyIfLeaderActive);\n\n    int maxTries = 0;\n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      CoreContainer coreContainer = it.handler.coreContainer;\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \" + onlyIfLeaderActive);\n\n    int maxTries = 0;\n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      CoreContainer coreContainer = it.handler.coreContainer;\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \" + onlyIfLeaderActive);\n\n    int maxTries = 0;\n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      CoreContainer coreContainer = it.handler.coreContainer;\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \" + onlyIfLeaderActive);\n\n    int maxTries = 0;\n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      CoreContainer coreContainer = it.handler.coreContainer;\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \" + onlyIfLeaderActive);\n\n    int maxTries = 0;\n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      CoreContainer coreContainer = it.handler.coreContainer;\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \" + onlyIfLeaderActive);\n\n    int maxTries = 0;\n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      CoreContainer coreContainer = it.handler.coreContainer;\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":["04ecf884544ff74add5faa452748f160c4af904b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \" + onlyIfLeaderActive);\n\n    int maxTries = 0;\n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      CoreContainer coreContainer = it.handler.coreContainer;\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \" + onlyIfLeaderActive);\n\n    int maxTries = 0;\n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      CoreContainer coreContainer = it.handler.coreContainer;\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    int maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n    log.info(\"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}, maxTime: {} s\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive, maxTries);\n    \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == Math.min(30, maxTries)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          \n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + Objects.toString(state) + \" live:\" + live + \" leader from ZK: \" + leaderInfo);\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled() && core != null) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \" + onlyIfLeaderActive);\n\n    int maxTries = 0;\n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      CoreContainer coreContainer = it.handler.coreContainer;\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":["04ecf884544ff74add5faa452748f160c4af904b","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    int maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n    log.info(\"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}, maxTime: {} s\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive, maxTries);\n    \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == Math.min(30, maxTries)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          \n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + Objects.toString(state) + \" live:\" + live + \" leader from ZK: \" + leaderInfo);\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled() && core != null) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \" + onlyIfLeaderActive);\n\n    int maxTries = 0;\n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      CoreContainer coreContainer = it.handler.coreContainer;\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04ecf884544ff74add5faa452748f160c4af904b","date":1506527215,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    int maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n    log.info(\"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}, maxTime: {} s\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive, maxTries);\n    \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == Math.min(30, maxTries)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          \n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + Objects.toString(state) + \" live:\" + live + \" leader from ZK: \" + leaderInfo);\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    int maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n    log.info(\"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}, maxTime: {} s\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive, maxTries);\n    \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == Math.min(30, maxTries)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          \n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + Objects.toString(state) + \" live:\" + live + \" leader from ZK: \" + leaderInfo);\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled() && core != null) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":["ddc1ae5ff40afa2c5136ee382632ebe602e050e6","729cb470f975115d4c60517b2cb7c42e37a7a2e1","61c45e99cf6676da48f19d7511c73712ad39402b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    int maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n    log.info(\"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}, maxTime: {} s\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive, maxTries);\n    \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == Math.min(30, maxTries)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          \n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + Objects.toString(state) + \" live:\" + live + \" leader from ZK: \" + leaderInfo);\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    int maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n    log.info(\"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}, maxTime: {} s\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive, maxTries);\n    \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == Math.min(30, maxTries)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          \n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + Objects.toString(state) + \" live:\" + live + \" leader from ZK: \" + leaderInfo);\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled() && core != null) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    int maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n    log.info(\"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}, maxTime: {} s\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive, maxTries);\n    \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == Math.min(30, maxTries)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              ZkShardTerms shardTerms = coreContainer.getZkController().getShardTerms(collectionName, slice.getName());\n              // if the replica is waiting for leader to see recovery state, the leader should refresh its terms\n              if (waitForState == Replica.State.RECOVERING && shardTerms.registered(coreNodeName) && !shardTerms.canBecomeLeader(coreNodeName)) {\n                shardTerms.refreshTerms();\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          \n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + Objects.toString(state) + \" live:\" + live + \" leader from ZK: \" + leaderInfo);\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    int maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n    log.info(\"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}, maxTime: {} s\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive, maxTries);\n    \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == Math.min(30, maxTries)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          \n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + Objects.toString(state) + \" live:\" + live + \" leader from ZK: \" + leaderInfo);\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94","date":1520143025,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    int maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n    log.info(\"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}, maxTime: {} s\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive, maxTries);\n    \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == Math.min(30, maxTries)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              ZkShardTerms shardTerms = coreContainer.getZkController().getShardTerms(collectionName, slice.getName());\n              // if the replica is waiting for leader to see recovery state, the leader should refresh its terms\n              if (waitForState == Replica.State.RECOVERING && shardTerms.registered(coreNodeName) && shardTerms.skipSendingUpdatesTo(coreNodeName)) {\n                // The replica changed it term, then published itself as RECOVERING.\n                // This core already see replica as RECOVERING\n                // so it is guarantees that a live-fetch will be enough for this core to see max term published\n                shardTerms.refreshTerms();\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          \n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + Objects.toString(state) + \" live:\" + live + \" leader from ZK: \" + leaderInfo);\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    int maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n    log.info(\"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}, maxTime: {} s\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive, maxTries);\n    \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == Math.min(30, maxTries)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              ZkShardTerms shardTerms = coreContainer.getZkController().getShardTerms(collectionName, slice.getName());\n              // if the replica is waiting for leader to see recovery state, the leader should refresh its terms\n              if (waitForState == Replica.State.RECOVERING && shardTerms.registered(coreNodeName) && !shardTerms.canBecomeLeader(coreNodeName)) {\n                shardTerms.refreshTerms();\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          \n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + Objects.toString(state) + \" live:\" + live + \" leader from ZK: \" + leaderInfo);\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    log.info(\n        \"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive);\n\n    String collectionName;\n    CloudDescriptor cloudDescriptor;\n    try (SolrCore core = coreContainer.getCore(cname)) {\n      if (core == null) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      collectionName = core.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n      cloudDescriptor = core.getCoreDescriptor()\n          .getCloudDescriptor();\n    }\n    AtomicReference<String> errorMessage = new AtomicReference<>();\n    try {\n      coreContainer.getZkController().getZkStateReader().waitForState(collectionName, conflictWaitMs, TimeUnit.MILLISECONDS, (n, c) -> {\n        if (c == null)\n          return false;\n\n        try (SolrCore core = coreContainer.getCore(cname)) {\n          if (core == null) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n        }\n\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        Replica.State state = null;\n        boolean live = false;\n        Slice slice = c.getSlice(cloudDescriptor.getShardId());\n        if (slice != null) {\n          final Replica replica = slice.getReplicasMap().get(coreNodeName);\n          if (replica != null) {\n            state = replica.getState();\n            live = n.contains(nodeName);\n\n            final Replica.State localState = cloudDescriptor.getLastPublished();\n\n            // TODO: This is funky but I've seen this in testing where the replica asks the\n            // leader to be in recovery? Need to track down how that happens ... in the meantime,\n            // this is a safeguard\n            boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                onlyIfLeader &&\n                cname.equals(replica.getStr(\"core\")) &&\n                waitForState == Replica.State.RECOVERING &&\n                localState == Replica.State.ACTIVE &&\n                state == Replica.State.ACTIVE);\n\n            if (leaderDoesNotNeedRecovery) {\n              log.warn(\n                  \"Leader \" + cname + \" ignoring request to be in the recovering state because it is live and active.\");\n            }\n\n            ZkShardTerms shardTerms = coreContainer.getZkController().getShardTerms(collectionName, slice.getName());\n            // if the replica is waiting for leader to see recovery state, the leader should refresh its terms\n            if (waitForState == Replica.State.RECOVERING && shardTerms.registered(coreNodeName)\n                && shardTerms.skipSendingUpdatesTo(coreNodeName)) {\n              // The replica changed it term, then published itself as RECOVERING.\n              // This core already see replica as RECOVERING\n              // so it is guarantees that a live-fetch will be enough for this core to see max term published\n              shardTerms.refreshTerms();\n            }\n\n            boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive\n                && localState != Replica.State.ACTIVE;\n            log.info(\n                \"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                    \", thisCore=\" + cname + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                    \", isLeader? \" + cloudDescriptor.isLeader() +\n                    \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString()\n                    + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                    \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult\n                    + \", nodeProps: \" + replica);\n\n            if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n              if (checkLive == null) {\n                return true;\n              } else if (checkLive && live) {\n                return true;\n              } else if (!checkLive && !live) {\n                return true;\n              }\n            }\n          }\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n      String error = errorMessage.get();\n      if (error == null)\n        error = \"Timeout waiting for collection state.\";\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    int maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n    log.info(\"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}, maxTime: {} s\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive, maxTries);\n    \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == Math.min(30, maxTries)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          String collectionName = cloudDescriptor.getCollectionName();\n\n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().forceUpdateCollection(collectionName);\n          }\n\n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          DocCollection collection = clusterState.getCollection(collectionName);\n          Slice slice = collection.getSlice(cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n\n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard\n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                  onlyIfLeader &&\n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING &&\n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n\n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \" + core.getName() + \" ignoring request to be in the recovering state because it is live and active.\");\n              }\n\n              ZkShardTerms shardTerms = coreContainer.getZkController().getShardTerms(collectionName, slice.getName());\n              // if the replica is waiting for leader to see recovery state, the leader should refresh its terms\n              if (waitForState == Replica.State.RECOVERING && shardTerms.registered(coreNodeName) && shardTerms.skipSendingUpdatesTo(coreNodeName)) {\n                // The replica changed it term, then published itself as RECOVERING.\n                // This core already see replica as RECOVERING\n                // so it is guarantees that a live-fetch will be enough for this core to see max term published\n                shardTerms.refreshTerms();\n              }\n\n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                  \", thisCore=\" + core.getName() + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                  \", isLeader? \" + core.getCoreDescriptor().getCloudDescriptor().isLeader() +\n                  \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString() + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                  \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult + \", nodeProps: \" + replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          \n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + Objects.toString(state) + \" live:\" + live + \" leader from ZK: \" + leaderInfo);\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":["ddc1ae5ff40afa2c5136ee382632ebe602e050e6","84f20f331d8001864545c7021812d8c6509c7593","8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94","61c45e99cf6676da48f19d7511c73712ad39402b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    log.info(\n        \"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive);\n\n    String collectionName;\n    CloudDescriptor cloudDescriptor;\n    try (SolrCore core = coreContainer.getCore(cname)) {\n      if (core == null) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      collectionName = core.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n      cloudDescriptor = core.getCoreDescriptor()\n          .getCloudDescriptor();\n    }\n    AtomicReference<String> errorMessage = new AtomicReference<>();\n    try {\n      coreContainer.getZkController().getZkStateReader().waitForState(collectionName, conflictWaitMs, TimeUnit.MILLISECONDS, (n, c) -> {\n        if (c == null)\n          return false;\n\n        try (SolrCore core = coreContainer.getCore(cname)) {\n          if (core == null) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n        }\n\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        Replica.State state = null;\n        boolean live = false;\n        Slice slice = c.getSlice(cloudDescriptor.getShardId());\n        if (slice != null) {\n          final Replica replica = slice.getReplicasMap().get(coreNodeName);\n          if (replica != null) {\n            state = replica.getState();\n            live = n.contains(nodeName);\n\n            final Replica.State localState = cloudDescriptor.getLastPublished();\n\n            // TODO: This is funky but I've seen this in testing where the replica asks the\n            // leader to be in recovery? Need to track down how that happens ... in the meantime,\n            // this is a safeguard\n            boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                onlyIfLeader &&\n                cname.equals(replica.getStr(\"core\")) &&\n                waitForState == Replica.State.RECOVERING &&\n                localState == Replica.State.ACTIVE &&\n                state == Replica.State.ACTIVE);\n\n            if (leaderDoesNotNeedRecovery) {\n              log.warn(\"Leader {} ignoring request to be in the recovering state because it is live and active.\", cname);\n            }\n\n            ZkShardTerms shardTerms = coreContainer.getZkController().getShardTerms(collectionName, slice.getName());\n            // if the replica is waiting for leader to see recovery state, the leader should refresh its terms\n            if (waitForState == Replica.State.RECOVERING && shardTerms.registered(coreNodeName)\n                && shardTerms.skipSendingUpdatesTo(coreNodeName)) {\n              // The replica changed it term, then published itself as RECOVERING.\n              // This core already see replica as RECOVERING\n              // so it is guarantees that a live-fetch will be enough for this core to see max term published\n              shardTerms.refreshTerms();\n            }\n\n            boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive\n                && localState != Replica.State.ACTIVE;\n            if (log.isInfoEnabled()) {\n              log.info(\n                  \"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                      \", thisCore=\" + cname + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                      \", isLeader? \" + cloudDescriptor.isLeader() +\n                      \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state\n                      + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                      \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult\n                      + \", nodeProps: \" + replica); //LOGOK\n            }\n            if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n              if (checkLive == null) {\n                return true;\n              } else if (checkLive && live) {\n                return true;\n              } else if (!checkLive && !live) {\n                return true;\n              }\n            }\n          }\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n      String error = errorMessage.get();\n      if (error == null)\n        error = \"Timeout waiting for collection state.\";\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    log.info(\n        \"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive);\n\n    String collectionName;\n    CloudDescriptor cloudDescriptor;\n    try (SolrCore core = coreContainer.getCore(cname)) {\n      if (core == null) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      collectionName = core.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n      cloudDescriptor = core.getCoreDescriptor()\n          .getCloudDescriptor();\n    }\n    AtomicReference<String> errorMessage = new AtomicReference<>();\n    try {\n      coreContainer.getZkController().getZkStateReader().waitForState(collectionName, conflictWaitMs, TimeUnit.MILLISECONDS, (n, c) -> {\n        if (c == null)\n          return false;\n\n        try (SolrCore core = coreContainer.getCore(cname)) {\n          if (core == null) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n        }\n\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        Replica.State state = null;\n        boolean live = false;\n        Slice slice = c.getSlice(cloudDescriptor.getShardId());\n        if (slice != null) {\n          final Replica replica = slice.getReplicasMap().get(coreNodeName);\n          if (replica != null) {\n            state = replica.getState();\n            live = n.contains(nodeName);\n\n            final Replica.State localState = cloudDescriptor.getLastPublished();\n\n            // TODO: This is funky but I've seen this in testing where the replica asks the\n            // leader to be in recovery? Need to track down how that happens ... in the meantime,\n            // this is a safeguard\n            boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                onlyIfLeader &&\n                cname.equals(replica.getStr(\"core\")) &&\n                waitForState == Replica.State.RECOVERING &&\n                localState == Replica.State.ACTIVE &&\n                state == Replica.State.ACTIVE);\n\n            if (leaderDoesNotNeedRecovery) {\n              log.warn(\n                  \"Leader \" + cname + \" ignoring request to be in the recovering state because it is live and active.\");\n            }\n\n            ZkShardTerms shardTerms = coreContainer.getZkController().getShardTerms(collectionName, slice.getName());\n            // if the replica is waiting for leader to see recovery state, the leader should refresh its terms\n            if (waitForState == Replica.State.RECOVERING && shardTerms.registered(coreNodeName)\n                && shardTerms.skipSendingUpdatesTo(coreNodeName)) {\n              // The replica changed it term, then published itself as RECOVERING.\n              // This core already see replica as RECOVERING\n              // so it is guarantees that a live-fetch will be enough for this core to see max term published\n              shardTerms.refreshTerms();\n            }\n\n            boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive\n                && localState != Replica.State.ACTIVE;\n            log.info(\n                \"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                    \", thisCore=\" + cname + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                    \", isLeader? \" + cloudDescriptor.isLeader() +\n                    \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state.toString()\n                    + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                    \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult\n                    + \", nodeProps: \" + replica);\n\n            if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n              if (checkLive == null) {\n                return true;\n              } else if (checkLive && live) {\n                return true;\n              } else if (!checkLive && !live) {\n                return true;\n              }\n            }\n          }\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n      String error = errorMessage.get();\n      if (error == null)\n        error = \"Timeout waiting for collection state.\";\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2d19164145b2a65acf62a657c75f4a249b649c0","date":1601732857,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/PrepRecoveryOp#execute(CallInfo).mjava","sourceNew":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    log.info(\n        \"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive);\n\n    String collectionName;\n    CloudDescriptor cloudDescriptor;\n    try (SolrCore core = coreContainer.getCore(cname)) {\n      if (core == null) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      collectionName = core.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n      cloudDescriptor = core.getCoreDescriptor()\n          .getCloudDescriptor();\n    }\n    AtomicReference<String> errorMessage = new AtomicReference<>();\n    try {\n      coreContainer.getZkController().getZkStateReader().waitForState(collectionName, conflictWaitMs, TimeUnit.MILLISECONDS, (n, c) -> {\n        if (c == null)\n          return false;\n\n        try (SolrCore core = coreContainer.getCore(cname)) {\n          if (core == null) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n        }\n\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        Replica.State state = null;\n        boolean live = false;\n        Slice slice = c.getSlice(cloudDescriptor.getShardId());\n        if (slice != null) {\n          final Replica replica = slice.getReplicasMap().get(coreNodeName);\n          if (replica != null) {\n            state = replica.getState();\n            live = n.contains(nodeName);\n\n            final Replica.State localState = cloudDescriptor.getLastPublished();\n\n            // TODO: This is funky but I've seen this in testing where the replica asks the\n            // leader to be in recovery? Need to track down how that happens ... in the meantime,\n            // this is a safeguard\n            boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                onlyIfLeader &&\n                cname.equals(replica.getStr(\"core\")) &&\n                waitForState == Replica.State.RECOVERING &&\n                localState == Replica.State.ACTIVE &&\n                state == Replica.State.ACTIVE);\n\n            if (leaderDoesNotNeedRecovery) {\n              log.warn(\"Leader {} ignoring request to be in the recovering state because it is live and active.\", cname);\n            }\n\n            ZkShardTerms shardTerms = coreContainer.getZkController().getShardTerms(collectionName, slice.getName());\n            // if the replica is waiting for leader to see recovery state, the leader should refresh its terms\n            if (waitForState == Replica.State.RECOVERING && shardTerms.registered(coreNodeName)\n                && shardTerms.skipSendingUpdatesTo(coreNodeName)) {\n              // The replica changed it term, then published itself as RECOVERING.\n              // This core already see replica as RECOVERING\n              // so it is guarantees that a live-fetch will be enough for this core to see max term published\n              shardTerms.refreshTerms();\n            }\n\n            boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive\n                && localState != Replica.State.ACTIVE;\n            if (log.isInfoEnabled()) {\n              log.info(\n                  \"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                      \", thisCore=\" + cname + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                      \", isLeader? \" + cloudDescriptor.isLeader() +\n                      \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state\n                      + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                      \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult\n                      + \", nodeProps: \" + replica); //nowarn\n            }\n            if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n              if (checkLive == null) {\n                return true;\n              } else if (checkLive && live) {\n                return true;\n              } else if (!checkLive && !live) {\n                return true;\n              }\n            }\n          }\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n      String error = errorMessage.get();\n      if (error == null)\n        error = \"Timeout waiting for collection state.\";\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void execute(CallInfo it) throws Exception {\n    assert TestInjection.injectPrepRecoveryOpPauseForever();\n\n    final SolrParams params = it.req.getParams();\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    CoreContainer coreContainer = it.handler.coreContainer;\n    // wait long enough for the leader conflict to work itself out plus a little extra\n    int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n    log.info(\n        \"Going to wait for coreNodeName: {}, state: {}, checkLive: {}, onlyIfLeader: {}, onlyIfLeaderActive: {}\",\n        coreNodeName, waitForState, checkLive, onlyIfLeader, onlyIfLeaderActive);\n\n    String collectionName;\n    CloudDescriptor cloudDescriptor;\n    try (SolrCore core = coreContainer.getCore(cname)) {\n      if (core == null) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      collectionName = core.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n      cloudDescriptor = core.getCoreDescriptor()\n          .getCloudDescriptor();\n    }\n    AtomicReference<String> errorMessage = new AtomicReference<>();\n    try {\n      coreContainer.getZkController().getZkStateReader().waitForState(collectionName, conflictWaitMs, TimeUnit.MILLISECONDS, (n, c) -> {\n        if (c == null)\n          return false;\n\n        try (SolrCore core = coreContainer.getCore(cname)) {\n          if (core == null) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n          if (onlyIfLeader != null && onlyIfLeader) {\n            if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"We are not the leader\");\n            }\n          }\n        }\n\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        Replica.State state = null;\n        boolean live = false;\n        Slice slice = c.getSlice(cloudDescriptor.getShardId());\n        if (slice != null) {\n          final Replica replica = slice.getReplicasMap().get(coreNodeName);\n          if (replica != null) {\n            state = replica.getState();\n            live = n.contains(nodeName);\n\n            final Replica.State localState = cloudDescriptor.getLastPublished();\n\n            // TODO: This is funky but I've seen this in testing where the replica asks the\n            // leader to be in recovery? Need to track down how that happens ... in the meantime,\n            // this is a safeguard\n            boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null &&\n                onlyIfLeader &&\n                cname.equals(replica.getStr(\"core\")) &&\n                waitForState == Replica.State.RECOVERING &&\n                localState == Replica.State.ACTIVE &&\n                state == Replica.State.ACTIVE);\n\n            if (leaderDoesNotNeedRecovery) {\n              log.warn(\"Leader {} ignoring request to be in the recovering state because it is live and active.\", cname);\n            }\n\n            ZkShardTerms shardTerms = coreContainer.getZkController().getShardTerms(collectionName, slice.getName());\n            // if the replica is waiting for leader to see recovery state, the leader should refresh its terms\n            if (waitForState == Replica.State.RECOVERING && shardTerms.registered(coreNodeName)\n                && shardTerms.skipSendingUpdatesTo(coreNodeName)) {\n              // The replica changed it term, then published itself as RECOVERING.\n              // This core already see replica as RECOVERING\n              // so it is guarantees that a live-fetch will be enough for this core to see max term published\n              shardTerms.refreshTerms();\n            }\n\n            boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive\n                && localState != Replica.State.ACTIVE;\n            if (log.isInfoEnabled()) {\n              log.info(\n                  \"In WaitForState(\" + waitForState + \"): collection=\" + collectionName + \", shard=\" + slice.getName() +\n                      \", thisCore=\" + cname + \", leaderDoesNotNeedRecovery=\" + leaderDoesNotNeedRecovery +\n                      \", isLeader? \" + cloudDescriptor.isLeader() +\n                      \", live=\" + live + \", checkLive=\" + checkLive + \", currentState=\" + state\n                      + \", localState=\" + localState + \", nodeName=\" + nodeName +\n                      \", coreNodeName=\" + coreNodeName + \", onlyIfActiveCheckResult=\" + onlyIfActiveCheckResult\n                      + \", nodeProps: \" + replica); //LOGOK\n            }\n            if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n              if (checkLive == null) {\n                return true;\n              } else if (checkLive && live) {\n                return true;\n              } else if (!checkLive && !live) {\n                return true;\n              }\n            }\n          }\n        }\n\n        if (coreContainer.isShutDown()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n\n        return false;\n      });\n    } catch (TimeoutException | InterruptedException e) {\n      String error = errorMessage.get();\n      if (error == null)\n        error = \"Timeout waiting for collection state.\";\n      throw new NotInClusterStateException(ErrorCode.SERVER_ERROR, error);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"04ecf884544ff74add5faa452748f160c4af904b":["61c45e99cf6676da48f19d7511c73712ad39402b"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["970a667af41fa94f5b9e55f7d08c90b51daf989d"],"61c45e99cf6676da48f19d7511c73712ad39402b":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","970a667af41fa94f5b9e55f7d08c90b51daf989d"],"575e66bd4b2349209027f6801184da7fc3cba13f":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"84f20f331d8001864545c7021812d8c6509c7593":["04ecf884544ff74add5faa452748f160c4af904b"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["84f20f331d8001864545c7021812d8c6509c7593"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["970a667af41fa94f5b9e55f7d08c90b51daf989d"],"970a667af41fa94f5b9e55f7d08c90b51daf989d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","61c45e99cf6676da48f19d7511c73712ad39402b"],"ddc1ae5ff40afa2c5136ee382632ebe602e050e6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["e9017cf144952056066919f1ebc7897ff9bd71b1","04ecf884544ff74add5faa452748f160c4af904b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ddc1ae5ff40afa2c5136ee382632ebe602e050e6"],"b2d19164145b2a65acf62a657c75f4a249b649c0":["575e66bd4b2349209027f6801184da7fc3cba13f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b2d19164145b2a65acf62a657c75f4a249b649c0"]},"commit2Childs":{"04ecf884544ff74add5faa452748f160c4af904b":["84f20f331d8001864545c7021812d8c6509c7593","6240b74b884c5587f2a4062dd27d6c32bf228889"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"61c45e99cf6676da48f19d7511c73712ad39402b":["04ecf884544ff74add5faa452748f160c4af904b","e9017cf144952056066919f1ebc7897ff9bd71b1"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["575e66bd4b2349209027f6801184da7fc3cba13f"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"575e66bd4b2349209027f6801184da7fc3cba13f":["b2d19164145b2a65acf62a657c75f4a249b649c0"],"84f20f331d8001864545c7021812d8c6509c7593":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"970a667af41fa94f5b9e55f7d08c90b51daf989d":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","199dfa410f1fdbfd3294106b04096cce5ed34b21","729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["61c45e99cf6676da48f19d7511c73712ad39402b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["199dfa410f1fdbfd3294106b04096cce5ed34b21"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"ddc1ae5ff40afa2c5136ee382632ebe602e050e6":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["970a667af41fa94f5b9e55f7d08c90b51daf989d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","ddc1ae5ff40afa2c5136ee382632ebe602e050e6","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"b2d19164145b2a65acf62a657c75f4a249b649c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}