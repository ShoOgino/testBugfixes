{"path":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"3a80994db3380cd78c6f65b84515e2e931b6b3da","date":1329530403,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handlePrepRecoveryAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    boolean checkLive = params.getBool(\"checkLive\", true);\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state = null;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        String collection = cloudDescriptor.getCollectionName();\n        ZkNodeProps nodeProps = \n            cloudState.getSlice(collection,\n                cloudDescriptor.getShardId()).getShards().get(coreNodeName);\n        boolean live = false;\n        if (nodeProps != null) {\n          \n          state = nodeProps.get(ZkStateReader.STATE_PROP);\n          live = cloudState.liveNodesContain(nodeName);\n          if (nodeProps != null && state.equals(waitForState)) {\n            if (checkLive && live) {\n              break;\n            } else {\n              break;\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \" + nodeName\n                  + \" but I still do not see the request state. I see state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      \n      Thread.sleep(pauseFor);\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","sourceOld":"  protected void handlePrepRecoveryAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    \n \n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state = null;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        String collection = cloudDescriptor.getCollectionName();\n        ZkNodeProps nodeProps = \n            cloudState.getSlice(collection,\n                cloudDescriptor.getShardId()).getShards().get(coreNodeName);\n        boolean live = false;\n        if (nodeProps != null) {\n          \n          state = nodeProps.get(ZkStateReader.STATE_PROP);\n          live = cloudState.liveNodesContain(nodeName);\n          if (nodeProps != null && state.equals(ZkStateReader.RECOVERING)\n              && live) {\n            break;\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to prep for recovery for \" + nodeName\n                  + \" but she is not live or not in a recovery state - state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      \n      Thread.sleep(4000);\n      \n      UpdateRequestProcessorChain processorChain = core\n          .getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n      \n      ModifiableSolrParams reqParams = new ModifiableSolrParams(req.getParams());\n      reqParams.set(DistributedUpdateProcessor.COMMIT_END_POINT, \"true\");\n      \n      SolrQueryRequest sqr = new LocalSolrQueryRequest(core, reqParams);\n      UpdateRequestProcessor processor = processorChain.createProcessor(sqr,\n          new SolrQueryResponse());\n      CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n      \n      processor.processCommit(cuc);\n      processor.finish();\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b834dd353486678973f4157b3ba402ac3a7ca88","date":1329782329,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state = null;\n      boolean live = false;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        String collection = cloudDescriptor.getCollectionName();\n        ZkNodeProps nodeProps = \n            cloudState.getSlice(collection,\n                cloudDescriptor.getShardId()).getShards().get(coreNodeName);\n        \n        if (nodeProps != null) {\n          state = nodeProps.get(ZkStateReader.STATE_PROP);\n          live = cloudState.liveNodesContain(nodeName);\n          if (nodeProps != null && state.equals(waitForState)) {\n            if (checkLive == null) {\n              break;\n            } else if (checkLive && live) {\n              break;\n            } else if (!checkLive && !live) {\n              break;\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \" + nodeName\n                  + \" but I still do not see the request state. I see state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      //System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor + \" live:\" + live);\n      Thread.sleep(pauseFor);\n      \n      // solrcloud_debug\n//      try {;\n//        LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,  new ModifiableSolrParams());\n//        CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n//        commitCmd.softCommit = true;\n//        core.getUpdateHandler().commit(commitCmd);\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    boolean checkLive = params.getBool(\"checkLive\", true);\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state = null;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        String collection = cloudDescriptor.getCollectionName();\n        ZkNodeProps nodeProps = \n            cloudState.getSlice(collection,\n                cloudDescriptor.getShardId()).getShards().get(coreNodeName);\n        boolean live = false;\n        if (nodeProps != null) {\n          \n          state = nodeProps.get(ZkStateReader.STATE_PROP);\n          live = cloudState.liveNodesContain(nodeName);\n          if (nodeProps != null && state.equals(waitForState)) {\n            if (checkLive && live) {\n              break;\n            } else {\n              break;\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \" + nodeName\n                  + \" but I still do not see the request state. I see state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      \n      Thread.sleep(pauseFor);\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"155c73ac282cdd86de7eb9b1e3de985300d2cc58","date":1329921053,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state = null;\n      boolean live = false;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        String collection = cloudDescriptor.getCollectionName();\n        Slice slice = cloudState.getSlice(collection,\n            cloudDescriptor.getShardId());\n        if (slice != null) {\n          ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n          if (nodeProps != null) {\n            state = nodeProps.get(ZkStateReader.STATE_PROP);\n            live = cloudState.liveNodesContain(nodeName);\n            if (nodeProps != null && state.equals(waitForState)) {\n              if (checkLive == null) {\n                break;\n              } else if (checkLive && live) {\n                break;\n              } else if (!checkLive && !live) {\n                break;\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \" + nodeName\n                  + \" but I still do not see the request state. I see state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      //System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor + \" live:\" + live);\n      Thread.sleep(pauseFor);\n      \n      // solrcloud_debug\n//      try {;\n//        LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,  new ModifiableSolrParams());\n//        CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n//        commitCmd.softCommit = true;\n//        core.getUpdateHandler().commit(commitCmd);\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state = null;\n      boolean live = false;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        String collection = cloudDescriptor.getCollectionName();\n        ZkNodeProps nodeProps = \n            cloudState.getSlice(collection,\n                cloudDescriptor.getShardId()).getShards().get(coreNodeName);\n        \n        if (nodeProps != null) {\n          state = nodeProps.get(ZkStateReader.STATE_PROP);\n          live = cloudState.liveNodesContain(nodeName);\n          if (nodeProps != null && state.equals(waitForState)) {\n            if (checkLive == null) {\n              break;\n            } else if (checkLive && live) {\n              break;\n            } else if (!checkLive && !live) {\n              break;\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \" + nodeName\n                  + \" but I still do not see the request state. I see state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      //System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor + \" live:\" + live);\n      Thread.sleep(pauseFor);\n      \n      // solrcloud_debug\n//      try {;\n//        LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,  new ModifiableSolrParams());\n//        CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n//        commitCmd.softCommit = true;\n//        core.getUpdateHandler().commit(commitCmd);\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"221ff19d62d5ff429ffecf8e7f3e01ff93754854","date":1329974551,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          CloudState cloudState = coreContainer.getZkController()\n              .getCloudState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = cloudState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.get(ZkStateReader.STATE_PROP);\n              live = cloudState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state = null;\n      boolean live = false;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        String collection = cloudDescriptor.getCollectionName();\n        Slice slice = cloudState.getSlice(collection,\n            cloudDescriptor.getShardId());\n        if (slice != null) {\n          ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n          if (nodeProps != null) {\n            state = nodeProps.get(ZkStateReader.STATE_PROP);\n            live = cloudState.liveNodesContain(nodeName);\n            if (nodeProps != null && state.equals(waitForState)) {\n              if (checkLive == null) {\n                break;\n              } else if (checkLive && live) {\n                break;\n              } else if (!checkLive && !live) {\n                break;\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \" + nodeName\n                  + \" but I still do not see the request state. I see state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      //System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor + \" live:\" + live);\n      Thread.sleep(pauseFor);\n      \n      // solrcloud_debug\n//      try {;\n//        LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,  new ModifiableSolrParams());\n//        CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n//        commitCmd.softCommit = true;\n//        core.getUpdateHandler().commit(commitCmd);\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          CloudState cloudState = coreContainer.getZkController()\n              .getCloudState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = cloudState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.get(ZkStateReader.STATE_PROP);\n              live = cloudState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    boolean checkLive = params.getBool(\"checkLive\", true);\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    SolrCore core =  null;\n\n    try {\n      core = coreContainer.getCore(cname);\n      if (core == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\" + cname);\n      }\n      String state = null;\n      int retry = 0;\n      while (true) {\n        // wait until we are sure the recovering node is ready\n        // to accept updates\n        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        CloudState cloudState = coreContainer\n            .getZkController()\n            .getCloudState();\n        String collection = cloudDescriptor.getCollectionName();\n        ZkNodeProps nodeProps = \n            cloudState.getSlice(collection,\n                cloudDescriptor.getShardId()).getShards().get(coreNodeName);\n        boolean live = false;\n        if (nodeProps != null) {\n          \n          state = nodeProps.get(ZkStateReader.STATE_PROP);\n          live = cloudState.liveNodesContain(nodeName);\n          if (nodeProps != null && state.equals(waitForState)) {\n            if (checkLive && live) {\n              break;\n            } else {\n              break;\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \" + nodeName\n                  + \" but I still do not see the request state. I see state: \" + state + \" live:\" + live);\n        }\n        \n        Thread.sleep(1000);\n      }\n      \n      // small safety net for any updates that started with state that\n      // kept it from sending the update to be buffered -\n      // pause for a while to let any outstanding updates finish\n      \n      Thread.sleep(pauseFor);\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" to replicate \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n      \n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.get(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          CloudState cloudState = coreContainer.getZkController()\n              .getCloudState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = cloudState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.get(ZkStateReader.STATE_PROP);\n              live = cloudState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.get(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          CloudState cloudState = coreContainer.getZkController()\n              .getCloudState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = cloudState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.get(ZkStateReader.STATE_PROP);\n              live = cloudState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.get(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          CloudState cloudState = coreContainer.getZkController()\n              .getCloudState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = cloudState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.get(ZkStateReader.STATE_PROP);\n              live = cloudState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6013b4c7388f1627659c8f96c44abd10a294d3a6","date":1346343796,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.get(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.get(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.get(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.get(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getShards().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.get(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    int pauseFor = params.getInt(\"pauseFor\", 0);\n    \n\n    \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n    \n    // small safety net for any updates that started with state that\n    // kept it from sending the update to be buffered -\n    // pause for a while to let any outstanding updates finish\n    // System.out.println(\"I saw state:\" + state + \" sleep for \" + pauseFor +\n    // \" live:\" + live);\n    Thread.sleep(pauseFor);\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","bugFix":["221ff19d62d5ff429ffecf8e7f3e01ff93754854","6013b4c7388f1627659c8f96c44abd10a294d3a6","3a80994db3380cd78c6f65b84515e2e931b6b3da"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"69e53cadb9d97be9e2d95466668a3843b45def8f","date":1355608873,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        // solrcloud_debug\n//        try {;\n//        LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n//        ModifiableSolrParams());\n//        CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n//        commitCmd.softCommit = true;\n//        core.getUpdateHandler().commit(commitCmd);\n//        RefCounted<SolrIndexSearcher> searchHolder =\n//        core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//        System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n//        + \" to replicate \"\n//        + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n//        core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n//        core.getDataDir());\n//        } finally {\n//        searchHolder.decref();\n//        }\n//        } catch (Exception e) {\n//       \n//        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    \n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75f1ae6eadb5cef6015f15efa08542c8fd90ea14","date":1355940756,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        // solrcloud_debug\n//        try {;\n//        LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n//        ModifiableSolrParams());\n//        CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n//        commitCmd.softCommit = true;\n//        core.getUpdateHandler().commit(commitCmd);\n//        RefCounted<SolrIndexSearcher> searchHolder =\n//        core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//        System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n//        + \" to replicate \"\n//        + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n//        core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n//        core.getDataDir());\n//        } finally {\n//        searchHolder.decref();\n//        }\n//        } catch (Exception e) {\n//       \n//        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    \n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        // solrcloud_debug\n//        try {;\n//        LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n//        ModifiableSolrParams());\n//        CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n//        commitCmd.softCommit = true;\n//        core.getUpdateHandler().commit(commitCmd);\n//        RefCounted<SolrIndexSearcher> searchHolder =\n//        core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//        System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n//        + \" to replicate \"\n//        + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n//        core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n//        core.getDataDir());\n//        } finally {\n//        searchHolder.decref();\n//        }\n//        } catch (Exception e) {\n//       \n//        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1a51611037ce7ff8473283986687f60d3491277","date":1356816551,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n//        try {;\n//        LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n//        ModifiableSolrParams());\n//        CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n//        commitCmd.softCommit = true;\n//        core.getUpdateHandler().commit(commitCmd);\n//        RefCounted<SolrIndexSearcher> searchHolder =\n//        core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//        System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n//        + \" to replicate \"\n//        + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n//        core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n//        core.getDataDir());\n//        } finally {\n//        searchHolder.decref();\n//        }\n//        } catch (Exception e) {\n//       \n//        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    \n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        // solrcloud_debug\n//        try {;\n//        LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n//        ModifiableSolrParams());\n//        CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n//        commitCmd.softCommit = true;\n//        core.getUpdateHandler().commit(commitCmd);\n//        RefCounted<SolrIndexSearcher> searchHolder =\n//        core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//        System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n//        + \" to replicate \"\n//        + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n//        core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n//        core.getDataDir());\n//        } finally {\n//        searchHolder.decref();\n//        }\n//        } catch (Exception e) {\n//       \n//        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n//        try {;\n//        LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n//        ModifiableSolrParams());\n//        CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n//        commitCmd.softCommit = true;\n//        core.getUpdateHandler().commit(commitCmd);\n//        RefCounted<SolrIndexSearcher> searchHolder =\n//        core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//        System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n//        + \" to replicate \"\n//        + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n//        core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n//        core.getDataDir());\n//        } finally {\n//        searchHolder.decref();\n//        }\n//        } catch (Exception e) {\n//       \n//        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    \n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the request state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    \n    // solrcloud_debug\n    // try {;\n    // LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n    // ModifiableSolrParams());\n    // CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n    // commitCmd.softCommit = true;\n    // core.getUpdateHandler().commit(commitCmd);\n    // RefCounted<SolrIndexSearcher> searchHolder =\n    // core.getNewestSearcher(false);\n    // SolrIndexSearcher searcher = searchHolder.get();\n    // try {\n    // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n    // + \" to replicate \"\n    // + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n    // core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n    // core.getDataDir());\n    // } finally {\n    // searchHolder.decref();\n    // }\n    // } catch (Exception e) {\n    //\n    // }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0beaed456aa3358e5e4a99ea2aea994ef6c81de3","date":1365434191,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n//        try {;\n//        LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n//        ModifiableSolrParams());\n//        CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n//        commitCmd.softCommit = true;\n//        core.getUpdateHandler().commit(commitCmd);\n//        RefCounted<SolrIndexSearcher> searchHolder =\n//        core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//        System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n//        + \" to replicate \"\n//        + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n//        core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n//        core.getDataDir());\n//        } finally {\n//        searchHolder.decref();\n//        }\n//        } catch (Exception e) {\n//       \n//        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n//        try {;\n//        LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n//        ModifiableSolrParams());\n//        CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n//        commitCmd.softCommit = true;\n//        core.getUpdateHandler().commit(commitCmd);\n//        RefCounted<SolrIndexSearcher> searchHolder =\n//        core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//        System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n//        + \" to replicate \"\n//        + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n//        core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n//        core.getDataDir());\n//        } finally {\n//        searchHolder.decref();\n//        }\n//        } catch (Exception e) {\n//       \n//        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c52ad29218ee436d52c57bf0829b98acad9de379","date":1383401544,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (Boolean.getBoolean(\"solr.cloud.debug\")) {\n          try {\n            ;\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              System.out.println(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n//        try {;\n//        LocalSolrQueryRequest r = new LocalSolrQueryRequest(core, new\n//        ModifiableSolrParams());\n//        CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n//        commitCmd.softCommit = true;\n//        core.getUpdateHandler().commit(commitCmd);\n//        RefCounted<SolrIndexSearcher> searchHolder =\n//        core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//        System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n//        + \" to replicate \"\n//        + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" gen:\" +\n//        core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" +\n//        core.getDataDir());\n//        } finally {\n//        searchHolder.decref();\n//        }\n//        } catch (Exception e) {\n//       \n//        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b17e61942d57c9c1c6dc8a926bce1c5c47882f8","date":1383401729,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (Boolean.getBoolean(\"solr.cloud.debug\")) {\n          try {\n            ;\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              System.err.println(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (Boolean.getBoolean(\"solr.cloud.debug\")) {\n          try {\n            ;\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              System.out.println(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89b56ee224dbe29ee4436d91a7070ca418ffc4fb","date":1383492966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            ;\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (Boolean.getBoolean(\"solr.cloud.debug\")) {\n          try {\n            ;\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              System.err.println(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"97bd2b0da4beced82821b752b29576be986cf1ff","date":1387747012,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n              if (onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE))) {\n                continue;\n              }\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            ;\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            ;\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b8e7d3f20d8577baadbc7ccdcf5dfac50c5806ea","date":1387777528,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            ;\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n              if (onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE))) {\n                continue;\n              }\n              if (nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            ;\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1146972d3c83a850288b4226fca1f26a6ffdadd2","date":1395414860,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 0);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry == 15 || retry == 60) {\n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        if (retry++ == 120) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live);\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            ;\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e332392bbbdd01cb69ad6a89051f483cda38e15e","date":1395758779,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 0);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      SolrCore core = null;\n      try {\n        core = coreContainer.getCore(cname);\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 0);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14d5815ecbef89580f5c48990bcd433f04f8563a","date":1399564106,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(nodeProps.getStr(\"core\")) &&\n                  ZkStateReader.RECOVERING.equals(waitForState) && \n                  ZkStateReader.ACTIVE.equals(localState) && \n                  ZkStateReader.ACTIVE.equals(state));\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", currentState=\"+state+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+nodeProps);\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && (state.equals(waitForState) || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && state.equals(waitForState)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 0);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aea1d78da2c058b98e64569bcd37981c733b52a8","date":1400551646,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(nodeProps.getStr(\"core\")) &&\n                  ZkStateReader.RECOVERING.equals(waitForState) && \n                  ZkStateReader.ACTIVE.equals(localState) && \n                  ZkStateReader.ACTIVE.equals(state));\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", thisCore=\"+core.getName()+\", leaderDoesNotNeedRecovery=\"+leaderDoesNotNeedRecovery+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", checkLive=\"+checkLive+\", currentState=\"+state+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+nodeProps);\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && (state.equals(waitForState) || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(nodeProps.getStr(\"core\")) &&\n                  ZkStateReader.RECOVERING.equals(waitForState) && \n                  ZkStateReader.ACTIVE.equals(localState) && \n                  ZkStateReader.ACTIVE.equals(state));\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", currentState=\"+state+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+nodeProps);\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && (state.equals(waitForState) || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(nodeProps.getStr(\"core\")) &&\n                  ZkStateReader.RECOVERING.equals(waitForState) && \n                  ZkStateReader.ACTIVE.equals(localState) && \n                  ZkStateReader.ACTIVE.equals(state));\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", thisCore=\"+core.getName()+\", leaderDoesNotNeedRecovery=\"+leaderDoesNotNeedRecovery+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", checkLive=\"+checkLive+\", currentState=\"+state+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+nodeProps);\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && (state.equals(waitForState) || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(nodeProps.getStr(\"core\")) &&\n                  ZkStateReader.RECOVERING.equals(waitForState) && \n                  ZkStateReader.ACTIVE.equals(localState) && \n                  ZkStateReader.ACTIVE.equals(state));\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", currentState=\"+state+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+nodeProps);\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && (state.equals(waitForState) || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c94d2661bc1c14426980ec7882e951fdcff08d0","date":1427167177,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(nodeProps.getStr(\"core\")) &&\n                  ZkStateReader.RECOVERING.equals(waitForState) && \n                  ZkStateReader.ACTIVE.equals(localState) && \n                  ZkStateReader.ACTIVE.equals(state));\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", thisCore=\"+core.getName()+\", leaderDoesNotNeedRecovery=\"+leaderDoesNotNeedRecovery+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", checkLive=\"+checkLive+\", currentState=\"+state+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+nodeProps);\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && (state.equals(waitForState) || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(nodeProps.getStr(\"core\")) &&\n                  ZkStateReader.RECOVERING.equals(waitForState) && \n                  ZkStateReader.ACTIVE.equals(localState) && \n                  ZkStateReader.ACTIVE.equals(state));\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", thisCore=\"+core.getName()+\", leaderDoesNotNeedRecovery=\"+leaderDoesNotNeedRecovery+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", checkLive=\"+checkLive+\", currentState=\"+state+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+nodeProps);\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && (state.equals(waitForState) || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":["c52ad29218ee436d52c57bf0829b98acad9de379"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(nodeProps.getStr(\"core\")) &&\n                  ZkStateReader.RECOVERING.equals(waitForState) && \n                  ZkStateReader.ACTIVE.equals(localState) && \n                  ZkStateReader.ACTIVE.equals(state));\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", thisCore=\"+core.getName()+\", leaderDoesNotNeedRecovery=\"+leaderDoesNotNeedRecovery+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", checkLive=\"+checkLive+\", currentState=\"+state+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+nodeProps);\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && (state.equals(waitForState) || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(nodeProps.getStr(\"core\")) &&\n                  ZkStateReader.RECOVERING.equals(waitForState) && \n                  ZkStateReader.ACTIVE.equals(localState) && \n                  ZkStateReader.ACTIVE.equals(state));\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", thisCore=\"+core.getName()+\", leaderDoesNotNeedRecovery=\"+leaderDoesNotNeedRecovery+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", checkLive=\"+checkLive+\", currentState=\"+state+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+nodeProps);\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && (state.equals(waitForState) || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n              \n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING && \n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", thisCore=\"+core.getName()+\", leaderDoesNotNeedRecovery=\"+leaderDoesNotNeedRecovery+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", checkLive=\"+checkLive+\", currentState=\"+state.toString()+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    String waitForState = params.get(\"state\");\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    String state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController()\n              .getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection,\n              cloudDescriptor.getShardId());\n          if (slice != null) {\n            ZkNodeProps nodeProps = slice.getReplicasMap().get(coreNodeName);\n            if (nodeProps != null) {\n              state = nodeProps.getStr(ZkStateReader.STATE_PROP);\n              live = clusterState.liveNodesContain(nodeName);\n              \n              String localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(nodeProps.getStr(\"core\")) &&\n                  ZkStateReader.RECOVERING.equals(waitForState) && \n                  ZkStateReader.ACTIVE.equals(localState) && \n                  ZkStateReader.ACTIVE.equals(state));\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", thisCore=\"+core.getName()+\", leaderDoesNotNeedRecovery=\"+leaderDoesNotNeedRecovery+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", checkLive=\"+checkLive+\", currentState=\"+state+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+nodeProps);\n\n              if (!onlyIfActiveCheckResult && nodeProps != null && (state.equals(waitForState) || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState();\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n              \n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING && \n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", thisCore=\"+core.getName()+\", leaderDoesNotNeedRecovery=\"+leaderDoesNotNeedRecovery+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", checkLive=\"+checkLive+\", currentState=\"+state.toString()+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n              \n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING && \n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", thisCore=\"+core.getName()+\", leaderDoesNotNeedRecovery=\"+leaderDoesNotNeedRecovery+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", checkLive=\"+checkLive+\", currentState=\"+state.toString()+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa0876236f0bd8be403747120d248bdd42b75a96","date":1451844229,"type":4,"author":"Noble Paul","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleWaitForStateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":null,"sourceOld":"  protected void handleWaitForStateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws IOException, InterruptedException, KeeperException {\n    final SolrParams params = req.getParams();\n    \n    String cname = params.get(CoreAdminParams.CORE);\n    if (cname == null) {\n      cname = \"\";\n    }\n    \n    String nodeName = params.get(\"nodeName\");\n    String coreNodeName = params.get(\"coreNodeName\");\n    Replica.State waitForState = Replica.State.getState(params.get(ZkStateReader.STATE_PROP));\n    Boolean checkLive = params.getBool(\"checkLive\");\n    Boolean onlyIfLeader = params.getBool(\"onlyIfLeader\");\n    Boolean onlyIfLeaderActive = params.getBool(\"onlyIfLeaderActive\");\n\n    log.info(\"Going to wait for coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader\n        + \", onlyIfLeaderActive: \"+onlyIfLeaderActive);\n\n    int maxTries = 0; \n    Replica.State state = null;\n    boolean live = false;\n    int retry = 0;\n    while (true) {\n      try (SolrCore core = coreContainer.getCore(cname)) {\n        if (core == null && retry == 30) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"core not found:\"\n              + cname);\n        }\n        if (core != null) {\n          if (onlyIfLeader != null && onlyIfLeader) {\n           if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {\n             throw new SolrException(ErrorCode.BAD_REQUEST, \"We are not the leader\");\n           }\n          }\n          \n          // wait until we are sure the recovering node is ready\n          // to accept updates\n          CloudDescriptor cloudDescriptor = core.getCoreDescriptor()\n              .getCloudDescriptor();\n          \n          if (retry % 15 == 0) {\n            if (retry > 0 && log.isInfoEnabled())\n              log.info(\"After \" + retry + \" seconds, core \" + cname + \" (\" +\n                  cloudDescriptor.getShardId() + \" of \" +\n                  cloudDescriptor.getCollectionName() + \") still does not have state: \" +\n                  waitForState + \"; forcing ClusterState update from ZooKeeper\");\n            \n            // force a cluster state update\n            coreContainer.getZkController().getZkStateReader().updateClusterState();\n          }\n\n          if (maxTries == 0) {\n            // wait long enough for the leader conflict to work itself out plus a little extra\n            int conflictWaitMs = coreContainer.getZkController().getLeaderConflictResolveWait();\n            maxTries = (int) Math.round(conflictWaitMs / 1000) + 3;\n            log.info(\"Will wait a max of \" + maxTries + \" seconds to see \" + cname + \" (\" +\n                cloudDescriptor.getShardId() + \" of \" +\n                cloudDescriptor.getCollectionName() + \") have state: \" + waitForState);\n          }\n          \n          ClusterState clusterState = coreContainer.getZkController().getClusterState();\n          String collection = cloudDescriptor.getCollectionName();\n          Slice slice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n          if (slice != null) {\n            final Replica replica = slice.getReplicasMap().get(coreNodeName);\n            if (replica != null) {\n              state = replica.getState();\n              live = clusterState.liveNodesContain(nodeName);\n              \n              final Replica.State localState = cloudDescriptor.getLastPublished();\n\n              // TODO: This is funky but I've seen this in testing where the replica asks the\n              // leader to be in recovery? Need to track down how that happens ... in the meantime,\n              // this is a safeguard \n              boolean leaderDoesNotNeedRecovery = (onlyIfLeader != null && \n                  onlyIfLeader && \n                  core.getName().equals(replica.getStr(\"core\")) &&\n                  waitForState == Replica.State.RECOVERING && \n                  localState == Replica.State.ACTIVE &&\n                  state == Replica.State.ACTIVE);\n              \n              if (leaderDoesNotNeedRecovery) {\n                log.warn(\"Leader \"+core.getName()+\" ignoring request to be in the recovering state because it is live and active.\");\n              }              \n              \n              boolean onlyIfActiveCheckResult = onlyIfLeaderActive != null && onlyIfLeaderActive && localState != Replica.State.ACTIVE;\n              log.info(\"In WaitForState(\"+waitForState+\"): collection=\"+collection+\", shard=\"+slice.getName()+\n                  \", thisCore=\"+core.getName()+\", leaderDoesNotNeedRecovery=\"+leaderDoesNotNeedRecovery+\n                  \", isLeader? \"+core.getCoreDescriptor().getCloudDescriptor().isLeader()+\n                  \", live=\"+live+\", checkLive=\"+checkLive+\", currentState=\"+state.toString()+\", localState=\"+localState+\", nodeName=\"+nodeName+\n                  \", coreNodeName=\"+coreNodeName+\", onlyIfActiveCheckResult=\"+onlyIfActiveCheckResult+\", nodeProps: \"+replica);\n\n              if (!onlyIfActiveCheckResult && replica != null && (state == waitForState || leaderDoesNotNeedRecovery)) {\n                if (checkLive == null) {\n                  break;\n                } else if (checkLive && live) {\n                  break;\n                } else if (!checkLive && !live) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        if (retry++ == maxTries) {\n          String collection = null;\n          String leaderInfo = null;\n          String shardId = null;\n          try {\n            CloudDescriptor cloudDescriptor =\n                core.getCoreDescriptor().getCloudDescriptor();\n            collection = cloudDescriptor.getCollectionName();\n            shardId = cloudDescriptor.getShardId();\n            leaderInfo = coreContainer.getZkController().\n                getZkStateReader().getLeaderUrl(collection, shardId, 5000);\n          } catch (Exception exc) {\n            leaderInfo = \"Not available due to: \" + exc;\n          }\n\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"I was asked to wait on state \" + waitForState + \" for \"\n                  + shardId + \" in \" + collection + \" on \" + nodeName\n                  + \" but I still do not see the requested state. I see state: \"\n                  + state.toString() + \" live:\" + live + \" leader from ZK: \" + leaderInfo\n          );\n        }\n        \n        if (coreContainer.isShutDown()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Solr is shutting down\");\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            LocalSolrQueryRequest r = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand commitCmd = new CommitUpdateCommand(r, false);\n            commitCmd.softCommit = true;\n            core.getUpdateHandler().commit(commitCmd);\n            RefCounted<SolrIndexSearcher> searchHolder = core\n                .getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer()\n                  .getZkController().getNodeName()\n                  + \" to replicate \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n                  + \" gen:\"\n                  + core.getDeletionPolicy().getLatestCommit().getGeneration()\n                  + \" data:\" + core.getDataDir());\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.debug(\"Error in solrcloud_debug block\", e);\n          }\n        }\n      }\n      Thread.sleep(1000);\n    }\n\n    log.info(\"Waited coreNodeName: \" + coreNodeName + \", state: \" + waitForState\n        + \", checkLive: \" + checkLive + \", onlyIfLeader: \" + onlyIfLeader + \" for: \" + retry + \" seconds.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a6378064655e76cd7b908b1cab4ce425b384b508","a1a51611037ce7ff8473283986687f60d3491277"],"1b17e61942d57c9c1c6dc8a926bce1c5c47882f8":["c52ad29218ee436d52c57bf0829b98acad9de379"],"97bd2b0da4beced82821b752b29576be986cf1ff":["89b56ee224dbe29ee4436d91a7070ca418ffc4fb"],"89b56ee224dbe29ee4436d91a7070ca418ffc4fb":["1b17e61942d57c9c1c6dc8a926bce1c5c47882f8"],"221ff19d62d5ff429ffecf8e7f3e01ff93754854":["155c73ac282cdd86de7eb9b1e3de985300d2cc58"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a80994db3380cd78c6f65b84515e2e931b6b3da","221ff19d62d5ff429ffecf8e7f3e01ff93754854"],"6b834dd353486678973f4157b3ba402ac3a7ca88":["3a80994db3380cd78c6f65b84515e2e931b6b3da"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["aea1d78da2c058b98e64569bcd37981c733b52a8"],"69e53cadb9d97be9e2d95466668a3843b45def8f":["a6378064655e76cd7b908b1cab4ce425b384b508"],"b7605579001505896d48b07160075a5c8b8e128e":["14d5815ecbef89580f5c48990bcd433f04f8563a","aea1d78da2c058b98e64569bcd37981c733b52a8"],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["aea1d78da2c058b98e64569bcd37981c733b52a8","6c94d2661bc1c14426980ec7882e951fdcff08d0"],"75f1ae6eadb5cef6015f15efa08542c8fd90ea14":["69e53cadb9d97be9e2d95466668a3843b45def8f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e332392bbbdd01cb69ad6a89051f483cda38e15e":["1146972d3c83a850288b4226fca1f26a6ffdadd2"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["e332392bbbdd01cb69ad6a89051f483cda38e15e"],"a1a51611037ce7ff8473283986687f60d3491277":["75f1ae6eadb5cef6015f15efa08542c8fd90ea14"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"1146972d3c83a850288b4226fca1f26a6ffdadd2":["b8e7d3f20d8577baadbc7ccdcf5dfac50c5806ea"],"fa64435b5902ce266c23755a4a00691a3285dab8":["6013b4c7388f1627659c8f96c44abd10a294d3a6"],"fa0876236f0bd8be403747120d248bdd42b75a96":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["221ff19d62d5ff429ffecf8e7f3e01ff93754854","3f767f8c99eaedb984df754fe61f21c5de260f94"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["a1a51611037ce7ff8473283986687f60d3491277"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["d6f074e73200c07d54f242d3880a8da5a35ff97b","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["221ff19d62d5ff429ffecf8e7f3e01ff93754854"],"155c73ac282cdd86de7eb9b1e3de985300d2cc58":["6b834dd353486678973f4157b3ba402ac3a7ca88"],"a6378064655e76cd7b908b1cab4ce425b384b508":["fa64435b5902ce266c23755a4a00691a3285dab8"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["221ff19d62d5ff429ffecf8e7f3e01ff93754854","3f767f8c99eaedb984df754fe61f21c5de260f94"],"c52ad29218ee436d52c57bf0829b98acad9de379":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"aea1d78da2c058b98e64569bcd37981c733b52a8":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fa0876236f0bd8be403747120d248bdd42b75a96"],"b8e7d3f20d8577baadbc7ccdcf5dfac50c5806ea":["97bd2b0da4beced82821b752b29576be986cf1ff"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"1b17e61942d57c9c1c6dc8a926bce1c5c47882f8":["89b56ee224dbe29ee4436d91a7070ca418ffc4fb"],"97bd2b0da4beced82821b752b29576be986cf1ff":["b8e7d3f20d8577baadbc7ccdcf5dfac50c5806ea"],"89b56ee224dbe29ee4436d91a7070ca418ffc4fb":["97bd2b0da4beced82821b752b29576be986cf1ff"],"221ff19d62d5ff429ffecf8e7f3e01ff93754854":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","8fd5be977c105554c6a7b68afcdbc511439723ab","3f767f8c99eaedb984df754fe61f21c5de260f94","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"6b834dd353486678973f4157b3ba402ac3a7ca88":["155c73ac282cdd86de7eb9b1e3de985300d2cc58"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["a219f1dcad1700e84807666bdbd2b573e8de7021","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"69e53cadb9d97be9e2d95466668a3843b45def8f":["75f1ae6eadb5cef6015f15efa08542c8fd90ea14"],"b7605579001505896d48b07160075a5c8b8e128e":[],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["fa64435b5902ce266c23755a4a00691a3285dab8","05a14b2611ead08655a2b2bdc61632eb31316e57"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"75f1ae6eadb5cef6015f15efa08542c8fd90ea14":["a1a51611037ce7ff8473283986687f60d3491277"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a80994db3380cd78c6f65b84515e2e931b6b3da"],"e332392bbbdd01cb69ad6a89051f483cda38e15e":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["b7605579001505896d48b07160075a5c8b8e128e","aea1d78da2c058b98e64569bcd37981c733b52a8"],"a1a51611037ce7ff8473283986687f60d3491277":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"1146972d3c83a850288b4226fca1f26a6ffdadd2":["e332392bbbdd01cb69ad6a89051f483cda38e15e"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["fa0876236f0bd8be403747120d248bdd42b75a96"],"fa64435b5902ce266c23755a4a00691a3285dab8":["a6378064655e76cd7b908b1cab4ce425b384b508"],"fa0876236f0bd8be403747120d248bdd42b75a96":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["c52ad29218ee436d52c57bf0829b98acad9de379"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"155c73ac282cdd86de7eb9b1e3de985300d2cc58":["221ff19d62d5ff429ffecf8e7f3e01ff93754854"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["6013b4c7388f1627659c8f96c44abd10a294d3a6","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"a6378064655e76cd7b908b1cab4ce425b384b508":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","69e53cadb9d97be9e2d95466668a3843b45def8f"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"c52ad29218ee436d52c57bf0829b98acad9de379":["1b17e61942d57c9c1c6dc8a926bce1c5c47882f8"],"aea1d78da2c058b98e64569bcd37981c733b52a8":["6c94d2661bc1c14426980ec7882e951fdcff08d0","b7605579001505896d48b07160075a5c8b8e128e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","6b834dd353486678973f4157b3ba402ac3a7ca88"],"b8e7d3f20d8577baadbc7ccdcf5dfac50c5806ea":["1146972d3c83a850288b4226fca1f26a6ffdadd2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","b7605579001505896d48b07160075a5c8b8e128e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","8fd5be977c105554c6a7b68afcdbc511439723ab","05a14b2611ead08655a2b2bdc61632eb31316e57","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}