{"path":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","pathOld":"/dev/null","sourceNew":"  public void testMapHashes() throws Exception {\n    HashPartitioner hp = new HashPartitioner();\n    \n    for (int i = 1; i <= 30000; i++) {\n      List<Range> ranges = hp.partitionRange(i);\n      \n      assertEquals(i, ranges.size());\n      \n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","pathOld":"/dev/null","sourceNew":"  public void testMapHashes() throws Exception {\n    HashPartitioner hp = new HashPartitioner();\n    \n    for (int i = 1; i <= 30000; i++) {\n      List<Range> ranges = hp.partitionRange(i);\n      \n      assertEquals(i, ranges.size());\n      \n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","pathOld":"/dev/null","sourceNew":"  public void testMapHashes() throws Exception {\n    HashPartitioner hp = new HashPartitioner();\n    \n    for (int i = 1; i <= 30000; i++) {\n      List<Range> ranges = hp.partitionRange(i);\n      \n      assertEquals(i, ranges.size());\n      \n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e147cce225492338f15a94a427f51f867da574ee","date":1346365916,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","sourceNew":"  public void testMapHashes() throws Exception {\n    HashPartitioner hp = new HashPartitioner();\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, 0, 0x7fffffff);\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    for (int i = 1; i <= 30000; i += 13) {\n      ranges = hp.partitionRange(i, Integer.MIN_VALUE, Integer.MAX_VALUE);\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  public void testMapHashes() throws Exception {\n    HashPartitioner hp = new HashPartitioner();\n    \n    for (int i = 1; i <= 30000; i++) {\n      List<Range> ranges = hp.partitionRange(i);\n      \n      assertEquals(i, ranges.size());\n      \n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","sourceNew":"  public void testMapHashes() throws Exception {\n    HashPartitioner hp = new HashPartitioner();\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, 0, 0x7fffffff);\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    for (int i = 1; i <= 30000; i += 13) {\n      ranges = hp.partitionRange(i, Integer.MIN_VALUE, Integer.MAX_VALUE);\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  public void testMapHashes() throws Exception {\n    HashPartitioner hp = new HashPartitioner();\n    \n    for (int i = 1; i <= 30000; i++) {\n      List<Range> ranges = hp.partitionRange(i);\n      \n      assertEquals(i, ranges.size());\n      \n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","sourceNew":"  public void testMapHashes() throws Exception {\n    HashPartitioner hp = new HashPartitioner();\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, hp.fullRange());\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, 0, 0x7fffffff);\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    for (int i = 1; i <= 30000; i += 13) {\n      ranges = hp.partitionRange(i, hp.fullRange());\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n\n      for (Range range : ranges) {\n        String s = range.toString();\n        Range newRange = hp.fromString(s);\n        assertEquals(range, newRange);\n      }\n\n\n    }\n  }\n\n","sourceOld":"  public void testMapHashes() throws Exception {\n    HashPartitioner hp = new HashPartitioner();\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, 0, 0x7fffffff);\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    for (int i = 1; i <= 30000; i += 13) {\n      ranges = hp.partitionRange(i, Integer.MIN_VALUE, Integer.MAX_VALUE);\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","sourceNew":"  public void testMapHashes() throws Exception {\n    DocRouter hp = new DocRouter();\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, hp.fullRange());\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, 0, 0x7fffffff);\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    for (int i = 1; i <= 30000; i += 13) {\n      ranges = hp.partitionRange(i, hp.fullRange());\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n\n      for (Range range : ranges) {\n        String s = range.toString();\n        Range newRange = hp.fromString(s);\n        assertEquals(range, newRange);\n      }\n\n\n    }\n  }\n\n","sourceOld":"  public void testMapHashes() throws Exception {\n    HashPartitioner hp = new HashPartitioner();\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, hp.fullRange());\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, 0, 0x7fffffff);\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    for (int i = 1; i <= 30000; i += 13) {\n      ranges = hp.partitionRange(i, hp.fullRange());\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n\n      for (Range range : ranges) {\n        String s = range.toString();\n        Range newRange = hp.fromString(s);\n        assertEquals(range, newRange);\n      }\n\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89f828d954597b98a28942874636f35c719b8a5d","date":1354471211,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","sourceNew":"  public void testMapHashes() throws Exception {\n    DocRouter hp = DocRouter.DEFAULT;\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, hp.fullRange());\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, 0, 0x7fffffff);\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    for (int i = 1; i <= 30000; i += 13) {\n      ranges = hp.partitionRange(i, hp.fullRange());\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n\n      for (Range range : ranges) {\n        String s = range.toString();\n        Range newRange = hp.fromString(s);\n        assertEquals(range, newRange);\n      }\n\n\n    }\n  }\n\n","sourceOld":"  public void testMapHashes() throws Exception {\n    DocRouter hp = new DocRouter();\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, hp.fullRange());\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, 0, 0x7fffffff);\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    for (int i = 1; i <= 30000; i += 13) {\n      ranges = hp.partitionRange(i, hp.fullRange());\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n\n      for (Range range : ranges) {\n        String s = range.toString();\n        Range newRange = hp.fromString(s);\n        assertEquals(range, newRange);\n      }\n\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","sourceNew":"  public void testMapHashes() throws Exception {\n    DocRouter hp = DocRouter.DEFAULT;\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, hp.fullRange());\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, 0, 0x7fffffff);\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    for (int i = 1; i <= 30000; i += 13) {\n      ranges = hp.partitionRange(i, hp.fullRange());\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n\n      for (Range range : ranges) {\n        String s = range.toString();\n        Range newRange = hp.fromString(s);\n        assertEquals(range, newRange);\n      }\n\n\n    }\n  }\n\n","sourceOld":"  public void testMapHashes() throws Exception {\n    HashPartitioner hp = new HashPartitioner();\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, hp.fullRange());\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, 0, 0x7fffffff);\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    for (int i = 1; i <= 30000; i += 13) {\n      ranges = hp.partitionRange(i, hp.fullRange());\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n\n      for (Range range : ranges) {\n        String s = range.toString();\n        Range newRange = hp.fromString(s);\n        assertEquals(range, newRange);\n      }\n\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09f37c23448e2f162cd158c9a5f575d10ad19308","date":1355253672,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","sourceNew":"  public void testMapHashes() throws Exception {\n    DocRouter hp = DocRouter.DEFAULT;\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, hp.fullRange());\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, new DocRouter.Range(0, 0x7fffffff));\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    int defaultLowerBits = 0x0000ffff;\n\n    for (int i = 1; i <= 30000; i++) {\n      // start skipping at higher numbers\n      if (i > 100) i+=13;\n      else if (i > 1000) i+=31;\n      else if (i > 5000) i+=101;\n\n      long rangeSize = 0x0000000100000000L / i;\n\n      ranges = hp.partitionRange(i, hp.fullRange());\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n\n      for (Range range : ranges) {\n        String s = range.toString();\n        Range newRange = hp.fromString(s);\n        assertEquals(range, newRange);\n      }\n\n      // ensure that ranges are contiguous and that size deviations are not too large.\n      int lastEnd = Integer.MIN_VALUE - 1;\n      for (Range range : ranges) {\n        int currStart = range.min;\n        int currEnd = range.max;\n        assertEquals(lastEnd+1, currStart);\n\n        if (ranges.size() < 4000) {\n          // ranges should be rounded to avoid crossing hash domains\n          assertEquals(defaultLowerBits, currEnd & defaultLowerBits);\n\n          // given our rounding condition that domains should be less than 1/16 of the step size,\n          // this means that any sizing deviations should also be less than 1/16th of the idealized range size.\n          // boolean round = rangeStep >= (1<<bits)*16;\n\n          long currRangeSize = (long)currEnd - (long)currStart;\n          long error = Math.abs(rangeSize - currRangeSize);\n          assertTrue( error < rangeSize/16);\n        }\n\n\n        // String s = range.toString();\n        // Range newRange = hp.fromString(s);\n        // assertEquals(range, newRange);\n        lastEnd = currEnd;\n      }\n\n    }\n  }\n\n","sourceOld":"  public void testMapHashes() throws Exception {\n    DocRouter hp = DocRouter.DEFAULT;\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, hp.fullRange());\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, 0, 0x7fffffff);\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    for (int i = 1; i <= 30000; i += 13) {\n      ranges = hp.partitionRange(i, hp.fullRange());\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n\n      for (Range range : ranges) {\n        String s = range.toString();\n        Range newRange = hp.fromString(s);\n        assertEquals(range, newRange);\n      }\n\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testMapHashes().mjava","sourceNew":"  public void testMapHashes() throws Exception {\n    DocRouter hp = DocRouter.DEFAULT;\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, hp.fullRange());\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, new DocRouter.Range(0, 0x7fffffff));\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    int defaultLowerBits = 0x0000ffff;\n\n    for (int i = 1; i <= 30000; i++) {\n      // start skipping at higher numbers\n      if (i > 100) i+=13;\n      else if (i > 1000) i+=31;\n      else if (i > 5000) i+=101;\n\n      long rangeSize = 0x0000000100000000L / i;\n\n      ranges = hp.partitionRange(i, hp.fullRange());\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n\n      for (Range range : ranges) {\n        String s = range.toString();\n        Range newRange = hp.fromString(s);\n        assertEquals(range, newRange);\n      }\n\n      // ensure that ranges are contiguous and that size deviations are not too large.\n      int lastEnd = Integer.MIN_VALUE - 1;\n      for (Range range : ranges) {\n        int currStart = range.min;\n        int currEnd = range.max;\n        assertEquals(lastEnd+1, currStart);\n\n        if (ranges.size() < 4000) {\n          // ranges should be rounded to avoid crossing hash domains\n          assertEquals(defaultLowerBits, currEnd & defaultLowerBits);\n\n          // given our rounding condition that domains should be less than 1/16 of the step size,\n          // this means that any sizing deviations should also be less than 1/16th of the idealized range size.\n          // boolean round = rangeStep >= (1<<bits)*16;\n\n          long currRangeSize = (long)currEnd - (long)currStart;\n          long error = Math.abs(rangeSize - currRangeSize);\n          assertTrue( error < rangeSize/16);\n        }\n\n\n        // String s = range.toString();\n        // Range newRange = hp.fromString(s);\n        // assertEquals(range, newRange);\n        lastEnd = currEnd;\n      }\n\n    }\n  }\n\n","sourceOld":"  public void testMapHashes() throws Exception {\n    DocRouter hp = DocRouter.DEFAULT;\n    List<Range> ranges;\n\n    // make sure the partitioner uses the \"natural\" boundaries and doesn't suffer from an off-by-one\n    ranges = hp.partitionRange(2, hp.fullRange());\n    assertEquals(Integer.MIN_VALUE, ranges.get(0).min);\n    assertEquals(0x80000000, ranges.get(0).min);\n    assertEquals(0xffffffff, ranges.get(0).max);\n    assertEquals(0x00000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    ranges = hp.partitionRange(2, 0, 0x7fffffff);\n    assertEquals(0x00000000, ranges.get(0).min);\n    assertEquals(0x3fffffff, ranges.get(0).max);\n    assertEquals(0x40000000, ranges.get(1).min);\n    assertEquals(0x7fffffff, ranges.get(1).max);\n\n    for (int i = 1; i <= 30000; i += 13) {\n      ranges = hp.partitionRange(i, hp.fullRange());\n      assertEquals(i, ranges.size());\n      assertTrue(\"First range does not start before \" + Integer.MIN_VALUE\n          + \" it is:\" + ranges.get(0).min,\n          ranges.get(0).min <= Integer.MIN_VALUE);\n      assertTrue(\"Last range does not end after \" + Integer.MAX_VALUE\n          + \" it is:\" + ranges.get(ranges.size() - 1).max,\n          ranges.get(ranges.size() - 1).max >= Integer.MAX_VALUE);\n\n      for (Range range : ranges) {\n        String s = range.toString();\n        Range newRange = hp.fromString(s);\n        assertEquals(range, newRange);\n      }\n\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","09f37c23448e2f162cd158c9a5f575d10ad19308"],"89f828d954597b98a28942874636f35c719b8a5d":["c5a558d54519c651068ddb202f03befefb1514a7"],"fa64435b5902ce266c23755a4a00691a3285dab8":["e147cce225492338f15a94a427f51f867da574ee"],"407687e67faf6e1f02a211ca078d8e3eed631027":["fa64435b5902ce266c23755a4a00691a3285dab8","89f828d954597b98a28942874636f35c719b8a5d"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"e147cce225492338f15a94a427f51f867da574ee":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","e147cce225492338f15a94a427f51f867da574ee"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c5a558d54519c651068ddb202f03befefb1514a7":["fa64435b5902ce266c23755a4a00691a3285dab8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"09f37c23448e2f162cd158c9a5f575d10ad19308":["89f828d954597b98a28942874636f35c719b8a5d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["09f37c23448e2f162cd158c9a5f575d10ad19308"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"89f828d954597b98a28942874636f35c719b8a5d":["407687e67faf6e1f02a211ca078d8e3eed631027","09f37c23448e2f162cd158c9a5f575d10ad19308"],"fa64435b5902ce266c23755a4a00691a3285dab8":["407687e67faf6e1f02a211ca078d8e3eed631027","c5a558d54519c651068ddb202f03befefb1514a7"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"e147cce225492338f15a94a427f51f867da574ee":["fa64435b5902ce266c23755a4a00691a3285dab8","05a14b2611ead08655a2b2bdc61632eb31316e57"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"c5a558d54519c651068ddb202f03befefb1514a7":["89f828d954597b98a28942874636f35c719b8a5d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","e147cce225492338f15a94a427f51f867da574ee","05a14b2611ead08655a2b2bdc61632eb31316e57","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"09f37c23448e2f162cd158c9a5f575d10ad19308":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","05a14b2611ead08655a2b2bdc61632eb31316e57","0d22ac6a4146774c1bc8400160fc0b6150294e92","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}