{"path":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","commits":[{"id":"d4769bdea5a853f1841c485bc1fd9d79cb7022fc","date":1292168168,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"/dev/null","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(false);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          fstEnum.reset();\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.advance(randomTerm);\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString());\n          }\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8405d98acebb7e287bf7ac40e937ba05b8661285","8405d98acebb7e287bf7ac40e937ba05b8661285","8405d98acebb7e287bf7ac40e937ba05b8661285","1ec890fad2ea96317f4429e0aa0085bb25673641","1ec890fad2ea96317f4429e0aa0085bb25673641","1ec890fad2ea96317f4429e0aa0085bb25673641"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba6fce0460f33d47c2ccbdc9e07b88f57cf46f11","date":1292181440,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(false);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          fstEnum.reset();\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.advance(randomTerm);\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString());\n          }\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(false);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          fstEnum.reset();\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.advance(randomTerm);\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString());\n          }\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"/dev/null","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(false);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          fstEnum.reset();\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.advance(randomTerm);\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString());\n          }\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"/dev/null","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(false);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          fstEnum.reset();\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.advance(randomTerm);\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString());\n          }\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56da903869515527852ee21ea7ef7bfe414cd40d","date":1294224724,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(false);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(false);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          fstEnum.reset();\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.advance(randomTerm);\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString());\n          }\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(false);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(false);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          fstEnum.reset();\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.advance(randomTerm);\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString());\n          }\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f3b2c50e54fbd02d573055c75580702f3d68cda5","date":1294494344,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(false);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(false);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          fstEnum.reset();\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.advance(randomTerm);\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString());\n          }\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1add9ddc0005b07550d4350720aac22dc9886b3","date":1295549635,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb378f8bdee16a26810e086303a4a86b4930ea12","date":1296410797,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(false);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2c5f0cb44df114db4228c8f77861714b5cabaea","date":1302542431,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"962d04139994fce5193143ef35615499a9a96d78","date":1302693744,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8be6e1e4fbbc94d90b78f175c03ff389b6949373","date":1306674752,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    if (CodecProvider.getDefault().getDefaultFieldCodec().equals(\"SimpleText\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 100 : 1;\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = new MockDirectoryWrapper(random, FSDirectory.open(tempDir));\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    writer.setInfoStream(VERBOSE ? System.out : null);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC * 1000;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, outputs);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(term, outputs.get(output));\n        ord++;\n        if (ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      final FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n\n          final TermsEnum.SeekStatus seekResult = termsEnum.seek(randomTerm);\n          final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","56da903869515527852ee21ea7ef7bfe414cd40d"],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["f2c5f0cb44df114db4228c8f77861714b5cabaea"],"ba6fce0460f33d47c2ccbdc9e07b88f57cf46f11":["d4769bdea5a853f1841c485bc1fd9d79cb7022fc"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["29ef99d61cda9641b6250bf9567329a6e65f901d","f2c5f0cb44df114db4228c8f77861714b5cabaea"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ba6fce0460f33d47c2ccbdc9e07b88f57cf46f11"],"962d04139994fce5193143ef35615499a9a96d78":["bde51b089eb7f86171eb3406e38a274743f9b7ac","f2c5f0cb44df114db4228c8f77861714b5cabaea"],"b1add9ddc0005b07550d4350720aac22dc9886b3":["f3b2c50e54fbd02d573055c75580702f3d68cda5"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ba6fce0460f33d47c2ccbdc9e07b88f57cf46f11"],"eb378f8bdee16a26810e086303a4a86b4930ea12":["b1add9ddc0005b07550d4350720aac22dc9886b3"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["868da859b43505d9d2a023bfeae6dd0c795f5295","b1add9ddc0005b07550d4350720aac22dc9886b3"],"d4769bdea5a853f1841c485bc1fd9d79cb7022fc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f3b2c50e54fbd02d573055c75580702f3d68cda5":["56da903869515527852ee21ea7ef7bfe414cd40d"],"f2c5f0cb44df114db4228c8f77861714b5cabaea":["eb378f8bdee16a26810e086303a4a86b4930ea12"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a3776dccca01c11e7046323cfad46a3b4a471233","8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"56da903869515527852ee21ea7ef7bfe414cd40d":["ba6fce0460f33d47c2ccbdc9e07b88f57cf46f11"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["70ad682703b8585f5d0a637efec044d57ec05efb","eb378f8bdee16a26810e086303a4a86b4930ea12"],"a3776dccca01c11e7046323cfad46a3b4a471233":["eb378f8bdee16a26810e086303a4a86b4930ea12","f2c5f0cb44df114db4228c8f77861714b5cabaea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","f3b2c50e54fbd02d573055c75580702f3d68cda5"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["e79a6d080bdd5b2a8f56342cf571b5476de04180","eb378f8bdee16a26810e086303a4a86b4930ea12"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["135621f3a0670a9394eb563224a3b76cc4dddc0f","8be6e1e4fbbc94d90b78f175c03ff389b6949373"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"ba6fce0460f33d47c2ccbdc9e07b88f57cf46f11":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","56da903869515527852ee21ea7ef7bfe414cd40d"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["2e10cb22a8bdb44339e282925a29182bb2f3174d"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["70ad682703b8585f5d0a637efec044d57ec05efb"],"962d04139994fce5193143ef35615499a9a96d78":[],"b1add9ddc0005b07550d4350720aac22dc9886b3":["eb378f8bdee16a26810e086303a4a86b4930ea12","e79a6d080bdd5b2a8f56342cf571b5476de04180"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"eb378f8bdee16a26810e086303a4a86b4930ea12":["f2c5f0cb44df114db4228c8f77861714b5cabaea","29ef99d61cda9641b6250bf9567329a6e65f901d","a3776dccca01c11e7046323cfad46a3b4a471233","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"d4769bdea5a853f1841c485bc1fd9d79cb7022fc":["ba6fce0460f33d47c2ccbdc9e07b88f57cf46f11"],"f3b2c50e54fbd02d573055c75580702f3d68cda5":["b1add9ddc0005b07550d4350720aac22dc9886b3","868da859b43505d9d2a023bfeae6dd0c795f5295"],"f2c5f0cb44df114db4228c8f77861714b5cabaea":["8be6e1e4fbbc94d90b78f175c03ff389b6949373","135621f3a0670a9394eb563224a3b76cc4dddc0f","962d04139994fce5193143ef35615499a9a96d78","a3776dccca01c11e7046323cfad46a3b4a471233"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"56da903869515527852ee21ea7ef7bfe414cd40d":["70ad682703b8585f5d0a637efec044d57ec05efb","f3b2c50e54fbd02d573055c75580702f3d68cda5"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"a3776dccca01c11e7046323cfad46a3b4a471233":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d4769bdea5a853f1841c485bc1fd9d79cb7022fc"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["e79a6d080bdd5b2a8f56342cf571b5476de04180"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["962d04139994fce5193143ef35615499a9a96d78"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["962d04139994fce5193143ef35615499a9a96d78","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}