{"path":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetJoinDomain#testBespoke().mjava","commits":[{"id":"92910727264a23a47b7a6c94b0f75d655537b9ea","date":1540414655,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetJoinDomain#testBespoke().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","sourceNew":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // sanity check our test methods can handle a query matching no docs\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"empty_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, strfield(7) + \":bogus\");\n      assertEquals(\"Empty search result shouldn't have found a single bucket\",\n                   UNIQUE_FIELD_VALS, maxBuckets.get());\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, \"-*:*\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"filtered_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"*:*\");\n      assertEquals(\"Empty join filter shouldn't have found a single bucket\",\n                   UNIQUE_FIELD_VALS, maxBuckets.get());\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having sub-terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(8), strfield(8), null));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(null, null, \"-*:*\")));\n      facets.put(\"filtered_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"*:*\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS);\n    }\n  \n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":16 OR \"+strfield(9)+\":16 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+intfield(7)+\":16 OR \"+intfield(3)+\":13)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":16 OR \"+strfield(9)+\":16 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n\n    }\n\n    { // low limits, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 0, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 0, true));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n    { // low limit, high overrequest\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, UNIQUE_FIELD_VALS + 10, false);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, UNIQUE_FIELD_VALS + 10, false));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n    { // low limit, low overrequest, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 7, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 7, true));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n  }\n\n","sourceOld":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // sanity check our test methods can handle a query matching no docs\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"empty_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, strfield(7) + \":bogus\");\n      assertEquals(\"Empty search result shouldn't have found a single bucket\",\n                   UNIQUE_FIELD_VALS, maxBuckets.get());\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, \"-*:*\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"filtered_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"*:*\");\n      assertEquals(\"Empty join filter shouldn't have found a single bucket\",\n                   UNIQUE_FIELD_VALS, maxBuckets.get());\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having sub-terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(8), strfield(8), null));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(null, null, \"-*:*\")));\n      facets.put(\"filtered_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"*:*\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS);\n    }\n  \n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":16 OR \"+strfield(9)+\":16 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+intfield(7)+\":16 OR \"+intfield(3)+\":13)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":16 OR \"+strfield(9)+\":16 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n\n    }\n\n    { // low limits, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 0, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 0, true));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n    { // low limit, high overrequest\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, UNIQUE_FIELD_VALS + 10, false);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, UNIQUE_FIELD_VALS + 10, false));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n    { // low limit, low overrequest, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 7, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 7, true));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"92910727264a23a47b7a6c94b0f75d655537b9ea":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["92910727264a23a47b7a6c94b0f75d655537b9ea"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["92910727264a23a47b7a6c94b0f75d655537b9ea"],"92910727264a23a47b7a6c94b0f75d655537b9ea":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}