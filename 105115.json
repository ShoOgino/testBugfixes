{"path":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor.ConfigurableFieldNameSelector#shouldMutate(String).mjava","commits":[{"id":"be9a5d1846ac0beb625ba68da060e16119d9f51e","date":1328820081,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor.ConfigurableFieldNameSelector#shouldMutate(String).mjava","pathOld":"/dev/null","sourceNew":"    public boolean shouldMutate(final String fieldName) {\n      \n      // order of checks is bsaed on what should be quicker \n      // (ie: set lookups faster the looping over instanceOf / matches tests\n      \n      if ( ! (fields.isEmpty() || fields.contains(fieldName)) ) {\n        return false;\n      }\n      \n      // do not consider it an error if the fieldName has no type\n      // there might be another processor dealing with it later\n      FieldType t = schema.getFieldTypeNoEx(fieldName);\n      if (null != t) {\n        if (! (typeNames.isEmpty() || typeNames.contains(t.getTypeName())) ) {\n          return false;\n        }\n        \n        if (! (classes.isEmpty() || instanceOfAny(t, classes)) ) {\n          return false;\n          }\n      }\n      \n      if (! (regexes.isEmpty() || matchesAny(fieldName, regexes)) ) {\n        return false;\n      }\n      \n      return true;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor.ConfigurableFieldNameSelector#shouldMutate(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor.ConfigurableFieldNameSelector#shouldMutate(String).mjava","sourceNew":"    @Override\n    public boolean shouldMutate(final String fieldName) {\n      \n      // order of checks is bsaed on what should be quicker \n      // (ie: set lookups faster the looping over instanceOf / matches tests\n      \n      if ( ! (fields.isEmpty() || fields.contains(fieldName)) ) {\n        return false;\n      }\n      \n      // do not consider it an error if the fieldName has no type\n      // there might be another processor dealing with it later\n      FieldType t = schema.getFieldTypeNoEx(fieldName);\n      if (null != t) {\n        if (! (typeNames.isEmpty() || typeNames.contains(t.getTypeName())) ) {\n          return false;\n        }\n        \n        if (! (classes.isEmpty() || instanceOfAny(t, classes)) ) {\n          return false;\n          }\n      }\n      \n      if (! (regexes.isEmpty() || matchesAny(fieldName, regexes)) ) {\n        return false;\n      }\n      \n      return true;\n    }\n\n","sourceOld":"    public boolean shouldMutate(final String fieldName) {\n      \n      // order of checks is bsaed on what should be quicker \n      // (ie: set lookups faster the looping over instanceOf / matches tests\n      \n      if ( ! (fields.isEmpty() || fields.contains(fieldName)) ) {\n        return false;\n      }\n      \n      // do not consider it an error if the fieldName has no type\n      // there might be another processor dealing with it later\n      FieldType t = schema.getFieldTypeNoEx(fieldName);\n      if (null != t) {\n        if (! (typeNames.isEmpty() || typeNames.contains(t.getTypeName())) ) {\n          return false;\n        }\n        \n        if (! (classes.isEmpty() || instanceOfAny(t, classes)) ) {\n          return false;\n          }\n      }\n      \n      if (! (regexes.isEmpty() || matchesAny(fieldName, regexes)) ) {\n        return false;\n      }\n      \n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor.ConfigurableFieldNameSelector#shouldMutate(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor.ConfigurableFieldNameSelector#shouldMutate(String).mjava","sourceNew":"    @Override\n    public boolean shouldMutate(final String fieldName) {\n      \n      // order of checks is bsaed on what should be quicker \n      // (ie: set lookups faster the looping over instanceOf / matches tests\n      \n      if ( ! (fields.isEmpty() || fields.contains(fieldName)) ) {\n        return false;\n      }\n      \n      // do not consider it an error if the fieldName has no type\n      // there might be another processor dealing with it later\n      FieldType t = schema.getFieldTypeNoEx(fieldName);\n      if (null != t) {\n        if (! (typeNames.isEmpty() || typeNames.contains(t.getTypeName())) ) {\n          return false;\n        }\n        \n        if (! (classes.isEmpty() || instanceOfAny(t, classes)) ) {\n          return false;\n          }\n      }\n      \n      if (! (regexes.isEmpty() || matchesAny(fieldName, regexes)) ) {\n        return false;\n      }\n      \n      return true;\n    }\n\n","sourceOld":"    public boolean shouldMutate(final String fieldName) {\n      \n      // order of checks is bsaed on what should be quicker \n      // (ie: set lookups faster the looping over instanceOf / matches tests\n      \n      if ( ! (fields.isEmpty() || fields.contains(fieldName)) ) {\n        return false;\n      }\n      \n      // do not consider it an error if the fieldName has no type\n      // there might be another processor dealing with it later\n      FieldType t = schema.getFieldTypeNoEx(fieldName);\n      if (null != t) {\n        if (! (typeNames.isEmpty() || typeNames.contains(t.getTypeName())) ) {\n          return false;\n        }\n        \n        if (! (classes.isEmpty() || instanceOfAny(t, classes)) ) {\n          return false;\n          }\n      }\n      \n      if (! (regexes.isEmpty() || matchesAny(fieldName, regexes)) ) {\n        return false;\n      }\n      \n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor.ConfigurableFieldNameSelector#shouldMutate(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor.ConfigurableFieldNameSelector#shouldMutate(String).mjava","sourceNew":"    @Override\n    public boolean shouldMutate(final String fieldName) {\n      \n      // order of checks is bsaed on what should be quicker \n      // (ie: set lookups faster the looping over instanceOf / matches tests\n      \n      if ( ! (fields.isEmpty() || fields.contains(fieldName)) ) {\n        return false;\n      }\n      \n      // do not consider it an error if the fieldName has no type\n      // there might be another processor dealing with it later\n      FieldType t =  core.getLatestSchema().getFieldTypeNoEx(fieldName);\n      if (null != t) {\n        if (! (typeNames.isEmpty() || typeNames.contains(t.getTypeName())) ) {\n          return false;\n        }\n        \n        if (! (classes.isEmpty() || instanceOfAny(t, classes)) ) {\n          return false;\n          }\n      }\n      \n      if (! (regexes.isEmpty() || matchesAny(fieldName, regexes)) ) {\n        return false;\n      }\n      \n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean shouldMutate(final String fieldName) {\n      \n      // order of checks is bsaed on what should be quicker \n      // (ie: set lookups faster the looping over instanceOf / matches tests\n      \n      if ( ! (fields.isEmpty() || fields.contains(fieldName)) ) {\n        return false;\n      }\n      \n      // do not consider it an error if the fieldName has no type\n      // there might be another processor dealing with it later\n      FieldType t = schema.getFieldTypeNoEx(fieldName);\n      if (null != t) {\n        if (! (typeNames.isEmpty() || typeNames.contains(t.getTypeName())) ) {\n          return false;\n        }\n        \n        if (! (classes.isEmpty() || instanceOfAny(t, classes)) ) {\n          return false;\n          }\n      }\n      \n      if (! (regexes.isEmpty() || matchesAny(fieldName, regexes)) ) {\n        return false;\n      }\n      \n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0a19f093878b8ef6d65992a55f7a565549f30ee","date":1370735567,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor.ConfigurableFieldNameSelector#shouldMutate(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor.ConfigurableFieldNameSelector#shouldMutate(String).mjava","sourceNew":"    @Override\n    public boolean shouldMutate(final String fieldName) {\n      \n      // order of checks is based on what should be quicker\n      // (ie: set lookups faster the looping over instanceOf / matches tests\n      \n      if ( ! (params.fieldName.isEmpty() || params.fieldName.contains(fieldName)) ) {\n        return false;\n      }\n      \n      // do not consider it an error if the fieldName has no type\n      // there might be another processor dealing with it later\n      FieldType t =  core.getLatestSchema().getFieldTypeNoEx(fieldName);\n      final boolean fieldExists = (null != t);\n\n      if ( (null != params.fieldNameMatchesSchemaField) &&\n           (fieldExists != params.fieldNameMatchesSchemaField) ) {\n        return false;\n      }\n\n      if (fieldExists) { \n\n        if (! (params.typeName.isEmpty() || params.typeName.contains(t.getTypeName())) ) {\n          return false;\n        }\n        \n        if (! (classes.isEmpty() || instanceOfAny(t, classes)) ) {\n          return false;\n        }\n      } \n      \n      if (! (params.fieldRegex.isEmpty() || matchesAny(fieldName, params.fieldRegex)) ) {\n        return false;\n      }\n      \n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean shouldMutate(final String fieldName) {\n      \n      // order of checks is bsaed on what should be quicker \n      // (ie: set lookups faster the looping over instanceOf / matches tests\n      \n      if ( ! (fields.isEmpty() || fields.contains(fieldName)) ) {\n        return false;\n      }\n      \n      // do not consider it an error if the fieldName has no type\n      // there might be another processor dealing with it later\n      FieldType t =  core.getLatestSchema().getFieldTypeNoEx(fieldName);\n      if (null != t) {\n        if (! (typeNames.isEmpty() || typeNames.contains(t.getTypeName())) ) {\n          return false;\n        }\n        \n        if (! (classes.isEmpty() || instanceOfAny(t, classes)) ) {\n          return false;\n          }\n      }\n      \n      if (! (regexes.isEmpty() || matchesAny(fieldName, regexes)) ) {\n        return false;\n      }\n      \n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f13b9d4c228e77327b284419c8cafd16913a7a19","date":1405437837,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor.ConfigurableFieldNameSelectorHelper#shouldMutateBasedOnSchema(String,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessor.ConfigurableFieldNameSelector#shouldMutate(String).mjava","sourceNew":"    public boolean shouldMutateBasedOnSchema(final String fieldName, IndexSchema schema) {\n      // order of checks is based on what should be quicker\n      // (ie: set lookups faster the looping over instanceOf / matches tests\n      \n      if ( ! (params.fieldName.isEmpty() || params.fieldName.contains(fieldName)) ) {\n        return false;\n      }\n      \n      // do not consider it an error if the fieldName has no type\n      // there might be another processor dealing with it later\n      FieldType t =  schema.getFieldTypeNoEx(fieldName);\n      final boolean fieldExists = (null != t);\n\n      if ( (null != params.fieldNameMatchesSchemaField) &&\n           (fieldExists != params.fieldNameMatchesSchemaField) ) {\n        return false;\n      }\n\n      if (fieldExists) { \n\n        if (! (params.typeName.isEmpty() || params.typeName.contains(t.getTypeName())) ) {\n          return false;\n        }\n        \n        if (! (classes.isEmpty() || instanceOfAny(t, classes)) ) {\n          return false;\n        }\n      } \n      \n      if (! (params.fieldRegex.isEmpty() || matchesAny(fieldName, params.fieldRegex)) ) {\n        return false;\n      }\n      \n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean shouldMutate(final String fieldName) {\n      \n      // order of checks is based on what should be quicker\n      // (ie: set lookups faster the looping over instanceOf / matches tests\n      \n      if ( ! (params.fieldName.isEmpty() || params.fieldName.contains(fieldName)) ) {\n        return false;\n      }\n      \n      // do not consider it an error if the fieldName has no type\n      // there might be another processor dealing with it later\n      FieldType t =  core.getLatestSchema().getFieldTypeNoEx(fieldName);\n      final boolean fieldExists = (null != t);\n\n      if ( (null != params.fieldNameMatchesSchemaField) &&\n           (fieldExists != params.fieldNameMatchesSchemaField) ) {\n        return false;\n      }\n\n      if (fieldExists) { \n\n        if (! (params.typeName.isEmpty() || params.typeName.contains(t.getTypeName())) ) {\n          return false;\n        }\n        \n        if (! (classes.isEmpty() || instanceOfAny(t, classes)) ) {\n          return false;\n        }\n      } \n      \n      if (! (params.fieldRegex.isEmpty() || matchesAny(fieldName, params.fieldRegex)) ) {\n        return false;\n      }\n      \n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["be9a5d1846ac0beb625ba68da060e16119d9f51e","7530de27b87b961b51f01bd1299b7004d46e8823"],"be9a5d1846ac0beb625ba68da060e16119d9f51e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b0a19f093878b8ef6d65992a55f7a565549f30ee":["08970e5b8411182a29412c177eff67ec1110095b"],"7530de27b87b961b51f01bd1299b7004d46e8823":["be9a5d1846ac0beb625ba68da060e16119d9f51e"],"f13b9d4c228e77327b284419c8cafd16913a7a19":["b0a19f093878b8ef6d65992a55f7a565549f30ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f13b9d4c228e77327b284419c8cafd16913a7a19"],"08970e5b8411182a29412c177eff67ec1110095b":["7530de27b87b961b51f01bd1299b7004d46e8823"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"be9a5d1846ac0beb625ba68da060e16119d9f51e":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["be9a5d1846ac0beb625ba68da060e16119d9f51e"],"b0a19f093878b8ef6d65992a55f7a565549f30ee":["f13b9d4c228e77327b284419c8cafd16913a7a19"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","08970e5b8411182a29412c177eff67ec1110095b"],"f13b9d4c228e77327b284419c8cafd16913a7a19":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"08970e5b8411182a29412c177eff67ec1110095b":["b0a19f093878b8ef6d65992a55f7a565549f30ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}