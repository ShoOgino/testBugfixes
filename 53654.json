{"path":"src/java/org/apache/solr/search/SolrIndexReader#SolrIndexReader(IndexReader,SolrIndexReader,int).mjava","commits":[{"id":"bfa71be65cf17963fa727d8e5f35bb35b110aa16","date":1234319413,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrIndexReader#SolrIndexReader(IndexReader,SolrIndexReader,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Recursively wrap an IndexReader in SolrIndexReader instances.\n   * @param in  the reader to wrap\n   * @param parent the parent, if any (null if none)\n   * @param base the docid offset in the parent (0 if top level)\n   */\n  public SolrIndexReader(IndexReader in, SolrIndexReader parent, int base) {\n    super(in);\n    assert(!(in instanceof SolrIndexReader));\n    this.parent = parent;\n    this.base = base;\n    IndexReader subs[] = in.getSequentialSubReaders();\n    subReaders = subs == null ? null : new SolrIndexReader[subs.length];\n    if (subs != null) {\n      int b=0;\n      for (int i=0; i<subReaders.length; i++) {\n        subReaders[i] = new SolrIndexReader(subs[i], this, b);\n        b += subReaders[i].maxDoc();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10845c160c29e7e480692d2e9d7dad15a6de2630","date":1242326245,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrIndexReader#SolrIndexReader(IndexReader,SolrIndexReader,int).mjava","pathOld":"src/java/org/apache/solr/search/SolrIndexReader#SolrIndexReader(IndexReader,SolrIndexReader,int).mjava","sourceNew":"  /** Recursively wrap an IndexReader in SolrIndexReader instances.\n   * @param in  the reader to wrap\n   * @param parent the parent, if any (null if none)\n   * @param base the docid offset in the parent (0 if top level)\n   */\n  public SolrIndexReader(IndexReader in, SolrIndexReader parent, int base) {\n    super(in);\n    assert(!(in instanceof SolrIndexReader));\n    this.parent = parent;\n    this.base = base;\n    IndexReader subs[] = in.getSequentialSubReaders();\n    if (subs != null) {\n      subReaders = new SolrIndexReader[subs.length]; \n      int numLeaves = subs.length;\n      leafOffsets = new int[numLeaves];\n      int b=0;\n      for (int i=0; i<subReaders.length; i++) {\n        SolrIndexReader sir = subReaders[i] = new SolrIndexReader(subs[i], this, b);\n        leafOffsets[i] = b;\n        b += sir.maxDoc();\n        IndexReader subLeaves[] = sir.leafReaders;\n        numLeaves += subLeaves.length - 1;  // subtract 1 for the parent\n      }\n      leafReaders = getLeaves(numLeaves);\n    } else {\n      subReaders = null;\n      leafReaders = new SolrIndexReader[]{this};\n      leafOffsets = zeroIntArray;\n    }\n\n  }\n\n","sourceOld":"  /** Recursively wrap an IndexReader in SolrIndexReader instances.\n   * @param in  the reader to wrap\n   * @param parent the parent, if any (null if none)\n   * @param base the docid offset in the parent (0 if top level)\n   */\n  public SolrIndexReader(IndexReader in, SolrIndexReader parent, int base) {\n    super(in);\n    assert(!(in instanceof SolrIndexReader));\n    this.parent = parent;\n    this.base = base;\n    IndexReader subs[] = in.getSequentialSubReaders();\n    subReaders = subs == null ? null : new SolrIndexReader[subs.length];\n    if (subs != null) {\n      int b=0;\n      for (int i=0; i<subReaders.length; i++) {\n        subReaders[i] = new SolrIndexReader(subs[i], this, b);\n        b += subReaders[i].maxDoc();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrIndexReader#SolrIndexReader(IndexReader,SolrIndexReader,int).mjava","pathOld":"src/java/org/apache/solr/search/SolrIndexReader#SolrIndexReader(IndexReader,SolrIndexReader,int).mjava","sourceNew":"  /** Recursively wrap an IndexReader in SolrIndexReader instances.\n   * @param in  the reader to wrap\n   * @param parent the parent, if any (null if none)\n   * @param base the docid offset in the parent (0 if top level)\n   */\n  public SolrIndexReader(IndexReader in, SolrIndexReader parent, int base) {\n    super(in);\n    assert(!(in instanceof SolrIndexReader));\n    this.parent = parent;\n    this.base = base;\n    IndexReader subs[] = in.getSequentialSubReaders();\n    if (subs != null) {\n      subReaders = new SolrIndexReader[subs.length]; \n      int numLeaves = subs.length;\n      leafOffsets = new int[numLeaves];\n      int b=0;\n      for (int i=0; i<subReaders.length; i++) {\n        SolrIndexReader sir = subReaders[i] = new SolrIndexReader(subs[i], this, b);\n        leafOffsets[i] = b;\n        b += sir.maxDoc();\n        IndexReader subLeaves[] = sir.leafReaders;\n        numLeaves += subLeaves.length - 1;  // subtract 1 for the parent\n      }\n      leafReaders = getLeaves(numLeaves);\n    } else {\n      subReaders = null;\n      leafReaders = new SolrIndexReader[]{this};\n      leafOffsets = zeroIntArray;\n    }\n\n  }\n\n","sourceOld":"  /** Recursively wrap an IndexReader in SolrIndexReader instances.\n   * @param in  the reader to wrap\n   * @param parent the parent, if any (null if none)\n   * @param base the docid offset in the parent (0 if top level)\n   */\n  public SolrIndexReader(IndexReader in, SolrIndexReader parent, int base) {\n    super(in);\n    assert(!(in instanceof SolrIndexReader));\n    this.parent = parent;\n    this.base = base;\n    IndexReader subs[] = in.getSequentialSubReaders();\n    if (subs != null) {\n      subReaders = new SolrIndexReader[subs.length]; \n      int numLeaves = subs.length;\n      leafOffsets = new int[numLeaves];\n      int b=0;\n      for (int i=0; i<subReaders.length; i++) {\n        SolrIndexReader sir = subReaders[i] = new SolrIndexReader(subs[i], this, b);\n        leafOffsets[i] = b;\n        b += sir.maxDoc();\n        IndexReader subLeaves[] = sir.leafReaders;\n        numLeaves += subLeaves.length - 1;  // subtract 1 for the parent\n      }\n      leafReaders = getLeaves(numLeaves);\n    } else {\n      subReaders = null;\n      leafReaders = new SolrIndexReader[]{this};\n      leafOffsets = zeroIntArray;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"10845c160c29e7e480692d2e9d7dad15a6de2630":["bfa71be65cf17963fa727d8e5f35bb35b110aa16"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bfa71be65cf17963fa727d8e5f35bb35b110aa16":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["10845c160c29e7e480692d2e9d7dad15a6de2630"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"10845c160c29e7e480692d2e9d7dad15a6de2630":["ad94625fb8d088209f46650c8097196fec67f00c"],"bfa71be65cf17963fa727d8e5f35bb35b110aa16":["10845c160c29e7e480692d2e9d7dad15a6de2630"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["bfa71be65cf17963fa727d8e5f35bb35b110aa16"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}