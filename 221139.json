{"path":"modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef,int).mjava","commits":[{"id":"de11853c992f764e52d4164cc9afdebb989dba8a","date":1313510465,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef,int).mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef).mjava","sourceNew":"  // Interleaves all output tokens onto the futureOutputs:\n  private void addOutput(BytesRef bytes, int matchInputLength) {\n    bytesReader.reset(bytes.bytes, bytes.offset, bytes.length);\n\n    final int code = bytesReader.readVInt();\n    final boolean keepOrig = (code & 0x1) == 0;\n    final int count = code >>> 1;\n    //System.out.println(\"  addOutput count=\" + count + \" keepOrig=\" + keepOrig);\n    for(int outputIDX=0;outputIDX<count;outputIDX++) {\n      synonyms.words.get(bytesReader.readVInt(),\n                         scratchBytes);\n      //System.out.println(\"    outIDX=\" + outputIDX + \" bytes=\" + scratchBytes.length);\n      UnicodeUtil.UTF8toUTF16(scratchBytes, scratchChars);\n      int lastStart = scratchChars.offset;\n      final int chEnd = lastStart + scratchChars.length;\n      int outputUpto = nextRead;\n      for(int chIDX=lastStart;chIDX<=chEnd;chIDX++) {\n        if (chIDX == chEnd || scratchChars.chars[chIDX] == SynonymMap.WORD_SEPARATOR) {\n          final int outputLen = chIDX - lastStart;\n          // Caller is not allowed to have empty string in\n          // the output:\n          assert outputLen > 0: \"output contains empty string: \" + scratchChars;\n          futureOutputs[outputUpto].add(scratchChars.chars, lastStart, outputLen);\n          //System.out.println(\"      \" + new String(scratchChars.chars, lastStart, outputLen) + \" outputUpto=\" + outputUpto);\n          lastStart = 1+chIDX;\n          //System.out.println(\"  slot=\" + outputUpto + \" keepOrig=\" + keepOrig);\n          outputUpto = rollIncr(outputUpto);\n          assert futureOutputs[outputUpto].posIncr == 1: \"outputUpto=\" + outputUpto + \" vs nextWrite=\" + nextWrite;\n        }\n      }\n    }\n\n    int upto = nextRead;\n    for(int idx=0;idx<matchInputLength;idx++) {\n      futureInputs[upto].keepOrig |= keepOrig;\n      futureInputs[upto].matched = true;\n      upto = rollIncr(upto);\n    }\n  }\n\n","sourceOld":"  // Interleaves all output tokens onto the futureOutputs:\n  private void addOutput(BytesRef bytes) {\n    bytesReader.reset(bytes.bytes, bytes.offset, bytes.length);\n\n    final int code = bytesReader.readVInt();\n    final boolean keepOrig = (code & 0x1) == 0;\n    final int count = code >>> 1;\n    //System.out.println(\"  addOutput count=\" + count + \" keepOrig=\" + keepOrig);\n    for(int outputIDX=0;outputIDX<count;outputIDX++) {\n      synonyms.words.get(bytesReader.readVInt(),\n                         scratchBytes);\n      //System.out.println(\"    outIDX=\" + outputIDX + \" bytes=\" + scratchBytes.length);\n      UnicodeUtil.UTF8toUTF16(scratchBytes, scratchChars);\n      int lastStart = scratchChars.offset;\n      final int chEnd = lastStart + scratchChars.length;\n      int outputUpto = nextRead;\n      for(int chIDX=lastStart;chIDX<=chEnd;chIDX++) {\n        if (chIDX == chEnd || scratchChars.chars[chIDX] == SynonymMap.WORD_SEPARATOR) {\n          final int outputLen = chIDX - lastStart;\n          // Caller is not allowed to have empty string in\n          // the output:\n          assert outputLen > 0: \"output contains empty string: \" + scratchChars;\n          futureOutputs[outputUpto].add(scratchChars.chars, lastStart, outputLen);\n          //System.out.println(\"      \" + new String(scratchChars.chars, lastStart, outputLen) + \" outputUpto=\" + outputUpto);\n          lastStart = 1+chIDX;\n          futureInputs[outputUpto].keepOrig |= keepOrig;\n          //System.out.println(\"  slot=\" + outputUpto + \" keepOrig=\" + keepOrig);\n          outputUpto = rollIncr(outputUpto);\n          assert futureOutputs[outputUpto].posIncr == 1: \"outputUpto=\" + outputUpto + \" vs nextWrite=\" + nextWrite;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"865b7d0f8430a08d385370b6b87a89a737aa6145","date":1325953575,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef,int,int).mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef,int).mjava","sourceNew":"  // Interleaves all output tokens onto the futureOutputs:\n  private void addOutput(BytesRef bytes, int matchInputLength, int matchEndOffset) {\n    bytesReader.reset(bytes.bytes, bytes.offset, bytes.length);\n\n    final int code = bytesReader.readVInt();\n    final boolean keepOrig = (code & 0x1) == 0;\n    final int count = code >>> 1;\n    //System.out.println(\"  addOutput count=\" + count + \" keepOrig=\" + keepOrig);\n    for(int outputIDX=0;outputIDX<count;outputIDX++) {\n      synonyms.words.get(bytesReader.readVInt(),\n                         scratchBytes);\n      //System.out.println(\"    outIDX=\" + outputIDX + \" bytes=\" + scratchBytes.length);\n      UnicodeUtil.UTF8toUTF16(scratchBytes, scratchChars);\n      int lastStart = scratchChars.offset;\n      final int chEnd = lastStart + scratchChars.length;\n      int outputUpto = nextRead;\n      for(int chIDX=lastStart;chIDX<=chEnd;chIDX++) {\n        if (chIDX == chEnd || scratchChars.chars[chIDX] == SynonymMap.WORD_SEPARATOR) {\n          final int outputLen = chIDX - lastStart;\n          // Caller is not allowed to have empty string in\n          // the output:\n          assert outputLen > 0: \"output contains empty string: \" + scratchChars;\n          final int endOffset;\n          if (chIDX == chEnd && lastStart == scratchChars.offset) {\n            // This rule had a single output token, so, we set\n            // this output's endOffset to the current\n            // endOffset (ie, endOffset of the last input\n            // token it matched):\n            endOffset = matchEndOffset;\n          } else {\n            // This rule has more than one output token; we\n            // can't pick any particular endOffset for this\n            // case, so, we inherit the endOffset for the\n            // input token which this output overlaps:\n            endOffset = -1;\n          }\n          futureOutputs[outputUpto].add(scratchChars.chars, lastStart, outputLen, endOffset);\n          //System.out.println(\"      \" + new String(scratchChars.chars, lastStart, outputLen) + \" outputUpto=\" + outputUpto);\n          lastStart = 1+chIDX;\n          //System.out.println(\"  slot=\" + outputUpto + \" keepOrig=\" + keepOrig);\n          outputUpto = rollIncr(outputUpto);\n          assert futureOutputs[outputUpto].posIncr == 1: \"outputUpto=\" + outputUpto + \" vs nextWrite=\" + nextWrite;\n        }\n      }\n    }\n\n    int upto = nextRead;\n    for(int idx=0;idx<matchInputLength;idx++) {\n      futureInputs[upto].keepOrig |= keepOrig;\n      futureInputs[upto].matched = true;\n      upto = rollIncr(upto);\n    }\n  }\n\n","sourceOld":"  // Interleaves all output tokens onto the futureOutputs:\n  private void addOutput(BytesRef bytes, int matchInputLength) {\n    bytesReader.reset(bytes.bytes, bytes.offset, bytes.length);\n\n    final int code = bytesReader.readVInt();\n    final boolean keepOrig = (code & 0x1) == 0;\n    final int count = code >>> 1;\n    //System.out.println(\"  addOutput count=\" + count + \" keepOrig=\" + keepOrig);\n    for(int outputIDX=0;outputIDX<count;outputIDX++) {\n      synonyms.words.get(bytesReader.readVInt(),\n                         scratchBytes);\n      //System.out.println(\"    outIDX=\" + outputIDX + \" bytes=\" + scratchBytes.length);\n      UnicodeUtil.UTF8toUTF16(scratchBytes, scratchChars);\n      int lastStart = scratchChars.offset;\n      final int chEnd = lastStart + scratchChars.length;\n      int outputUpto = nextRead;\n      for(int chIDX=lastStart;chIDX<=chEnd;chIDX++) {\n        if (chIDX == chEnd || scratchChars.chars[chIDX] == SynonymMap.WORD_SEPARATOR) {\n          final int outputLen = chIDX - lastStart;\n          // Caller is not allowed to have empty string in\n          // the output:\n          assert outputLen > 0: \"output contains empty string: \" + scratchChars;\n          futureOutputs[outputUpto].add(scratchChars.chars, lastStart, outputLen);\n          //System.out.println(\"      \" + new String(scratchChars.chars, lastStart, outputLen) + \" outputUpto=\" + outputUpto);\n          lastStart = 1+chIDX;\n          //System.out.println(\"  slot=\" + outputUpto + \" keepOrig=\" + keepOrig);\n          outputUpto = rollIncr(outputUpto);\n          assert futureOutputs[outputUpto].posIncr == 1: \"outputUpto=\" + outputUpto + \" vs nextWrite=\" + nextWrite;\n        }\n      }\n    }\n\n    int upto = nextRead;\n    for(int idx=0;idx<matchInputLength;idx++) {\n      futureInputs[upto].keepOrig |= keepOrig;\n      futureInputs[upto].matched = true;\n      upto = rollIncr(upto);\n    }\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"865b7d0f8430a08d385370b6b87a89a737aa6145":["de11853c992f764e52d4164cc9afdebb989dba8a"],"de11853c992f764e52d4164cc9afdebb989dba8a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["865b7d0f8430a08d385370b6b87a89a737aa6145"]},"commit2Childs":{"865b7d0f8430a08d385370b6b87a89a737aa6145":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"de11853c992f764e52d4164cc9afdebb989dba8a":["865b7d0f8430a08d385370b6b87a89a737aa6145"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["de11853c992f764e52d4164cc9afdebb989dba8a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}