{"path":"lucene/core/src/test/org/apache/lucene/util/TestRollingCharBuffer#test().mjava","commits":[{"id":"0984ad47974c2d5d354519ddb2aa8358973a6271","date":1330868053,"type":0,"author":"Christian Moen","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestRollingCharBuffer#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n    final int ITERS = atLeast(1000);\n    \n    RollingCharBuffer buffer = new RollingCharBuffer();\n\n    for(int iter=0;iter<ITERS;iter++) {\n      final int stringLen = random.nextBoolean() ? random.nextInt(50) : random.nextInt(20000);\n      final String s;\n      if (stringLen == 0) {\n        s = \"\";\n      } else {\n        s = _TestUtil.randomUnicodeString(random, stringLen);\n      }\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s.length()=\" + s.length());\n      }\n      buffer.reset(new StringReader(s));\n      int nextRead = 0;\n      int availCount = 0;\n      while(nextRead < s.length()) {\n        if (VERBOSE) {\n          System.out.println(\"  cycle nextRead=\" + nextRead + \" avail=\" + availCount);\n        }\n        if (availCount == 0 || random.nextBoolean()) {\n          // Read next char\n          if (VERBOSE) {\n            System.out.println(\"    new char\");\n          }\n          assertEquals(s.charAt(nextRead), buffer.get(nextRead));\n          nextRead++;\n          availCount++;\n        } else if (random.nextBoolean()) {\n          // Read previous char\n          int pos = _TestUtil.nextInt(random, nextRead-availCount, nextRead-1);\n          if (VERBOSE) {\n            System.out.println(\"    old char pos=\" + pos);\n          }\n          assertEquals(s.charAt(pos), buffer.get(pos));\n        } else {\n          // Read slice\n          int length;\n          if (availCount == 1) {\n            length = 1;\n          } else {\n            length = _TestUtil.nextInt(random, 1, availCount);\n          }\n          int start;\n          if (length == availCount) {\n            start = nextRead - availCount;\n          } else {\n            start = nextRead - availCount + random.nextInt(availCount-length);\n          }\n          if (VERBOSE) {\n            System.out.println(\"    slice start=\" + start + \" length=\" + length);\n          }\n          assertEquals(s.substring(start, start+length),\n                       new String(buffer.get(start, length)));\n        }\n\n        if (availCount > 0 && random.nextInt(20) == 17) {\n          final int toFree = random.nextInt(availCount);\n          if (VERBOSE) {\n            System.out.println(\"    free \" + toFree + \" (avail=\" + (availCount-toFree) + \")\");\n          }\n          buffer.freeBefore(nextRead-(availCount-toFree));\n          availCount -= toFree;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["71da933d30aea361ccc224d6544c451cbf49916d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestRollingCharBuffer#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n    final int ITERS = atLeast(1000);\n    \n    RollingCharBuffer buffer = new RollingCharBuffer();\n\n    for(int iter=0;iter<ITERS;iter++) {\n      final int stringLen = random.nextBoolean() ? random.nextInt(50) : random.nextInt(20000);\n      final String s;\n      if (stringLen == 0) {\n        s = \"\";\n      } else {\n        s = _TestUtil.randomUnicodeString(random, stringLen);\n      }\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s.length()=\" + s.length());\n      }\n      buffer.reset(new StringReader(s));\n      int nextRead = 0;\n      int availCount = 0;\n      while(nextRead < s.length()) {\n        if (VERBOSE) {\n          System.out.println(\"  cycle nextRead=\" + nextRead + \" avail=\" + availCount);\n        }\n        if (availCount == 0 || random.nextBoolean()) {\n          // Read next char\n          if (VERBOSE) {\n            System.out.println(\"    new char\");\n          }\n          assertEquals(s.charAt(nextRead), buffer.get(nextRead));\n          nextRead++;\n          availCount++;\n        } else if (random.nextBoolean()) {\n          // Read previous char\n          int pos = _TestUtil.nextInt(random, nextRead-availCount, nextRead-1);\n          if (VERBOSE) {\n            System.out.println(\"    old char pos=\" + pos);\n          }\n          assertEquals(s.charAt(pos), buffer.get(pos));\n        } else {\n          // Read slice\n          int length;\n          if (availCount == 1) {\n            length = 1;\n          } else {\n            length = _TestUtil.nextInt(random, 1, availCount);\n          }\n          int start;\n          if (length == availCount) {\n            start = nextRead - availCount;\n          } else {\n            start = nextRead - availCount + random.nextInt(availCount-length);\n          }\n          if (VERBOSE) {\n            System.out.println(\"    slice start=\" + start + \" length=\" + length);\n          }\n          assertEquals(s.substring(start, start+length),\n                       new String(buffer.get(start, length)));\n        }\n\n        if (availCount > 0 && random.nextInt(20) == 17) {\n          final int toFree = random.nextInt(availCount);\n          if (VERBOSE) {\n            System.out.println(\"    free \" + toFree + \" (avail=\" + (availCount-toFree) + \")\");\n          }\n          buffer.freeBefore(nextRead-(availCount-toFree));\n          availCount -= toFree;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestRollingCharBuffer#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestRollingCharBuffer#test().mjava","sourceNew":"  public void test() throws Exception {\n    final int ITERS = atLeast(1000);\n    \n    RollingCharBuffer buffer = new RollingCharBuffer();\n\n    Random random = random();\n    for(int iter=0;iter<ITERS;iter++) {\n      final int stringLen = random.nextBoolean() ? random.nextInt(50) : random.nextInt(20000);\n      final String s;\n      if (stringLen == 0) {\n        s = \"\";\n      } else {\n        s = _TestUtil.randomUnicodeString(random, stringLen);\n      }\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s.length()=\" + s.length());\n      }\n      buffer.reset(new StringReader(s));\n      int nextRead = 0;\n      int availCount = 0;\n      while(nextRead < s.length()) {\n        if (VERBOSE) {\n          System.out.println(\"  cycle nextRead=\" + nextRead + \" avail=\" + availCount);\n        }\n        if (availCount == 0 || random.nextBoolean()) {\n          // Read next char\n          if (VERBOSE) {\n            System.out.println(\"    new char\");\n          }\n          assertEquals(s.charAt(nextRead), buffer.get(nextRead));\n          nextRead++;\n          availCount++;\n        } else if (random.nextBoolean()) {\n          // Read previous char\n          int pos = _TestUtil.nextInt(random, nextRead-availCount, nextRead-1);\n          if (VERBOSE) {\n            System.out.println(\"    old char pos=\" + pos);\n          }\n          assertEquals(s.charAt(pos), buffer.get(pos));\n        } else {\n          // Read slice\n          int length;\n          if (availCount == 1) {\n            length = 1;\n          } else {\n            length = _TestUtil.nextInt(random, 1, availCount);\n          }\n          int start;\n          if (length == availCount) {\n            start = nextRead - availCount;\n          } else {\n            start = nextRead - availCount + random.nextInt(availCount-length);\n          }\n          if (VERBOSE) {\n            System.out.println(\"    slice start=\" + start + \" length=\" + length);\n          }\n          assertEquals(s.substring(start, start+length),\n                       new String(buffer.get(start, length)));\n        }\n\n        if (availCount > 0 && random.nextInt(20) == 17) {\n          final int toFree = random.nextInt(availCount);\n          if (VERBOSE) {\n            System.out.println(\"    free \" + toFree + \" (avail=\" + (availCount-toFree) + \")\");\n          }\n          buffer.freeBefore(nextRead-(availCount-toFree));\n          availCount -= toFree;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final int ITERS = atLeast(1000);\n    \n    RollingCharBuffer buffer = new RollingCharBuffer();\n\n    for(int iter=0;iter<ITERS;iter++) {\n      final int stringLen = random.nextBoolean() ? random.nextInt(50) : random.nextInt(20000);\n      final String s;\n      if (stringLen == 0) {\n        s = \"\";\n      } else {\n        s = _TestUtil.randomUnicodeString(random, stringLen);\n      }\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s.length()=\" + s.length());\n      }\n      buffer.reset(new StringReader(s));\n      int nextRead = 0;\n      int availCount = 0;\n      while(nextRead < s.length()) {\n        if (VERBOSE) {\n          System.out.println(\"  cycle nextRead=\" + nextRead + \" avail=\" + availCount);\n        }\n        if (availCount == 0 || random.nextBoolean()) {\n          // Read next char\n          if (VERBOSE) {\n            System.out.println(\"    new char\");\n          }\n          assertEquals(s.charAt(nextRead), buffer.get(nextRead));\n          nextRead++;\n          availCount++;\n        } else if (random.nextBoolean()) {\n          // Read previous char\n          int pos = _TestUtil.nextInt(random, nextRead-availCount, nextRead-1);\n          if (VERBOSE) {\n            System.out.println(\"    old char pos=\" + pos);\n          }\n          assertEquals(s.charAt(pos), buffer.get(pos));\n        } else {\n          // Read slice\n          int length;\n          if (availCount == 1) {\n            length = 1;\n          } else {\n            length = _TestUtil.nextInt(random, 1, availCount);\n          }\n          int start;\n          if (length == availCount) {\n            start = nextRead - availCount;\n          } else {\n            start = nextRead - availCount + random.nextInt(availCount-length);\n          }\n          if (VERBOSE) {\n            System.out.println(\"    slice start=\" + start + \" length=\" + length);\n          }\n          assertEquals(s.substring(start, start+length),\n                       new String(buffer.get(start, length)));\n        }\n\n        if (availCount > 0 && random.nextInt(20) == 17) {\n          final int toFree = random.nextInt(availCount);\n          if (VERBOSE) {\n            System.out.println(\"    free \" + toFree + \" (avail=\" + (availCount-toFree) + \")\");\n          }\n          buffer.freeBefore(nextRead-(availCount-toFree));\n          availCount -= toFree;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b496a51639fc02b2ff28d1b029b37e42f6c7627","date":1347885256,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/util/TestRollingCharBuffer#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestRollingCharBuffer#test().mjava","sourceNew":"  public void test() throws Exception {\n    final int ITERS = atLeast(1000);\n    \n    RollingCharBuffer buffer = new RollingCharBuffer();\n\n    Random random = random();\n    for(int iter=0;iter<ITERS;iter++) {\n      final int stringLen = random.nextBoolean() ? random.nextInt(50) : random.nextInt(20000);\n      final String s;\n      if (stringLen == 0) {\n        s = \"\";\n      } else {\n        s = _TestUtil.randomUnicodeString(random, stringLen);\n      }\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s.length()=\" + s.length());\n      }\n      buffer.reset(new StringReader(s));\n      int nextRead = 0;\n      int availCount = 0;\n      while(nextRead < s.length()) {\n        if (VERBOSE) {\n          System.out.println(\"  cycle nextRead=\" + nextRead + \" avail=\" + availCount);\n        }\n        if (availCount == 0 || random.nextBoolean()) {\n          // Read next char\n          if (VERBOSE) {\n            System.out.println(\"    new char\");\n          }\n          assertEquals(s.charAt(nextRead), buffer.get(nextRead));\n          nextRead++;\n          availCount++;\n        } else if (random.nextBoolean()) {\n          // Read previous char\n          int pos = _TestUtil.nextInt(random, nextRead-availCount, nextRead-1);\n          if (VERBOSE) {\n            System.out.println(\"    old char pos=\" + pos);\n          }\n          assertEquals(s.charAt(pos), buffer.get(pos));\n        } else {\n          // Read slice\n          int length;\n          if (availCount == 1) {\n            length = 1;\n          } else {\n            length = _TestUtil.nextInt(random, 1, availCount);\n          }\n          int start;\n          if (length == availCount) {\n            start = nextRead - availCount;\n          } else {\n            start = nextRead - availCount + random.nextInt(availCount-length);\n          }\n          if (VERBOSE) {\n            System.out.println(\"    slice start=\" + start + \" length=\" + length);\n          }\n          assertEquals(s.substring(start, start+length),\n                       new String(buffer.get(start, length)));\n        }\n\n        if (availCount > 0 && random.nextInt(20) == 17) {\n          final int toFree = random.nextInt(availCount);\n          if (VERBOSE) {\n            System.out.println(\"    free \" + toFree + \" (avail=\" + (availCount-toFree) + \")\");\n          }\n          buffer.freeBefore(nextRead-(availCount-toFree));\n          availCount -= toFree;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final int ITERS = atLeast(1000);\n    \n    RollingCharBuffer buffer = new RollingCharBuffer();\n\n    Random random = random();\n    for(int iter=0;iter<ITERS;iter++) {\n      final int stringLen = random.nextBoolean() ? random.nextInt(50) : random.nextInt(20000);\n      final String s;\n      if (stringLen == 0) {\n        s = \"\";\n      } else {\n        s = _TestUtil.randomUnicodeString(random, stringLen);\n      }\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s.length()=\" + s.length());\n      }\n      buffer.reset(new StringReader(s));\n      int nextRead = 0;\n      int availCount = 0;\n      while(nextRead < s.length()) {\n        if (VERBOSE) {\n          System.out.println(\"  cycle nextRead=\" + nextRead + \" avail=\" + availCount);\n        }\n        if (availCount == 0 || random.nextBoolean()) {\n          // Read next char\n          if (VERBOSE) {\n            System.out.println(\"    new char\");\n          }\n          assertEquals(s.charAt(nextRead), buffer.get(nextRead));\n          nextRead++;\n          availCount++;\n        } else if (random.nextBoolean()) {\n          // Read previous char\n          int pos = _TestUtil.nextInt(random, nextRead-availCount, nextRead-1);\n          if (VERBOSE) {\n            System.out.println(\"    old char pos=\" + pos);\n          }\n          assertEquals(s.charAt(pos), buffer.get(pos));\n        } else {\n          // Read slice\n          int length;\n          if (availCount == 1) {\n            length = 1;\n          } else {\n            length = _TestUtil.nextInt(random, 1, availCount);\n          }\n          int start;\n          if (length == availCount) {\n            start = nextRead - availCount;\n          } else {\n            start = nextRead - availCount + random.nextInt(availCount-length);\n          }\n          if (VERBOSE) {\n            System.out.println(\"    slice start=\" + start + \" length=\" + length);\n          }\n          assertEquals(s.substring(start, start+length),\n                       new String(buffer.get(start, length)));\n        }\n\n        if (availCount > 0 && random.nextInt(20) == 17) {\n          final int toFree = random.nextInt(availCount);\n          if (VERBOSE) {\n            System.out.println(\"    free \" + toFree + \" (avail=\" + (availCount-toFree) + \")\");\n          }\n          buffer.freeBefore(nextRead-(availCount-toFree));\n          availCount -= toFree;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0984ad47974c2d5d354519ddb2aa8358973a6271"],"0984ad47974c2d5d354519ddb2aa8358973a6271":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6b496a51639fc02b2ff28d1b029b37e42f6c7627":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["0984ad47974c2d5d354519ddb2aa8358973a6271"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6b496a51639fc02b2ff28d1b029b37e42f6c7627"]},"commit2Childs":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"0984ad47974c2d5d354519ddb2aa8358973a6271":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0984ad47974c2d5d354519ddb2aa8358973a6271"],"6b496a51639fc02b2ff28d1b029b37e42f6c7627":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["6b496a51639fc02b2ff28d1b029b37e42f6c7627"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}