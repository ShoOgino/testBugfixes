{"path":"lucene/test-framework/src/java/org/apache/lucene/index/RandomPostingsTester#verifyEnum(Random,ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","commits":[{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomPostingsTester#verifyEnum(Random,ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(Random random,\n                          ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random.nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  use liveDocs: \" + globalLiveDocs.length());\n      }\n    } else {\n      liveDocs = null;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            globalLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random.nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random.nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random.nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (LuceneTestCase.VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random.nextInt(10) == 7) {\n      stopAt = random.nextInt(expected.docFreq-1);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random.nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random, 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random.nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n\n    if (LuceneTestCase.VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random.nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random.nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random, 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random, 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random.nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random.nextDouble() <= freqAskChance) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random.nextInt(5) == 1) {\n          numPosToConsume = random.nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random.nextDouble() <= payloadCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random.nextDouble() <= offsetCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomPostingsTester#verifyEnum(Random,ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(Random random,\n                          ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random.nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  use liveDocs: \" + globalLiveDocs.length());\n      }\n    } else {\n      liveDocs = null;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            globalLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random.nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random.nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random.nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (LuceneTestCase.VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random.nextInt(10) == 7) {\n      stopAt = random.nextInt(expected.docFreq-1);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random.nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random, 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random.nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n\n    if (LuceneTestCase.VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random.nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random.nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random, 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random, 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random.nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random.nextDouble() <= freqAskChance) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random.nextInt(5) == 1) {\n          numPosToConsume = random.nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random.nextDouble() <= payloadCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random.nextDouble() <= offsetCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomPostingsTester#verifyEnum(Random,ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomPostingsTester#verifyEnum(Random,ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(Random random,\n                          ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random.nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random.nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random.nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (LuceneTestCase.VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random.nextInt(10) == 7) {\n      stopAt = random.nextInt(expected.docFreq-1);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random.nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random, 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random.nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n\n    if (LuceneTestCase.VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random.nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random.nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random, 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random, 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random.nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random.nextDouble() <= freqAskChance) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random.nextInt(5) == 1) {\n          numPosToConsume = random.nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random.nextDouble() <= payloadCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random.nextDouble() <= offsetCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(Random random,\n                          ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random.nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  use liveDocs: \" + globalLiveDocs.length());\n      }\n    } else {\n      liveDocs = null;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            globalLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random.nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random.nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random.nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (LuceneTestCase.VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random.nextInt(10) == 7) {\n      stopAt = random.nextInt(expected.docFreq-1);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random.nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random, 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random.nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n\n    if (LuceneTestCase.VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random.nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random.nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random, 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random, 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random.nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random.nextDouble() <= freqAskChance) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random.nextInt(5) == 1) {\n          numPosToConsume = random.nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random.nextDouble() <= payloadCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random.nextDouble() <= offsetCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"622a708571e534680618b3c5e0c28ac539a47776","date":1517406892,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomPostingsTester#verifyEnum(Random,ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomPostingsTester#verifyEnum(Random,ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(Random random,\n                          ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random.nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random.nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random.nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (LuceneTestCase.VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random.nextInt(10) == 7) {\n      stopAt = random.nextInt(expected.docFreq-1);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random.nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random, 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random.nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n\n    if (LuceneTestCase.VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random.nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random.nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random, 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random, 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random.nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random.nextDouble() <= freqAskChance) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random.nextInt(5) == 1) {\n          numPosToConsume = random.nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random.nextDouble() <= payloadCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random.nextDouble() <= offsetCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n\n    if (options.contains(Option.SKIPPING)) {\n      final IntToLongFunction docToNorm;\n      if (fieldInfo.hasNorms()) {\n        docToNorm = DOC_TO_NORM;\n      } else {\n        docToNorm = doc -> 1L;\n      }\n      for (int s = 0; s < 3; ++s) {\n        final int scoreMode = s;\n        SimScorer scorer = new SimScorer(field) {\n          @Override\n          public float score(float freq, long norm) {\n            switch (scoreMode) {\n              case 0:\n                return freq; // make sure the postings record the best freq\n              case 1:\n                return 1f / norm; // make sure the postings record the best norm\n              default:\n                return freq - norm + MAX_NORM; // now a combination that could make intermediate pairs more competitive\n            }\n          }\n        };\n\n        // First check max scores and block uptos\n        int max = -1;\n        float maxScore = 0;\n        int flags = PostingsEnum.FREQS;\n        if (doCheckPositions) {\n          flags |= PostingsEnum.POSITIONS;\n          if (doCheckOffsets) {\n            flags |= PostingsEnum.OFFSETS;\n          }\n          if (doCheckPayloads) {\n            flags |= PostingsEnum.PAYLOADS;\n          }\n        }\n\n        ImpactsEnum impacts = termsEnum.impacts(scorer, flags);\n        PostingsEnum postings = termsEnum.postings(null, flags);\n        for (int doc = impacts.nextDoc(); ; doc = impacts.nextDoc()) {\n          assertEquals(postings.nextDoc(), doc);\n          if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n            break;\n          }\n          int freq = postings.freq();\n          assertEquals(\"freq is wrong\", freq, impacts.freq());\n          for (int i = 0; i < freq; ++i) {\n            int pos = postings.nextPosition();\n            assertEquals(\"position is wrong\", pos, impacts.nextPosition());\n            if (doCheckOffsets) {\n              assertEquals(\"startOffset is wrong\", postings.startOffset(), impacts.startOffset());\n              assertEquals(\"endOffset is wrong\", postings.endOffset(), impacts.endOffset());\n            }\n            if (doCheckPayloads) {\n              assertEquals(\"payload is wrong\", postings.getPayload(), impacts.getPayload());\n            }\n          }\n          if (doc > max) {\n            max = impacts.advanceShallow(doc);\n            assertTrue(max >= doc);\n            maxScore = impacts.getMaxScore(max);\n          }\n          assertEquals(max, impacts.advanceShallow(doc));\n          assertTrue(scorer.score(impacts.freq(), docToNorm.applyAsLong(doc)) <= maxScore);\n        }\n\n        // Now check advancing\n        impacts = termsEnum.impacts(scorer, flags);\n        postings = termsEnum.postings(postings, flags);\n\n        max = -1;\n        while (true) {\n          int doc = impacts.docID();\n          boolean advance;\n          int target;\n          if (random.nextBoolean()) {\n            advance = false;\n            target = doc + 1;\n          } else {\n            advance = true;\n            int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc);\n            target = impacts.docID() + delta;\n          }\n\n          if (target > max && random.nextBoolean()) {\n            int delta = Math.min(random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - target);\n            max = target + delta;\n            int m = impacts.advanceShallow(target);\n            assertTrue(m >= target);\n            maxScore = impacts.getMaxScore(max);\n          }\n\n          if (advance) {\n            doc = impacts.advance(target);\n          } else {\n            doc = impacts.nextDoc();\n          }\n\n          assertEquals(postings.advance(target), doc);\n          if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n            break;\n          }\n          int freq = postings.freq();\n          assertEquals(\"freq is wrong\", freq, impacts.freq());\n          for (int i = 0; i < postings.freq(); ++i) {\n            int pos = postings.nextPosition();\n            assertEquals(\"position is wrong\", pos, impacts.nextPosition());\n            if (doCheckOffsets) {\n              assertEquals(\"startOffset is wrong\", postings.startOffset(), impacts.startOffset());\n              assertEquals(\"endOffset is wrong\", postings.endOffset(), impacts.endOffset());\n            }\n            if (doCheckPayloads) {\n              assertEquals(\"payload is wrong\", postings.getPayload(), impacts.getPayload());\n            }\n          }\n\n          if (doc > max) {\n            int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc);\n            max = doc + delta;\n            int m = impacts.advanceShallow(doc);\n            assertTrue(m >= doc);\n            maxScore = impacts.getMaxScore(max);\n          }\n\n          float score = scorer.score(impacts.freq(), docToNorm.applyAsLong(doc));\n          assertTrue(score <= maxScore);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(Random random,\n                          ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random.nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random.nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random.nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (LuceneTestCase.VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random.nextInt(10) == 7) {\n      stopAt = random.nextInt(expected.docFreq-1);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random.nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random, 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random.nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n\n    if (LuceneTestCase.VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random.nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random.nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random, 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random, 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random.nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random.nextDouble() <= freqAskChance) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random.nextInt(5) == 1) {\n          numPosToConsume = random.nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random.nextDouble() <= payloadCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random.nextDouble() <= offsetCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a692be6c8e120ef6dbfcd5dde3de42815813cd2","date":1525265372,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomPostingsTester#verifyEnum(Random,ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomPostingsTester#verifyEnum(Random,ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(Random random,\n                          ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random.nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random.nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random.nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (LuceneTestCase.VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random.nextInt(10) == 7) {\n      stopAt = random.nextInt(expected.docFreq-1);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random.nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random, 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random.nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n\n    if (LuceneTestCase.VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random.nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random.nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random, 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random, 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random.nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random.nextDouble() <= freqAskChance) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random.nextInt(5) == 1) {\n          numPosToConsume = random.nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random.nextDouble() <= payloadCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random.nextDouble() <= offsetCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n\n    if (options.contains(Option.SKIPPING)) {\n      final IntToLongFunction docToNorm;\n      if (fieldInfo.hasNorms()) {\n        docToNorm = DOC_TO_NORM;\n      } else {\n        docToNorm = doc -> 1L;\n      }\n\n      // First check impacts and block uptos\n      int max = -1;\n      List<Impact> impactsCopy = null;\n      int flags = PostingsEnum.FREQS;\n      if (doCheckPositions) {\n        flags |= PostingsEnum.POSITIONS;\n        if (doCheckOffsets) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (doCheckPayloads) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n      }\n\n      ImpactsEnum impactsEnum = termsEnum.impacts(flags);\n      PostingsEnum postings = termsEnum.postings(null, flags);\n      for (int doc = impactsEnum.nextDoc(); ; doc = impactsEnum.nextDoc()) {\n        assertEquals(postings.nextDoc(), doc);\n        if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n        int freq = postings.freq();\n        assertEquals(\"freq is wrong\", freq, impactsEnum.freq());\n        for (int i = 0; i < freq; ++i) {\n          int pos = postings.nextPosition();\n          assertEquals(\"position is wrong\", pos, impactsEnum.nextPosition());\n          if (doCheckOffsets) {\n            assertEquals(\"startOffset is wrong\", postings.startOffset(), impactsEnum.startOffset());\n            assertEquals(\"endOffset is wrong\", postings.endOffset(), impactsEnum.endOffset());\n          }\n          if (doCheckPayloads) {\n            assertEquals(\"payload is wrong\", postings.getPayload(), impactsEnum.getPayload());\n          }\n        }\n        if (doc > max) {\n          impactsEnum.advanceShallow(doc);\n          Impacts impacts = impactsEnum.getImpacts();\n          CheckIndex.checkImpacts(impacts, doc);\n          impactsCopy = impacts.getImpacts(0)\n              .stream()\n              .map(i -> new Impact(i.freq, i.norm))\n              .collect(Collectors.toList());\n        }\n        freq = impactsEnum.freq();\n        long norm = docToNorm.applyAsLong(doc);\n        int idx = Collections.binarySearch(impactsCopy, new Impact(freq, norm), Comparator.comparing(i -> i.freq));\n        if (idx < 0) {\n          idx = -1 - idx;\n        }\n        assertTrue(\"Got \" + new Impact(freq, norm) + \" in postings, but no impact triggers equal or better scores in \" + impactsCopy,\n            idx <= impactsCopy.size() && impactsCopy.get(idx).norm <= norm);\n      }\n\n      // Now check advancing\n      impactsEnum = termsEnum.impacts(flags);\n      postings = termsEnum.postings(postings, flags);\n\n      max = -1;\n      while (true) {\n        int doc = impactsEnum.docID();\n        boolean advance;\n        int target;\n        if (random.nextBoolean()) {\n          advance = false;\n          target = doc + 1;\n        } else {\n          advance = true;\n          int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc);\n          target = impactsEnum.docID() + delta;\n        }\n\n        if (target > max && random.nextBoolean()) {\n          int delta = Math.min(random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - target);\n          max = target + delta;\n          \n          impactsEnum.advanceShallow(target);\n          Impacts impacts = impactsEnum.getImpacts();\n          CheckIndex.checkImpacts(impacts, target);\n          impactsCopy = Collections.singletonList(new Impact(Integer.MAX_VALUE, 1L));\n          for (int level = 0; level < impacts.numLevels(); ++level) {\n            if (impacts.getDocIdUpTo(level) >= max) {\n              impactsCopy = impacts.getImpacts(level)\n                  .stream()\n                  .map(i -> new Impact(i.freq, i.norm))\n                  .collect(Collectors.toList());\n              break;\n            }\n          }\n        }\n\n        if (advance) {\n          doc = impactsEnum.advance(target);\n        } else {\n          doc = impactsEnum.nextDoc();\n        }\n\n        assertEquals(postings.advance(target), doc);\n        if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n        int freq = postings.freq();\n        assertEquals(\"freq is wrong\", freq, impactsEnum.freq());\n        for (int i = 0; i < postings.freq(); ++i) {\n          int pos = postings.nextPosition();\n          assertEquals(\"position is wrong\", pos, impactsEnum.nextPosition());\n          if (doCheckOffsets) {\n            assertEquals(\"startOffset is wrong\", postings.startOffset(), impactsEnum.startOffset());\n            assertEquals(\"endOffset is wrong\", postings.endOffset(), impactsEnum.endOffset());\n          }\n          if (doCheckPayloads) {\n            assertEquals(\"payload is wrong\", postings.getPayload(), impactsEnum.getPayload());\n          }\n        }\n\n        if (doc > max) {\n          int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc);\n          max = doc + delta;\n          Impacts impacts = impactsEnum.getImpacts();\n          CheckIndex.checkImpacts(impacts, doc);\n          impactsCopy = Collections.singletonList(new Impact(Integer.MAX_VALUE, 1L));\n          for (int level = 0; level < impacts.numLevels(); ++level) {\n            if (impacts.getDocIdUpTo(level) >= max) {\n              impactsCopy = impacts.getImpacts(level)\n                  .stream()\n                  .map(i -> new Impact(i.freq, i.norm))\n                  .collect(Collectors.toList());\n              break;\n            }\n          }\n        }\n\n        freq = impactsEnum.freq();\n        long norm = docToNorm.applyAsLong(doc);\n        int idx = Collections.binarySearch(impactsCopy, new Impact(freq, norm), Comparator.comparing(i -> i.freq));\n        if (idx < 0) {\n          idx = -1 - idx;\n        }\n        assertTrue(\"Got \" + new Impact(freq, norm) + \" in postings, but no impact triggers equal or better scores in \" + impactsCopy,\n            idx <= impactsCopy.size() && impactsCopy.get(idx).norm <= norm);\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(Random random,\n                          ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random.nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random.nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random.nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (LuceneTestCase.VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random.nextInt(10) == 7) {\n      stopAt = random.nextInt(expected.docFreq-1);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random.nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random, 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random.nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n\n    if (LuceneTestCase.VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random.nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random.nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random, 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random, 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random.nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random.nextDouble() <= freqAskChance) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random.nextInt(5) == 1) {\n          numPosToConsume = random.nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random.nextDouble() <= payloadCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random.nextDouble() <= offsetCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n\n    if (options.contains(Option.SKIPPING)) {\n      final IntToLongFunction docToNorm;\n      if (fieldInfo.hasNorms()) {\n        docToNorm = DOC_TO_NORM;\n      } else {\n        docToNorm = doc -> 1L;\n      }\n      for (int s = 0; s < 3; ++s) {\n        final int scoreMode = s;\n        SimScorer scorer = new SimScorer(field) {\n          @Override\n          public float score(float freq, long norm) {\n            switch (scoreMode) {\n              case 0:\n                return freq; // make sure the postings record the best freq\n              case 1:\n                return 1f / norm; // make sure the postings record the best norm\n              default:\n                return freq - norm + MAX_NORM; // now a combination that could make intermediate pairs more competitive\n            }\n          }\n        };\n\n        // First check max scores and block uptos\n        int max = -1;\n        float maxScore = 0;\n        int flags = PostingsEnum.FREQS;\n        if (doCheckPositions) {\n          flags |= PostingsEnum.POSITIONS;\n          if (doCheckOffsets) {\n            flags |= PostingsEnum.OFFSETS;\n          }\n          if (doCheckPayloads) {\n            flags |= PostingsEnum.PAYLOADS;\n          }\n        }\n\n        ImpactsEnum impacts = termsEnum.impacts(scorer, flags);\n        PostingsEnum postings = termsEnum.postings(null, flags);\n        for (int doc = impacts.nextDoc(); ; doc = impacts.nextDoc()) {\n          assertEquals(postings.nextDoc(), doc);\n          if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n            break;\n          }\n          int freq = postings.freq();\n          assertEquals(\"freq is wrong\", freq, impacts.freq());\n          for (int i = 0; i < freq; ++i) {\n            int pos = postings.nextPosition();\n            assertEquals(\"position is wrong\", pos, impacts.nextPosition());\n            if (doCheckOffsets) {\n              assertEquals(\"startOffset is wrong\", postings.startOffset(), impacts.startOffset());\n              assertEquals(\"endOffset is wrong\", postings.endOffset(), impacts.endOffset());\n            }\n            if (doCheckPayloads) {\n              assertEquals(\"payload is wrong\", postings.getPayload(), impacts.getPayload());\n            }\n          }\n          if (doc > max) {\n            max = impacts.advanceShallow(doc);\n            assertTrue(max >= doc);\n            maxScore = impacts.getMaxScore(max);\n          }\n          assertEquals(max, impacts.advanceShallow(doc));\n          assertTrue(scorer.score(impacts.freq(), docToNorm.applyAsLong(doc)) <= maxScore);\n        }\n\n        // Now check advancing\n        impacts = termsEnum.impacts(scorer, flags);\n        postings = termsEnum.postings(postings, flags);\n\n        max = -1;\n        while (true) {\n          int doc = impacts.docID();\n          boolean advance;\n          int target;\n          if (random.nextBoolean()) {\n            advance = false;\n            target = doc + 1;\n          } else {\n            advance = true;\n            int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc);\n            target = impacts.docID() + delta;\n          }\n\n          if (target > max && random.nextBoolean()) {\n            int delta = Math.min(random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - target);\n            max = target + delta;\n            int m = impacts.advanceShallow(target);\n            assertTrue(m >= target);\n            maxScore = impacts.getMaxScore(max);\n          }\n\n          if (advance) {\n            doc = impacts.advance(target);\n          } else {\n            doc = impacts.nextDoc();\n          }\n\n          assertEquals(postings.advance(target), doc);\n          if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n            break;\n          }\n          int freq = postings.freq();\n          assertEquals(\"freq is wrong\", freq, impacts.freq());\n          for (int i = 0; i < postings.freq(); ++i) {\n            int pos = postings.nextPosition();\n            assertEquals(\"position is wrong\", pos, impacts.nextPosition());\n            if (doCheckOffsets) {\n              assertEquals(\"startOffset is wrong\", postings.startOffset(), impacts.startOffset());\n              assertEquals(\"endOffset is wrong\", postings.endOffset(), impacts.endOffset());\n            }\n            if (doCheckPayloads) {\n              assertEquals(\"payload is wrong\", postings.getPayload(), impacts.getPayload());\n            }\n          }\n\n          if (doc > max) {\n            int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc);\n            max = doc + delta;\n            int m = impacts.advanceShallow(doc);\n            assertTrue(m >= doc);\n            maxScore = impacts.getMaxScore(max);\n          }\n\n          float score = scorer.score(impacts.freq(), docToNorm.applyAsLong(doc));\n          assertTrue(score <= maxScore);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["3e8715d826e588419327562287d5d6a8040d63d6"],"6a692be6c8e120ef6dbfcd5dde3de42815813cd2":["622a708571e534680618b3c5e0c28ac539a47776"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3e8715d826e588419327562287d5d6a8040d63d6"],"622a708571e534680618b3c5e0c28ac539a47776":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"3e8715d826e588419327562287d5d6a8040d63d6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6a692be6c8e120ef6dbfcd5dde3de42815813cd2"]},"commit2Childs":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["622a708571e534680618b3c5e0c28ac539a47776"],"6a692be6c8e120ef6dbfcd5dde3de42815813cd2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"622a708571e534680618b3c5e0c28ac539a47776":["6a692be6c8e120ef6dbfcd5dde3de42815813cd2"],"3e8715d826e588419327562287d5d6a8040d63d6":["0f4464508ee83288c8c4585b533f9faaa93aa314","d2638f781be724518ff6c2263d14a48cf6e68017"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}