{"path":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHJdbcTestCase#modifySomePeople().mjava","commits":[{"id":"baf341ad3a1a8fb73fb37091af85f8aef0398367","date":1352222680,"type":0,"author":"James Dyer","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHJdbcTestCase#modifySomePeople().mjava","pathOld":"/dev/null","sourceNew":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>(); \n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null; \n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    //One second in the future ensures a change time after the last import (DIH uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    try {    \n      conn = DriverManager.getConnection(\"jdbc:hsqldb:mem:.\");    \n      change = conn.prepareStatement(\"update people set name=?, last_modified=? where id=?\");  \n      delete  = conn.prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn.prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'NEW',?)\");\n      for(int i=0 ; i<numberToChange ; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if(!changeSet.contains(id) && !deleteSet.contains(id)) {\n            boolean changeDontDelete = random().nextBoolean();\n            if(changeDontDelete) {\n              changeSet.add(id);\n              change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n              change.setTimestamp(2, theTime);\n              change.setInt(3, id);\n              Assert.assertEquals(1, change.executeUpdate());\n            } else {\n              deleteSet.add(id);\n              delete.setTimestamp(1, theTime);\n              delete.setInt(2, id);\n              Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for(int i=0 ; i<numberToAdd ; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id+1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if(!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try { change.close(); } catch(Exception ex) { }\n      try { conn.close(); } catch(Exception ex) { }\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys=changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys=deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys=addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78bba2225c30df6990ac27a75743069e928ef81d","date":1352741580,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHJdbcTestCase#modifySomePeople().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHJdbcTestCase#modifySomePeople().mjava","sourceNew":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>(); \n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null; \n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    //One second in the future ensures a change time after the last import (DIH uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    try {    \n      conn = newConnection();\n      change = conn.prepareStatement(\"update people set name=?, last_modified=? where id=?\");  \n      delete  = conn.prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn.prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for(int i=0 ; i<numberToChange ; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if(!changeSet.contains(id) && !deleteSet.contains(id)) {\n            boolean changeDontDelete = random().nextBoolean();\n            if(changeDontDelete) {\n              changeSet.add(id);\n              change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n              change.setTimestamp(2, theTime);\n              change.setInt(3, id);\n              Assert.assertEquals(1, change.executeUpdate());\n            } else {\n              deleteSet.add(id);\n              delete.setTimestamp(1, theTime);\n              delete.setInt(2, id);\n              Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for(int i=0 ; i<numberToAdd ; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id+1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if(!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try { change.close(); } catch(Exception ex) { }\n      try { conn.close(); } catch(Exception ex) { }\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys=changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys=deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys=addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","sourceOld":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>(); \n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null; \n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    //One second in the future ensures a change time after the last import (DIH uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    try {    \n      conn = DriverManager.getConnection(\"jdbc:hsqldb:mem:.\");    \n      change = conn.prepareStatement(\"update people set name=?, last_modified=? where id=?\");  \n      delete  = conn.prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn.prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'NEW',?)\");\n      for(int i=0 ; i<numberToChange ; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if(!changeSet.contains(id) && !deleteSet.contains(id)) {\n            boolean changeDontDelete = random().nextBoolean();\n            if(changeDontDelete) {\n              changeSet.add(id);\n              change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n              change.setTimestamp(2, theTime);\n              change.setInt(3, id);\n              Assert.assertEquals(1, change.executeUpdate());\n            } else {\n              deleteSet.add(id);\n              delete.setTimestamp(1, theTime);\n              delete.setInt(2, id);\n              Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for(int i=0 ; i<numberToAdd ; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id+1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if(!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try { change.close(); } catch(Exception ex) { }\n      try { conn.close(); } catch(Exception ex) { }\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys=changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys=deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys=addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b4804614e0358954d5d9f51128fcf3cd79e6e25b","date":1352831451,"type":5,"author":"James Dyer","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractSqlEntityProcessorTestCase#modifySomePeople().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHJdbcTestCase#modifySomePeople().mjava","sourceNew":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>();\n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null;\n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    // One second in the future ensures a change time after the last import (DIH\n    // uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    try {\n      conn = newConnection();\n      change = conn\n          .prepareStatement(\"update people set name=?, last_modified=? where id=?\");\n      delete = conn\n          .prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn\n          .prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for (int i = 0; i < numberToChange; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if (!changeSet.contains(id) && !deleteSet.contains(id)) {\n          boolean changeDontDelete = random().nextBoolean();\n          if (changeDontDelete) {\n            changeSet.add(id);\n            change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n            change.setTimestamp(2, theTime);\n            change.setInt(3, id);\n            Assert.assertEquals(1, change.executeUpdate());\n          } else {\n            deleteSet.add(id);\n            delete.setTimestamp(1, theTime);\n            delete.setInt(2, id);\n            Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for (int i = 0; i < numberToAdd; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id + 1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if (!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try {\n        change.close();\n      } catch (Exception ex) {}\n      try {\n        conn.close();\n      } catch (Exception ex) {}\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys = changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys = deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys = addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","sourceOld":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>(); \n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null; \n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    //One second in the future ensures a change time after the last import (DIH uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    try {    \n      conn = newConnection();\n      change = conn.prepareStatement(\"update people set name=?, last_modified=? where id=?\");  \n      delete  = conn.prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn.prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'ZZ',?)\");\n      for(int i=0 ; i<numberToChange ; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if(!changeSet.contains(id) && !deleteSet.contains(id)) {\n            boolean changeDontDelete = random().nextBoolean();\n            if(changeDontDelete) {\n              changeSet.add(id);\n              change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n              change.setTimestamp(2, theTime);\n              change.setInt(3, id);\n              Assert.assertEquals(1, change.executeUpdate());\n            } else {\n              deleteSet.add(id);\n              delete.setTimestamp(1, theTime);\n              delete.setInt(2, id);\n              Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for(int i=0 ; i<numberToAdd ; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id+1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if(!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try { change.close(); } catch(Exception ex) { }\n      try { conn.close(); } catch(Exception ex) { }\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys=changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys=deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys=addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHJdbcTestCase#modifySomePeople().mjava","sourceNew":null,"sourceOld":"  public IntChanges modifySomePeople() throws Exception {\n    underlyingDataModified = true;\n    int numberToChange = random().nextInt(people.length + 1);\n    Set<Integer> changeSet = new HashSet<Integer>(); \n    Set<Integer> deleteSet = new HashSet<Integer>();\n    Set<Integer> addSet = new HashSet<Integer>();\n    Connection conn = null;\n    PreparedStatement change = null; \n    PreparedStatement delete = null;\n    PreparedStatement add = null;\n    //One second in the future ensures a change time after the last import (DIH uses second precision only)\n    Timestamp theTime = new Timestamp(System.currentTimeMillis() + 1000);\n    try {    \n      conn = DriverManager.getConnection(\"jdbc:hsqldb:mem:.\");    \n      change = conn.prepareStatement(\"update people set name=?, last_modified=? where id=?\");  \n      delete  = conn.prepareStatement(\"update people set deleted='Y', last_modified=? where id=?\");\n      add = conn.prepareStatement(\"insert into people (id,name,country_code,last_modified) values (?,?,'NEW',?)\");\n      for(int i=0 ; i<numberToChange ; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        if(!changeSet.contains(id) && !deleteSet.contains(id)) {\n            boolean changeDontDelete = random().nextBoolean();\n            if(changeDontDelete) {\n              changeSet.add(id);\n              change.setString(1, \"MODIFIED \" + people[tryIndex][1]);\n              change.setTimestamp(2, theTime);\n              change.setInt(3, id);\n              Assert.assertEquals(1, change.executeUpdate());\n            } else {\n              deleteSet.add(id);\n              delete.setTimestamp(1, theTime);\n              delete.setInt(2, id);\n              Assert.assertEquals(1, delete.executeUpdate());\n          }\n        }\n      }\n      int numberToAdd = random().nextInt(3);\n      for(int i=0 ; i<numberToAdd ; i++) {\n        int tryIndex = random().nextInt(people.length);\n        Integer id = (Integer) people[tryIndex][0];\n        Integer newId = id+1000;\n        String newDesc = \"ADDED \" + people[tryIndex][1];\n        if(!addSet.contains(newId)) {\n          addSet.add(newId);\n          add.setInt(1, newId);\n          add.setString(2, newDesc);\n          add.setTimestamp(3, theTime);\n          Assert.assertEquals(1, add.executeUpdate());\n        }\n      }\n      conn.commit();\n    } catch (SQLException e) {\n      throw e;\n    } finally {\n      try { change.close(); } catch(Exception ex) { }\n      try { conn.close(); } catch(Exception ex) { }\n    }\n    IntChanges c = new IntChanges();\n    c.changedKeys=changeSet.toArray(new Integer[changeSet.size()]);\n    c.deletedKeys=deleteSet.toArray(new Integer[deleteSet.size()]);\n    c.addedKeys=addSet.toArray(new Integer[addSet.size()]);\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b4804614e0358954d5d9f51128fcf3cd79e6e25b":["78bba2225c30df6990ac27a75743069e928ef81d"],"78bba2225c30df6990ac27a75743069e928ef81d":["baf341ad3a1a8fb73fb37091af85f8aef0398367"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["baf341ad3a1a8fb73fb37091af85f8aef0398367","b4804614e0358954d5d9f51128fcf3cd79e6e25b"],"baf341ad3a1a8fb73fb37091af85f8aef0398367":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b4804614e0358954d5d9f51128fcf3cd79e6e25b"]},"commit2Childs":{"b4804614e0358954d5d9f51128fcf3cd79e6e25b":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"78bba2225c30df6990ac27a75743069e928ef81d":["b4804614e0358954d5d9f51128fcf3cd79e6e25b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["baf341ad3a1a8fb73fb37091af85f8aef0398367"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"baf341ad3a1a8fb73fb37091af85f8aef0398367":["78bba2225c30df6990ac27a75743069e928ef81d","407687e67faf6e1f02a211ca078d8e3eed631027"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}