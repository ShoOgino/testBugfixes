{"path":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","commits":[{"id":"693a4c06f749274d170a2e87d4afb2709a810f46","date":1060700703,"type":0,"author":"Scott Ganyo","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","pathOld":"/dev/null","sourceNew":"  /** Attempt to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n     boolean locked = obtain();\n     int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n     int sleepCount = 0;\n     while (!locked) {\n         if (++sleepCount == maxSleepCount) {\n             throw new IOException(\"Lock obtain timed out\");\n         }\n         try {\n             Thread.sleep(LOCK_POLL_INTERVAL);\n         } catch (InterruptedException e) {\n             throw new IOException(e.toString());\n         }\n         locked = obtain();\n     }\n     return locked;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1b54a9bc667895a2095a886184bf69a3179e63df","ca4c6ae8e5160adba89ead25d5776d494bbcd17f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"22f869833b37788422366a853701b288987bd424","date":1066055387,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","pathOld":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","sourceNew":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (++sleepCount == maxSleepCount) {\n        throw new IOException(\"Lock obtain timed out\");\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","sourceOld":"  /** Attempt to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n     boolean locked = obtain();\n     int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n     int sleepCount = 0;\n     while (!locked) {\n         if (++sleepCount == maxSleepCount) {\n             throw new IOException(\"Lock obtain timed out\");\n         }\n         try {\n             Thread.sleep(LOCK_POLL_INTERVAL);\n         } catch (InterruptedException e) {\n             throw new IOException(e.toString());\n         }\n         locked = obtain();\n     }\n     return locked;\n  }\n\n","bugFix":null,"bugIntro":["ca4c6ae8e5160adba89ead25d5776d494bbcd17f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e1425bf3470c9f39dfa4622997c93e061da354a0","date":1084106507,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","pathOld":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","sourceNew":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (++sleepCount == maxSleepCount) {\n        String s = \"Lock obtain timed out\";\n        if (lockFile != null) {\n            s += \", lock file =\" + lockFile.getAbsolutePath();\n        }\n        throw new IOException(s);\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","sourceOld":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (++sleepCount == maxSleepCount) {\n        throw new IOException(\"Lock obtain timed out\");\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85540c3d0b253bd20f0bbe6792106fef9a9b1548","date":1084232816,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","pathOld":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","sourceNew":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (++sleepCount == maxSleepCount) {\n        String s = \"Lock obtain timed out\";\n        if (lockName != null) {\n            s += \", lock name =\" + lockName;\n        }\n        throw new IOException(s);\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","sourceOld":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (++sleepCount == maxSleepCount) {\n        String s = \"Lock obtain timed out\";\n        if (lockFile != null) {\n            s += \", lock file =\" + lockFile.getAbsolutePath();\n        }\n        throw new IOException(s);\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2993c486daad7c2eadd1973c500ea7b570928398","date":1084297408,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","pathOld":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","sourceNew":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (++sleepCount == maxSleepCount) {\n        throw new IOException(\"Lock obtain timed out: \" + this.toString());\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","sourceOld":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (++sleepCount == maxSleepCount) {\n        String s = \"Lock obtain timed out\";\n        if (lockName != null) {\n            s += \", lock name =\" + lockName;\n        }\n        throw new IOException(s);\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee59b6a9c0bfc2edce862231f9798a183ed1fcb3","date":1117656658,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","pathOld":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","sourceNew":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (sleepCount++ == maxSleepCount) {\n        throw new IOException(\"Lock obtain timed out: \" + this.toString());\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","sourceOld":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (++sleepCount == maxSleepCount) {\n        throw new IOException(\"Lock obtain timed out: \" + this.toString());\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","bugFix":null,"bugIntro":["ca4c6ae8e5160adba89ead25d5776d494bbcd17f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f118a5ec962b5e2658d313e6f4e6f28faa3bcb39","date":1161023282,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","pathOld":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","sourceNew":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n    failureReason = null;\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (sleepCount++ == maxSleepCount) {\n        String reason = \"Lock obtain timed out: \" + this.toString();\n        if (failureReason != null) {\n          reason += \": \" + failureReason;\n        }\n        IOException e = new IOException(reason);\n        if (failureReason != null) {\n          e.initCause(failureReason);\n        }\n        throw e;\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","sourceOld":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (sleepCount++ == maxSleepCount) {\n        throw new IOException(\"Lock obtain timed out: \" + this.toString());\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","bugFix":null,"bugIntro":["1b54a9bc667895a2095a886184bf69a3179e63df"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b54a9bc667895a2095a886184bf69a3179e63df","date":1172088096,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","pathOld":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","sourceNew":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws LockObtainFailedException if lock wait times out\n   * @throws IOException if obtain() throws IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {\n    failureReason = null;\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (sleepCount++ == maxSleepCount) {\n        String reason = \"Lock obtain timed out: \" + this.toString();\n        if (failureReason != null) {\n          reason += \": \" + failureReason;\n        }\n        LockObtainFailedException e = new LockObtainFailedException(reason);\n        if (failureReason != null) {\n          e.initCause(failureReason);\n        }\n        throw e;\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","sourceOld":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws IOException if lock wait times out or obtain() throws an IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws IOException {\n    failureReason = null;\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (sleepCount++ == maxSleepCount) {\n        String reason = \"Lock obtain timed out: \" + this.toString();\n        if (failureReason != null) {\n          reason += \": \" + failureReason;\n        }\n        IOException e = new IOException(reason);\n        if (failureReason != null) {\n          e.initCause(failureReason);\n        }\n        throw e;\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","bugFix":["693a4c06f749274d170a2e87d4afb2709a810f46","f118a5ec962b5e2658d313e6f4e6f28faa3bcb39"],"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ca4c6ae8e5160adba89ead25d5776d494bbcd17f","date":1194702198,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","pathOld":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","sourceNew":"  /** Attempts to obtain an exclusive lock within amount of\n   *  time given. Polls once per {@link #LOCK_POLL_INTERVAL}\n   *  (currently 1000) milliseconds until lockWaitTimeout is\n   *  passed.\n   * @param lockWaitTimeout length of time to wait in\n   *        milliseconds or {@link\n   *        #LOCK_OBTAIN_WAIT_FOREVER} to retry forever\n   * @return true if lock was obtained\n   * @throws LockObtainFailedException if lock wait times out\n   * @throws IllegalArgumentException if lockWaitTimeout is\n   *         out of bounds\n   * @throws IOException if obtain() throws IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {\n    failureReason = null;\n    boolean locked = obtain();\n    if (lockWaitTimeout < 0 && lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER)\n      throw new IllegalArgumentException(\"lockWaitTimeout should be LOCK_OBTAIN_WAIT_FOREVER or a non-negative number (got \" + lockWaitTimeout + \")\");\n\n    long maxSleepCount = lockWaitTimeout / LOCK_POLL_INTERVAL;\n    long sleepCount = 0;\n    while (!locked) {\n      if (lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER && sleepCount++ >= maxSleepCount) {\n        String reason = \"Lock obtain timed out: \" + this.toString();\n        if (failureReason != null) {\n          reason += \": \" + failureReason;\n        }\n        LockObtainFailedException e = new LockObtainFailedException(reason);\n        if (failureReason != null) {\n          e.initCause(failureReason);\n        }\n        throw e;\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","sourceOld":"  /** Attempts to obtain an exclusive lock within amount\n   *  of time given. Currently polls once per second until\n   *  lockWaitTimeout is passed.\n   * @param lockWaitTimeout length of time to wait in ms\n   * @return true if lock was obtained\n   * @throws LockObtainFailedException if lock wait times out\n   * @throws IOException if obtain() throws IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {\n    failureReason = null;\n    boolean locked = obtain();\n    int maxSleepCount = (int)(lockWaitTimeout / LOCK_POLL_INTERVAL);\n    int sleepCount = 0;\n    while (!locked) {\n      if (sleepCount++ == maxSleepCount) {\n        String reason = \"Lock obtain timed out: \" + this.toString();\n        if (failureReason != null) {\n          reason += \": \" + failureReason;\n        }\n        LockObtainFailedException e = new LockObtainFailedException(reason);\n        if (failureReason != null) {\n          e.initCause(failureReason);\n        }\n        throw e;\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","bugFix":["ee59b6a9c0bfc2edce862231f9798a183ed1fcb3","22f869833b37788422366a853701b288987bd424","693a4c06f749274d170a2e87d4afb2709a810f46"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba7fd1181f778e9954547e8e6a47587ebf08e3fb","date":1238267455,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","pathOld":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","sourceNew":"  /** Attempts to obtain an exclusive lock within amount of\n   *  time given. Polls once per {@link #LOCK_POLL_INTERVAL}\n   *  (currently 1000) milliseconds until lockWaitTimeout is\n   *  passed.\n   * @param lockWaitTimeout length of time to wait in\n   *        milliseconds or {@link\n   *        #LOCK_OBTAIN_WAIT_FOREVER} to retry forever\n   * @return true if lock was obtained\n   * @throws LockObtainFailedException if lock wait times out\n   * @throws IllegalArgumentException if lockWaitTimeout is\n   *         out of bounds\n   * @throws IOException if obtain() throws IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {\n    failureReason = null;\n    boolean locked = obtain();\n    if (lockWaitTimeout < 0 && lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER)\n      throw new IllegalArgumentException(\"lockWaitTimeout should be LOCK_OBTAIN_WAIT_FOREVER or a non-negative number (got \" + lockWaitTimeout + \")\");\n\n    long maxSleepCount = lockWaitTimeout / LOCK_POLL_INTERVAL;\n    long sleepCount = 0;\n    while (!locked) {\n      if (lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER && sleepCount++ >= maxSleepCount) {\n        String reason = \"Lock obtain timed out: \" + this.toString();\n        if (failureReason != null) {\n          reason += \": \" + failureReason;\n        }\n        LockObtainFailedException e = new LockObtainFailedException(reason);\n        if (failureReason != null) {\n          e.initCause(failureReason);\n        }\n        throw e;\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        // In 3.0 we will change this to throw\n        // InterruptedException instead\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","sourceOld":"  /** Attempts to obtain an exclusive lock within amount of\n   *  time given. Polls once per {@link #LOCK_POLL_INTERVAL}\n   *  (currently 1000) milliseconds until lockWaitTimeout is\n   *  passed.\n   * @param lockWaitTimeout length of time to wait in\n   *        milliseconds or {@link\n   *        #LOCK_OBTAIN_WAIT_FOREVER} to retry forever\n   * @return true if lock was obtained\n   * @throws LockObtainFailedException if lock wait times out\n   * @throws IllegalArgumentException if lockWaitTimeout is\n   *         out of bounds\n   * @throws IOException if obtain() throws IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {\n    failureReason = null;\n    boolean locked = obtain();\n    if (lockWaitTimeout < 0 && lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER)\n      throw new IllegalArgumentException(\"lockWaitTimeout should be LOCK_OBTAIN_WAIT_FOREVER or a non-negative number (got \" + lockWaitTimeout + \")\");\n\n    long maxSleepCount = lockWaitTimeout / LOCK_POLL_INTERVAL;\n    long sleepCount = 0;\n    while (!locked) {\n      if (lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER && sleepCount++ >= maxSleepCount) {\n        String reason = \"Lock obtain timed out: \" + this.toString();\n        if (failureReason != null) {\n          reason += \": \" + failureReason;\n        }\n        LockObtainFailedException e = new LockObtainFailedException(reason);\n        if (failureReason != null) {\n          e.initCause(failureReason);\n        }\n        throw e;\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7ad46e7c5ae040bfc25d0f572fb66d7bac542961","date":1240927543,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","pathOld":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","sourceNew":"  /** Attempts to obtain an exclusive lock within amount of\n   *  time given. Polls once per {@link #LOCK_POLL_INTERVAL}\n   *  (currently 1000) milliseconds until lockWaitTimeout is\n   *  passed.\n   * @param lockWaitTimeout length of time to wait in\n   *        milliseconds or {@link\n   *        #LOCK_OBTAIN_WAIT_FOREVER} to retry forever\n   * @return true if lock was obtained\n   * @throws LockObtainFailedException if lock wait times out\n   * @throws IllegalArgumentException if lockWaitTimeout is\n   *         out of bounds\n   * @throws IOException if obtain() throws IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {\n    failureReason = null;\n    boolean locked = obtain();\n    if (lockWaitTimeout < 0 && lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER)\n      throw new IllegalArgumentException(\"lockWaitTimeout should be LOCK_OBTAIN_WAIT_FOREVER or a non-negative number (got \" + lockWaitTimeout + \")\");\n\n    long maxSleepCount = lockWaitTimeout / LOCK_POLL_INTERVAL;\n    long sleepCount = 0;\n    while (!locked) {\n      if (lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER && sleepCount++ >= maxSleepCount) {\n        String reason = \"Lock obtain timed out: \" + this.toString();\n        if (failureReason != null) {\n          reason += \": \" + failureReason;\n        }\n        LockObtainFailedException e = new LockObtainFailedException(reason);\n        if (failureReason != null) {\n          e.initCause(failureReason);\n        }\n        throw e;\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        // In 3.0 we will change this to throw\n        // InterruptedException instead\n        Thread.currentThread().interrupt();\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","sourceOld":"  /** Attempts to obtain an exclusive lock within amount of\n   *  time given. Polls once per {@link #LOCK_POLL_INTERVAL}\n   *  (currently 1000) milliseconds until lockWaitTimeout is\n   *  passed.\n   * @param lockWaitTimeout length of time to wait in\n   *        milliseconds or {@link\n   *        #LOCK_OBTAIN_WAIT_FOREVER} to retry forever\n   * @return true if lock was obtained\n   * @throws LockObtainFailedException if lock wait times out\n   * @throws IllegalArgumentException if lockWaitTimeout is\n   *         out of bounds\n   * @throws IOException if obtain() throws IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {\n    failureReason = null;\n    boolean locked = obtain();\n    if (lockWaitTimeout < 0 && lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER)\n      throw new IllegalArgumentException(\"lockWaitTimeout should be LOCK_OBTAIN_WAIT_FOREVER or a non-negative number (got \" + lockWaitTimeout + \")\");\n\n    long maxSleepCount = lockWaitTimeout / LOCK_POLL_INTERVAL;\n    long sleepCount = 0;\n    while (!locked) {\n      if (lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER && sleepCount++ >= maxSleepCount) {\n        String reason = \"Lock obtain timed out: \" + this.toString();\n        if (failureReason != null) {\n          reason += \": \" + failureReason;\n        }\n        LockObtainFailedException e = new LockObtainFailedException(reason);\n        if (failureReason != null) {\n          e.initCause(failureReason);\n        }\n        throw e;\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        // In 3.0 we will change this to throw\n        // InterruptedException instead\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa4b66eb16ead894fa7130904af6ecf34331f050","date":1258198413,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","pathOld":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","sourceNew":"  /** Attempts to obtain an exclusive lock within amount of\n   *  time given. Polls once per {@link #LOCK_POLL_INTERVAL}\n   *  (currently 1000) milliseconds until lockWaitTimeout is\n   *  passed.\n   * @param lockWaitTimeout length of time to wait in\n   *        milliseconds or {@link\n   *        #LOCK_OBTAIN_WAIT_FOREVER} to retry forever\n   * @return true if lock was obtained\n   * @throws LockObtainFailedException if lock wait times out\n   * @throws IllegalArgumentException if lockWaitTimeout is\n   *         out of bounds\n   * @throws IOException if obtain() throws IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {\n    failureReason = null;\n    boolean locked = obtain();\n    if (lockWaitTimeout < 0 && lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER)\n      throw new IllegalArgumentException(\"lockWaitTimeout should be LOCK_OBTAIN_WAIT_FOREVER or a non-negative number (got \" + lockWaitTimeout + \")\");\n\n    long maxSleepCount = lockWaitTimeout / LOCK_POLL_INTERVAL;\n    long sleepCount = 0;\n    while (!locked) {\n      if (lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER && sleepCount++ >= maxSleepCount) {\n        String reason = \"Lock obtain timed out: \" + this.toString();\n        if (failureReason != null) {\n          reason += \": \" + failureReason;\n        }\n        LockObtainFailedException e = new LockObtainFailedException(reason);\n        if (failureReason != null) {\n          e.initCause(failureReason);\n        }\n        throw e;\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","sourceOld":"  /** Attempts to obtain an exclusive lock within amount of\n   *  time given. Polls once per {@link #LOCK_POLL_INTERVAL}\n   *  (currently 1000) milliseconds until lockWaitTimeout is\n   *  passed.\n   * @param lockWaitTimeout length of time to wait in\n   *        milliseconds or {@link\n   *        #LOCK_OBTAIN_WAIT_FOREVER} to retry forever\n   * @return true if lock was obtained\n   * @throws LockObtainFailedException if lock wait times out\n   * @throws IllegalArgumentException if lockWaitTimeout is\n   *         out of bounds\n   * @throws IOException if obtain() throws IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {\n    failureReason = null;\n    boolean locked = obtain();\n    if (lockWaitTimeout < 0 && lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER)\n      throw new IllegalArgumentException(\"lockWaitTimeout should be LOCK_OBTAIN_WAIT_FOREVER or a non-negative number (got \" + lockWaitTimeout + \")\");\n\n    long maxSleepCount = lockWaitTimeout / LOCK_POLL_INTERVAL;\n    long sleepCount = 0;\n    while (!locked) {\n      if (lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER && sleepCount++ >= maxSleepCount) {\n        String reason = \"Lock obtain timed out: \" + this.toString();\n        if (failureReason != null) {\n          reason += \": \" + failureReason;\n        }\n        LockObtainFailedException e = new LockObtainFailedException(reason);\n        if (failureReason != null) {\n          e.initCause(failureReason);\n        }\n        throw e;\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException e) {\n        // In 3.0 we will change this to throw\n        // InterruptedException instead\n        Thread.currentThread().interrupt();\n        throw new IOException(e.toString());\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/Lock#obtain(long).mjava","pathOld":"src/java/org/apache/lucene/store/Lock#obtain(long).mjava","sourceNew":"  /** Attempts to obtain an exclusive lock within amount of\n   *  time given. Polls once per {@link #LOCK_POLL_INTERVAL}\n   *  (currently 1000) milliseconds until lockWaitTimeout is\n   *  passed.\n   * @param lockWaitTimeout length of time to wait in\n   *        milliseconds or {@link\n   *        #LOCK_OBTAIN_WAIT_FOREVER} to retry forever\n   * @return true if lock was obtained\n   * @throws LockObtainFailedException if lock wait times out\n   * @throws IllegalArgumentException if lockWaitTimeout is\n   *         out of bounds\n   * @throws IOException if obtain() throws IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {\n    failureReason = null;\n    boolean locked = obtain();\n    if (lockWaitTimeout < 0 && lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER)\n      throw new IllegalArgumentException(\"lockWaitTimeout should be LOCK_OBTAIN_WAIT_FOREVER or a non-negative number (got \" + lockWaitTimeout + \")\");\n\n    long maxSleepCount = lockWaitTimeout / LOCK_POLL_INTERVAL;\n    long sleepCount = 0;\n    while (!locked) {\n      if (lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER && sleepCount++ >= maxSleepCount) {\n        String reason = \"Lock obtain timed out: \" + this.toString();\n        if (failureReason != null) {\n          reason += \": \" + failureReason;\n        }\n        LockObtainFailedException e = new LockObtainFailedException(reason);\n        if (failureReason != null) {\n          e.initCause(failureReason);\n        }\n        throw e;\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","sourceOld":"  /** Attempts to obtain an exclusive lock within amount of\n   *  time given. Polls once per {@link #LOCK_POLL_INTERVAL}\n   *  (currently 1000) milliseconds until lockWaitTimeout is\n   *  passed.\n   * @param lockWaitTimeout length of time to wait in\n   *        milliseconds or {@link\n   *        #LOCK_OBTAIN_WAIT_FOREVER} to retry forever\n   * @return true if lock was obtained\n   * @throws LockObtainFailedException if lock wait times out\n   * @throws IllegalArgumentException if lockWaitTimeout is\n   *         out of bounds\n   * @throws IOException if obtain() throws IOException\n   */\n  public boolean obtain(long lockWaitTimeout) throws LockObtainFailedException, IOException {\n    failureReason = null;\n    boolean locked = obtain();\n    if (lockWaitTimeout < 0 && lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER)\n      throw new IllegalArgumentException(\"lockWaitTimeout should be LOCK_OBTAIN_WAIT_FOREVER or a non-negative number (got \" + lockWaitTimeout + \")\");\n\n    long maxSleepCount = lockWaitTimeout / LOCK_POLL_INTERVAL;\n    long sleepCount = 0;\n    while (!locked) {\n      if (lockWaitTimeout != LOCK_OBTAIN_WAIT_FOREVER && sleepCount++ >= maxSleepCount) {\n        String reason = \"Lock obtain timed out: \" + this.toString();\n        if (failureReason != null) {\n          reason += \": \" + failureReason;\n        }\n        LockObtainFailedException e = new LockObtainFailedException(reason);\n        if (failureReason != null) {\n          e.initCause(failureReason);\n        }\n        throw e;\n      }\n      try {\n        Thread.sleep(LOCK_POLL_INTERVAL);\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n      locked = obtain();\n    }\n    return locked;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"693a4c06f749274d170a2e87d4afb2709a810f46":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1b54a9bc667895a2095a886184bf69a3179e63df":["f118a5ec962b5e2658d313e6f4e6f28faa3bcb39"],"aa4b66eb16ead894fa7130904af6ecf34331f050":["7ad46e7c5ae040bfc25d0f572fb66d7bac542961"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["ca4c6ae8e5160adba89ead25d5776d494bbcd17f"],"7ad46e7c5ae040bfc25d0f572fb66d7bac542961":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"e1425bf3470c9f39dfa4622997c93e061da354a0":["22f869833b37788422366a853701b288987bd424"],"85540c3d0b253bd20f0bbe6792106fef9a9b1548":["e1425bf3470c9f39dfa4622997c93e061da354a0"],"2993c486daad7c2eadd1973c500ea7b570928398":["85540c3d0b253bd20f0bbe6792106fef9a9b1548"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22f869833b37788422366a853701b288987bd424":["693a4c06f749274d170a2e87d4afb2709a810f46"],"f118a5ec962b5e2658d313e6f4e6f28faa3bcb39":["ee59b6a9c0bfc2edce862231f9798a183ed1fcb3"],"ca4c6ae8e5160adba89ead25d5776d494bbcd17f":["1b54a9bc667895a2095a886184bf69a3179e63df"],"ee59b6a9c0bfc2edce862231f9798a183ed1fcb3":["2993c486daad7c2eadd1973c500ea7b570928398"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["aa4b66eb16ead894fa7130904af6ecf34331f050"]},"commit2Childs":{"693a4c06f749274d170a2e87d4afb2709a810f46":["22f869833b37788422366a853701b288987bd424"],"1b54a9bc667895a2095a886184bf69a3179e63df":["ca4c6ae8e5160adba89ead25d5776d494bbcd17f"],"aa4b66eb16ead894fa7130904af6ecf34331f050":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["7ad46e7c5ae040bfc25d0f572fb66d7bac542961"],"7ad46e7c5ae040bfc25d0f572fb66d7bac542961":["aa4b66eb16ead894fa7130904af6ecf34331f050"],"e1425bf3470c9f39dfa4622997c93e061da354a0":["85540c3d0b253bd20f0bbe6792106fef9a9b1548"],"85540c3d0b253bd20f0bbe6792106fef9a9b1548":["2993c486daad7c2eadd1973c500ea7b570928398"],"2993c486daad7c2eadd1973c500ea7b570928398":["ee59b6a9c0bfc2edce862231f9798a183ed1fcb3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["693a4c06f749274d170a2e87d4afb2709a810f46"],"22f869833b37788422366a853701b288987bd424":["e1425bf3470c9f39dfa4622997c93e061da354a0"],"f118a5ec962b5e2658d313e6f4e6f28faa3bcb39":["1b54a9bc667895a2095a886184bf69a3179e63df"],"ca4c6ae8e5160adba89ead25d5776d494bbcd17f":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"ee59b6a9c0bfc2edce862231f9798a183ed1fcb3":["f118a5ec962b5e2658d313e6f4e6f28faa3bcb39"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}