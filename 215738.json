{"path":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","commits":[{"id":"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","date":1358521790,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSimpleDocValues#simpleSortedValues(IndexReader,String).mjava","sourceNew":"  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n          @Override\n          public int numDocs() {\n            return maxDoc(); // lie\n          }\n          @Override\n          public boolean hasDeletions() {\n            return false; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","sourceOld":"  public static SortedDocValues simpleSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n          @Override\n          public int numDocs() {\n            return maxDoc(); // lie\n          }\n          @Override\n          public boolean hasDeletions() {\n            return false; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f694ce7d95cc96d1b019de3e943b70f6672c554b","date":1358786402,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      // fake up fieldinfos\n      FieldInfo fi = new FieldInfo(field, false, 0, false, false, false, null, DocValuesType.SORTED, null, null);\n      final FieldInfos fis = new FieldInfos(new FieldInfo[] { fi });\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n          @Override\n          public int numDocs() {\n            return maxDoc(); // lie\n          }\n          @Override\n          public boolean hasDeletions() {\n            return false; // lie\n          }\n          @Override\n          public FieldInfos getFieldInfos() {\n            return fis;\n          }\n          @Override\n          public Fields getTermVectors(int docID) throws IOException {\n            return null; // lie\n          }\n          @Override\n          public void document(int docID, StoredFieldVisitor visitor) throws IOException {\n            // lie\n          }\n          @Override\n          public Fields fields() throws IOException {\n            return null; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","sourceOld":"  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n          @Override\n          public int numDocs() {\n            return maxDoc(); // lie\n          }\n          @Override\n          public boolean hasDeletions() {\n            return false; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4772ea9604873dc0b22ea724398008998afc8e41","date":1359133954,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things) */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      // fake up fieldinfos\n      FieldInfo fi = new FieldInfo(field, false, 0, false, false, false, null, DocValuesType.SORTED, null, null);\n      final FieldInfos fis = new FieldInfos(new FieldInfo[] { fi });\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n          @Override\n          public int numDocs() {\n            return maxDoc(); // lie\n          }\n          @Override\n          public boolean hasDeletions() {\n            return false; // lie\n          }\n          @Override\n          public FieldInfos getFieldInfos() {\n            return fis;\n          }\n          @Override\n          public Fields getTermVectors(int docID) throws IOException {\n            return null; // lie\n          }\n          @Override\n          public void document(int docID, StoredFieldVisitor visitor) throws IOException {\n            // lie\n          }\n          @Override\n          public Fields fields() throws IOException {\n            return null; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","sourceOld":"  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      // fake up fieldinfos\n      FieldInfo fi = new FieldInfo(field, false, 0, false, false, false, null, DocValuesType.SORTED, null, null);\n      final FieldInfos fis = new FieldInfos(new FieldInfo[] { fi });\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n          @Override\n          public int numDocs() {\n            return maxDoc(); // lie\n          }\n          @Override\n          public boolean hasDeletions() {\n            return false; // lie\n          }\n          @Override\n          public FieldInfos getFieldInfos() {\n            return fis;\n          }\n          @Override\n          public Fields getTermVectors(int docID) throws IOException {\n            return null; // lie\n          }\n          @Override\n          public void document(int docID, StoredFieldVisitor visitor) throws IOException {\n            // lie\n          }\n          @Override\n          public Fields fields() throws IOException {\n            return null; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"026059dab6db2d84d0e57c4774484b93a540ee6c","date":1359995853,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      // fake up fieldinfos\n      FieldInfo fi = new FieldInfo(field, false, 0, false, false, false, null, DocValuesType.SORTED, null, null);\n      final FieldInfos fis = new FieldInfos(new FieldInfo[] { fi });\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n          @Override\n          public int numDocs() {\n            return maxDoc(); // lie\n          }\n          @Override\n          public boolean hasDeletions() {\n            return false; // lie\n          }\n          @Override\n          public FieldInfos getFieldInfos() {\n            return fis;\n          }\n          @Override\n          public Fields getTermVectors(int docID) throws IOException {\n            return null; // lie\n          }\n          @Override\n          public void document(int docID, StoredFieldVisitor visitor) throws IOException {\n            // lie\n          }\n          @Override\n          public Fields fields() throws IOException {\n            return null; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","sourceOld":"  /** returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things) */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      // fake up fieldinfos\n      FieldInfo fi = new FieldInfo(field, false, 0, false, false, false, null, DocValuesType.SORTED, null, null);\n      final FieldInfos fis = new FieldInfos(new FieldInfo[] { fi });\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n          @Override\n          public int numDocs() {\n            return maxDoc(); // lie\n          }\n          @Override\n          public boolean hasDeletions() {\n            return false; // lie\n          }\n          @Override\n          public FieldInfos getFieldInfos() {\n            return fis;\n          }\n          @Override\n          public Fields getTermVectors(int docID) throws IOException {\n            return null; // lie\n          }\n          @Override\n          public void document(int docID, StoredFieldVisitor visitor) throws IOException {\n            // lie\n          }\n          @Override\n          public Fields fields() throws IOException {\n            return null; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10cd984eebb9656e4afcd6ccf6968b710d630704","date":1360002935,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMapping mapping = new OrdinalMapping(values);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      // fake up fieldinfos\n      FieldInfo fi = new FieldInfo(field, false, 0, false, false, false, null, DocValuesType.SORTED, null, null);\n      final FieldInfos fis = new FieldInfos(new FieldInfo[] { fi });\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n          @Override\n          public int numDocs() {\n            return maxDoc(); // lie\n          }\n          @Override\n          public boolean hasDeletions() {\n            return false; // lie\n          }\n          @Override\n          public FieldInfos getFieldInfos() {\n            return fis;\n          }\n          @Override\n          public Fields getTermVectors(int docID) throws IOException {\n            return null; // lie\n          }\n          @Override\n          public void document(int docID, StoredFieldVisitor visitor) throws IOException {\n            // lie\n          }\n          @Override\n          public Fields fields() throws IOException {\n            return null; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","bugFix":null,"bugIntro":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6509c8bbcf8f92ba1ecfaccea085eac1d5c4754e","date":1360007824,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = new OrdinalMap(values);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMapping mapping = new OrdinalMapping(values);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf3d78aec0a22d08438820ca1492a3ea4371466e","date":1360105770,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), values);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = new OrdinalMap(values);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), values);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f366ce28775e2b8ea4e06355009471328711666d","date":1360551293,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = new SortedDocValuesTermsEnum(values[i]);\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), values);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ddbb72a33557d2b5bc22ee95daf3281c43560502","date":1361334582,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = new SortedDocValuesTermsEnum(values[i]);\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), values);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e129598ae448211d969dd7cdf2ad4558a0658a1","date":1362963550,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = new SortedDocValuesTermsEnum(values[i]);\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"64e6baad25b7155a116cb0126b4e2a06b945a5c5","date":1362976847,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = new SortedDocValuesTermsEnum(values[i]);\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5c2b6033d1fc841b41dbf56c765ce3dc053ecba6","date":1363054647,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = new SortedDocValuesTermsEnum(values[i]);\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8429ddf2214f2bf8abcbb5484fefef6aaf5c417e","date":1397206443,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.EMPTY_SORTED;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = SortedDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":["10cd984eebb9656e4afcd6ccf6968b710d630704"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","date":1401983689,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.EMPTY_SORTED;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bcfd864fb8b916f7d21f2579d2010a31892055d","date":1403359094,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22aab7a3b640b0dba26cc5e9416bc7af93614b46","date":1462575761,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      if (context.reader().getIndexSort() != null) {\n        throw new IllegalArgumentException(\"cannot handle index sort: reader=\" + context.reader());\n      }\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"815972da4a13279b8e975d2e32ca450649d6c295","date":1462635959,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      if (context.reader().getIndexSort() != null) {\n        throw new IllegalArgumentException(\"cannot handle index sort: reader=\" + context.reader());\n      }\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n        totalCost += v.cost();\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (anyReal == false) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping, totalCost);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n        totalCost += v.cost();\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (anyReal == false) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping, totalCost);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n        totalCost += v.cost();\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (anyReal == false) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping, totalCost);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n        totalCost += v.cost();\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (anyReal == false) {\n      return null;\n    } else {\n      IndexReader.CacheHelper cacheHelper = r.getReaderCacheHelper();\n      IndexReader.CacheKey owner = cacheHelper == null ? null : cacheHelper.getKey();\n      OrdinalMap mapping = OrdinalMap.build(owner, values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping, totalCost);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedDocValues(String)}\n   * </p>  \n   */\n  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedDocValues[] values = new SortedDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedDocValues v = context.reader().getSortedDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySorted();\n      } else {\n        anyReal = true;\n        totalCost += v.cost();\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (anyReal == false) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedDocValues(values, starts, mapping, totalCost);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cf3d78aec0a22d08438820ca1492a3ea4371466e":["6509c8bbcf8f92ba1ecfaccea085eac1d5c4754e"],"026059dab6db2d84d0e57c4774484b93a540ee6c":["4772ea9604873dc0b22ea724398008998afc8e41"],"10cd984eebb9656e4afcd6ccf6968b710d630704":["026059dab6db2d84d0e57c4774484b93a540ee6c"],"f694ce7d95cc96d1b019de3e943b70f6672c554b":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["d4d69c535930b5cce125cff868d40f6373dc27d4","f366ce28775e2b8ea4e06355009471328711666d"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["5bcfd864fb8b916f7d21f2579d2010a31892055d"],"22aab7a3b640b0dba26cc5e9416bc7af93614b46":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7e129598ae448211d969dd7cdf2ad4558a0658a1":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"d211216c83f01894810543d1c107160a9ae3650b":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["c9fb5f46e264daf5ba3860defe623a89d202dd87","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"f366ce28775e2b8ea4e06355009471328711666d":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c9fb5f46e264daf5ba3860defe623a89d202dd87","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"8429ddf2214f2bf8abcbb5484fefef6aaf5c417e":["5c2b6033d1fc841b41dbf56c765ce3dc053ecba6"],"5c2b6033d1fc841b41dbf56c765ce3dc053ecba6":["64e6baad25b7155a116cb0126b4e2a06b945a5c5"],"6509c8bbcf8f92ba1ecfaccea085eac1d5c4754e":["10cd984eebb9656e4afcd6ccf6968b710d630704"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","cf3d78aec0a22d08438820ca1492a3ea4371466e"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"64e6baad25b7155a116cb0126b4e2a06b945a5c5":["7e129598ae448211d969dd7cdf2ad4558a0658a1"],"815972da4a13279b8e975d2e32ca450649d6c295":["22aab7a3b640b0dba26cc5e9416bc7af93614b46"],"5bcfd864fb8b916f7d21f2579d2010a31892055d":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"4772ea9604873dc0b22ea724398008998afc8e41":["f694ce7d95cc96d1b019de3e943b70f6672c554b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d211216c83f01894810543d1c107160a9ae3650b"]},"commit2Childs":{"cf3d78aec0a22d08438820ca1492a3ea4371466e":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"026059dab6db2d84d0e57c4774484b93a540ee6c":["10cd984eebb9656e4afcd6ccf6968b710d630704"],"10cd984eebb9656e4afcd6ccf6968b710d630704":["6509c8bbcf8f92ba1ecfaccea085eac1d5c4754e"],"f694ce7d95cc96d1b019de3e943b70f6672c554b":["4772ea9604873dc0b22ea724398008998afc8e41"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["7e129598ae448211d969dd7cdf2ad4558a0658a1"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["22aab7a3b640b0dba26cc5e9416bc7af93614b46","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"22aab7a3b640b0dba26cc5e9416bc7af93614b46":["815972da4a13279b8e975d2e32ca450649d6c295"],"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["f694ce7d95cc96d1b019de3e943b70f6672c554b"],"7e129598ae448211d969dd7cdf2ad4558a0658a1":["64e6baad25b7155a116cb0126b4e2a06b945a5c5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","d4d69c535930b5cce125cff868d40f6373dc27d4"],"d211216c83f01894810543d1c107160a9ae3650b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["d211216c83f01894810543d1c107160a9ae3650b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"f366ce28775e2b8ea4e06355009471328711666d":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["5bcfd864fb8b916f7d21f2579d2010a31892055d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"8429ddf2214f2bf8abcbb5484fefef6aaf5c417e":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"6509c8bbcf8f92ba1ecfaccea085eac1d5c4754e":["cf3d78aec0a22d08438820ca1492a3ea4371466e"],"5c2b6033d1fc841b41dbf56c765ce3dc053ecba6":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["ddbb72a33557d2b5bc22ee95daf3281c43560502","f366ce28775e2b8ea4e06355009471328711666d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"64e6baad25b7155a116cb0126b4e2a06b945a5c5":["5c2b6033d1fc841b41dbf56c765ce3dc053ecba6"],"815972da4a13279b8e975d2e32ca450649d6c295":[],"4772ea9604873dc0b22ea724398008998afc8e41":["026059dab6db2d84d0e57c4774484b93a540ee6c"],"5bcfd864fb8b916f7d21f2579d2010a31892055d":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","815972da4a13279b8e975d2e32ca450649d6c295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}