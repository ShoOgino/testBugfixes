{"path":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","commits":[{"id":"3c1d0e98e69e3b34294528b2f9ce96fe46b3e77a","date":1445465230,"type":0,"author":"Nick Knize","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"/dev/null","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    initIndexWriterConfig(FIELD_NAME, iwc);\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // BBox: don't allow dateline crossing when testing small:\n                final GeoRect bbox = randomRect(small, small == false);\n\n                query = newBBoxQuery(FIELD_NAME, bbox);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(bbox, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"322b048703a28bdd7e7fdda1f423b57f52579a63","date":1445521287,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    initIndexWriterConfig(FIELD_NAME, iwc);\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // BBox: don't allow dateline crossing when testing small:\n                final GeoRect bbox = randomRect(small, small == false);\n\n                query = newBBoxQuery(FIELD_NAME, bbox);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(bbox, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    initIndexWriterConfig(FIELD_NAME, iwc);\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // BBox: don't allow dateline crossing when testing small:\n                final GeoRect bbox = randomRect(small, small == false);\n\n                query = newBBoxQuery(FIELD_NAME, bbox);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(bbox, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    initIndexWriterConfig(FIELD_NAME, iwc);\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // BBox: don't allow dateline crossing when testing small:\n                final GeoRect bbox = randomRect(small, small == false);\n\n                query = newBBoxQuery(FIELD_NAME, bbox);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(bbox, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a5621907ebbd315f9ceb1060cbcb194455edee3","date":1451905835,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a1862266772deb28cdcb7d996b64d2177022687","date":1453077824,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"937923083e4d137932336fc80f3d78758ff698a6","date":1454691519,"type":5,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":5,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3c1d0e98e69e3b34294528b2f9ce96fe46b3e77a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0a5621907ebbd315f9ceb1060cbcb194455edee3":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"2a1862266772deb28cdcb7d996b64d2177022687":["0a5621907ebbd315f9ceb1060cbcb194455edee3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["0d49a158012a8ff48f328a4558e4bfcffbaed16f","937923083e4d137932336fc80f3d78758ff698a6"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["322b048703a28bdd7e7fdda1f423b57f52579a63"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["2a1862266772deb28cdcb7d996b64d2177022687"],"937923083e4d137932336fc80f3d78758ff698a6":["2a1862266772deb28cdcb7d996b64d2177022687"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["937923083e4d137932336fc80f3d78758ff698a6"],"322b048703a28bdd7e7fdda1f423b57f52579a63":["3c1d0e98e69e3b34294528b2f9ce96fe46b3e77a"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["2a1862266772deb28cdcb7d996b64d2177022687"]},"commit2Childs":{"3c1d0e98e69e3b34294528b2f9ce96fe46b3e77a":["322b048703a28bdd7e7fdda1f423b57f52579a63"],"0a5621907ebbd315f9ceb1060cbcb194455edee3":["2a1862266772deb28cdcb7d996b64d2177022687"],"2a1862266772deb28cdcb7d996b64d2177022687":["6bfe104fc023fadc9e709f8d17403d2cc61133fe","937923083e4d137932336fc80f3d78758ff698a6","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3c1d0e98e69e3b34294528b2f9ce96fe46b3e77a"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"1904709ea0185dc04e3d77ea01c79e909caf2796":["0a5621907ebbd315f9ceb1060cbcb194455edee3"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":[],"937923083e4d137932336fc80f3d78758ff698a6":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"322b048703a28bdd7e7fdda1f423b57f52579a63":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","6bfe104fc023fadc9e709f8d17403d2cc61133fe","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}