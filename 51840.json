{"path":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/FacetRangeGenerator#getRanges().mjava","commits":[{"id":"c495edcca4d0bc51bf62d9be3527c87bf9b44ded","date":1498673617,"type":0,"author":"Dennis Gove","isMerge":false,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/FacetRangeGenerator#getRanges().mjava","pathOld":"/dev/null","sourceNew":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(rangeFacet.getStart());\n    T end = getValue(rangeFacet.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final List<String> gaps = rangeFacet.getGaps();\n    String gap = gaps.get(0);\n    \n    final EnumSet<FacetRangeInclude> include = rangeFacet.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.size()) {\n        gap = gaps.get(gapCounter++);\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (rangeFacet.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = rangeFacet.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/FacetRangeGenerator#getRanges().mjava","pathOld":"/dev/null","sourceNew":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(rangeFacet.getStart());\n    T end = getValue(rangeFacet.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final List<String> gaps = rangeFacet.getGaps();\n    String gap = gaps.get(0);\n    \n    final EnumSet<FacetRangeInclude> include = rangeFacet.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.size()) {\n        gap = gaps.get(gapCounter++);\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (rangeFacet.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = rangeFacet.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/FacetRangeGenerator#getRanges().mjava","pathOld":"/dev/null","sourceNew":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(rangeFacet.getStart());\n    T end = getValue(rangeFacet.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final List<String> gaps = rangeFacet.getGaps();\n    String gap = gaps.get(0);\n    \n    final EnumSet<FacetRangeInclude> include = rangeFacet.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.size()) {\n        gap = gaps.get(gapCounter++);\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (rangeFacet.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = rangeFacet.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e4e64b7199d2f2a17be7f3926c7532553910dce","date":1564342581,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/FacetRangeGenerator#getRanges().mjava","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/FacetRangeGenerator#getRanges().mjava","sourceNew":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(rangeFacet.getStart());\n    T end = getValue(rangeFacet.getEnd()); // not final, hardend may change this\n\n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n\n    // explicitly return the gap.  compute this early so we are more\n    // likely to catch parse errors before attempting math\n    final List<String> gaps = rangeFacet.getGaps();\n    String gap = gaps.get(0);\n\n    final EnumSet<FacetRangeInclude> include = rangeFacet.getInclude();\n\n    T low = start;\n\n    List<FacetRange> ranges = new ArrayList<>();\n\n    int gapCounter = 0;\n\n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.size()) {\n        gap = gaps.get(gapCounter++);\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (rangeFacet.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n\n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n\n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n\n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) &&\n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) &&\n                                   0 == high.compareTo(end)));\n\n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n\n    final Set<FacetRangeOther> others = rangeFacet.getOthers();\n    if (null != others && 0 < others.size() ) {\n\n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n\n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(),\n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n\n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(),\n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n\n    }\n\n    return ranges;\n  }\n\n","sourceOld":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(rangeFacet.getStart());\n    T end = getValue(rangeFacet.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final List<String> gaps = rangeFacet.getGaps();\n    String gap = gaps.get(0);\n    \n    final EnumSet<FacetRangeInclude> include = rangeFacet.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.size()) {\n        gap = gaps.get(gapCounter++);\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (rangeFacet.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = rangeFacet.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/FacetRangeGenerator#getRanges().mjava","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/FacetRangeGenerator#getRanges().mjava","sourceNew":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(rangeFacet.getStart());\n    T end = getValue(rangeFacet.getEnd()); // not final, hardend may change this\n\n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n\n    // explicitly return the gap.  compute this early so we are more\n    // likely to catch parse errors before attempting math\n    final List<String> gaps = rangeFacet.getGaps();\n    String gap = gaps.get(0);\n\n    final EnumSet<FacetRangeInclude> include = rangeFacet.getInclude();\n\n    T low = start;\n\n    List<FacetRange> ranges = new ArrayList<>();\n\n    int gapCounter = 0;\n\n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.size()) {\n        gap = gaps.get(gapCounter++);\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (rangeFacet.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n\n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n\n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n\n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) &&\n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) &&\n                                   0 == high.compareTo(end)));\n\n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n\n    final Set<FacetRangeOther> others = rangeFacet.getOthers();\n    if (null != others && 0 < others.size() ) {\n\n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n\n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(),\n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n\n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(),\n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n\n    }\n\n    return ranges;\n  }\n\n","sourceOld":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(rangeFacet.getStart());\n    T end = getValue(rangeFacet.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final List<String> gaps = rangeFacet.getGaps();\n    String gap = gaps.get(0);\n    \n    final EnumSet<FacetRangeInclude> include = rangeFacet.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.size()) {\n        gap = gaps.get(gapCounter++);\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (rangeFacet.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = rangeFacet.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1e4e64b7199d2f2a17be7f3926c7532553910dce":["28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"30c8e5574b55d57947e989443dfde611646530ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","28288370235ed02234a64753cdbf0c6ec096304a"],"c495edcca4d0bc51bf62d9be3527c87bf9b44ded":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c495edcca4d0bc51bf62d9be3527c87bf9b44ded"],"f8061ddd97f3352007d927dae445884a6f3d857b":["28288370235ed02234a64753cdbf0c6ec096304a","1e4e64b7199d2f2a17be7f3926c7532553910dce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1e4e64b7199d2f2a17be7f3926c7532553910dce"]},"commit2Childs":{"1e4e64b7199d2f2a17be7f3926c7532553910dce":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["30c8e5574b55d57947e989443dfde611646530ee","c495edcca4d0bc51bf62d9be3527c87bf9b44ded","28288370235ed02234a64753cdbf0c6ec096304a"],"30c8e5574b55d57947e989443dfde611646530ee":[],"c495edcca4d0bc51bf62d9be3527c87bf9b44ded":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["1e4e64b7199d2f2a17be7f3926c7532553910dce","30c8e5574b55d57947e989443dfde611646530ee","f8061ddd97f3352007d927dae445884a6f3d857b"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["30c8e5574b55d57947e989443dfde611646530ee","f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}