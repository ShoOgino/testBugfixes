{"path":"lucene/backwards/src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"backwards/src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private IndexReader reader;\n          private Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(reader, true, false);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) {\n            this.reader = reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        List<IndexReader> readerList = new ArrayList<IndexReader>();\n        ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n        IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);\n        for(int i = 0; i < readers.length; i++) {\n          IndexReader reader = readers[i];\n          Weight w = q.weight(s);\n          Scorer scorer = w.scorer(reader, true, false);\n          \n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n      \n            if (more && lastDoc[0] != -1) \n              Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private IndexReader reader;\n          private Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(reader, true, false);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) {\n            this.reader = reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        List<IndexReader> readerList = new ArrayList<IndexReader>();\n        ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n        IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);\n        for(int i = 0; i < readers.length; i++) {\n          IndexReader reader = readers[i];\n          Weight w = q.weight(s);\n          Scorer scorer = w.scorer(reader, true, false);\n          \n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n      \n            if (more && lastDoc[0] != -1) \n              Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6","date":1272983566,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/backwards/src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":null,"sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private IndexReader reader;\n          private Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(reader, true, false);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) {\n            this.reader = reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        List<IndexReader> readerList = new ArrayList<IndexReader>();\n        ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n        IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);\n        for(int i = 0; i < readers.length; i++) {\n          IndexReader reader = readers[i];\n          Weight w = q.weight(s);\n          Scorer scorer = w.scorer(reader, true, false);\n          \n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n      \n            if (more && lastDoc[0] != -1) \n              Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}