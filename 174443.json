{"path":"solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotsTool#getIndexFilesPathForSnapshot(String,String,Optional[String]).mjava","commits":[{"id":"2f42765a8ec9db88d334d2931fb3df8c5a2c4c3b","date":1478629715,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotsTool#getIndexFilesPathForSnapshot(String,String,Optional[String]).mjava","pathOld":"/dev/null","sourceNew":"  public Map<String, List<String>> getIndexFilesPathForSnapshot(String collectionName,  String snapshotName, Optional<String> pathPrefix)\n      throws SolrServerException, IOException {\n    Map<String, List<String>> result = new HashMap<>();\n\n    Collection<CollectionSnapshotMetaData> snaps = listCollectionSnapshots(collectionName);\n    Optional<CollectionSnapshotMetaData> meta = Optional.empty();\n    for (CollectionSnapshotMetaData m : snaps) {\n      if (snapshotName.equals(m.getName())) {\n        meta = Optional.of(m);\n      }\n    }\n\n    if (!meta.isPresent()) {\n      throw new IllegalArgumentException(\"The snapshot named \" + snapshotName\n          + \" is not found for collection \" + collectionName);\n    }\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    for (Slice s : collectionState.getSlices()) {\n      List<CoreSnapshotMetaData> replicaSnaps = meta.get().getReplicaSnapshotsForShard(s.getName());\n      // Prepare a list of *existing* replicas (since one or more replicas could have been deleted after the snapshot creation).\n      List<CoreSnapshotMetaData> availableReplicas = new ArrayList<>();\n      for (CoreSnapshotMetaData m : replicaSnaps) {\n        if (isReplicaAvailable(s, m.getCoreName())) {\n          availableReplicas.add(m);\n        }\n      }\n\n      if (availableReplicas.isEmpty()) {\n        throw new IllegalArgumentException(\n            \"The snapshot named \" + snapshotName + \" not found for shard \"\n                + s.getName() + \" of collection \" + collectionName);\n      }\n\n      // Prefer a leader replica (at the time when the snapshot was created).\n      CoreSnapshotMetaData coreSnap = availableReplicas.get(0);\n      for (CoreSnapshotMetaData m : availableReplicas) {\n        if (m.isLeader()) {\n          coreSnap = m;\n        }\n      }\n\n      String indexDirPath = coreSnap.getIndexDirPath();\n      if (pathPrefix.isPresent()) {\n        // If the path prefix is specified, rebuild the path to the index directory.\n        Path t = new Path(coreSnap.getIndexDirPath());\n        indexDirPath = (new Path(pathPrefix.get(), t.toUri().getPath())).toString();\n      }\n\n      List<String> paths = new ArrayList<>();\n      for (String fileName : coreSnap.getFiles()) {\n        Path p = new Path(indexDirPath, fileName);\n        paths.add(p.toString());\n      }\n\n      result.put(s.getName(), paths);\n    }\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotsTool#getIndexFilesPathForSnapshot(String,String,Optional[String]).mjava","pathOld":"/dev/null","sourceNew":"  public Map<String, List<String>> getIndexFilesPathForSnapshot(String collectionName,  String snapshotName, Optional<String> pathPrefix)\n      throws SolrServerException, IOException {\n    Map<String, List<String>> result = new HashMap<>();\n\n    Collection<CollectionSnapshotMetaData> snaps = listCollectionSnapshots(collectionName);\n    Optional<CollectionSnapshotMetaData> meta = Optional.empty();\n    for (CollectionSnapshotMetaData m : snaps) {\n      if (snapshotName.equals(m.getName())) {\n        meta = Optional.of(m);\n      }\n    }\n\n    if (!meta.isPresent()) {\n      throw new IllegalArgumentException(\"The snapshot named \" + snapshotName\n          + \" is not found for collection \" + collectionName);\n    }\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    for (Slice s : collectionState.getSlices()) {\n      List<CoreSnapshotMetaData> replicaSnaps = meta.get().getReplicaSnapshotsForShard(s.getName());\n      // Prepare a list of *existing* replicas (since one or more replicas could have been deleted after the snapshot creation).\n      List<CoreSnapshotMetaData> availableReplicas = new ArrayList<>();\n      for (CoreSnapshotMetaData m : replicaSnaps) {\n        if (isReplicaAvailable(s, m.getCoreName())) {\n          availableReplicas.add(m);\n        }\n      }\n\n      if (availableReplicas.isEmpty()) {\n        throw new IllegalArgumentException(\n            \"The snapshot named \" + snapshotName + \" not found for shard \"\n                + s.getName() + \" of collection \" + collectionName);\n      }\n\n      // Prefer a leader replica (at the time when the snapshot was created).\n      CoreSnapshotMetaData coreSnap = availableReplicas.get(0);\n      for (CoreSnapshotMetaData m : availableReplicas) {\n        if (m.isLeader()) {\n          coreSnap = m;\n        }\n      }\n\n      String indexDirPath = coreSnap.getIndexDirPath();\n      if (pathPrefix.isPresent()) {\n        // If the path prefix is specified, rebuild the path to the index directory.\n        Path t = new Path(coreSnap.getIndexDirPath());\n        indexDirPath = (new Path(pathPrefix.get(), t.toUri().getPath())).toString();\n      }\n\n      List<String> paths = new ArrayList<>();\n      for (String fileName : coreSnap.getFiles()) {\n        Path p = new Path(indexDirPath, fileName);\n        paths.add(p.toString());\n      }\n\n      result.put(s.getName(), paths);\n    }\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2f42765a8ec9db88d334d2931fb3df8c5a2c4c3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2f42765a8ec9db88d334d2931fb3df8c5a2c4c3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2f42765a8ec9db88d334d2931fb3df8c5a2c4c3b"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2f42765a8ec9db88d334d2931fb3df8c5a2c4c3b","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"2f42765a8ec9db88d334d2931fb3df8c5a2c4c3b":["199dfa410f1fdbfd3294106b04096cce5ed34b21","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}