{"path":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","commits":[{"id":"3edfeec51825f0aa5e0f17705c86810302f6385e","date":1235652068,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Used for handling cases where there is a slash '/' character\n   * inside the attribute value e.g. x@html='text/html'. We need to split\n   * by '/' excluding the '/' which is a part of the attribute's value.\n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<String>();\n    String[] ss = str.split(\"/\");\n    for (int i = 0; i < ss.length; i++) {\n      if (ss[i].length() == 0 && result.size() == 0) continue;\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j = 0; j < ss[i].length(); j++) if (ss[i].charAt(j) == '\\'') quoteCount++;\n        if ((quoteCount % 2) == 0) break;\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b14ccda0bdb398cf86bc3804e1c136a615dbd89b","date":1253269935,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","sourceNew":"  /**\n   * The Xpath is split into segments using the '/' s a seperator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We need to split\n   * by '/' excluding the '/' which is a part of the attribute's value.\n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<String>();\n    String[] ss = str.split(\"/\");\n    for (int i = 0; i < ss.length; i++) {\n      if (ss[i].length() == 0 && result.size() == 0) continue;\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j = 0; j < ss[i].length(); j++) if (ss[i].charAt(j) == '\\'') quoteCount++;\n        if ((quoteCount % 2) == 0) break;\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Used for handling cases where there is a slash '/' character\n   * inside the attribute value e.g. x@html='text/html'. We need to split\n   * by '/' excluding the '/' which is a part of the attribute's value.\n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<String>();\n    String[] ss = str.split(\"/\");\n    for (int i = 0; i < ss.length; i++) {\n      if (ss[i].length() == 0 && result.size() == 0) continue;\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j = 0; j < ss[i].length(); j++) if (ss[i].charAt(j) == '\\'') quoteCount++;\n        if ((quoteCount % 2) == 0) break;\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f2a93a28913071a0b713be1d4b8a1181388d550","date":1254814948,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","sourceNew":"  /**\n   * The Xpath is split into segments using the '/' as a seperator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a seperator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * seperator or if a sequence of multiple seperator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<String>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip seperator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * The Xpath is split into segments using the '/' s a seperator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We need to split\n   * by '/' excluding the '/' which is a part of the attribute's value.\n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<String>();\n    String[] ss = str.split(\"/\");\n    for (int i = 0; i < ss.length; i++) {\n      if (ss[i].length() == 0 && result.size() == 0) continue;\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j = 0; j < ss[i].length(); j++) if (ss[i].charAt(j) == '\\'') quoteCount++;\n        if ((quoteCount % 2) == 0) break;\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","sourceNew":"  /**\n   * The Xpath is split into segments using the '/' as a seperator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a seperator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * seperator or if a sequence of multiple seperator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<String>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip seperator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * The Xpath is split into segments using the '/' as a seperator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a seperator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * seperator or if a sequence of multiple seperator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<String>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip seperator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3edfeec51825f0aa5e0f17705c86810302f6385e":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["7f2a93a28913071a0b713be1d4b8a1181388d550"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7f2a93a28913071a0b713be1d4b8a1181388d550":["b14ccda0bdb398cf86bc3804e1c136a615dbd89b"],"b14ccda0bdb398cf86bc3804e1c136a615dbd89b":["3edfeec51825f0aa5e0f17705c86810302f6385e"]},"commit2Childs":{"3edfeec51825f0aa5e0f17705c86810302f6385e":["b14ccda0bdb398cf86bc3804e1c136a615dbd89b"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["3edfeec51825f0aa5e0f17705c86810302f6385e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"7f2a93a28913071a0b713be1d4b8a1181388d550":["ad94625fb8d088209f46650c8097196fec67f00c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b14ccda0bdb398cf86bc3804e1c136a615dbd89b":["7f2a93a28913071a0b713be1d4b8a1181388d550"]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}