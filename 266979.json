{"path":"backwards/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","commits":[{"id":"480d01e5b0ef8efb136d51670fec297ae5ae2c9c","date":1268821447,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"backwards/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = segment + \".\" + IndexFileNames.VECTORS_INDEX_EXTENSION;\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"backwards/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = segment + \".\" + IndexFileNames.VECTORS_INDEX_EXTENSION;\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = segment + \".\" + IndexFileNames.VECTORS_INDEX_EXTENSION;\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"]},"commit2Childs":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}