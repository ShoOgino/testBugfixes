{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionFieldsConsumer.CompletionTermWriter#write(BytesRef,TermsEnum).mjava","commits":[{"id":"07e29e9a1cbba8cc30091c3e4f8e9eac7ec7d22a","date":1427495869,"type":0,"author":"Areek Zillur","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionFieldsConsumer.CompletionTermWriter#write(BytesRef,TermsEnum).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Writes all postings (surface form, weight, document id) for <code>term</code>\n     */\n    public void write(BytesRef term, TermsEnum termsEnum) throws IOException {\n      postingsEnum = termsEnum.postings(null, postingsEnum, PostingsEnum.PAYLOADS);\n      builder.startTerm(term);\n      int docFreq = 0;\n      while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        int docID = postingsEnum.docID();\n        for (int i = 0; i < postingsEnum.freq(); i++) {\n          postingsEnum.nextPosition();\n          assert postingsEnum.getPayload() != null;\n          BytesRef payload = postingsEnum.getPayload();\n          ByteArrayDataInput input = new ByteArrayDataInput(payload.bytes, payload.offset, payload.length);\n          int len = input.readVInt();\n          scratch.grow(len);\n          scratch.setLength(len);\n          input.readBytes(scratch.bytes(), 0, scratch.length());\n          builder.addEntry(docID, scratch.get(), input.readVLong() - 1);\n        }\n        docFreq++;\n        docCount = Math.max(docCount, docFreq + 1);\n      }\n      builder.finishTerm();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionFieldsConsumer.CompletionTermWriter#write(BytesRef,TermsEnum).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Writes all postings (surface form, weight, document id) for <code>term</code>\n     */\n    public void write(BytesRef term, TermsEnum termsEnum) throws IOException {\n      postingsEnum = termsEnum.postings(null, postingsEnum, PostingsEnum.PAYLOADS);\n      builder.startTerm(term);\n      int docFreq = 0;\n      while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        int docID = postingsEnum.docID();\n        for (int i = 0; i < postingsEnum.freq(); i++) {\n          postingsEnum.nextPosition();\n          assert postingsEnum.getPayload() != null;\n          BytesRef payload = postingsEnum.getPayload();\n          ByteArrayDataInput input = new ByteArrayDataInput(payload.bytes, payload.offset, payload.length);\n          int len = input.readVInt();\n          scratch.grow(len);\n          scratch.setLength(len);\n          input.readBytes(scratch.bytes(), 0, scratch.length());\n          builder.addEntry(docID, scratch.get(), input.readVLong() - 1);\n        }\n        docFreq++;\n        docCount = Math.max(docCount, docFreq + 1);\n      }\n      builder.finishTerm();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c33f6677a2078739058f81eca1df69d12cd62b0","date":1432799589,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionFieldsConsumer.CompletionTermWriter#write(BytesRef,TermsEnum).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionFieldsConsumer.CompletionTermWriter#write(BytesRef,TermsEnum).mjava","sourceNew":"    /**\n     * Writes all postings (surface form, weight, document id) for <code>term</code>\n     */\n    public void write(BytesRef term, TermsEnum termsEnum) throws IOException {\n      postingsEnum = termsEnum.postings(null, postingsEnum, PostingsEnum.PAYLOADS);\n      builder.startTerm(term);\n      int docFreq = 0;\n      while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        int docID = postingsEnum.docID();\n        for (int i = 0; i < postingsEnum.freq(); i++) {\n          postingsEnum.nextPosition();\n          assert postingsEnum.getPayload() != null;\n          BytesRef payload = postingsEnum.getPayload();\n          ByteArrayDataInput input = new ByteArrayDataInput(payload.bytes, payload.offset, payload.length);\n          int len = input.readVInt();\n          scratch.grow(len);\n          scratch.setLength(len);\n          input.readBytes(scratch.bytes(), 0, scratch.length());\n          long weight = input.readVInt() - 1;\n          maxWeight = Math.max(maxWeight, weight);\n          minWeight = Math.min(minWeight, weight);\n          byte type = input.readByte();\n          if (first) {\n            this.type = type;\n            first = false;\n          } else if (this.type != type) {\n            throw new IllegalArgumentException(\"single field name has mixed types\");\n          }\n          builder.addEntry(docID, scratch.get(), weight);\n        }\n        docFreq++;\n        docCount = Math.max(docCount, docFreq + 1);\n      }\n      builder.finishTerm();\n    }\n\n","sourceOld":"    /**\n     * Writes all postings (surface form, weight, document id) for <code>term</code>\n     */\n    public void write(BytesRef term, TermsEnum termsEnum) throws IOException {\n      postingsEnum = termsEnum.postings(null, postingsEnum, PostingsEnum.PAYLOADS);\n      builder.startTerm(term);\n      int docFreq = 0;\n      while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        int docID = postingsEnum.docID();\n        for (int i = 0; i < postingsEnum.freq(); i++) {\n          postingsEnum.nextPosition();\n          assert postingsEnum.getPayload() != null;\n          BytesRef payload = postingsEnum.getPayload();\n          ByteArrayDataInput input = new ByteArrayDataInput(payload.bytes, payload.offset, payload.length);\n          int len = input.readVInt();\n          scratch.grow(len);\n          scratch.setLength(len);\n          input.readBytes(scratch.bytes(), 0, scratch.length());\n          builder.addEntry(docID, scratch.get(), input.readVLong() - 1);\n        }\n        docFreq++;\n        docCount = Math.max(docCount, docFreq + 1);\n      }\n      builder.finishTerm();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionFieldsConsumer.CompletionTermWriter#write(BytesRef,TermsEnum).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionFieldsConsumer.CompletionTermWriter#write(BytesRef,TermsEnum).mjava","sourceNew":"    /**\n     * Writes all postings (surface form, weight, document id) for <code>term</code>\n     */\n    public void write(BytesRef term, TermsEnum termsEnum) throws IOException {\n      postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.PAYLOADS);\n      builder.startTerm(term);\n      int docFreq = 0;\n      while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        int docID = postingsEnum.docID();\n        for (int i = 0; i < postingsEnum.freq(); i++) {\n          postingsEnum.nextPosition();\n          assert postingsEnum.getPayload() != null;\n          BytesRef payload = postingsEnum.getPayload();\n          ByteArrayDataInput input = new ByteArrayDataInput(payload.bytes, payload.offset, payload.length);\n          int len = input.readVInt();\n          scratch.grow(len);\n          scratch.setLength(len);\n          input.readBytes(scratch.bytes(), 0, scratch.length());\n          long weight = input.readVInt() - 1;\n          maxWeight = Math.max(maxWeight, weight);\n          minWeight = Math.min(minWeight, weight);\n          byte type = input.readByte();\n          if (first) {\n            this.type = type;\n            first = false;\n          } else if (this.type != type) {\n            throw new IllegalArgumentException(\"single field name has mixed types\");\n          }\n          builder.addEntry(docID, scratch.get(), weight);\n        }\n        docFreq++;\n        docCount = Math.max(docCount, docFreq + 1);\n      }\n      builder.finishTerm();\n    }\n\n","sourceOld":"    /**\n     * Writes all postings (surface form, weight, document id) for <code>term</code>\n     */\n    public void write(BytesRef term, TermsEnum termsEnum) throws IOException {\n      postingsEnum = termsEnum.postings(null, postingsEnum, PostingsEnum.PAYLOADS);\n      builder.startTerm(term);\n      int docFreq = 0;\n      while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        int docID = postingsEnum.docID();\n        for (int i = 0; i < postingsEnum.freq(); i++) {\n          postingsEnum.nextPosition();\n          assert postingsEnum.getPayload() != null;\n          BytesRef payload = postingsEnum.getPayload();\n          ByteArrayDataInput input = new ByteArrayDataInput(payload.bytes, payload.offset, payload.length);\n          int len = input.readVInt();\n          scratch.grow(len);\n          scratch.setLength(len);\n          input.readBytes(scratch.bytes(), 0, scratch.length());\n          long weight = input.readVInt() - 1;\n          maxWeight = Math.max(maxWeight, weight);\n          minWeight = Math.min(minWeight, weight);\n          byte type = input.readByte();\n          if (first) {\n            this.type = type;\n            first = false;\n          } else if (this.type != type) {\n            throw new IllegalArgumentException(\"single field name has mixed types\");\n          }\n          builder.addEntry(docID, scratch.get(), weight);\n        }\n        docFreq++;\n        docCount = Math.max(docCount, docFreq + 1);\n      }\n      builder.finishTerm();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","07e29e9a1cbba8cc30091c3e4f8e9eac7ec7d22a"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["8c33f6677a2078739058f81eca1df69d12cd62b0"],"07e29e9a1cbba8cc30091c3e4f8e9eac7ec7d22a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8c33f6677a2078739058f81eca1df69d12cd62b0":["07e29e9a1cbba8cc30091c3e4f8e9eac7ec7d22a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4464508ee83288c8c4585b533f9faaa93aa314"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0f4464508ee83288c8c4585b533f9faaa93aa314":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"07e29e9a1cbba8cc30091c3e4f8e9eac7ec7d22a":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","8c33f6677a2078739058f81eca1df69d12cd62b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","07e29e9a1cbba8cc30091c3e4f8e9eac7ec7d22a"],"8c33f6677a2078739058f81eca1df69d12cd62b0":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}