{"path":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","commits":[{"id":"a760e2135dfe20a04dea360873d4de1c6a0280bb","date":1430762855,"type":0,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Extract handler from the URL path if not set.\n   * This returns true if the action is set.\n   * \n   */\n  private void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            return;\n          }\n        }\n\n      }\n      // no handler yet but allowed to handle select; let's check\n\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          invalidStates = checkStateIsValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fcf710a8fcd590cf55c855d422c7a10fce3e6117","date":1485842253,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","sourceNew":"  /**\n   * Extract handler from the URL path if not set.\n   * This returns true if the action is set.\n   * \n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            return;\n          }\n        }\n\n      }\n      // no handler yet but allowed to handle select; let's check\n\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          invalidStates = checkStateIsValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Extract handler from the URL path if not set.\n   * This returns true if the action is set.\n   * \n   */\n  private void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            return;\n          }\n        }\n\n      }\n      // no handler yet but allowed to handle select; let's check\n\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          invalidStates = checkStateIsValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","sourceNew":"  /**\n   * Extract handler from the URL path if not set.\n   * This returns true if the action is set.\n   * \n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            return;\n          }\n        }\n\n      }\n      // no handler yet but allowed to handle select; let's check\n\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          invalidStates = checkStateIsValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Extract handler from the URL path if not set.\n   * This returns true if the action is set.\n   * \n   */\n  private void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            return;\n          }\n        }\n\n      }\n      // no handler yet but allowed to handle select; let's check\n\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          invalidStates = checkStateIsValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9d03b984af6c0085aa4985799de48f8c203844a","date":1498707843,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","sourceNew":"  /**\n   * Extract handler from the URL path if not set.\n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            return;\n          }\n        }\n      }\n\n      // no handler yet but <requestDispatcher> allows us to handle /select with a 'qt' param\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Extract handler from the URL path if not set.\n   * This returns true if the action is set.\n   * \n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            return;\n          }\n        }\n\n      }\n      // no handler yet but allowed to handle select; let's check\n\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          invalidStates = checkStateIsValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","sourceNew":"  /**\n   * Extract handler from the URL path if not set.\n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            return;\n          }\n        }\n      }\n\n      // no handler yet but <requestDispatcher> allows us to handle /select with a 'qt' param\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Extract handler from the URL path if not set.\n   * This returns true if the action is set.\n   * \n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            return;\n          }\n        }\n\n      }\n      // no handler yet but allowed to handle select; let's check\n\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          invalidStates = checkStateIsValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","sourceNew":"  /**\n   * Extract handler from the URL path if not set.\n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            return;\n          }\n        }\n      }\n\n      // no handler yet but <requestDispatcher> allows us to handle /select with a 'qt' param\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Extract handler from the URL path if not set.\n   * This returns true if the action is set.\n   * \n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            return;\n          }\n        }\n\n      }\n      // no handler yet but allowed to handle select; let's check\n\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          invalidStates = checkStateIsValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba52b298388110adda4c077defc2ab02b2b3fcc7","date":1563183607,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","sourceNew":"  /**\n   * Extract handler from the URL path if not set.\n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            SolrRequestInfo.getRequestInfo().setAction(action);\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            SolrRequestInfo.getRequestInfo().setAction(action);\n            return;\n          }\n        }\n      }\n\n      // no handler yet but <requestDispatcher> allows us to handle /select with a 'qt' param\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Extract handler from the URL path if not set.\n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            return;\n          }\n        }\n      }\n\n      // no handler yet but <requestDispatcher> allows us to handle /select with a 'qt' param\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96a40e7df78bbd3a3fcc50819359d6ce811755f2","date":1579797423,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","sourceNew":"  /**\n   * Extract handler from the URL path if not set.\n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n          }\n          SolrRequestInfo.getRequestInfo().setAction(action);\n          return;\n        }\n      }\n\n      // no handler yet but <requestDispatcher> allows us to handle /select with a 'qt' param\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Extract handler from the URL path if not set.\n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n            SolrRequestInfo.getRequestInfo().setAction(action);\n            return;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n            SolrRequestInfo.getRequestInfo().setAction(action);\n            return;\n          }\n        }\n      }\n\n      // no handler yet but <requestDispatcher> allows us to handle /select with a 'qt' param\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4","date":1592286410,"type":3,"author":"Nazerke Seidan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","sourceNew":"  /**\n   * Extract handler from the URL path if not set.\n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          mustClearSolrRequestInfo = true;\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n          }\n          SolrRequestInfo.getRequestInfo().setAction(action);\n          return;\n        }\n      }\n\n      // no handler yet but <requestDispatcher> allows us to handle /select with a 'qt' param\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Extract handler from the URL path if not set.\n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n          }\n          SolrRequestInfo.getRequestInfo().setAction(action);\n          return;\n        }\n      }\n\n      // no handler yet but <requestDispatcher> allows us to handle /select with a 'qt' param\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b","date":1601832109,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#extractHandlerFromURLPath(SolrRequestParsers).mjava","sourceNew":"  /**\n   * Extract handler from the URL path if not set.\n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n      // no handler yet but <requestDispatcher> allows us to handle /select with a 'qt' param\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Extract handler from the URL path if not set.\n   */\n  protected void extractHandlerFromURLPath(SolrRequestParsers parser) throws Exception {\n    if (handler == null && path.length() > 1) { // don't match \"\" or \"/\" as valid path\n      handler = core.getRequestHandler(path);\n\n      if (handler == null) {\n        //may be a restlet path\n        // Handle /schema/* paths via Restlet\n        if (path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n          solrReq = parser.parse(core, path, req);\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n          mustClearSolrRequestInfo = true;\n          if (path.equals(req.getServletPath())) {\n            // avoid endless loop - pass through to Restlet via webapp\n            action = PASSTHROUGH;\n          } else {\n            // forward rewritten URI (without path prefix and core/collection name) to Restlet\n            action = FORWARD;\n          }\n          SolrRequestInfo.getRequestInfo().setAction(action);\n          return;\n        }\n      }\n\n      // no handler yet but <requestDispatcher> allows us to handle /select with a 'qt' param\n      if (handler == null && parser.isHandleSelect()) {\n        if (\"/select\".equals(path) || \"/select/\".equals(path)) {\n          solrReq = parser.parse(core, path, req);\n          String qt = solrReq.getParams().get(CommonParams.QT);\n          handler = core.getRequestHandler(qt);\n          if (handler == null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \" + qt);\n          }\n          if (qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n            //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n            //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \" + qt);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b":["a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4"],"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["a760e2135dfe20a04dea360873d4de1c6a0280bb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["a760e2135dfe20a04dea360873d4de1c6a0280bb","fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"a760e2135dfe20a04dea360873d4de1c6a0280bb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"30c8e5574b55d57947e989443dfde611646530ee":["fcf710a8fcd590cf55c855d422c7a10fce3e6117","28288370235ed02234a64753cdbf0c6ec096304a"],"96a40e7df78bbd3a3fcc50819359d6ce811755f2":["ba52b298388110adda4c077defc2ab02b2b3fcc7"],"ba52b298388110adda4c077defc2ab02b2b3fcc7":["28288370235ed02234a64753cdbf0c6ec096304a"],"a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4":["96a40e7df78bbd3a3fcc50819359d6ce811755f2"],"c9d03b984af6c0085aa4985799de48f8c203844a":["fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"28288370235ed02234a64753cdbf0c6ec096304a":["fcf710a8fcd590cf55c855d422c7a10fce3e6117","c9d03b984af6c0085aa4985799de48f8c203844a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b"]},"commit2Childs":{"89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","30c8e5574b55d57947e989443dfde611646530ee","c9d03b984af6c0085aa4985799de48f8c203844a","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a760e2135dfe20a04dea360873d4de1c6a0280bb"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"a760e2135dfe20a04dea360873d4de1c6a0280bb":["fcf710a8fcd590cf55c855d422c7a10fce3e6117","7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"30c8e5574b55d57947e989443dfde611646530ee":[],"96a40e7df78bbd3a3fcc50819359d6ce811755f2":["a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4"],"ba52b298388110adda4c077defc2ab02b2b3fcc7":["96a40e7df78bbd3a3fcc50819359d6ce811755f2"],"a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4":["89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b"],"c9d03b984af6c0085aa4985799de48f8c203844a":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["30c8e5574b55d57947e989443dfde611646530ee","ba52b298388110adda4c077defc2ab02b2b3fcc7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}