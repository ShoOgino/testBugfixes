{"path":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","pathOld":"modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","sourceNew":"    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(true){\n          final InputStream localFileIS = is;\n          try {\n            // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n            CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n            reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n          } catch (IOException ioe) {\n            synchronized(EnwikiContentSource.this) {\n              if (localFileIS != is) {\n                // fileIS was closed on us, so, just fall\n                // through\n              } else\n                // Exception is real\n                throw ioe;\n            }\n          }\n          synchronized(this) {\n            if (!forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = StreamUtils.inputStream(file);\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","sourceOld":"    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(true){\n          final InputStream localFileIS = is;\n          try {\n            // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n            CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n            reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n          } catch (IOException ioe) {\n            synchronized(EnwikiContentSource.this) {\n              if (localFileIS != is) {\n                // fileIS was closed on us, so, just fall\n                // through\n              } else\n                // Exception is real\n                throw ioe;\n            }\n          }\n          synchronized(this) {\n            if (!forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = StreamUtils.inputStream(file);\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c49feedffe47df314319e4b6a415dde78a67827","date":1354787662,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","sourceNew":"    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          try {\n            // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n            CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n            reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n          } catch (IOException ioe) {\n            synchronized(EnwikiContentSource.this) {\n              if (localFileIS != is) {\n                // fileIS was closed on us, so, just fall through\n              } else\n                // Exception is real\n                throw ioe;\n            }\n          }\n          synchronized(this) {\n            if (!forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","sourceOld":"    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(true){\n          final InputStream localFileIS = is;\n          try {\n            // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n            CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n            reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n          } catch (IOException ioe) {\n            synchronized(EnwikiContentSource.this) {\n              if (localFileIS != is) {\n                // fileIS was closed on us, so, just fall\n                // through\n              } else\n                // Exception is real\n                throw ioe;\n            }\n          }\n          synchronized(this) {\n            if (!forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = StreamUtils.inputStream(file);\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa1c670e7847c52786d5edfd513bd4210e6160d7","date":1354879913,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","sourceNew":"    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                  .onMalformedInput(CodingErrorAction.REPORT)\n                  .onUnmappableCharacter(CodingErrorAction.REPORT);\n              reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","sourceOld":"    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          try {\n            // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n            CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n            reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n          } catch (IOException ioe) {\n            synchronized(EnwikiContentSource.this) {\n              if (localFileIS != is) {\n                // fileIS was closed on us, so, just fall through\n              } else\n                // Exception is real\n                throw ioe;\n            }\n          }\n          synchronized(this) {\n            if (!forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","sourceNew":"    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                  .onMalformedInput(CodingErrorAction.REPORT)\n                  .onUnmappableCharacter(CodingErrorAction.REPORT);\n              reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","sourceOld":"    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(true){\n          final InputStream localFileIS = is;\n          try {\n            // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n            CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n            reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n          } catch (IOException ioe) {\n            synchronized(EnwikiContentSource.this) {\n              if (localFileIS != is) {\n                // fileIS was closed on us, so, just fall\n                // through\n              } else\n                // Exception is real\n                throw ioe;\n            }\n          }\n          synchronized(this) {\n            if (!forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = StreamUtils.inputStream(file);\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                  .onMalformedInput(CodingErrorAction.REPORT)\n                  .onUnmappableCharacter(CodingErrorAction.REPORT);\n              reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","sourceOld":"    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                  .onMalformedInput(CodingErrorAction.REPORT)\n                  .onUnmappableCharacter(CodingErrorAction.REPORT);\n              reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                  .onMalformedInput(CodingErrorAction.REPORT)\n                  .onUnmappableCharacter(CodingErrorAction.REPORT);\n              reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","sourceOld":"    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                  .onMalformedInput(CodingErrorAction.REPORT)\n                  .onUnmappableCharacter(CodingErrorAction.REPORT);\n              reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d89d7e4e5101347833eea558851bf4209218619","date":1396265641,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              reader.parse(new InputSource(IOUtils.getDecodingReader(localFileIS, StandardCharsets.UTF_8)));\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                  .onMalformedInput(CodingErrorAction.REPORT)\n                  .onUnmappableCharacter(CodingErrorAction.REPORT);\n              reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              reader.parse(new InputSource(IOUtils.getDecodingReader(localFileIS, StandardCharsets.UTF_8)));\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n                  .onMalformedInput(CodingErrorAction.REPORT)\n                  .onUnmappableCharacter(CodingErrorAction.REPORT);\n              reader.parse(new InputSource(new BufferedReader(new InputStreamReader(localFileIS, decoder))));\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5891bd634d5ddbf7c48cff0f4818c682ca42a4a6","date":1421884114,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              reader.parse(new InputSource(IOUtils.getDecodingReader(localFileIS, StandardCharsets.UTF_8)));\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException | IOException sae) {\n        throw new RuntimeException(sae);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              reader.parse(new InputSource(IOUtils.getDecodingReader(localFileIS, StandardCharsets.UTF_8)));\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException sae) {\n        throw new RuntimeException(sae);\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.Parser#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      try {\n        SAXParser reader = SAX_PARSER_FACTORY.newSAXParser();\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              reader.parse(new InputSource(IOUtils.getDecodingReader(localFileIS, StandardCharsets.UTF_8)), this);\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException | IOException | ParserConfigurationException sae) {\n        throw new RuntimeException(sae);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      try {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setContentHandler(this);\n        reader.setErrorHandler(this);\n        while(!stopped){\n          final InputStream localFileIS = is;\n          if (localFileIS != null) { // null means fileIS was closed on us \n            try {\n              // To work around a bug in XERCES (XERCESJ-1257), we assume the XML is always UTF8, so we simply provide reader.\n              reader.parse(new InputSource(IOUtils.getDecodingReader(localFileIS, StandardCharsets.UTF_8)));\n            } catch (IOException ioe) {\n              synchronized(EnwikiContentSource.this) {\n                if (localFileIS != is) {\n                  // fileIS was closed on us, so, just fall through\n                } else\n                  // Exception is real\n                  throw ioe;\n              }\n            }\n          }\n          synchronized(this) {\n            if (stopped || !forever) {\n              nmde = new NoMoreDataException();\n              notify();\n              return;\n            } else if (localFileIS == is) {\n              // If file is not already re-opened then re-open it now\n              is = openInputStream();\n            }\n          }\n        }\n      } catch (SAXException | IOException sae) {\n        throw new RuntimeException(sae);\n      } finally {\n        synchronized(this) {\n          threadDone = true;\n          notify();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["7530de27b87b961b51f01bd1299b7004d46e8823","7d89d7e4e5101347833eea558851bf4209218619"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","7530de27b87b961b51f01bd1299b7004d46e8823"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["5891bd634d5ddbf7c48cff0f4818c682ca42a4a6"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2c49feedffe47df314319e4b6a415dde78a67827":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"5891bd634d5ddbf7c48cff0f4818c682ca42a4a6":["7d89d7e4e5101347833eea558851bf4209218619"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["b89678825b68eccaf09e6ab71675fc0b0af1e099","aa1c670e7847c52786d5edfd513bd4210e6160d7"],"7d89d7e4e5101347833eea558851bf4209218619":["7530de27b87b961b51f01bd1299b7004d46e8823"],"7530de27b87b961b51f01bd1299b7004d46e8823":["aa1c670e7847c52786d5edfd513bd4210e6160d7"],"aa1c670e7847c52786d5edfd513bd4210e6160d7":["2c49feedffe47df314319e4b6a415dde78a67827"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b88a121b875f9ae2ac50f85cf46dcb680f126357"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["2c49feedffe47df314319e4b6a415dde78a67827","407687e67faf6e1f02a211ca078d8e3eed631027"],"2c49feedffe47df314319e4b6a415dde78a67827":["aa1c670e7847c52786d5edfd513bd4210e6160d7"],"5891bd634d5ddbf7c48cff0f4818c682ca42a4a6":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"7d89d7e4e5101347833eea558851bf4209218619":["5eb2511ababf862ea11e10761c70ee560cd84510","5891bd634d5ddbf7c48cff0f4818c682ca42a4a6"],"7530de27b87b961b51f01bd1299b7004d46e8823":["5eb2511ababf862ea11e10761c70ee560cd84510","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7d89d7e4e5101347833eea558851bf4209218619"],"aa1c670e7847c52786d5edfd513bd4210e6160d7":["407687e67faf6e1f02a211ca078d8e3eed631027","7530de27b87b961b51f01bd1299b7004d46e8823"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}