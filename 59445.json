{"path":"src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","pathOld":"/dev/null","sourceNew":"  public static final boolean wildcardEquals(String pattern, int patternIdx, String string, int stringIdx) {\n    for ( int p = patternIdx; ; ++p ) {\n      for ( int s = stringIdx; ; ++p, ++s ) {\n        boolean sEnd = (s >= string.length());\n        boolean pEnd = (p >= pattern.length());\n        \n        if (sEnd && pEnd) return true;\n        if (sEnd || pEnd) break;\n        if (pattern.charAt(p) == WILDCARD_CHAR) continue;\n        if (pattern.charAt(p) == WILDCARD_STRING) {\n          int i;\n          ++p;\n          for (i = string.length(); i >= s; --i)\n            if (wildcardEquals(pattern, p, string, i))\n              return true;\n          break;\n        }\n        if (pattern.charAt(p) != string.charAt(s)) break;\n      }\n      return false;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"541afc123d92f32d0d5fc1bf817fc97f73665622","date":1018411538,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","pathOld":"src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","sourceNew":"    /**\n     * Determines if a word matches a wildcard pattern.\n     * <small>Work released by Granta Design Ltd after originally being done on\n     * company time.</small>\n     */\n    public static final boolean wildcardEquals(String pattern, int patternIdx,\n\tString string, int stringIdx)\n    {\n        for (int p = patternIdx; ; ++p)\n        {\n            for (int s = stringIdx; ; ++p, ++s)\n            {\n                // End of string yet?\n                boolean sEnd = (s >= string.length());\n                // End of pattern yet?\n                boolean pEnd = (p >= pattern.length());\n\n                // If we're looking at the end of the string...\n                if (sEnd)\n                {\n                    // Assume the only thing left on the pattern is/are wildcards\n                    boolean justWildcardsLeft = true;\n\n                    // Current wildcard position\n                    int wildcardSearchPos = p;\n                    // While we haven't found the end of the pattern,\n\t\t    // and haven't encountered any non-wildcard characters\n                    while (wildcardSearchPos < pattern.length() && justWildcardsLeft)\n                    {\n                        // Check the character at the current position\n                        char wildchar = pattern.charAt(wildcardSearchPos);\n                        // If it's not a wildcard character, then there is more\n\t\t\t// pattern information after this/these wildcards.\n\n                        if (wildchar != WILDCARD_CHAR &&\n\t\t\t    wildchar != WILDCARD_STRING)\n                        {\n                            justWildcardsLeft = false;\n                        }\n                        else\n                        {\n                            // Look at the next character\n                            wildcardSearchPos++;\n                        }\n                    }\n\n                    // This was a prefix wildcard search, and we've matched, so\n\t\t    // return true.\n                    if (justWildcardsLeft)\n\t\t    {\n                        return true;\n\t\t    }\n                }\n\n                // If we've gone past the end of the string, or the pattern,\n\t\t// return false.\n                if (sEnd || pEnd)\n\t\t{\n\t\t    break;\n\t\t}\n\n                // Match a single character, so continue.\n                if (pattern.charAt(p) == WILDCARD_CHAR)\n\t\t{\n\t\t    continue;\n\t\t}\n\n                //\n                if (pattern.charAt(p) == WILDCARD_STRING)\n                {\n                    // Look at the character beyond the '*'.\n                    ++p;\n                    // Examine the string, starting at the last character.\n                    for (int i = string.length(); i >= s; --i)\n                    {\n                        if (wildcardEquals(pattern, p, string, i))\n\t\t\t{\n                            return true;\n\t\t\t}\n                    }\n                    break;\n                }\n                if (pattern.charAt(p) != string.charAt(s))\n\t\t{\n\t\t    break;\n\t\t}\n            }\n            return false;\n\t}\n    }\n\n","sourceOld":"  public static final boolean wildcardEquals(String pattern, int patternIdx, String string, int stringIdx) {\n    for ( int p = patternIdx; ; ++p ) {\n      for ( int s = stringIdx; ; ++p, ++s ) {\n        boolean sEnd = (s >= string.length());\n        boolean pEnd = (p >= pattern.length());\n        \n        if (sEnd && pEnd) return true;\n        if (sEnd || pEnd) break;\n        if (pattern.charAt(p) == WILDCARD_CHAR) continue;\n        if (pattern.charAt(p) == WILDCARD_STRING) {\n          int i;\n          ++p;\n          for (i = string.length(); i >= s; --i)\n            if (wildcardEquals(pattern, p, string, i))\n              return true;\n          break;\n        }\n        if (pattern.charAt(p) != string.charAt(s)) break;\n      }\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3449282534151d4584c6dd66673158b9d62996a7","date":1063188287,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","pathOld":"src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","sourceNew":"  /**\n   * Determines if a word matches a wildcard pattern.\n   * <small>Work released by Granta Design Ltd after originally being done on\n   * company time.</small>\n   */\n  public static final boolean wildcardEquals(String pattern, int patternIdx,\n    String string, int stringIdx)\n  {\n    for (int p = patternIdx; ; ++p)\n    {\n      for (int s = stringIdx; ; ++p, ++s)\n      {\n        // End of string yet?\n        boolean sEnd = (s >= string.length());\n        // End of pattern yet?\n        boolean pEnd = (p >= pattern.length());\n\n        // If we're looking at the end of the string...\n        if (sEnd)\n        {\n          // Assume the only thing left on the pattern is/are wildcards\n          boolean justWildcardsLeft = true;\n\n          // Current wildcard position\n          int wildcardSearchPos = p;\n          // While we haven't found the end of the pattern,\n          // and haven't encountered any non-wildcard characters\n          while (wildcardSearchPos < pattern.length() && justWildcardsLeft)\n          {\n            // Check the character at the current position\n            char wildchar = pattern.charAt(wildcardSearchPos);\n            // If it's not a wildcard character, then there is more\n            // pattern information after this/these wildcards.\n\n            if (wildchar != WILDCARD_CHAR && wildchar != WILDCARD_STRING)\n            {\n              justWildcardsLeft = false;\n            }\n            else\n            {\n              // Look at the next character\n              wildcardSearchPos++;\n            }\n          }\n\n          // This was a prefix wildcard search, and we've matched, so\n          // return true.\n          if (justWildcardsLeft)\n          {\n            return true;\n          }\n        }\n\n        // If we've gone past the end of the string, or the pattern,\n        // return false.\n        if (sEnd || pEnd)\n        {\n          break;\n        }\n\n        // Match a single character, so continue.\n        if (pattern.charAt(p) == WILDCARD_CHAR)\n        {\n          continue;\n        }\n\n        //\n        if (pattern.charAt(p) == WILDCARD_STRING)\n        {\n          // Look at the character beyond the '*'.\n          ++p;\n          // Examine the string, starting at the last character.\n          for (int i = string.length(); i >= s; --i)\n          {\n            if (wildcardEquals(pattern, p, string, i))\n            {\n              return true;\n            }\n          }\n          break;\n        }\n        if (pattern.charAt(p) != string.charAt(s))\n        {\n          break;\n        }\n      }\n      return false;\n    }\n  }\n\n","sourceOld":"    /**\n     * Determines if a word matches a wildcard pattern.\n     * <small>Work released by Granta Design Ltd after originally being done on\n     * company time.</small>\n     */\n    public static final boolean wildcardEquals(String pattern, int patternIdx,\n\tString string, int stringIdx)\n    {\n        for (int p = patternIdx; ; ++p)\n        {\n            for (int s = stringIdx; ; ++p, ++s)\n            {\n                // End of string yet?\n                boolean sEnd = (s >= string.length());\n                // End of pattern yet?\n                boolean pEnd = (p >= pattern.length());\n\n                // If we're looking at the end of the string...\n                if (sEnd)\n                {\n                    // Assume the only thing left on the pattern is/are wildcards\n                    boolean justWildcardsLeft = true;\n\n                    // Current wildcard position\n                    int wildcardSearchPos = p;\n                    // While we haven't found the end of the pattern,\n\t\t    // and haven't encountered any non-wildcard characters\n                    while (wildcardSearchPos < pattern.length() && justWildcardsLeft)\n                    {\n                        // Check the character at the current position\n                        char wildchar = pattern.charAt(wildcardSearchPos);\n                        // If it's not a wildcard character, then there is more\n\t\t\t// pattern information after this/these wildcards.\n\n                        if (wildchar != WILDCARD_CHAR &&\n\t\t\t    wildchar != WILDCARD_STRING)\n                        {\n                            justWildcardsLeft = false;\n                        }\n                        else\n                        {\n                            // Look at the next character\n                            wildcardSearchPos++;\n                        }\n                    }\n\n                    // This was a prefix wildcard search, and we've matched, so\n\t\t    // return true.\n                    if (justWildcardsLeft)\n\t\t    {\n                        return true;\n\t\t    }\n                }\n\n                // If we've gone past the end of the string, or the pattern,\n\t\t// return false.\n                if (sEnd || pEnd)\n\t\t{\n\t\t    break;\n\t\t}\n\n                // Match a single character, so continue.\n                if (pattern.charAt(p) == WILDCARD_CHAR)\n\t\t{\n\t\t    continue;\n\t\t}\n\n                //\n                if (pattern.charAt(p) == WILDCARD_STRING)\n                {\n                    // Look at the character beyond the '*'.\n                    ++p;\n                    // Examine the string, starting at the last character.\n                    for (int i = string.length(); i >= s; --i)\n                    {\n                        if (wildcardEquals(pattern, p, string, i))\n\t\t\t{\n                            return true;\n\t\t\t}\n                    }\n                    break;\n                }\n                if (pattern.charAt(p) != string.charAt(s))\n\t\t{\n\t\t    break;\n\t\t}\n            }\n            return false;\n\t}\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9643123c5376a78d0f62a0bb8d5bfd6beb667053","date":1095957827,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","pathOld":"src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","sourceNew":"  /**\n   * Determines if a word matches a wildcard pattern.\n   * <small>Work released by Granta Design Ltd after originally being done on\n   * company time.</small>\n   */\n  public static final boolean wildcardEquals(String pattern, int patternIdx,\n    String string, int stringIdx)\n  {\n    int p = patternIdx;\n    \n    for (int s = stringIdx; ; ++p, ++s)\n      {\n        // End of string yet?\n        boolean sEnd = (s >= string.length());\n        // End of pattern yet?\n        boolean pEnd = (p >= pattern.length());\n\n        // If we're looking at the end of the string...\n        if (sEnd)\n        {\n          // Assume the only thing left on the pattern is/are wildcards\n          boolean justWildcardsLeft = true;\n\n          // Current wildcard position\n          int wildcardSearchPos = p;\n          // While we haven't found the end of the pattern,\n          // and haven't encountered any non-wildcard characters\n          while (wildcardSearchPos < pattern.length() && justWildcardsLeft)\n          {\n            // Check the character at the current position\n            char wildchar = pattern.charAt(wildcardSearchPos);\n            // If it's not a wildcard character, then there is more\n            // pattern information after this/these wildcards.\n\n            if (wildchar != WILDCARD_CHAR && wildchar != WILDCARD_STRING)\n            {\n              justWildcardsLeft = false;\n            }\n            else\n            {\n              // Look at the next character\n              wildcardSearchPos++;\n            }\n          }\n\n          // This was a prefix wildcard search, and we've matched, so\n          // return true.\n          if (justWildcardsLeft)\n          {\n            return true;\n          }\n        }\n\n        // If we've gone past the end of the string, or the pattern,\n        // return false.\n        if (sEnd || pEnd)\n        {\n          break;\n        }\n\n        // Match a single character, so continue.\n        if (pattern.charAt(p) == WILDCARD_CHAR)\n        {\n          continue;\n        }\n\n        //\n        if (pattern.charAt(p) == WILDCARD_STRING)\n        {\n          // Look at the character beyond the '*'.\n          ++p;\n          // Examine the string, starting at the last character.\n          for (int i = string.length(); i >= s; --i)\n          {\n            if (wildcardEquals(pattern, p, string, i))\n            {\n              return true;\n            }\n          }\n          break;\n        }\n        if (pattern.charAt(p) != string.charAt(s))\n        {\n          break;\n        }\n      }\n      return false;\n  }\n\n","sourceOld":"  /**\n   * Determines if a word matches a wildcard pattern.\n   * <small>Work released by Granta Design Ltd after originally being done on\n   * company time.</small>\n   */\n  public static final boolean wildcardEquals(String pattern, int patternIdx,\n    String string, int stringIdx)\n  {\n    for (int p = patternIdx; ; ++p)\n    {\n      for (int s = stringIdx; ; ++p, ++s)\n      {\n        // End of string yet?\n        boolean sEnd = (s >= string.length());\n        // End of pattern yet?\n        boolean pEnd = (p >= pattern.length());\n\n        // If we're looking at the end of the string...\n        if (sEnd)\n        {\n          // Assume the only thing left on the pattern is/are wildcards\n          boolean justWildcardsLeft = true;\n\n          // Current wildcard position\n          int wildcardSearchPos = p;\n          // While we haven't found the end of the pattern,\n          // and haven't encountered any non-wildcard characters\n          while (wildcardSearchPos < pattern.length() && justWildcardsLeft)\n          {\n            // Check the character at the current position\n            char wildchar = pattern.charAt(wildcardSearchPos);\n            // If it's not a wildcard character, then there is more\n            // pattern information after this/these wildcards.\n\n            if (wildchar != WILDCARD_CHAR && wildchar != WILDCARD_STRING)\n            {\n              justWildcardsLeft = false;\n            }\n            else\n            {\n              // Look at the next character\n              wildcardSearchPos++;\n            }\n          }\n\n          // This was a prefix wildcard search, and we've matched, so\n          // return true.\n          if (justWildcardsLeft)\n          {\n            return true;\n          }\n        }\n\n        // If we've gone past the end of the string, or the pattern,\n        // return false.\n        if (sEnd || pEnd)\n        {\n          break;\n        }\n\n        // Match a single character, so continue.\n        if (pattern.charAt(p) == WILDCARD_CHAR)\n        {\n          continue;\n        }\n\n        //\n        if (pattern.charAt(p) == WILDCARD_STRING)\n        {\n          // Look at the character beyond the '*'.\n          ++p;\n          // Examine the string, starting at the last character.\n          for (int i = string.length(); i >= s; --i)\n          {\n            if (wildcardEquals(pattern, p, string, i))\n            {\n              return true;\n            }\n          }\n          break;\n        }\n        if (pattern.charAt(p) != string.charAt(s))\n        {\n          break;\n        }\n      }\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83fc06d3da543755d60fc5c175a35575b2c8c6dc","date":1130778336,"type":3,"author":"Bernhard Messer","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","pathOld":"src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","sourceNew":"  /**\n   * Determines if a word matches a wildcard pattern.\n   * <small>Work released by Granta Design Ltd after originally being done on\n   * company time.</small>\n   */\n  public static final boolean wildcardEquals(String pattern, int patternIdx,\n    String string, int stringIdx)\n  {\n    int p = patternIdx;\n    \n    for (int s = stringIdx; ; ++p, ++s)\n      {\n        // End of string yet?\n        boolean sEnd = (s >= string.length());\n        // End of pattern yet?\n        boolean pEnd = (p >= pattern.length());\n\n        // If we're looking at the end of the string...\n        if (sEnd)\n        {\n          // Assume the only thing left on the pattern is/are wildcards\n          boolean justWildcardsLeft = true;\n\n          // Current wildcard position\n          int wildcardSearchPos = p;\n          // While we haven't found the end of the pattern,\n          // and haven't encountered any non-wildcard characters\n          while (wildcardSearchPos < pattern.length() && justWildcardsLeft)\n          {\n            // Check the character at the current position\n            char wildchar = pattern.charAt(wildcardSearchPos);\n            \n            // If it's not a wildcard character, then there is more\n            // pattern information after this/these wildcards.\n            if (wildchar != WILDCARD_CHAR && wildchar != WILDCARD_STRING)\n            {\n              justWildcardsLeft = false;\n            }\n            else\n            {\n              // to prevent \"cat\" matches \"ca??\"\n              if (wildchar == WILDCARD_CHAR) {\n                return false;\n              }\n              \n              // Look at the next character\n              wildcardSearchPos++;\n            }\n          }\n\n          // This was a prefix wildcard search, and we've matched, so\n          // return true.\n          if (justWildcardsLeft)\n          {\n            return true;\n          }\n        }\n\n        // If we've gone past the end of the string, or the pattern,\n        // return false.\n        if (sEnd || pEnd)\n        {\n          break;\n        }\n\n        // Match a single character, so continue.\n        if (pattern.charAt(p) == WILDCARD_CHAR)\n        {\n          continue;\n        }\n\n        //\n        if (pattern.charAt(p) == WILDCARD_STRING)\n        {\n          // Look at the character beyond the '*'.\n          ++p;\n          // Examine the string, starting at the last character.\n          for (int i = string.length(); i >= s; --i)\n          {\n            if (wildcardEquals(pattern, p, string, i))\n            {\n              return true;\n            }\n          }\n          break;\n        }\n        if (pattern.charAt(p) != string.charAt(s))\n        {\n          break;\n        }\n      }\n      return false;\n  }\n\n","sourceOld":"  /**\n   * Determines if a word matches a wildcard pattern.\n   * <small>Work released by Granta Design Ltd after originally being done on\n   * company time.</small>\n   */\n  public static final boolean wildcardEquals(String pattern, int patternIdx,\n    String string, int stringIdx)\n  {\n    int p = patternIdx;\n    \n    for (int s = stringIdx; ; ++p, ++s)\n      {\n        // End of string yet?\n        boolean sEnd = (s >= string.length());\n        // End of pattern yet?\n        boolean pEnd = (p >= pattern.length());\n\n        // If we're looking at the end of the string...\n        if (sEnd)\n        {\n          // Assume the only thing left on the pattern is/are wildcards\n          boolean justWildcardsLeft = true;\n\n          // Current wildcard position\n          int wildcardSearchPos = p;\n          // While we haven't found the end of the pattern,\n          // and haven't encountered any non-wildcard characters\n          while (wildcardSearchPos < pattern.length() && justWildcardsLeft)\n          {\n            // Check the character at the current position\n            char wildchar = pattern.charAt(wildcardSearchPos);\n            // If it's not a wildcard character, then there is more\n            // pattern information after this/these wildcards.\n\n            if (wildchar != WILDCARD_CHAR && wildchar != WILDCARD_STRING)\n            {\n              justWildcardsLeft = false;\n            }\n            else\n            {\n              // Look at the next character\n              wildcardSearchPos++;\n            }\n          }\n\n          // This was a prefix wildcard search, and we've matched, so\n          // return true.\n          if (justWildcardsLeft)\n          {\n            return true;\n          }\n        }\n\n        // If we've gone past the end of the string, or the pattern,\n        // return false.\n        if (sEnd || pEnd)\n        {\n          break;\n        }\n\n        // Match a single character, so continue.\n        if (pattern.charAt(p) == WILDCARD_CHAR)\n        {\n          continue;\n        }\n\n        //\n        if (pattern.charAt(p) == WILDCARD_STRING)\n        {\n          // Look at the character beyond the '*'.\n          ++p;\n          // Examine the string, starting at the last character.\n          for (int i = string.length(); i >= s; --i)\n          {\n            if (wildcardEquals(pattern, p, string, i))\n            {\n              return true;\n            }\n          }\n          break;\n        }\n        if (pattern.charAt(p) != string.charAt(s))\n        {\n          break;\n        }\n      }\n      return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","pathOld":"src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","sourceNew":"  /**\n   * Determines if a word matches a wildcard pattern.\n   * <small>Work released by Granta Design Ltd after originally being done on\n   * company time.</small>\n   */\n  public static final boolean wildcardEquals(String pattern, int patternIdx,\n    String string, int stringIdx)\n  {\n    int p = patternIdx;\n    \n    for (int s = stringIdx; ; ++p, ++s)\n      {\n        // End of string yet?\n        boolean sEnd = (s >= string.length());\n        // End of pattern yet?\n        boolean pEnd = (p >= pattern.length());\n\n        // If we're looking at the end of the string...\n        if (sEnd)\n        {\n          // Assume the only thing left on the pattern is/are wildcards\n          boolean justWildcardsLeft = true;\n\n          // Current wildcard position\n          int wildcardSearchPos = p;\n          // While we haven't found the end of the pattern,\n          // and haven't encountered any non-wildcard characters\n          while (wildcardSearchPos < pattern.length() && justWildcardsLeft)\n          {\n            // Check the character at the current position\n            char wildchar = pattern.charAt(wildcardSearchPos);\n            \n            // If it's not a wildcard character, then there is more\n            // pattern information after this/these wildcards.\n            if (wildchar != WILDCARD_CHAR && wildchar != WILDCARD_STRING)\n            {\n              justWildcardsLeft = false;\n            }\n            else\n            {\n              // to prevent \"cat\" matches \"ca??\"\n              if (wildchar == WILDCARD_CHAR) {\n                return false;\n              }\n              \n              // Look at the next character\n              wildcardSearchPos++;\n            }\n          }\n\n          // This was a prefix wildcard search, and we've matched, so\n          // return true.\n          if (justWildcardsLeft)\n          {\n            return true;\n          }\n        }\n\n        // If we've gone past the end of the string, or the pattern,\n        // return false.\n        if (sEnd || pEnd)\n        {\n          break;\n        }\n\n        // Match a single character, so continue.\n        if (pattern.charAt(p) == WILDCARD_CHAR)\n        {\n          continue;\n        }\n\n        //\n        if (pattern.charAt(p) == WILDCARD_STRING)\n        {\n          // Look at the character beyond the '*'.\n          ++p;\n          // Examine the string, starting at the last character.\n          for (int i = string.length(); i >= s; --i)\n          {\n            if (wildcardEquals(pattern, p, string, i))\n            {\n              return true;\n            }\n          }\n          break;\n        }\n        if (pattern.charAt(p) != string.charAt(s))\n        {\n          break;\n        }\n      }\n      return false;\n  }\n\n","sourceOld":"  /**\n   * Determines if a word matches a wildcard pattern.\n   * <small>Work released by Granta Design Ltd after originally being done on\n   * company time.</small>\n   */\n  public static final boolean wildcardEquals(String pattern, int patternIdx,\n    String string, int stringIdx)\n  {\n    int p = patternIdx;\n    \n    for (int s = stringIdx; ; ++p, ++s)\n      {\n        // End of string yet?\n        boolean sEnd = (s >= string.length());\n        // End of pattern yet?\n        boolean pEnd = (p >= pattern.length());\n\n        // If we're looking at the end of the string...\n        if (sEnd)\n        {\n          // Assume the only thing left on the pattern is/are wildcards\n          boolean justWildcardsLeft = true;\n\n          // Current wildcard position\n          int wildcardSearchPos = p;\n          // While we haven't found the end of the pattern,\n          // and haven't encountered any non-wildcard characters\n          while (wildcardSearchPos < pattern.length() && justWildcardsLeft)\n          {\n            // Check the character at the current position\n            char wildchar = pattern.charAt(wildcardSearchPos);\n            \n            // If it's not a wildcard character, then there is more\n            // pattern information after this/these wildcards.\n            if (wildchar != WILDCARD_CHAR && wildchar != WILDCARD_STRING)\n            {\n              justWildcardsLeft = false;\n            }\n            else\n            {\n              // to prevent \"cat\" matches \"ca??\"\n              if (wildchar == WILDCARD_CHAR) {\n                return false;\n              }\n              \n              // Look at the next character\n              wildcardSearchPos++;\n            }\n          }\n\n          // This was a prefix wildcard search, and we've matched, so\n          // return true.\n          if (justWildcardsLeft)\n          {\n            return true;\n          }\n        }\n\n        // If we've gone past the end of the string, or the pattern,\n        // return false.\n        if (sEnd || pEnd)\n        {\n          break;\n        }\n\n        // Match a single character, so continue.\n        if (pattern.charAt(p) == WILDCARD_CHAR)\n        {\n          continue;\n        }\n\n        //\n        if (pattern.charAt(p) == WILDCARD_STRING)\n        {\n          // Look at the character beyond the '*'.\n          ++p;\n          // Examine the string, starting at the last character.\n          for (int i = string.length(); i >= s; --i)\n          {\n            if (wildcardEquals(pattern, p, string, i))\n            {\n              return true;\n            }\n          }\n          break;\n        }\n        if (pattern.charAt(p) != string.charAt(s))\n        {\n          break;\n        }\n      }\n      return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9643123c5376a78d0f62a0bb8d5bfd6beb667053":["3449282534151d4584c6dd66673158b9d62996a7"],"541afc123d92f32d0d5fc1bf817fc97f73665622":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3449282534151d4584c6dd66673158b9d62996a7":["541afc123d92f32d0d5fc1bf817fc97f73665622"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"83fc06d3da543755d60fc5c175a35575b2c8c6dc":["9643123c5376a78d0f62a0bb8d5bfd6beb667053"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["83fc06d3da543755d60fc5c175a35575b2c8c6dc"]},"commit2Childs":{"9643123c5376a78d0f62a0bb8d5bfd6beb667053":["83fc06d3da543755d60fc5c175a35575b2c8c6dc"],"541afc123d92f32d0d5fc1bf817fc97f73665622":["3449282534151d4584c6dd66673158b9d62996a7"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["541afc123d92f32d0d5fc1bf817fc97f73665622"],"3449282534151d4584c6dd66673158b9d62996a7":["9643123c5376a78d0f62a0bb8d5bfd6beb667053"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"83fc06d3da543755d60fc5c175a35575b2c8c6dc":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}