{"path":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","commits":[{"id":"5613a70439d5d429f0689c2c5a21615e58deff97","date":1512102314,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimePartitionedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Object routeValue = cmd.getSolrInputDocument().getFieldValue(routeField);\n    final String targetCollection = findTargetCollectionGivenRouteKey(routeValue);\n    if (targetCollection == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + routeField + \"=\" + routeValue);\n    }\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = lookupShardLeaderOfCollection(targetCollection);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Object routeValue = cmd.getSolrInputDocument().getFieldValue(routeField);\n    final String targetCollection = findTargetCollectionGivenRouteKey(routeValue);\n    if (targetCollection == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + routeField + \"=\" + routeValue);\n    }\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = lookupShardLeaderOfCollection(targetCollection);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af3e10d8a1fbcc5c79b22f7477e79de467dd326c","date":1515178406,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Object routeValue = cmd.getSolrInputDocument().getFieldValue(routeField);\n    final Instant routeTimestamp = parseRouteKey(routeValue);\n\n    updateParsedCollectionAliases();\n    String targetCollection;\n    do {\n      targetCollection = findTargetCollectionGivenTimestamp(routeTimestamp);\n\n      if (targetCollection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + routeField + \"=\" + routeTimestamp);\n      }\n\n      // Note: the following rule is tempting but not necessary and is not compatible with\n      // only using this URP when the alias distrib phase is NONE; otherwise a doc may be routed to from a non-recent\n      // collection to the most recent only to then go there directly instead of realizing a new collection is needed.\n      //      // If it's going to some other collection (not \"this\") then break to just send it there\n      //      if (!thisCollection.equals(targetCollection)) {\n      //        break;\n      //      }\n      // Also tempting but not compatible:  check that we're the leader, if not then break\n\n      // If the doc goes to the most recent collection then do some checks below, otherwise break the loop.\n      final Instant mostRecentCollTimestamp = parsedCollectionsDesc.get(0).getKey();\n      final String mostRecentCollName = parsedCollectionsDesc.get(0).getValue();\n      if (!mostRecentCollName.equals(targetCollection)) {\n        break;\n      }\n\n      // Check the doc isn't too far in the future\n      final Instant maxFutureTime = Instant.now().plusMillis(maxFutureMs);\n      if (routeTimestamp.isAfter(maxFutureTime)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"The document's time routed key of \" + routeValue + \" is too far in the future given \" +\n                ROUTER_MAX_FUTURE_TIME_METADATA + \"=\" + maxFutureMs);\n      }\n\n      // Create a new collection?\n      final Instant nextCollTimestamp = computeNextCollTimestamp(mostRecentCollTimestamp, intervalDateMath, intervalTimeZone);\n      if (routeTimestamp.isBefore(nextCollTimestamp)) {\n        break; // thus we don't need another collection\n      }\n\n      createCollectionAfter(mostRecentCollName); // *should* throw if fails for some reason but...\n      final boolean updated = updateParsedCollectionAliases();\n      if (!updated) { // thus we didn't make progress...\n        // this is not expected, even in known failure cases, but we check just in case\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n      }\n      // then retry the loop ...\n    } while(true);\n    assert targetCollection != null;\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = lookupShardLeaderOfCollection(targetCollection);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Object routeValue = cmd.getSolrInputDocument().getFieldValue(routeField);\n    final String targetCollection = findTargetCollectionGivenRouteKey(routeValue);\n    if (targetCollection == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + routeField + \"=\" + routeValue);\n    }\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = lookupShardLeaderOfCollection(targetCollection);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Object routeValue = cmd.getSolrInputDocument().getFieldValue(routeField);\n    final Instant routeTimestamp = parseRouteKey(routeValue);\n\n    updateParsedCollectionAliases();\n    String targetCollection;\n    do {\n      targetCollection = findTargetCollectionGivenTimestamp(routeTimestamp);\n\n      if (targetCollection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + routeField + \"=\" + routeTimestamp);\n      }\n\n      // Note: the following rule is tempting but not necessary and is not compatible with\n      // only using this URP when the alias distrib phase is NONE; otherwise a doc may be routed to from a non-recent\n      // collection to the most recent only to then go there directly instead of realizing a new collection is needed.\n      //      // If it's going to some other collection (not \"this\") then break to just send it there\n      //      if (!thisCollection.equals(targetCollection)) {\n      //        break;\n      //      }\n      // Also tempting but not compatible:  check that we're the leader, if not then break\n\n      // If the doc goes to the most recent collection then do some checks below, otherwise break the loop.\n      final Instant mostRecentCollTimestamp = parsedCollectionsDesc.get(0).getKey();\n      final String mostRecentCollName = parsedCollectionsDesc.get(0).getValue();\n      if (!mostRecentCollName.equals(targetCollection)) {\n        break;\n      }\n\n      // Check the doc isn't too far in the future\n      final Instant maxFutureTime = Instant.now().plusMillis(maxFutureMs);\n      if (routeTimestamp.isAfter(maxFutureTime)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"The document's time routed key of \" + routeValue + \" is too far in the future given \" +\n                ROUTER_MAX_FUTURE_TIME_METADATA + \"=\" + maxFutureMs);\n      }\n\n      // Create a new collection?\n      final Instant nextCollTimestamp = computeNextCollTimestamp(mostRecentCollTimestamp, intervalDateMath, intervalTimeZone);\n      if (routeTimestamp.isBefore(nextCollTimestamp)) {\n        break; // thus we don't need another collection\n      }\n\n      createCollectionAfter(mostRecentCollName); // *should* throw if fails for some reason but...\n      final boolean updated = updateParsedCollectionAliases();\n      if (!updated) { // thus we didn't make progress...\n        // this is not expected, even in known failure cases, but we check just in case\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n      }\n      // then retry the loop ...\n    } while(true);\n    assert targetCollection != null;\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = lookupShardLeaderOfCollection(targetCollection);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Object routeValue = cmd.getSolrInputDocument().getFieldValue(routeField);\n    final String targetCollection = findTargetCollectionGivenRouteKey(routeValue);\n    if (targetCollection == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + routeField + \"=\" + routeValue);\n    }\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = lookupShardLeaderOfCollection(targetCollection);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46589ed5cc841861bf6b5e2afc55f718ebcd02a0","date":1516984620,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Object routeValue = cmd.getSolrInputDocument().getFieldValue(timeRoutedAlias.getRouteField());\n    final Instant routeTimestamp = parseRouteKey(routeValue);\n\n    updateParsedCollectionAliases();\n    String targetCollection;\n    do {\n      targetCollection = findTargetCollectionGivenTimestamp(routeTimestamp);\n\n      if (targetCollection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + timeRoutedAlias.getRouteField() + \"=\" + routeTimestamp);\n      }\n\n      // Note: the following rule is tempting but not necessary and is not compatible with\n      // only using this URP when the alias distrib phase is NONE; otherwise a doc may be routed to from a non-recent\n      // collection to the most recent only to then go there directly instead of realizing a new collection is needed.\n      //      // If it's going to some other collection (not \"this\") then break to just send it there\n      //      if (!thisCollection.equals(targetCollection)) {\n      //        break;\n      //      }\n      // Also tempting but not compatible:  check that we're the leader, if not then break\n\n      // If the doc goes to the most recent collection then do some checks below, otherwise break the loop.\n      final Instant mostRecentCollTimestamp = parsedCollectionsDesc.get(0).getKey();\n      final String mostRecentCollName = parsedCollectionsDesc.get(0).getValue();\n      if (!mostRecentCollName.equals(targetCollection)) {\n        break;\n      }\n\n      // Check the doc isn't too far in the future\n      final Instant maxFutureTime = Instant.now().plusMillis(timeRoutedAlias.getMaxFutureMs());\n      if (routeTimestamp.isAfter(maxFutureTime)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"The document's time routed key of \" + routeValue + \" is too far in the future given \" +\n                TimeRoutedAlias.ROUTER_MAX_FUTURE + \"=\" + timeRoutedAlias.getMaxFutureMs());\n      }\n\n      // Create a new collection?\n      final Instant nextCollTimestamp = timeRoutedAlias.computeNextCollTimestamp(mostRecentCollTimestamp);\n      if (routeTimestamp.isBefore(nextCollTimestamp)) {\n        break; // thus we don't need another collection\n      }\n\n      createCollectionAfter(mostRecentCollName); // *should* throw if fails for some reason but...\n      final boolean updated = updateParsedCollectionAliases();\n      if (!updated) { // thus we didn't make progress...\n        // this is not expected, even in known failure cases, but we check just in case\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n      }\n      // then retry the loop ...\n    } while(true);\n    assert targetCollection != null;\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = lookupShardLeaderOfCollection(targetCollection);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Object routeValue = cmd.getSolrInputDocument().getFieldValue(routeField);\n    final Instant routeTimestamp = parseRouteKey(routeValue);\n\n    updateParsedCollectionAliases();\n    String targetCollection;\n    do {\n      targetCollection = findTargetCollectionGivenTimestamp(routeTimestamp);\n\n      if (targetCollection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + routeField + \"=\" + routeTimestamp);\n      }\n\n      // Note: the following rule is tempting but not necessary and is not compatible with\n      // only using this URP when the alias distrib phase is NONE; otherwise a doc may be routed to from a non-recent\n      // collection to the most recent only to then go there directly instead of realizing a new collection is needed.\n      //      // If it's going to some other collection (not \"this\") then break to just send it there\n      //      if (!thisCollection.equals(targetCollection)) {\n      //        break;\n      //      }\n      // Also tempting but not compatible:  check that we're the leader, if not then break\n\n      // If the doc goes to the most recent collection then do some checks below, otherwise break the loop.\n      final Instant mostRecentCollTimestamp = parsedCollectionsDesc.get(0).getKey();\n      final String mostRecentCollName = parsedCollectionsDesc.get(0).getValue();\n      if (!mostRecentCollName.equals(targetCollection)) {\n        break;\n      }\n\n      // Check the doc isn't too far in the future\n      final Instant maxFutureTime = Instant.now().plusMillis(maxFutureMs);\n      if (routeTimestamp.isAfter(maxFutureTime)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"The document's time routed key of \" + routeValue + \" is too far in the future given \" +\n                ROUTER_MAX_FUTURE_TIME_METADATA + \"=\" + maxFutureMs);\n      }\n\n      // Create a new collection?\n      final Instant nextCollTimestamp = computeNextCollTimestamp(mostRecentCollTimestamp, intervalDateMath, intervalTimeZone);\n      if (routeTimestamp.isBefore(nextCollTimestamp)) {\n        break; // thus we don't need another collection\n      }\n\n      createCollectionAfter(mostRecentCollName); // *should* throw if fails for some reason but...\n      final boolean updated = updateParsedCollectionAliases();\n      if (!updated) { // thus we didn't make progress...\n        // this is not expected, even in known failure cases, but we check just in case\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n      }\n      // then retry the loop ...\n    } while(true);\n    assert targetCollection != null;\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = lookupShardLeaderOfCollection(targetCollection);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cbd743a4843f513f793670e3ab0e272bf824faf","date":1518149529,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Object routeValue = cmd.getSolrInputDocument().getFieldValue(timeRoutedAlias.getRouteField());\n    final Instant routeTimestamp = parseRouteKey(routeValue);\n\n    updateParsedCollectionAliases();\n    String targetCollection;\n    do { // typically we don't loop; it's only when we need to create a collection\n      targetCollection = findTargetCollectionGivenTimestamp(routeTimestamp);\n\n      if (targetCollection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + timeRoutedAlias.getRouteField() + \"=\" + routeTimestamp);\n      }\n\n      // Note: the following rule is tempting but not necessary and is not compatible with\n      // only using this URP when the alias distrib phase is NONE; otherwise a doc may be routed to from a non-recent\n      // collection to the most recent only to then go there directly instead of realizing a new collection is needed.\n      //      // If it's going to some other collection (not \"this\") then break to just send it there\n      //      if (!thisCollection.equals(targetCollection)) {\n      //        break;\n      //      }\n      // Also tempting but not compatible:  check that we're the leader, if not then break\n\n      // If the doc goes to the most recent collection then do some checks below, otherwise break the loop.\n      final Instant mostRecentCollTimestamp = parsedCollectionsDesc.get(0).getKey();\n      final String mostRecentCollName = parsedCollectionsDesc.get(0).getValue();\n      if (!mostRecentCollName.equals(targetCollection)) {\n        break;\n      }\n\n      // Check the doc isn't too far in the future\n      final Instant maxFutureTime = Instant.now().plusMillis(timeRoutedAlias.getMaxFutureMs());\n      if (routeTimestamp.isAfter(maxFutureTime)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"The document's time routed key of \" + routeValue + \" is too far in the future given \" +\n                TimeRoutedAlias.ROUTER_MAX_FUTURE + \"=\" + timeRoutedAlias.getMaxFutureMs());\n      }\n\n      // Create a new collection?\n      final Instant nextCollTimestamp = timeRoutedAlias.computeNextCollTimestamp(mostRecentCollTimestamp);\n      if (routeTimestamp.isBefore(nextCollTimestamp)) {\n        break; // thus we don't need another collection\n      }\n\n      createCollectionAfter(mostRecentCollName); // *should* throw if fails for some reason but...\n      final boolean updated = updateParsedCollectionAliases();\n      if (!updated) { // thus we didn't make progress...\n        // this is not expected, even in known failure cases, but we check just in case\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n      }\n      // then retry the loop ...\n    } while(true);\n    assert targetCollection != null;\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = lookupShardLeaderOfCollection(targetCollection);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Object routeValue = cmd.getSolrInputDocument().getFieldValue(timeRoutedAlias.getRouteField());\n    final Instant routeTimestamp = parseRouteKey(routeValue);\n\n    updateParsedCollectionAliases();\n    String targetCollection;\n    do {\n      targetCollection = findTargetCollectionGivenTimestamp(routeTimestamp);\n\n      if (targetCollection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + timeRoutedAlias.getRouteField() + \"=\" + routeTimestamp);\n      }\n\n      // Note: the following rule is tempting but not necessary and is not compatible with\n      // only using this URP when the alias distrib phase is NONE; otherwise a doc may be routed to from a non-recent\n      // collection to the most recent only to then go there directly instead of realizing a new collection is needed.\n      //      // If it's going to some other collection (not \"this\") then break to just send it there\n      //      if (!thisCollection.equals(targetCollection)) {\n      //        break;\n      //      }\n      // Also tempting but not compatible:  check that we're the leader, if not then break\n\n      // If the doc goes to the most recent collection then do some checks below, otherwise break the loop.\n      final Instant mostRecentCollTimestamp = parsedCollectionsDesc.get(0).getKey();\n      final String mostRecentCollName = parsedCollectionsDesc.get(0).getValue();\n      if (!mostRecentCollName.equals(targetCollection)) {\n        break;\n      }\n\n      // Check the doc isn't too far in the future\n      final Instant maxFutureTime = Instant.now().plusMillis(timeRoutedAlias.getMaxFutureMs());\n      if (routeTimestamp.isAfter(maxFutureTime)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"The document's time routed key of \" + routeValue + \" is too far in the future given \" +\n                TimeRoutedAlias.ROUTER_MAX_FUTURE + \"=\" + timeRoutedAlias.getMaxFutureMs());\n      }\n\n      // Create a new collection?\n      final Instant nextCollTimestamp = timeRoutedAlias.computeNextCollTimestamp(mostRecentCollTimestamp);\n      if (routeTimestamp.isBefore(nextCollTimestamp)) {\n        break; // thus we don't need another collection\n      }\n\n      createCollectionAfter(mostRecentCollName); // *should* throw if fails for some reason but...\n      final boolean updated = updateParsedCollectionAliases();\n      if (!updated) { // thus we didn't make progress...\n        // this is not expected, even in known failure cases, but we check just in case\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n      }\n      // then retry the loop ...\n    } while(true);\n    assert targetCollection != null;\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = lookupShardLeaderOfCollection(targetCollection);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60b45f127b5537b5bf62181784ef28b52f4b6a08","date":1529595959,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument solrInputDocument = cmd.getSolrInputDocument();\n    final Object routeValue = solrInputDocument.getFieldValue(timeRoutedAlias.getRouteField());\n    final Instant routeTimestamp = parseRouteKey(routeValue);\n\n    updateParsedCollectionAliases();\n    String targetCollection;\n    do { // typically we don't loop; it's only when we need to create a collection\n      targetCollection = findTargetCollectionGivenTimestamp(routeTimestamp);\n\n      if (targetCollection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + timeRoutedAlias.getRouteField() + \"=\" + routeTimestamp);\n      }\n\n      // Note: the following rule is tempting but not necessary and is not compatible with\n      // only using this URP when the alias distrib phase is NONE; otherwise a doc may be routed to from a non-recent\n      // collection to the most recent only to then go there directly instead of realizing a new collection is needed.\n      //      // If it's going to some other collection (not \"this\") then break to just send it there\n      //      if (!thisCollection.equals(targetCollection)) {\n      //        break;\n      //      }\n      // Also tempting but not compatible:  check that we're the leader, if not then break\n\n      // If the doc goes to the most recent collection then do some checks below, otherwise break the loop.\n      final Instant mostRecentCollTimestamp = parsedCollectionsDesc.get(0).getKey();\n      final String mostRecentCollName = parsedCollectionsDesc.get(0).getValue();\n      if (!mostRecentCollName.equals(targetCollection)) {\n        break;\n      }\n\n      // Check the doc isn't too far in the future\n      final Instant maxFutureTime = Instant.now().plusMillis(timeRoutedAlias.getMaxFutureMs());\n      if (routeTimestamp.isAfter(maxFutureTime)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"The document's time routed key of \" + routeValue + \" is too far in the future given \" +\n                TimeRoutedAlias.ROUTER_MAX_FUTURE + \"=\" + timeRoutedAlias.getMaxFutureMs());\n      }\n\n      // Create a new collection?\n      final Instant nextCollTimestamp = timeRoutedAlias.computeNextCollTimestamp(mostRecentCollTimestamp);\n      if (routeTimestamp.isBefore(nextCollTimestamp)) {\n        break; // thus we don't need another collection\n      }\n\n      createCollectionAfter(mostRecentCollName); // *should* throw if fails for some reason but...\n      final boolean updated = updateParsedCollectionAliases();\n      if (!updated) { // thus we didn't make progress...\n        // this is not expected, even in known failure cases, but we check just in case\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n      }\n      // then retry the loop ...\n    } while(true);\n    assert targetCollection != null;\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = routeDocToSlice(targetCollection, solrInputDocument);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Object routeValue = cmd.getSolrInputDocument().getFieldValue(timeRoutedAlias.getRouteField());\n    final Instant routeTimestamp = parseRouteKey(routeValue);\n\n    updateParsedCollectionAliases();\n    String targetCollection;\n    do { // typically we don't loop; it's only when we need to create a collection\n      targetCollection = findTargetCollectionGivenTimestamp(routeTimestamp);\n\n      if (targetCollection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + timeRoutedAlias.getRouteField() + \"=\" + routeTimestamp);\n      }\n\n      // Note: the following rule is tempting but not necessary and is not compatible with\n      // only using this URP when the alias distrib phase is NONE; otherwise a doc may be routed to from a non-recent\n      // collection to the most recent only to then go there directly instead of realizing a new collection is needed.\n      //      // If it's going to some other collection (not \"this\") then break to just send it there\n      //      if (!thisCollection.equals(targetCollection)) {\n      //        break;\n      //      }\n      // Also tempting but not compatible:  check that we're the leader, if not then break\n\n      // If the doc goes to the most recent collection then do some checks below, otherwise break the loop.\n      final Instant mostRecentCollTimestamp = parsedCollectionsDesc.get(0).getKey();\n      final String mostRecentCollName = parsedCollectionsDesc.get(0).getValue();\n      if (!mostRecentCollName.equals(targetCollection)) {\n        break;\n      }\n\n      // Check the doc isn't too far in the future\n      final Instant maxFutureTime = Instant.now().plusMillis(timeRoutedAlias.getMaxFutureMs());\n      if (routeTimestamp.isAfter(maxFutureTime)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"The document's time routed key of \" + routeValue + \" is too far in the future given \" +\n                TimeRoutedAlias.ROUTER_MAX_FUTURE + \"=\" + timeRoutedAlias.getMaxFutureMs());\n      }\n\n      // Create a new collection?\n      final Instant nextCollTimestamp = timeRoutedAlias.computeNextCollTimestamp(mostRecentCollTimestamp);\n      if (routeTimestamp.isBefore(nextCollTimestamp)) {\n        break; // thus we don't need another collection\n      }\n\n      createCollectionAfter(mostRecentCollName); // *should* throw if fails for some reason but...\n      final boolean updated = updateParsedCollectionAliases();\n      if (!updated) { // thus we didn't make progress...\n        // this is not expected, even in known failure cases, but we check just in case\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n      }\n      // then retry the loop ...\n    } while(true);\n    assert targetCollection != null;\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = lookupShardLeaderOfCollection(targetCollection);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument solrInputDocument = cmd.getSolrInputDocument();\n    final Object routeValue = solrInputDocument.getFieldValue(timeRoutedAlias.getRouteField());\n    final Instant routeTimestamp = parseRouteKey(routeValue);\n\n    updateParsedCollectionAliases();\n    String targetCollection;\n    do { // typically we don't loop; it's only when we need to create a collection\n      targetCollection = findTargetCollectionGivenTimestamp(routeTimestamp);\n\n      if (targetCollection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + timeRoutedAlias.getRouteField() + \"=\" + routeTimestamp);\n      }\n\n      // Note: the following rule is tempting but not necessary and is not compatible with\n      // only using this URP when the alias distrib phase is NONE; otherwise a doc may be routed to from a non-recent\n      // collection to the most recent only to then go there directly instead of realizing a new collection is needed.\n      //      // If it's going to some other collection (not \"this\") then break to just send it there\n      //      if (!thisCollection.equals(targetCollection)) {\n      //        break;\n      //      }\n      // Also tempting but not compatible:  check that we're the leader, if not then break\n\n      // If the doc goes to the most recent collection then do some checks below, otherwise break the loop.\n      final Instant mostRecentCollTimestamp = parsedCollectionsDesc.get(0).getKey();\n      final String mostRecentCollName = parsedCollectionsDesc.get(0).getValue();\n      if (!mostRecentCollName.equals(targetCollection)) {\n        break;\n      }\n\n      // Check the doc isn't too far in the future\n      final Instant maxFutureTime = Instant.now().plusMillis(timeRoutedAlias.getMaxFutureMs());\n      if (routeTimestamp.isAfter(maxFutureTime)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"The document's time routed key of \" + routeValue + \" is too far in the future given \" +\n                TimeRoutedAlias.ROUTER_MAX_FUTURE + \"=\" + timeRoutedAlias.getMaxFutureMs());\n      }\n\n      // Create a new collection?\n      final Instant nextCollTimestamp = timeRoutedAlias.computeNextCollTimestamp(mostRecentCollTimestamp);\n      if (routeTimestamp.isBefore(nextCollTimestamp)) {\n        break; // thus we don't need another collection\n      }\n\n      createCollectionAfter(mostRecentCollName); // *should* throw if fails for some reason but...\n      final boolean updated = updateParsedCollectionAliases();\n      if (!updated) { // thus we didn't make progress...\n        // this is not expected, even in known failure cases, but we check just in case\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n      }\n      // then retry the loop ...\n    } while(true);\n    assert targetCollection != null;\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = routeDocToSlice(targetCollection, solrInputDocument);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Object routeValue = cmd.getSolrInputDocument().getFieldValue(timeRoutedAlias.getRouteField());\n    final Instant routeTimestamp = parseRouteKey(routeValue);\n\n    updateParsedCollectionAliases();\n    String targetCollection;\n    do { // typically we don't loop; it's only when we need to create a collection\n      targetCollection = findTargetCollectionGivenTimestamp(routeTimestamp);\n\n      if (targetCollection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + timeRoutedAlias.getRouteField() + \"=\" + routeTimestamp);\n      }\n\n      // Note: the following rule is tempting but not necessary and is not compatible with\n      // only using this URP when the alias distrib phase is NONE; otherwise a doc may be routed to from a non-recent\n      // collection to the most recent only to then go there directly instead of realizing a new collection is needed.\n      //      // If it's going to some other collection (not \"this\") then break to just send it there\n      //      if (!thisCollection.equals(targetCollection)) {\n      //        break;\n      //      }\n      // Also tempting but not compatible:  check that we're the leader, if not then break\n\n      // If the doc goes to the most recent collection then do some checks below, otherwise break the loop.\n      final Instant mostRecentCollTimestamp = parsedCollectionsDesc.get(0).getKey();\n      final String mostRecentCollName = parsedCollectionsDesc.get(0).getValue();\n      if (!mostRecentCollName.equals(targetCollection)) {\n        break;\n      }\n\n      // Check the doc isn't too far in the future\n      final Instant maxFutureTime = Instant.now().plusMillis(timeRoutedAlias.getMaxFutureMs());\n      if (routeTimestamp.isAfter(maxFutureTime)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"The document's time routed key of \" + routeValue + \" is too far in the future given \" +\n                TimeRoutedAlias.ROUTER_MAX_FUTURE + \"=\" + timeRoutedAlias.getMaxFutureMs());\n      }\n\n      // Create a new collection?\n      final Instant nextCollTimestamp = timeRoutedAlias.computeNextCollTimestamp(mostRecentCollTimestamp);\n      if (routeTimestamp.isBefore(nextCollTimestamp)) {\n        break; // thus we don't need another collection\n      }\n\n      createCollectionAfter(mostRecentCollName); // *should* throw if fails for some reason but...\n      final boolean updated = updateParsedCollectionAliases();\n      if (!updated) { // thus we didn't make progress...\n        // this is not expected, even in known failure cases, but we check just in case\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n      }\n      // then retry the loop ...\n    } while(true);\n    assert targetCollection != null;\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = lookupShardLeaderOfCollection(targetCollection);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument solrInputDocument = cmd.getSolrInputDocument();\n    final Object routeValue = solrInputDocument.getFieldValue(timeRoutedAlias.getRouteField());\n    final Instant routeTimestamp = parseRouteKey(routeValue);\n\n    updateParsedCollectionAliases();\n    String targetCollection;\n    do { // typically we don't loop; it's only when we need to create a collection\n      targetCollection = findTargetCollectionGivenTimestamp(routeTimestamp);\n\n      if (targetCollection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + timeRoutedAlias.getRouteField() + \"=\" + routeTimestamp);\n      }\n\n      // Note: the following rule is tempting but not necessary and is not compatible with\n      // only using this URP when the alias distrib phase is NONE; otherwise a doc may be routed to from a non-recent\n      // collection to the most recent only to then go there directly instead of realizing a new collection is needed.\n      //      // If it's going to some other collection (not \"this\") then break to just send it there\n      //      if (!thisCollection.equals(targetCollection)) {\n      //        break;\n      //      }\n      // Also tempting but not compatible:  check that we're the leader, if not then break\n\n      // If the doc goes to the most recent collection then do some checks below, otherwise break the loop.\n      final Instant mostRecentCollTimestamp = parsedCollectionsDesc.get(0).getKey();\n      final String mostRecentCollName = parsedCollectionsDesc.get(0).getValue();\n      if (!mostRecentCollName.equals(targetCollection)) {\n        break;\n      }\n\n      // Check the doc isn't too far in the future\n      final Instant maxFutureTime = Instant.now().plusMillis(timeRoutedAlias.getMaxFutureMs());\n      if (routeTimestamp.isAfter(maxFutureTime)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"The document's time routed key of \" + routeValue + \" is too far in the future given \" +\n                TimeRoutedAlias.ROUTER_MAX_FUTURE + \"=\" + timeRoutedAlias.getMaxFutureMs());\n      }\n\n      // Create a new collection?\n      final Instant nextCollTimestamp = timeRoutedAlias.computeNextCollTimestamp(mostRecentCollTimestamp);\n      if (routeTimestamp.isBefore(nextCollTimestamp)) {\n        break; // thus we don't need another collection\n      }\n\n      createCollectionAfter(mostRecentCollName); // *should* throw if fails for some reason but...\n      final boolean updated = updateParsedCollectionAliases();\n      if (!updated) { // thus we didn't make progress...\n        // this is not expected, even in known failure cases, but we check just in case\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n      }\n      // then retry the loop ...\n    } while(true);\n    assert targetCollection != null;\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = routeDocToSlice(targetCollection, solrInputDocument);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Object routeValue = cmd.getSolrInputDocument().getFieldValue(timeRoutedAlias.getRouteField());\n    final Instant routeTimestamp = parseRouteKey(routeValue);\n\n    updateParsedCollectionAliases();\n    String targetCollection;\n    do { // typically we don't loop; it's only when we need to create a collection\n      targetCollection = findTargetCollectionGivenTimestamp(routeTimestamp);\n\n      if (targetCollection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + timeRoutedAlias.getRouteField() + \"=\" + routeTimestamp);\n      }\n\n      // Note: the following rule is tempting but not necessary and is not compatible with\n      // only using this URP when the alias distrib phase is NONE; otherwise a doc may be routed to from a non-recent\n      // collection to the most recent only to then go there directly instead of realizing a new collection is needed.\n      //      // If it's going to some other collection (not \"this\") then break to just send it there\n      //      if (!thisCollection.equals(targetCollection)) {\n      //        break;\n      //      }\n      // Also tempting but not compatible:  check that we're the leader, if not then break\n\n      // If the doc goes to the most recent collection then do some checks below, otherwise break the loop.\n      final Instant mostRecentCollTimestamp = parsedCollectionsDesc.get(0).getKey();\n      final String mostRecentCollName = parsedCollectionsDesc.get(0).getValue();\n      if (!mostRecentCollName.equals(targetCollection)) {\n        break;\n      }\n\n      // Check the doc isn't too far in the future\n      final Instant maxFutureTime = Instant.now().plusMillis(timeRoutedAlias.getMaxFutureMs());\n      if (routeTimestamp.isAfter(maxFutureTime)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"The document's time routed key of \" + routeValue + \" is too far in the future given \" +\n                TimeRoutedAlias.ROUTER_MAX_FUTURE + \"=\" + timeRoutedAlias.getMaxFutureMs());\n      }\n\n      // Create a new collection?\n      final Instant nextCollTimestamp = timeRoutedAlias.computeNextCollTimestamp(mostRecentCollTimestamp);\n      if (routeTimestamp.isBefore(nextCollTimestamp)) {\n        break; // thus we don't need another collection\n      }\n\n      createCollectionAfter(mostRecentCollName); // *should* throw if fails for some reason but...\n      final boolean updated = updateParsedCollectionAliases();\n      if (!updated) { // thus we didn't make progress...\n        // this is not expected, even in known failure cases, but we check just in case\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n      }\n      // then retry the loop ...\n    } while(true);\n    assert targetCollection != null;\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = lookupShardLeaderOfCollection(targetCollection);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"849083f8095b1ffaff05a66e0b1e024617b9968d","date":1536291524,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(timeRoutedAlias.getRouteField()));\n\n    // TODO: maybe in some cases the user would want to ignore/warn instead?\n    if (docTimestamp.isAfter(Instant.now().plusMillis(timeRoutedAlias.getMaxFutureMs()))) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"The document's time routed key of \" + docTimestamp + \" is too far in the future given \" +\n              TimeRoutedAlias.ROUTER_MAX_FUTURE + \"=\" + timeRoutedAlias.getMaxFutureMs());\n    }\n\n    // to avoid potential for race conditions, this next method should not get called again unless\n    // we have created a collection synchronously\n    updateParsedCollectionAliases();\n\n    String targetCollection = createCollectionsIfRequired(docTimestamp, cmd);\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = routeDocToSlice(targetCollection, cmd.getSolrInputDocument());\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument solrInputDocument = cmd.getSolrInputDocument();\n    final Object routeValue = solrInputDocument.getFieldValue(timeRoutedAlias.getRouteField());\n    final Instant routeTimestamp = parseRouteKey(routeValue);\n\n    updateParsedCollectionAliases();\n    String targetCollection;\n    do { // typically we don't loop; it's only when we need to create a collection\n      targetCollection = findTargetCollectionGivenTimestamp(routeTimestamp);\n\n      if (targetCollection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doc \" + cmd.getPrintableId() + \" couldn't be routed with \" + timeRoutedAlias.getRouteField() + \"=\" + routeTimestamp);\n      }\n\n      // Note: the following rule is tempting but not necessary and is not compatible with\n      // only using this URP when the alias distrib phase is NONE; otherwise a doc may be routed to from a non-recent\n      // collection to the most recent only to then go there directly instead of realizing a new collection is needed.\n      //      // If it's going to some other collection (not \"this\") then break to just send it there\n      //      if (!thisCollection.equals(targetCollection)) {\n      //        break;\n      //      }\n      // Also tempting but not compatible:  check that we're the leader, if not then break\n\n      // If the doc goes to the most recent collection then do some checks below, otherwise break the loop.\n      final Instant mostRecentCollTimestamp = parsedCollectionsDesc.get(0).getKey();\n      final String mostRecentCollName = parsedCollectionsDesc.get(0).getValue();\n      if (!mostRecentCollName.equals(targetCollection)) {\n        break;\n      }\n\n      // Check the doc isn't too far in the future\n      final Instant maxFutureTime = Instant.now().plusMillis(timeRoutedAlias.getMaxFutureMs());\n      if (routeTimestamp.isAfter(maxFutureTime)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"The document's time routed key of \" + routeValue + \" is too far in the future given \" +\n                TimeRoutedAlias.ROUTER_MAX_FUTURE + \"=\" + timeRoutedAlias.getMaxFutureMs());\n      }\n\n      // Create a new collection?\n      final Instant nextCollTimestamp = timeRoutedAlias.computeNextCollTimestamp(mostRecentCollTimestamp);\n      if (routeTimestamp.isBefore(nextCollTimestamp)) {\n        break; // thus we don't need another collection\n      }\n\n      createCollectionAfter(mostRecentCollName); // *should* throw if fails for some reason but...\n      final boolean updated = updateParsedCollectionAliases();\n      if (!updated) { // thus we didn't make progress...\n        // this is not expected, even in known failure cases, but we check just in case\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"We need to create a new time routed collection but for unknown reasons were unable to do so.\");\n      }\n      // then retry the loop ...\n    } while(true);\n    assert targetCollection != null;\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = routeDocToSlice(targetCollection, solrInputDocument);\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":5,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/RoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    routedAlias.validateRouteValue(cmd);\n\n    // to avoid potential for race conditions, this next method should not get called again unless\n    // we have created a collection synchronously\n    routedAlias.updateParsedCollectionAliases(this.zkController);\n\n    String targetCollection = routedAlias.createCollectionsIfRequired(cmd);\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = routeDocToSlice(targetCollection, cmd.getSolrInputDocument());\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(timeRoutedAlias.getRouteField()));\n\n    // TODO: maybe in some cases the user would want to ignore/warn instead?\n    if (docTimestamp.isAfter(Instant.now().plusMillis(timeRoutedAlias.getMaxFutureMs()))) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"The document's time routed key of \" + docTimestamp + \" is too far in the future given \" +\n              TimeRoutedAlias.ROUTER_MAX_FUTURE + \"=\" + timeRoutedAlias.getMaxFutureMs());\n    }\n\n    // to avoid potential for race conditions, this next method should not get called again unless\n    // we have created a collection synchronously\n    updateParsedCollectionAliases();\n\n    String targetCollection = createCollectionsIfRequired(docTimestamp, cmd);\n\n    if (thisCollection.equals(targetCollection)) {\n      // pass on through; we've reached the right collection\n      super.processAdd(cmd);\n    } else {\n      // send to the right collection\n      SolrCmdDistributor.Node targetLeaderNode = routeDocToSlice(targetCollection, cmd.getSolrInputDocument());\n      cmdDistrib.distribAdd(cmd, Collections.singletonList(targetLeaderNode), new ModifiableSolrParams(outParamsToLeader));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["5613a70439d5d429f0689c2c5a21615e58deff97","af3e10d8a1fbcc5c79b22f7477e79de467dd326c"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["3cbd743a4843f513f793670e3ab0e272bf824faf","60b45f127b5537b5bf62181784ef28b52f4b6a08"],"46589ed5cc841861bf6b5e2afc55f718ebcd02a0":["b94236357aaa22b76c10629851fe4e376e0cea82"],"3cbd743a4843f513f793670e3ab0e272bf824faf":["46589ed5cc841861bf6b5e2afc55f718ebcd02a0"],"af3e10d8a1fbcc5c79b22f7477e79de467dd326c":["5613a70439d5d429f0689c2c5a21615e58deff97"],"849083f8095b1ffaff05a66e0b1e024617b9968d":["60b45f127b5537b5bf62181784ef28b52f4b6a08"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b627755385655c7cd3fb296f17593658805cf4d5":["849083f8095b1ffaff05a66e0b1e024617b9968d"],"5613a70439d5d429f0689c2c5a21615e58deff97":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"60b45f127b5537b5bf62181784ef28b52f4b6a08":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b627755385655c7cd3fb296f17593658805cf4d5"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["3cbd743a4843f513f793670e3ab0e272bf824faf","60b45f127b5537b5bf62181784ef28b52f4b6a08"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["46589ed5cc841861bf6b5e2afc55f718ebcd02a0"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"46589ed5cc841861bf6b5e2afc55f718ebcd02a0":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"af3e10d8a1fbcc5c79b22f7477e79de467dd326c":["b94236357aaa22b76c10629851fe4e376e0cea82"],"3cbd743a4843f513f793670e3ab0e272bf824faf":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","60b45f127b5537b5bf62181784ef28b52f4b6a08","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"849083f8095b1ffaff05a66e0b1e024617b9968d":["b627755385655c7cd3fb296f17593658805cf4d5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5613a70439d5d429f0689c2c5a21615e58deff97"],"5613a70439d5d429f0689c2c5a21615e58deff97":["b94236357aaa22b76c10629851fe4e376e0cea82","af3e10d8a1fbcc5c79b22f7477e79de467dd326c"],"b627755385655c7cd3fb296f17593658805cf4d5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"60b45f127b5537b5bf62181784ef28b52f4b6a08":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","849083f8095b1ffaff05a66e0b1e024617b9968d","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}