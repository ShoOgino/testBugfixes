{"path":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"/dev/null","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":null,"sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"/dev/null","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0aea57ab530d174e645bf6e14d04db1e243e13d7","date":1274216848,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":["aceda38d9d3f703668f1a4569473f90880ed3f1e","c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f7e3e91f914e6265ed09a3208cc60c9ba2a477d","date":1286157263,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd9325c7ff9928fabe81c28553b41fc7aa57dfab","date":1295896411,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb9b72f7c3d7827c64dd4ec580ded81778da361d","date":1295897920,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","date":1296400215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public Similarity getSimilarity() {\n          return Similarity.getDefault();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a Similarlity and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public Similarity getSimilarity() {\n            return (Similarity) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b24326411db492f92ea49f6fb947c90bc73cf19e","date":1298813468,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":null,"sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":null,"sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f7e3e91f914e6265ed09a3208cc60c9ba2a477d":["0aea57ab530d174e645bf6e14d04db1e243e13d7"],"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01":["fd9325c7ff9928fabe81c28553b41fc7aa57dfab"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["0aea57ab530d174e645bf6e14d04db1e243e13d7","3f7e3e91f914e6265ed09a3208cc60c9ba2a477d"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","fd9325c7ff9928fabe81c28553b41fc7aa57dfab"],"b24326411db492f92ea49f6fb947c90bc73cf19e":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"fd9325c7ff9928fabe81c28553b41fc7aa57dfab":["3f7e3e91f914e6265ed09a3208cc60c9ba2a477d"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["bde51b089eb7f86171eb3406e38a274743f9b7ac","b24326411db492f92ea49f6fb947c90bc73cf19e"],"0aea57ab530d174e645bf6e14d04db1e243e13d7":["1da8d55113b689b06716246649de6f62430f15c0"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["29ef99d61cda9641b6250bf9567329a6e65f901d","b24326411db492f92ea49f6fb947c90bc73cf19e"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["3f7e3e91f914e6265ed09a3208cc60c9ba2a477d","70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b24326411db492f92ea49f6fb947c90bc73cf19e"]},"commit2Childs":{"3f7e3e91f914e6265ed09a3208cc60c9ba2a477d":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","fd9325c7ff9928fabe81c28553b41fc7aa57dfab","29ef99d61cda9641b6250bf9567329a6e65f901d"],"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01":["b24326411db492f92ea49f6fb947c90bc73cf19e","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"b24326411db492f92ea49f6fb947c90bc73cf19e":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1da8d55113b689b06716246649de6f62430f15c0":["0aea57ab530d174e645bf6e14d04db1e243e13d7"],"fd9325c7ff9928fabe81c28553b41fc7aa57dfab":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"0aea57ab530d174e645bf6e14d04db1e243e13d7":["3f7e3e91f914e6265ed09a3208cc60c9ba2a477d","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"d619839baa8ce5503e496b94a9e42ad6f079293f":[],"29ef99d61cda9641b6250bf9567329a6e65f901d":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}