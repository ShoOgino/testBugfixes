{"path":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doPushes().mjava","commits":[{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doPushes().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","sourceNew":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, new Term(fieldInfo.name, scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == internedFieldName) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","sourceOld":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, new Term(fieldInfo.name, scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == internedFieldName) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6e919043fa85ee891123768dd655a98edbbf63c","date":1322225413,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doPushes().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doPushes().mjava","sourceNew":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, new Term(fieldInfo.name, scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == internedFieldName) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copyBytes(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","sourceOld":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, new Term(fieldInfo.name, scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == internedFieldName) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doPushes().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doPushes().mjava","sourceNew":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, new Term(fieldInfo.name, scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == internedFieldName) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copyBytes(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","sourceOld":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, new Term(fieldInfo.name, scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == internedFieldName) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copyBytes(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["e6e919043fa85ee891123768dd655a98edbbf63c"],"e6e919043fa85ee891123768dd655a98edbbf63c":["7b91922b55d15444d554721b352861d028eb8278"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["e6e919043fa85ee891123768dd655a98edbbf63c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7b91922b55d15444d554721b352861d028eb8278"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e6e919043fa85ee891123768dd655a98edbbf63c":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}