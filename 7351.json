{"path":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","commits":[{"id":"c2045b132a2396bb23dff28d2d9f349a6907d36e","date":1367513076,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getGeneration();\n    if (targetGen > curGen) {\n      throw new IllegalArgumentException(\"targetGen=\" + targetGen + \" was never returned by the ReferenceManager instance (current gen=\" + curGen + \")\");\n    }\n    if (targetGen > searchingGen) {\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = ((startMS + maxMS) - (System.nanoTime())/1000000);\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a9b907a7568aa04bcad16628b3ede514dd0266ab"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9b907a7568aa04bcad16628b3ede514dd0266ab","date":1392986355,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","sourceNew":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getGeneration();\n    if (targetGen > curGen) {\n      throw new IllegalArgumentException(\"targetGen=\" + targetGen + \" was never returned by the ReferenceManager instance (current gen=\" + curGen + \")\");\n    }\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as its used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - (System.nanoTime())/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getGeneration();\n    if (targetGen > curGen) {\n      throw new IllegalArgumentException(\"targetGen=\" + targetGen + \" was never returned by the ReferenceManager instance (current gen=\" + curGen + \")\");\n    }\n    if (targetGen > searchingGen) {\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = ((startMS + maxMS) - (System.nanoTime())/1000000);\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":["c2045b132a2396bb23dff28d2d9f349a6907d36e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","sourceNew":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getGeneration();\n    if (targetGen > curGen) {\n      throw new IllegalArgumentException(\"targetGen=\" + targetGen + \" was never returned by the ReferenceManager instance (current gen=\" + curGen + \")\");\n    }\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - (System.nanoTime())/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getGeneration();\n    if (targetGen > curGen) {\n      throw new IllegalArgumentException(\"targetGen=\" + targetGen + \" was never returned by the ReferenceManager instance (current gen=\" + curGen + \")\");\n    }\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as its used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - (System.nanoTime())/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e5cee716c29944d6fcbb8f558285d2aa5c07da8","date":1450118305,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","sourceNew":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getGeneration();\n    if (targetGen > curGen) {\n      throw new IllegalArgumentException(\"targetGen=\" + targetGen + \" was never returned by the ReferenceManager instance (current gen=\" + curGen + \")\");\n    }\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getGeneration();\n    if (targetGen > curGen) {\n      throw new IllegalArgumentException(\"targetGen=\" + targetGen + \" was never returned by the ReferenceManager instance (current gen=\" + curGen + \")\");\n    }\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - (System.nanoTime())/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"427bf5b96e9aacef8f01879bc1b93c3619c43439","date":1464134313,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","sourceNew":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getLastSequenceNumber();\n    if (targetGen > curGen) {\n      throw new IllegalArgumentException(\"targetGen=\" + targetGen + \" was never returned by the ReferenceManager instance (current gen=\" + curGen + \")\");\n    }\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getGeneration();\n    if (targetGen > curGen) {\n      throw new IllegalArgumentException(\"targetGen=\" + targetGen + \" was never returned by the ReferenceManager instance (current gen=\" + curGen + \")\");\n    }\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9972d96003bc59c07a44e73de3cdd505dc08fd17","date":1464216081,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","sourceNew":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getLastSequenceNumber();\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getLastSequenceNumber();\n    if (targetGen > curGen) {\n      throw new IllegalArgumentException(\"targetGen=\" + targetGen + \" was never returned by the ReferenceManager instance (current gen=\" + curGen + \")\");\n    }\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","sourceNew":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getLastSequenceNumber();\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getGeneration();\n    if (targetGen > curGen) {\n      throw new IllegalArgumentException(\"targetGen=\" + targetGen + \" was never returned by the ReferenceManager instance (current gen=\" + curGen + \")\");\n    }\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","sourceNew":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getLastSequenceNumber();\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getGeneration();\n    if (targetGen > curGen) {\n      throw new IllegalArgumentException(\"targetGen=\" + targetGen + \" was never returned by the ReferenceManager instance (current gen=\" + curGen + \")\");\n    }\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"730b7b729dd280f1fec51e6b252f24c4de2a68e1","date":1465891767,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","sourceNew":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getLastSequenceNumber();\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57dc82c7b33cd580e7ab5179019bc78f3d7f8e79","date":1465913303,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","sourceNew":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getLastSequenceNumber();\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#waitForGeneration(long,int).mjava","sourceNew":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Waits for the target generation to become visible in\n   * the searcher, up to a maximum specified milli-seconds.\n   * If the current searcher is older than the target\n   * generation, this method will block until the\n   * searcher has been reopened by another thread via\n   * {@link ReferenceManager#maybeRefresh}, the given waiting time has elapsed, or until\n   * the {@link ReferenceManager} is closed.\n   * <p>\n   * NOTE: if the waiting time elapses before the requested target generation is\n   * available the current {@link SearcherManager} is returned instead.\n   * \n   * @param targetGen\n   *          the generation to wait for\n   * @param maxMS\n   *          maximum milliseconds to wait, or -1 to wait indefinitely\n   * @return true if the targetGeneration is now available,\n   *         or false if maxMS wait time was exceeded\n   */\n  public synchronized boolean waitForGeneration(long targetGen, int maxMS) throws InterruptedException {\n    final long curGen = writer.getGeneration();\n    if (targetGen > curGen) {\n      throw new IllegalArgumentException(\"targetGen=\" + targetGen + \" was never returned by the ReferenceManager instance (current gen=\" + curGen + \")\");\n    }\n    if (targetGen > searchingGen) {\n      // Notify the reopen thread that the waitingGen has\n      // changed, so it may wake up and realize it should\n      // not sleep for much or any longer before reopening:\n      reopenLock.lock();\n\n      // Need to find waitingGen inside lock as it's used to determine\n      // stale time\n      waitingGen = Math.max(waitingGen, targetGen);\n\n      try {\n        reopenCond.signal();\n      } finally {\n        reopenLock.unlock();\n      }\n\n      long startMS = System.nanoTime()/1000000;\n\n      while (targetGen > searchingGen) {\n        if (maxMS < 0) {\n          wait();\n        } else {\n          long msLeft = (startMS + maxMS) - System.nanoTime()/1000000;\n          if (msLeft <= 0) {\n            return false;\n          } else {\n            wait(msLeft);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c2045b132a2396bb23dff28d2d9f349a6907d36e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"730b7b729dd280f1fec51e6b252f24c4de2a68e1":["191128ac5b85671b1671e2c857437694283b6ebf"],"6483e4260c08168709c02238ae083a51519a28dd":["7e5cee716c29944d6fcbb8f558285d2aa5c07da8","9972d96003bc59c07a44e73de3cdd505dc08fd17"],"191128ac5b85671b1671e2c857437694283b6ebf":["7e5cee716c29944d6fcbb8f558285d2aa5c07da8","6483e4260c08168709c02238ae083a51519a28dd"],"7e5cee716c29944d6fcbb8f558285d2aa5c07da8":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7e5cee716c29944d6fcbb8f558285d2aa5c07da8","57dc82c7b33cd580e7ab5179019bc78f3d7f8e79"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["a9b907a7568aa04bcad16628b3ede514dd0266ab"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a9b907a7568aa04bcad16628b3ede514dd0266ab":["c2045b132a2396bb23dff28d2d9f349a6907d36e"],"9972d96003bc59c07a44e73de3cdd505dc08fd17":["427bf5b96e9aacef8f01879bc1b93c3619c43439"],"57dc82c7b33cd580e7ab5179019bc78f3d7f8e79":["191128ac5b85671b1671e2c857437694283b6ebf","730b7b729dd280f1fec51e6b252f24c4de2a68e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57dc82c7b33cd580e7ab5179019bc78f3d7f8e79"],"427bf5b96e9aacef8f01879bc1b93c3619c43439":["7e5cee716c29944d6fcbb8f558285d2aa5c07da8"]},"commit2Childs":{"c2045b132a2396bb23dff28d2d9f349a6907d36e":["a9b907a7568aa04bcad16628b3ede514dd0266ab"],"730b7b729dd280f1fec51e6b252f24c4de2a68e1":["57dc82c7b33cd580e7ab5179019bc78f3d7f8e79"],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["730b7b729dd280f1fec51e6b252f24c4de2a68e1","57dc82c7b33cd580e7ab5179019bc78f3d7f8e79"],"7e5cee716c29944d6fcbb8f558285d2aa5c07da8":["6483e4260c08168709c02238ae083a51519a28dd","191128ac5b85671b1671e2c857437694283b6ebf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","427bf5b96e9aacef8f01879bc1b93c3619c43439"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["7e5cee716c29944d6fcbb8f558285d2aa5c07da8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c2045b132a2396bb23dff28d2d9f349a6907d36e"],"a9b907a7568aa04bcad16628b3ede514dd0266ab":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"9972d96003bc59c07a44e73de3cdd505dc08fd17":["6483e4260c08168709c02238ae083a51519a28dd"],"57dc82c7b33cd580e7ab5179019bc78f3d7f8e79":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"427bf5b96e9aacef8f01879bc1b93c3619c43439":["9972d96003bc59c07a44e73de3cdd505dc08fd17"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}