{"path":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","commits":[{"id":"b2e70b697d9f5a6130848741a4f0cdc08a1fe258","date":1168661303,"type":0,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"/dev/null","sourceNew":"  /**\r\n   * Read algorithm from file\r\n   * @param runData perf-run-data used at running the tasks.\r\n   * @throws Exception if errors while parsing the algorithm \r\n   */\r\n  public Algorithm (PerfRunData runData) throws Exception {\r\n    String algTxt = runData.getConfig().getAlgorithmText();\r\n    sequence = new TaskSequence(runData,null,null,false);\r\n    TaskSequence currSequence = sequence;\r\n    PerfTask prevTask = null;\r\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\r\n    stok.commentChar('#');\r\n    stok.eolIsSignificant(false);\r\n    stok.ordinaryChar('\"');\r\n    stok.ordinaryChar('/');\r\n    stok.ordinaryChar('(');\r\n    stok.ordinaryChar(')');\r\n    boolean colonOk = false; \r\n    currSequence.setDepth(0);\r\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\r\n    \r\n    Class paramClass[] = {PerfRunData.class};\r\n    PerfRunData paramObj[] = {runData};\r\n    \r\n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \r\n      switch(stok.ttype) {\r\n  \r\n        case StreamTokenizer.TT_WORD:\r\n          String s = stok.sval;\r\n          Constructor cnstr = Class.forName(taskPackage+s+\"Task\").getConstructor(paramClass);\r\n          PerfTask task = (PerfTask) cnstr.newInstance(paramObj);\r\n          currSequence.addTask(task);\r\n          if (task instanceof RepSumByPrefTask) {\r\n            stok.nextToken();\r\n            String prefix = stok.sval;\r\n            if (prefix==null || prefix.length()==0) { \r\n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \r\n            }\r\n            ((RepSumByPrefTask) task).setPrefix(prefix);\r\n          }\r\n          // check for task param: '(' someParam ')'\r\n          stok.nextToken();\r\n          if (stok.ttype!='(') {\r\n            stok.pushBack();\r\n          } else {\r\n            // get params, for tasks that supports them, - anything until next ')'\r\n            StringBuffer params = new StringBuffer();\r\n            stok.nextToken();\r\n            while (stok.ttype!=')') { \r\n              switch (stok.ttype) {\r\n                case StreamTokenizer.TT_NUMBER:  \r\n                  params.append(stok.nval);\r\n                  break;\r\n                case StreamTokenizer.TT_WORD:    \r\n                  params.append(stok.sval);             \r\n                  break;\r\n                case StreamTokenizer.TT_EOF:     \r\n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\r\n                default:\r\n                  params.append((char)stok.ttype);\r\n              }\r\n              stok.nextToken();\r\n            }\r\n            String prm = params.toString().trim();\r\n            if (prm.length()>0) {\r\n              task.setParams(prm);\r\n            }\r\n          }\r\n\r\n          // ---------------------------------------\r\n          colonOk = false; prevTask = task;\r\n          break;\r\n  \r\n        default:\r\n          char c = (char)stok.ttype;\r\n          \r\n          switch(c) {\r\n          \r\n            case ':' :\r\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\r\n              colonOk = false;\r\n              // get repetitions number\r\n              stok.nextToken();\r\n              if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expexted repetitions number: - \"+stok.toString());\r\n              ((TaskSequence)prevTask).setRepetitions((int)stok.nval); \r\n              // check for rate specification (ops/min)\r\n              stok.nextToken();\r\n              if (stok.ttype!=':') {\r\n                stok.pushBack();\r\n              } else {\r\n                // get rate number\r\n                stok.nextToken();\r\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expexted rate number: - \"+stok.toString());\r\n                // check for unit - min or sec, sec is default\r\n                stok.nextToken();\r\n                if (stok.ttype!='/') {\r\n                  stok.pushBack();\r\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\r\n                } else {\r\n                  stok.nextToken();\r\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expexted rate unit: 'min' or 'sec' - \"+stok.toString());\r\n                  String unit = stok.sval.toLowerCase();\r\n                  if (\"min\".equals(unit)) {\r\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\r\n                  } else if (\"sec\".equals(unit)) {\r\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\r\n                  } else {\r\n                    throw new Exception(\"expexted rate unit: 'min' or 'sec' - \"+stok.toString());\r\n                  }\r\n                }\r\n              }\r\n              colonOk = false;\r\n              break;\r\n    \r\n            case '{' : \r\n            case '[' :  \r\n              // a sequence\r\n              // check for sequence name\r\n              String name = null;\r\n              stok.nextToken();\r\n              if (stok.ttype!='\"') {\r\n                stok.pushBack();\r\n              } else {\r\n                stok.nextToken();\r\n                name = stok.sval;\r\n                stok.nextToken();\r\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \r\n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \r\n                }\r\n              }\r\n              // start the sequence\r\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\r\n              currSequence.addTask(seq2);\r\n              currSequence = seq2;\r\n              colonOk = false;\r\n              break;\r\n    \r\n            case '>' :\r\n              currSequence.setNoChildReport();\r\n            case '}' : \r\n            case ']' : \r\n              // end sequence\r\n              colonOk = true; prevTask = currSequence;\r\n              currSequence = currSequence.getParent();\r\n              break;\r\n          \r\n          } //switch(c)\r\n          break;\r\n          \r\n      } //switch(stok.ttype)\r\n      \r\n    }\r\n    \r\n    if (sequence != currSequence) {\r\n      throw new Exception(\"Unmatched sequences\");\r\n    }\r\n    \r\n    // remove redundant top level enclosing sequences\r\n    while (sequence.getRepetitions()==1 && sequence.getRate()==0) {\r\n      ArrayList t = sequence.getTasks();\r\n      if (t!=null && t.size()==1) {\r\n        PerfTask p = (PerfTask) t.get(0);\r\n        if (p instanceof TaskSequence) {\r\n          sequence = (TaskSequence) p;\r\n          continue;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81573e29e6e5db648330b225c60d44b1c3eb388e","date":1174927593,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\r\n   * Read algorithm from file\r\n   * @param runData perf-run-data used at running the tasks.\r\n   * @throws Exception if errors while parsing the algorithm \r\n   */\r\n  public Algorithm (PerfRunData runData) throws Exception {\r\n    String algTxt = runData.getConfig().getAlgorithmText();\r\n    sequence = new TaskSequence(runData,null,null,false);\r\n    TaskSequence currSequence = sequence;\r\n    PerfTask prevTask = null;\r\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\r\n    stok.commentChar('#');\r\n    stok.eolIsSignificant(false);\r\n    stok.ordinaryChar('\"');\r\n    stok.ordinaryChar('/');\r\n    stok.ordinaryChar('(');\r\n    stok.ordinaryChar(')');\r\n    boolean colonOk = false; \r\n    currSequence.setDepth(0);\r\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\r\n    \r\n    Class paramClass[] = {PerfRunData.class};\r\n    PerfRunData paramObj[] = {runData};\r\n    \r\n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \r\n      switch(stok.ttype) {\r\n  \r\n        case StreamTokenizer.TT_WORD:\r\n          String s = stok.sval;\r\n          Constructor cnstr = Class.forName(taskPackage+s+\"Task\").getConstructor(paramClass);\r\n          PerfTask task = (PerfTask) cnstr.newInstance(paramObj);\r\n          currSequence.addTask(task);\r\n          if (task instanceof RepSumByPrefTask) {\r\n            stok.nextToken();\r\n            String prefix = stok.sval;\r\n            if (prefix==null || prefix.length()==0) { \r\n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \r\n            }\r\n            ((RepSumByPrefTask) task).setPrefix(prefix);\r\n          }\r\n          // check for task param: '(' someParam ')'\r\n          stok.nextToken();\r\n          if (stok.ttype!='(') {\r\n            stok.pushBack();\r\n          } else {\r\n            // get params, for tasks that supports them, - anything until next ')'\r\n            StringBuffer params = new StringBuffer();\r\n            stok.nextToken();\r\n            while (stok.ttype!=')') { \r\n              switch (stok.ttype) {\r\n                case StreamTokenizer.TT_NUMBER:  \r\n                  params.append(stok.nval);\r\n                  break;\r\n                case StreamTokenizer.TT_WORD:    \r\n                  params.append(stok.sval);             \r\n                  break;\r\n                case StreamTokenizer.TT_EOF:     \r\n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\r\n                default:\r\n                  params.append((char)stok.ttype);\r\n              }\r\n              stok.nextToken();\r\n            }\r\n            String prm = params.toString().trim();\r\n            if (prm.length()>0) {\r\n              task.setParams(prm);\r\n            }\r\n          }\r\n\r\n          // ---------------------------------------\r\n          colonOk = false; prevTask = task;\r\n          break;\r\n  \r\n        default:\r\n          char c = (char)stok.ttype;\r\n          \r\n          switch(c) {\r\n          \r\n            case ':' :\r\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\r\n              colonOk = false;\r\n              // get repetitions number\r\n              stok.nextToken();\r\n              if ((char)stok.ttype == '*') {\r\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\r\n              } else {\r\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expexted repetitions number: - \"+stok.toString());\r\n                ((TaskSequence)prevTask).setRepetitions((int)stok.nval);\r\n              }\r\n              // check for rate specification (ops/min)\r\n              stok.nextToken();\r\n              if (stok.ttype!=':') {\r\n                stok.pushBack();\r\n              } else {\r\n                // get rate number\r\n                stok.nextToken();\r\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expexted rate number: - \"+stok.toString());\r\n                // check for unit - min or sec, sec is default\r\n                stok.nextToken();\r\n                if (stok.ttype!='/') {\r\n                  stok.pushBack();\r\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\r\n                } else {\r\n                  stok.nextToken();\r\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expexted rate unit: 'min' or 'sec' - \"+stok.toString());\r\n                  String unit = stok.sval.toLowerCase();\r\n                  if (\"min\".equals(unit)) {\r\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\r\n                  } else if (\"sec\".equals(unit)) {\r\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\r\n                  } else {\r\n                    throw new Exception(\"expexted rate unit: 'min' or 'sec' - \"+stok.toString());\r\n                  }\r\n                }\r\n              }\r\n              colonOk = false;\r\n              break;\r\n    \r\n            case '{' : \r\n            case '[' :  \r\n              // a sequence\r\n              // check for sequence name\r\n              String name = null;\r\n              stok.nextToken();\r\n              if (stok.ttype!='\"') {\r\n                stok.pushBack();\r\n              } else {\r\n                stok.nextToken();\r\n                name = stok.sval;\r\n                stok.nextToken();\r\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \r\n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \r\n                }\r\n              }\r\n              // start the sequence\r\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\r\n              currSequence.addTask(seq2);\r\n              currSequence = seq2;\r\n              colonOk = false;\r\n              break;\r\n    \r\n            case '>' :\r\n              currSequence.setNoChildReport();\r\n            case '}' : \r\n            case ']' : \r\n              // end sequence\r\n              colonOk = true; prevTask = currSequence;\r\n              currSequence = currSequence.getParent();\r\n              break;\r\n          \r\n          } //switch(c)\r\n          break;\r\n          \r\n      } //switch(stok.ttype)\r\n      \r\n    }\r\n    \r\n    if (sequence != currSequence) {\r\n      throw new Exception(\"Unmatched sequences\");\r\n    }\r\n    \r\n    // remove redundant top level enclosing sequences\r\n    while (sequence.getRepetitions()==1 && sequence.getRate()==0) {\r\n      ArrayList t = sequence.getTasks();\r\n      if (t!=null && t.size()==1) {\r\n        PerfTask p = (PerfTask) t.get(0);\r\n        if (p instanceof TaskSequence) {\r\n          sequence = (TaskSequence) p;\r\n          continue;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\n","sourceOld":"  /**\r\n   * Read algorithm from file\r\n   * @param runData perf-run-data used at running the tasks.\r\n   * @throws Exception if errors while parsing the algorithm \r\n   */\r\n  public Algorithm (PerfRunData runData) throws Exception {\r\n    String algTxt = runData.getConfig().getAlgorithmText();\r\n    sequence = new TaskSequence(runData,null,null,false);\r\n    TaskSequence currSequence = sequence;\r\n    PerfTask prevTask = null;\r\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\r\n    stok.commentChar('#');\r\n    stok.eolIsSignificant(false);\r\n    stok.ordinaryChar('\"');\r\n    stok.ordinaryChar('/');\r\n    stok.ordinaryChar('(');\r\n    stok.ordinaryChar(')');\r\n    boolean colonOk = false; \r\n    currSequence.setDepth(0);\r\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\r\n    \r\n    Class paramClass[] = {PerfRunData.class};\r\n    PerfRunData paramObj[] = {runData};\r\n    \r\n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \r\n      switch(stok.ttype) {\r\n  \r\n        case StreamTokenizer.TT_WORD:\r\n          String s = stok.sval;\r\n          Constructor cnstr = Class.forName(taskPackage+s+\"Task\").getConstructor(paramClass);\r\n          PerfTask task = (PerfTask) cnstr.newInstance(paramObj);\r\n          currSequence.addTask(task);\r\n          if (task instanceof RepSumByPrefTask) {\r\n            stok.nextToken();\r\n            String prefix = stok.sval;\r\n            if (prefix==null || prefix.length()==0) { \r\n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \r\n            }\r\n            ((RepSumByPrefTask) task).setPrefix(prefix);\r\n          }\r\n          // check for task param: '(' someParam ')'\r\n          stok.nextToken();\r\n          if (stok.ttype!='(') {\r\n            stok.pushBack();\r\n          } else {\r\n            // get params, for tasks that supports them, - anything until next ')'\r\n            StringBuffer params = new StringBuffer();\r\n            stok.nextToken();\r\n            while (stok.ttype!=')') { \r\n              switch (stok.ttype) {\r\n                case StreamTokenizer.TT_NUMBER:  \r\n                  params.append(stok.nval);\r\n                  break;\r\n                case StreamTokenizer.TT_WORD:    \r\n                  params.append(stok.sval);             \r\n                  break;\r\n                case StreamTokenizer.TT_EOF:     \r\n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\r\n                default:\r\n                  params.append((char)stok.ttype);\r\n              }\r\n              stok.nextToken();\r\n            }\r\n            String prm = params.toString().trim();\r\n            if (prm.length()>0) {\r\n              task.setParams(prm);\r\n            }\r\n          }\r\n\r\n          // ---------------------------------------\r\n          colonOk = false; prevTask = task;\r\n          break;\r\n  \r\n        default:\r\n          char c = (char)stok.ttype;\r\n          \r\n          switch(c) {\r\n          \r\n            case ':' :\r\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\r\n              colonOk = false;\r\n              // get repetitions number\r\n              stok.nextToken();\r\n              if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expexted repetitions number: - \"+stok.toString());\r\n              ((TaskSequence)prevTask).setRepetitions((int)stok.nval); \r\n              // check for rate specification (ops/min)\r\n              stok.nextToken();\r\n              if (stok.ttype!=':') {\r\n                stok.pushBack();\r\n              } else {\r\n                // get rate number\r\n                stok.nextToken();\r\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expexted rate number: - \"+stok.toString());\r\n                // check for unit - min or sec, sec is default\r\n                stok.nextToken();\r\n                if (stok.ttype!='/') {\r\n                  stok.pushBack();\r\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\r\n                } else {\r\n                  stok.nextToken();\r\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expexted rate unit: 'min' or 'sec' - \"+stok.toString());\r\n                  String unit = stok.sval.toLowerCase();\r\n                  if (\"min\".equals(unit)) {\r\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\r\n                  } else if (\"sec\".equals(unit)) {\r\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\r\n                  } else {\r\n                    throw new Exception(\"expexted rate unit: 'min' or 'sec' - \"+stok.toString());\r\n                  }\r\n                }\r\n              }\r\n              colonOk = false;\r\n              break;\r\n    \r\n            case '{' : \r\n            case '[' :  \r\n              // a sequence\r\n              // check for sequence name\r\n              String name = null;\r\n              stok.nextToken();\r\n              if (stok.ttype!='\"') {\r\n                stok.pushBack();\r\n              } else {\r\n                stok.nextToken();\r\n                name = stok.sval;\r\n                stok.nextToken();\r\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \r\n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \r\n                }\r\n              }\r\n              // start the sequence\r\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\r\n              currSequence.addTask(seq2);\r\n              currSequence = seq2;\r\n              colonOk = false;\r\n              break;\r\n    \r\n            case '>' :\r\n              currSequence.setNoChildReport();\r\n            case '}' : \r\n            case ']' : \r\n              // end sequence\r\n              colonOk = true; prevTask = currSequence;\r\n              currSequence = currSequence.getParent();\r\n              break;\r\n          \r\n          } //switch(c)\r\n          break;\r\n          \r\n      } //switch(stok.ttype)\r\n      \r\n    }\r\n    \r\n    if (sequence != currSequence) {\r\n      throw new Exception(\"Unmatched sequences\");\r\n    }\r\n    \r\n    // remove redundant top level enclosing sequences\r\n    while (sequence.getRepetitions()==1 && sequence.getRate()==0) {\r\n      ArrayList t = sequence.getTasks();\r\n      if (t!=null && t.size()==1) {\r\n        PerfTask p = (PerfTask) t.get(0);\r\n        if (p instanceof TaskSequence) {\r\n          sequence = (TaskSequence) p;\r\n          continue;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3738fa43eaa87dc7b393fe98b04cde1019e20bac","date":1175557034,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    Class paramClass[] = {PerfRunData.class};\n    PerfRunData paramObj[] = {runData};\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor cnstr = Class.forName(taskPackage+s+\"Task\").getConstructor(paramClass);\n          PerfTask task = (PerfTask) cnstr.newInstance(paramObj);\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expexted repetitions number: - \"+stok.toString());\n                ((TaskSequence)prevTask).setRepetitions((int)stok.nval);\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expexted rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expexted rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expexted rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = (PerfTask) t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\r\n   * Read algorithm from file\r\n   * @param runData perf-run-data used at running the tasks.\r\n   * @throws Exception if errors while parsing the algorithm \r\n   */\r\n  public Algorithm (PerfRunData runData) throws Exception {\r\n    String algTxt = runData.getConfig().getAlgorithmText();\r\n    sequence = new TaskSequence(runData,null,null,false);\r\n    TaskSequence currSequence = sequence;\r\n    PerfTask prevTask = null;\r\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\r\n    stok.commentChar('#');\r\n    stok.eolIsSignificant(false);\r\n    stok.ordinaryChar('\"');\r\n    stok.ordinaryChar('/');\r\n    stok.ordinaryChar('(');\r\n    stok.ordinaryChar(')');\r\n    boolean colonOk = false; \r\n    currSequence.setDepth(0);\r\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\r\n    \r\n    Class paramClass[] = {PerfRunData.class};\r\n    PerfRunData paramObj[] = {runData};\r\n    \r\n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \r\n      switch(stok.ttype) {\r\n  \r\n        case StreamTokenizer.TT_WORD:\r\n          String s = stok.sval;\r\n          Constructor cnstr = Class.forName(taskPackage+s+\"Task\").getConstructor(paramClass);\r\n          PerfTask task = (PerfTask) cnstr.newInstance(paramObj);\r\n          currSequence.addTask(task);\r\n          if (task instanceof RepSumByPrefTask) {\r\n            stok.nextToken();\r\n            String prefix = stok.sval;\r\n            if (prefix==null || prefix.length()==0) { \r\n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \r\n            }\r\n            ((RepSumByPrefTask) task).setPrefix(prefix);\r\n          }\r\n          // check for task param: '(' someParam ')'\r\n          stok.nextToken();\r\n          if (stok.ttype!='(') {\r\n            stok.pushBack();\r\n          } else {\r\n            // get params, for tasks that supports them, - anything until next ')'\r\n            StringBuffer params = new StringBuffer();\r\n            stok.nextToken();\r\n            while (stok.ttype!=')') { \r\n              switch (stok.ttype) {\r\n                case StreamTokenizer.TT_NUMBER:  \r\n                  params.append(stok.nval);\r\n                  break;\r\n                case StreamTokenizer.TT_WORD:    \r\n                  params.append(stok.sval);             \r\n                  break;\r\n                case StreamTokenizer.TT_EOF:     \r\n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\r\n                default:\r\n                  params.append((char)stok.ttype);\r\n              }\r\n              stok.nextToken();\r\n            }\r\n            String prm = params.toString().trim();\r\n            if (prm.length()>0) {\r\n              task.setParams(prm);\r\n            }\r\n          }\r\n\r\n          // ---------------------------------------\r\n          colonOk = false; prevTask = task;\r\n          break;\r\n  \r\n        default:\r\n          char c = (char)stok.ttype;\r\n          \r\n          switch(c) {\r\n          \r\n            case ':' :\r\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\r\n              colonOk = false;\r\n              // get repetitions number\r\n              stok.nextToken();\r\n              if ((char)stok.ttype == '*') {\r\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\r\n              } else {\r\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expexted repetitions number: - \"+stok.toString());\r\n                ((TaskSequence)prevTask).setRepetitions((int)stok.nval);\r\n              }\r\n              // check for rate specification (ops/min)\r\n              stok.nextToken();\r\n              if (stok.ttype!=':') {\r\n                stok.pushBack();\r\n              } else {\r\n                // get rate number\r\n                stok.nextToken();\r\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expexted rate number: - \"+stok.toString());\r\n                // check for unit - min or sec, sec is default\r\n                stok.nextToken();\r\n                if (stok.ttype!='/') {\r\n                  stok.pushBack();\r\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\r\n                } else {\r\n                  stok.nextToken();\r\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expexted rate unit: 'min' or 'sec' - \"+stok.toString());\r\n                  String unit = stok.sval.toLowerCase();\r\n                  if (\"min\".equals(unit)) {\r\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\r\n                  } else if (\"sec\".equals(unit)) {\r\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\r\n                  } else {\r\n                    throw new Exception(\"expexted rate unit: 'min' or 'sec' - \"+stok.toString());\r\n                  }\r\n                }\r\n              }\r\n              colonOk = false;\r\n              break;\r\n    \r\n            case '{' : \r\n            case '[' :  \r\n              // a sequence\r\n              // check for sequence name\r\n              String name = null;\r\n              stok.nextToken();\r\n              if (stok.ttype!='\"') {\r\n                stok.pushBack();\r\n              } else {\r\n                stok.nextToken();\r\n                name = stok.sval;\r\n                stok.nextToken();\r\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \r\n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \r\n                }\r\n              }\r\n              // start the sequence\r\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\r\n              currSequence.addTask(seq2);\r\n              currSequence = seq2;\r\n              colonOk = false;\r\n              break;\r\n    \r\n            case '>' :\r\n              currSequence.setNoChildReport();\r\n            case '}' : \r\n            case ']' : \r\n              // end sequence\r\n              colonOk = true; prevTask = currSequence;\r\n              currSequence = currSequence.getParent();\r\n              break;\r\n          \r\n          } //switch(c)\r\n          break;\r\n          \r\n      } //switch(stok.ttype)\r\n      \r\n    }\r\n    \r\n    if (sequence != currSequence) {\r\n      throw new Exception(\"Unmatched sequences\");\r\n    }\r\n    \r\n    // remove redundant top level enclosing sequences\r\n    while (sequence.getRepetitions()==1 && sequence.getRate()==0) {\r\n      ArrayList t = sequence.getTasks();\r\n      if (t!=null && t.size()==1) {\r\n        PerfTask p = (PerfTask) t.get(0);\r\n        if (p instanceof TaskSequence) {\r\n          sequence = (TaskSequence) p;\r\n          continue;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cef13333102a2c287543f5141a0f24ccca005b2e","date":1201185584,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    Class paramClass[] = {PerfRunData.class};\n    PerfRunData paramObj[] = {runData};\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor cnstr = Class.forName(taskPackage+s+\"Task\").getConstructor(paramClass);\n          PerfTask task = (PerfTask) cnstr.newInstance(paramObj);\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected repetitions number: - \"+stok.toString());\n                ((TaskSequence)prevTask).setRepetitions((int)stok.nval);\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = (PerfTask) t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    Class paramClass[] = {PerfRunData.class};\n    PerfRunData paramObj[] = {runData};\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor cnstr = Class.forName(taskPackage+s+\"Task\").getConstructor(paramClass);\n          PerfTask task = (PerfTask) cnstr.newInstance(paramObj);\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expexted repetitions number: - \"+stok.toString());\n                ((TaskSequence)prevTask).setRepetitions((int)stok.nval);\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expexted rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expexted rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expexted rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = (PerfTask) t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b26918d056f1bcc0ae9accb3bf0cb2b87803fe64","date":1201200417,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar('-');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    Class paramClass[] = {PerfRunData.class};\n    PerfRunData paramObj[] = {runData};\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor cnstr = Class.forName(taskPackage+s+\"Task\").getConstructor(paramClass);\n          PerfTask task = (PerfTask) cnstr.newInstance(paramObj);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) \n                  throw new Exception(\"expected repetitions number: - \"+stok.toString());\n                ((TaskSequence)prevTask).setRepetitions((int)stok.nval);\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = (PerfTask) t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    Class paramClass[] = {PerfRunData.class};\n    PerfRunData paramObj[] = {runData};\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor cnstr = Class.forName(taskPackage+s+\"Task\").getConstructor(paramClass);\n          PerfTask task = (PerfTask) cnstr.newInstance(paramObj);\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected repetitions number: - \"+stok.toString());\n                ((TaskSequence)prevTask).setRepetitions((int)stok.nval);\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = (PerfTask) t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":["4a17d4f02835375bd1c2e7a968e19a537bc21242"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a1d7886f5b663e876f02df6f9d56b2f5528c4ea1","date":1229762709,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar('-');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    Class paramClass[] = {PerfRunData.class};\n    PerfRunData paramObj[] = {runData};\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor cnstr = Class.forName(taskPackage+s+\"Task\").getConstructor(paramClass);\n          PerfTask task = (PerfTask) cnstr.newInstance(paramObj);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = (PerfTask) t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar('-');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    Class paramClass[] = {PerfRunData.class};\n    PerfRunData paramObj[] = {runData};\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor cnstr = Class.forName(taskPackage+s+\"Task\").getConstructor(paramClass);\n          PerfTask task = (PerfTask) cnstr.newInstance(paramObj);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) \n                  throw new Exception(\"expected repetitions number: - \"+stok.toString());\n                ((TaskSequence)prevTask).setRepetitions((int)stok.nval);\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = (PerfTask) t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4256bc1b3c94786287ccdfc751230374521843cf","date":1254612273,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar('-');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = (PerfTask) t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar('-');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    Class paramClass[] = {PerfRunData.class};\n    PerfRunData paramObj[] = {runData};\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor cnstr = Class.forName(taskPackage+s+\"Task\").getConstructor(paramClass);\n          PerfTask task = (PerfTask) cnstr.newInstance(paramObj);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = (PerfTask) t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e1ce9be74263e9659aad8a6ee1f213193710b71","date":1256298843,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar('-');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar('-');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = (PerfTask) t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3353540ef2debe4c4c017e9d86e2c60f9e784336","date":1258197258,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar('-');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground();\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar('-');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f5ebdc25cde64f1bd2b6337721292bdd1b23f714","date":1258737814,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar('-');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar('-');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground();\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a17d4f02835375bd1c2e7a968e19a537bc21242","date":1261048374,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    stok.ordinaryChar('-');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":["b26918d056f1bcc0ae9accb3bf0cb2b87803fe64"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuffer params = new StringBuffer();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport();\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cef13333102a2c287543f5141a0f24ccca005b2e":["3738fa43eaa87dc7b393fe98b04cde1019e20bac"],"4e1ce9be74263e9659aad8a6ee1f213193710b71":["4256bc1b3c94786287ccdfc751230374521843cf"],"a1d7886f5b663e876f02df6f9d56b2f5528c4ea1":["b26918d056f1bcc0ae9accb3bf0cb2b87803fe64"],"3738fa43eaa87dc7b393fe98b04cde1019e20bac":["81573e29e6e5db648330b225c60d44b1c3eb388e"],"b2e70b697d9f5a6130848741a4f0cdc08a1fe258":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b26918d056f1bcc0ae9accb3bf0cb2b87803fe64":["cef13333102a2c287543f5141a0f24ccca005b2e"],"4256bc1b3c94786287ccdfc751230374521843cf":["a1d7886f5b663e876f02df6f9d56b2f5528c4ea1"],"3353540ef2debe4c4c017e9d86e2c60f9e784336":["4e1ce9be74263e9659aad8a6ee1f213193710b71"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f5ebdc25cde64f1bd2b6337721292bdd1b23f714":["3353540ef2debe4c4c017e9d86e2c60f9e784336"],"4a17d4f02835375bd1c2e7a968e19a537bc21242":["f5ebdc25cde64f1bd2b6337721292bdd1b23f714"],"81573e29e6e5db648330b225c60d44b1c3eb388e":["b2e70b697d9f5a6130848741a4f0cdc08a1fe258"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["4a17d4f02835375bd1c2e7a968e19a537bc21242"]},"commit2Childs":{"cef13333102a2c287543f5141a0f24ccca005b2e":["b26918d056f1bcc0ae9accb3bf0cb2b87803fe64"],"4e1ce9be74263e9659aad8a6ee1f213193710b71":["3353540ef2debe4c4c017e9d86e2c60f9e784336"],"a1d7886f5b663e876f02df6f9d56b2f5528c4ea1":["4256bc1b3c94786287ccdfc751230374521843cf"],"3738fa43eaa87dc7b393fe98b04cde1019e20bac":["cef13333102a2c287543f5141a0f24ccca005b2e"],"b2e70b697d9f5a6130848741a4f0cdc08a1fe258":["81573e29e6e5db648330b225c60d44b1c3eb388e"],"b26918d056f1bcc0ae9accb3bf0cb2b87803fe64":["a1d7886f5b663e876f02df6f9d56b2f5528c4ea1"],"4256bc1b3c94786287ccdfc751230374521843cf":["4e1ce9be74263e9659aad8a6ee1f213193710b71"],"3353540ef2debe4c4c017e9d86e2c60f9e784336":["f5ebdc25cde64f1bd2b6337721292bdd1b23f714"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b2e70b697d9f5a6130848741a4f0cdc08a1fe258"],"f5ebdc25cde64f1bd2b6337721292bdd1b23f714":["4a17d4f02835375bd1c2e7a968e19a537bc21242"],"81573e29e6e5db648330b225c60d44b1c3eb388e":["3738fa43eaa87dc7b393fe98b04cde1019e20bac"],"4a17d4f02835375bd1c2e7a968e19a537bc21242":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}