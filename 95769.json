{"path":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","commits":[{"id":"be658e3695ce5dfe92a3ad3d6531cfc987ae8935","date":1329142379,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n\n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getPath())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getAbsolutePath();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0dc336cf0d57e7e3a9fb0de2d61bb4563940c29d","date":1333562012,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","sourceNew":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n\n    // validate the jar matches against our expected hash\n    final File checksumFile = new File(jarFile.getParent(), \n                                       jarFile.getName() + \".\" + CHECKSUM_TYPE);\n    if (! (checksumFile.exists() && checksumFile.canRead()) ) {\n      log(\"MISSING \" +CHECKSUM_TYPE+ \" checksum file for: \" + jarFile.getPath(), Project.MSG_ERR);\n      this.failures = true;\n      return false;\n    } else {\n      final String expectedChecksum = readChecksumFile(checksumFile);\n      try {\n        final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n        byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n        try {\n          FileInputStream fis = new FileInputStream(jarFile);\n          try {\n            DigestInputStream dis = new DigestInputStream(fis, md);\n            try {\n              while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                // NOOP\n              }\n            } finally {\n              dis.close();\n            }\n          } finally {\n            fis.close();\n          }\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO error computing checksum of file: \" + jarFile, ioe);\n        }\n        final byte[] checksumBytes = md.digest();\n        final String checksum = createChecksumString(checksumBytes);\n        if ( ! checksum.equals(expectedChecksum) ) {\n          log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \n              \" (expected: \\\"\" + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\", \n              Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        }\n\n      } catch (NoSuchAlgorithmException ae) {\n        throw new BuildException(\"Digest type \" + CHECKSUM_TYPE + \" not supported by your JVM\", ae);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getPath())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getAbsolutePath();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n\n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getPath())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getAbsolutePath();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2495c89d72babf74bc9fdbb3938474704876a710","date":1343416729,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","sourceNew":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n\n    // validate the jar matches against our expected hash\n    final File checksumFile = new File(licenseDirectory, \n                                       jarFile.getName() + \".\" + CHECKSUM_TYPE);\n    if (! (checksumFile.exists() && checksumFile.canRead()) ) {\n      log(\"MISSING \" +CHECKSUM_TYPE+ \" checksum file for: \" + jarFile.getPath(), Project.MSG_ERR);\n      this.failures = true;\n      return false;\n    } else {\n      final String expectedChecksum = readChecksumFile(checksumFile);\n      try {\n        final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n        byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n        try {\n          FileInputStream fis = new FileInputStream(jarFile);\n          try {\n            DigestInputStream dis = new DigestInputStream(fis, md);\n            try {\n              while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                // NOOP\n              }\n            } finally {\n              dis.close();\n            }\n          } finally {\n            fis.close();\n          }\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO error computing checksum of file: \" + jarFile, ioe);\n        }\n        final byte[] checksumBytes = md.digest();\n        final String checksum = createChecksumString(checksumBytes);\n        if ( ! checksum.equals(expectedChecksum) ) {\n          log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \n              \" (expected: \\\"\" + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\", \n              Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        }\n\n      } catch (NoSuchAlgorithmException ae) {\n        throw new BuildException(\"Digest type \" + CHECKSUM_TYPE + \" not supported by your JVM\", ae);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n\n    // validate the jar matches against our expected hash\n    final File checksumFile = new File(jarFile.getParent(), \n                                       jarFile.getName() + \".\" + CHECKSUM_TYPE);\n    if (! (checksumFile.exists() && checksumFile.canRead()) ) {\n      log(\"MISSING \" +CHECKSUM_TYPE+ \" checksum file for: \" + jarFile.getPath(), Project.MSG_ERR);\n      this.failures = true;\n      return false;\n    } else {\n      final String expectedChecksum = readChecksumFile(checksumFile);\n      try {\n        final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n        byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n        try {\n          FileInputStream fis = new FileInputStream(jarFile);\n          try {\n            DigestInputStream dis = new DigestInputStream(fis, md);\n            try {\n              while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                // NOOP\n              }\n            } finally {\n              dis.close();\n            }\n          } finally {\n            fis.close();\n          }\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO error computing checksum of file: \" + jarFile, ioe);\n        }\n        final byte[] checksumBytes = md.digest();\n        final String checksum = createChecksumString(checksumBytes);\n        if ( ! checksum.equals(expectedChecksum) ) {\n          log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \n              \" (expected: \\\"\" + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\", \n              Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        }\n\n      } catch (NoSuchAlgorithmException ae) {\n        throw new BuildException(\"Digest type \" + CHECKSUM_TYPE + \" not supported by your JVM\", ae);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getPath())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getAbsolutePath();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","sourceNew":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n\n    // validate the jar matches against our expected hash\n    final File checksumFile = new File(licenseDirectory, \n                                       jarFile.getName() + \".\" + CHECKSUM_TYPE);\n    if (! (checksumFile.exists() && checksumFile.canRead()) ) {\n      log(\"MISSING \" +CHECKSUM_TYPE+ \" checksum file for: \" + jarFile.getPath(), Project.MSG_ERR);\n      this.failures = true;\n      return false;\n    } else {\n      final String expectedChecksum = readChecksumFile(checksumFile);\n      try {\n        final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n        byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n        try {\n          FileInputStream fis = new FileInputStream(jarFile);\n          try {\n            DigestInputStream dis = new DigestInputStream(fis, md);\n            try {\n              while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                // NOOP\n              }\n            } finally {\n              dis.close();\n            }\n          } finally {\n            fis.close();\n          }\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO error computing checksum of file: \" + jarFile, ioe);\n        }\n        final byte[] checksumBytes = md.digest();\n        final String checksum = createChecksumString(checksumBytes);\n        if ( ! checksum.equals(expectedChecksum) ) {\n          log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \n              \" (expected: \\\"\" + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\", \n              Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        }\n\n      } catch (NoSuchAlgorithmException ae) {\n        throw new BuildException(\"Digest type \" + CHECKSUM_TYPE + \" not supported by your JVM\", ae);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n\n    // validate the jar matches against our expected hash\n    final File checksumFile = new File(jarFile.getParent(), \n                                       jarFile.getName() + \".\" + CHECKSUM_TYPE);\n    if (! (checksumFile.exists() && checksumFile.canRead()) ) {\n      log(\"MISSING \" +CHECKSUM_TYPE+ \" checksum file for: \" + jarFile.getPath(), Project.MSG_ERR);\n      this.failures = true;\n      return false;\n    } else {\n      final String expectedChecksum = readChecksumFile(checksumFile);\n      try {\n        final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n        byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n        try {\n          FileInputStream fis = new FileInputStream(jarFile);\n          try {\n            DigestInputStream dis = new DigestInputStream(fis, md);\n            try {\n              while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                // NOOP\n              }\n            } finally {\n              dis.close();\n            }\n          } finally {\n            fis.close();\n          }\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO error computing checksum of file: \" + jarFile, ioe);\n        }\n        final byte[] checksumBytes = md.digest();\n        final String checksum = createChecksumString(checksumBytes);\n        if ( ! checksum.equals(expectedChecksum) ) {\n          log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \n              \" (expected: \\\"\" + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\", \n              Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        }\n\n      } catch (NoSuchAlgorithmException ae) {\n        throw new BuildException(\"Digest type \" + CHECKSUM_TYPE + \" not supported by your JVM\", ae);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getPath())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getAbsolutePath();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","sourceNew":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n\n    // validate the jar matches against our expected hash\n    final File checksumFile = new File(licenseDirectory, \n                                       jarFile.getName() + \".\" + CHECKSUM_TYPE);\n    if (! (checksumFile.exists() && checksumFile.canRead()) ) {\n      log(\"MISSING \" +CHECKSUM_TYPE+ \" checksum file for: \" + jarFile.getPath(), Project.MSG_ERR);\n      this.failures = true;\n      return false;\n    } else {\n      final String expectedChecksum = readChecksumFile(checksumFile);\n      try {\n        final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n        byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n        try {\n          FileInputStream fis = new FileInputStream(jarFile);\n          try {\n            DigestInputStream dis = new DigestInputStream(fis, md);\n            try {\n              while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                // NOOP\n              }\n            } finally {\n              dis.close();\n            }\n          } finally {\n            fis.close();\n          }\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO error computing checksum of file: \" + jarFile, ioe);\n        }\n        final byte[] checksumBytes = md.digest();\n        final String checksum = createChecksumString(checksumBytes);\n        if ( ! checksum.equals(expectedChecksum) ) {\n          log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \n              \" (expected: \\\"\" + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\", \n              Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        }\n\n      } catch (NoSuchAlgorithmException ae) {\n        throw new BuildException(\"Digest type \" + CHECKSUM_TYPE + \" not supported by your JVM\", ae);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n\n    // validate the jar matches against our expected hash\n    final File checksumFile = new File(jarFile.getParent(), \n                                       jarFile.getName() + \".\" + CHECKSUM_TYPE);\n    if (! (checksumFile.exists() && checksumFile.canRead()) ) {\n      log(\"MISSING \" +CHECKSUM_TYPE+ \" checksum file for: \" + jarFile.getPath(), Project.MSG_ERR);\n      this.failures = true;\n      return false;\n    } else {\n      final String expectedChecksum = readChecksumFile(checksumFile);\n      try {\n        final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n        byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n        try {\n          FileInputStream fis = new FileInputStream(jarFile);\n          try {\n            DigestInputStream dis = new DigestInputStream(fis, md);\n            try {\n              while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                // NOOP\n              }\n            } finally {\n              dis.close();\n            }\n          } finally {\n            fis.close();\n          }\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO error computing checksum of file: \" + jarFile, ioe);\n        }\n        final byte[] checksumBytes = md.digest();\n        final String checksum = createChecksumString(checksumBytes);\n        if ( ! checksum.equals(expectedChecksum) ) {\n          log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \n              \" (expected: \\\"\" + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\", \n              Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        }\n\n      } catch (NoSuchAlgorithmException ae) {\n        throw new BuildException(\"Digest type \" + CHECKSUM_TYPE + \" not supported by your JVM\", ae);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getPath())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getAbsolutePath();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f503a82102feb003545f46c969da131db63ff0a","date":1379201582,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","sourceNew":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n    \n    if (!skipSnapshotsChecksum || !jarFile.getName().contains(\"-SNAPSHOT\")) {\n      // validate the jar matches against our expected hash\n      final File checksumFile = new File(licenseDirectory, \n                                         jarFile.getName() + \".\" + CHECKSUM_TYPE);\n      if (! (checksumFile.exists() && checksumFile.canRead()) ) {\n        log(\"MISSING \" +CHECKSUM_TYPE+ \" checksum file for: \" + jarFile.getPath(), Project.MSG_ERR);\n        log(\"EXPECTED \" +CHECKSUM_TYPE+ \" checksum file : \" + checksumFile.getPath(), Project.MSG_ERR);\n        this.failures = true;\n        return false;\n      } else {\n        final String expectedChecksum = readChecksumFile(checksumFile);\n        try {\n          final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n          byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n          try {\n            FileInputStream fis = new FileInputStream(jarFile);\n            try {\n              DigestInputStream dis = new DigestInputStream(fis, md);\n              try {\n                while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                  // NOOP\n                }\n              } finally {\n                dis.close();\n              }\n            } finally {\n              fis.close();\n            }\n          } catch (IOException ioe) {\n            throw new BuildException(\"IO error computing checksum of file: \" + jarFile, ioe);\n          }\n          final byte[] checksumBytes = md.digest();\n          final String checksum = createChecksumString(checksumBytes);\n          if ( ! checksum.equals(expectedChecksum) ) {\n            log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \n                \" (expected: \\\"\" + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\", \n                Project.MSG_ERR);\n            this.failures = true;\n            return false;\n          }\n  \n        } catch (NoSuchAlgorithmException ae) {\n          throw new BuildException(\"Digest type \" + CHECKSUM_TYPE + \" not supported by your JVM\", ae);\n        }\n      }\n    } else if (skipSnapshotsChecksum) {\n      log(\"Skipping jar because it is a SNAPSHOT : \" + jarFile.getAbsolutePath(), Project.MSG_INFO);\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n\n    // validate the jar matches against our expected hash\n    final File checksumFile = new File(licenseDirectory, \n                                       jarFile.getName() + \".\" + CHECKSUM_TYPE);\n    if (! (checksumFile.exists() && checksumFile.canRead()) ) {\n      log(\"MISSING \" +CHECKSUM_TYPE+ \" checksum file for: \" + jarFile.getPath(), Project.MSG_ERR);\n      this.failures = true;\n      return false;\n    } else {\n      final String expectedChecksum = readChecksumFile(checksumFile);\n      try {\n        final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n        byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n        try {\n          FileInputStream fis = new FileInputStream(jarFile);\n          try {\n            DigestInputStream dis = new DigestInputStream(fis, md);\n            try {\n              while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                // NOOP\n              }\n            } finally {\n              dis.close();\n            }\n          } finally {\n            fis.close();\n          }\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO error computing checksum of file: \" + jarFile, ioe);\n        }\n        final byte[] checksumBytes = md.digest();\n        final String checksum = createChecksumString(checksumBytes);\n        if ( ! checksum.equals(expectedChecksum) ) {\n          log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \n              \" (expected: \\\"\" + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\", \n              Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        }\n\n      } catch (NoSuchAlgorithmException ae) {\n        throw new BuildException(\"Digest type \" + CHECKSUM_TYPE + \" not supported by your JVM\", ae);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3a107512eb86932c2d2d250017aff89f7a876de","date":1379216763,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","sourceNew":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n    \n    if (!skipSnapshotsChecksum || !jarFile.getName().contains(\"-SNAPSHOT\")) {\n      // validate the jar matches against our expected hash\n      final File checksumFile = new File(licenseDirectory, \n                                         jarFile.getName() + \".\" + CHECKSUM_TYPE);\n      if (! (checksumFile.exists() && checksumFile.canRead()) ) {\n        log(\"MISSING \" +CHECKSUM_TYPE+ \" checksum file for: \" + jarFile.getPath(), Project.MSG_ERR);\n        log(\"EXPECTED \" +CHECKSUM_TYPE+ \" checksum file : \" + checksumFile.getPath(), Project.MSG_ERR);\n        this.failures = true;\n        return false;\n      } else {\n        final String expectedChecksum = readChecksumFile(checksumFile);\n        try {\n          final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n          byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n          try {\n            FileInputStream fis = new FileInputStream(jarFile);\n            try {\n              DigestInputStream dis = new DigestInputStream(fis, md);\n              try {\n                while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                  // NOOP\n                }\n              } finally {\n                dis.close();\n              }\n            } finally {\n              fis.close();\n            }\n          } catch (IOException ioe) {\n            throw new BuildException(\"IO error computing checksum of file: \" + jarFile, ioe);\n          }\n          final byte[] checksumBytes = md.digest();\n          final String checksum = createChecksumString(checksumBytes);\n          if ( ! checksum.equals(expectedChecksum) ) {\n            log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \n                \" (expected: \\\"\" + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\", \n                Project.MSG_ERR);\n            this.failures = true;\n            return false;\n          }\n  \n        } catch (NoSuchAlgorithmException ae) {\n          throw new BuildException(\"Digest type \" + CHECKSUM_TYPE + \" not supported by your JVM\", ae);\n        }\n      }\n    } else if (skipSnapshotsChecksum) {\n      log(\"Skipping jar because it is a SNAPSHOT : \" + jarFile.getAbsolutePath(), Project.MSG_INFO);\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n\n    // validate the jar matches against our expected hash\n    final File checksumFile = new File(licenseDirectory, \n                                       jarFile.getName() + \".\" + CHECKSUM_TYPE);\n    if (! (checksumFile.exists() && checksumFile.canRead()) ) {\n      log(\"MISSING \" +CHECKSUM_TYPE+ \" checksum file for: \" + jarFile.getPath(), Project.MSG_ERR);\n      this.failures = true;\n      return false;\n    } else {\n      final String expectedChecksum = readChecksumFile(checksumFile);\n      try {\n        final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n        byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n        try {\n          FileInputStream fis = new FileInputStream(jarFile);\n          try {\n            DigestInputStream dis = new DigestInputStream(fis, md);\n            try {\n              while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                // NOOP\n              }\n            } finally {\n              dis.close();\n            }\n          } finally {\n            fis.close();\n          }\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO error computing checksum of file: \" + jarFile, ioe);\n        }\n        final byte[] checksumBytes = md.digest();\n        final String checksum = createChecksumString(checksumBytes);\n        if ( ! checksum.equals(expectedChecksum) ) {\n          log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \n              \" (expected: \\\"\" + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\", \n              Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        }\n\n      } catch (NoSuchAlgorithmException ae) {\n        throw new BuildException(\"Digest type \" + CHECKSUM_TYPE + \" not supported by your JVM\", ae);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9d6165e8b8a6195f41e7363a6f11e98045dd58b","date":1382203220,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","sourceNew":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n    \n    if (!skipChecksum) {\n      if (!skipSnapshotsChecksum || !jarFile.getName().contains(\"-SNAPSHOT\")) {\n        // validate the jar matches against our expected hash\n        final File checksumFile = new File(licenseDirectory, jarFile.getName()\n            + \".\" + CHECKSUM_TYPE);\n        if (!(checksumFile.exists() && checksumFile.canRead())) {\n          log(\"MISSING \" + CHECKSUM_TYPE + \" checksum file for: \"\n              + jarFile.getPath(), Project.MSG_ERR);\n          log(\"EXPECTED \" + CHECKSUM_TYPE + \" checksum file : \"\n              + checksumFile.getPath(), Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        } else {\n          final String expectedChecksum = readChecksumFile(checksumFile);\n          try {\n            final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n            byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n            try {\n              FileInputStream fis = new FileInputStream(jarFile);\n              try {\n                DigestInputStream dis = new DigestInputStream(fis, md);\n                try {\n                  while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                    // NOOP\n                  }\n                } finally {\n                  dis.close();\n                }\n              } finally {\n                fis.close();\n              }\n            } catch (IOException ioe) {\n              throw new BuildException(\"IO error computing checksum of file: \"\n                  + jarFile, ioe);\n            }\n            final byte[] checksumBytes = md.digest();\n            final String checksum = createChecksumString(checksumBytes);\n            if (!checksum.equals(expectedChecksum)) {\n              log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \" (expected: \\\"\"\n                  + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\",\n                  Project.MSG_ERR);\n              this.failures = true;\n              return false;\n            }\n            \n          } catch (NoSuchAlgorithmException ae) {\n            throw new BuildException(\"Digest type \" + CHECKSUM_TYPE\n                + \" not supported by your JVM\", ae);\n          }\n        }\n      } else if (skipSnapshotsChecksum) {\n        log(\"Skipping jar because it is a SNAPSHOT : \"\n            + jarFile.getAbsolutePath(), Project.MSG_INFO);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n    \n    if (!skipSnapshotsChecksum || !jarFile.getName().contains(\"-SNAPSHOT\")) {\n      // validate the jar matches against our expected hash\n      final File checksumFile = new File(licenseDirectory, \n                                         jarFile.getName() + \".\" + CHECKSUM_TYPE);\n      if (! (checksumFile.exists() && checksumFile.canRead()) ) {\n        log(\"MISSING \" +CHECKSUM_TYPE+ \" checksum file for: \" + jarFile.getPath(), Project.MSG_ERR);\n        log(\"EXPECTED \" +CHECKSUM_TYPE+ \" checksum file : \" + checksumFile.getPath(), Project.MSG_ERR);\n        this.failures = true;\n        return false;\n      } else {\n        final String expectedChecksum = readChecksumFile(checksumFile);\n        try {\n          final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n          byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n          try {\n            FileInputStream fis = new FileInputStream(jarFile);\n            try {\n              DigestInputStream dis = new DigestInputStream(fis, md);\n              try {\n                while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                  // NOOP\n                }\n              } finally {\n                dis.close();\n              }\n            } finally {\n              fis.close();\n            }\n          } catch (IOException ioe) {\n            throw new BuildException(\"IO error computing checksum of file: \" + jarFile, ioe);\n          }\n          final byte[] checksumBytes = md.digest();\n          final String checksum = createChecksumString(checksumBytes);\n          if ( ! checksum.equals(expectedChecksum) ) {\n            log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \n                \" (expected: \\\"\" + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\", \n                Project.MSG_ERR);\n            this.failures = true;\n            return false;\n          }\n  \n        } catch (NoSuchAlgorithmException ae) {\n          throw new BuildException(\"Digest type \" + CHECKSUM_TYPE + \" not supported by your JVM\", ae);\n        }\n      }\n    } else if (skipSnapshotsChecksum) {\n      log(\"Skipping jar because it is a SNAPSHOT : \" + jarFile.getAbsolutePath(), Project.MSG_INFO);\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","sourceNew":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n    \n    if (!skipChecksum) {\n      if (!skipSnapshotsChecksum || !jarFile.getName().contains(\"-SNAPSHOT\")) {\n        // validate the jar matches against our expected hash\n        final File checksumFile = new File(licenseDirectory, jarFile.getName()\n            + \".\" + CHECKSUM_TYPE);\n        if (!(checksumFile.exists() && checksumFile.canRead())) {\n          log(\"MISSING \" + CHECKSUM_TYPE + \" checksum file for: \"\n              + jarFile.getPath(), Project.MSG_ERR);\n          log(\"EXPECTED \" + CHECKSUM_TYPE + \" checksum file : \"\n              + checksumFile.getPath(), Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        } else {\n          final String expectedChecksum = readChecksumFile(checksumFile);\n          try {\n            final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n            byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n            try {\n              FileInputStream fis = new FileInputStream(jarFile);\n              try {\n                DigestInputStream dis = new DigestInputStream(fis, md);\n                try {\n                  while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                    // NOOP\n                  }\n                } finally {\n                  dis.close();\n                }\n              } finally {\n                fis.close();\n              }\n            } catch (IOException ioe) {\n              throw new BuildException(\"IO error computing checksum of file: \"\n                  + jarFile, ioe);\n            }\n            final byte[] checksumBytes = md.digest();\n            final String checksum = createChecksumString(checksumBytes);\n            if (!checksum.equals(expectedChecksum)) {\n              log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \" (expected: \\\"\"\n                  + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\",\n                  Project.MSG_ERR);\n              this.failures = true;\n              return false;\n            }\n            \n          } catch (NoSuchAlgorithmException ae) {\n            throw new BuildException(\"Digest type \" + CHECKSUM_TYPE\n                + \" not supported by your JVM\", ae);\n          }\n        }\n      } else if (skipSnapshotsChecksum) {\n        log(\"Skipping jar because it is a SNAPSHOT : \"\n            + jarFile.getAbsolutePath(), Project.MSG_INFO);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<>();\n    List<File> expectedLocations = new ArrayList<>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n    \n    if (!skipChecksum) {\n      if (!skipSnapshotsChecksum || !jarFile.getName().contains(\"-SNAPSHOT\")) {\n        // validate the jar matches against our expected hash\n        final File checksumFile = new File(licenseDirectory, jarFile.getName()\n            + \".\" + CHECKSUM_TYPE);\n        if (!(checksumFile.exists() && checksumFile.canRead())) {\n          log(\"MISSING \" + CHECKSUM_TYPE + \" checksum file for: \"\n              + jarFile.getPath(), Project.MSG_ERR);\n          log(\"EXPECTED \" + CHECKSUM_TYPE + \" checksum file : \"\n              + checksumFile.getPath(), Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        } else {\n          final String expectedChecksum = readChecksumFile(checksumFile);\n          try {\n            final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n            byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n            try {\n              FileInputStream fis = new FileInputStream(jarFile);\n              try {\n                DigestInputStream dis = new DigestInputStream(fis, md);\n                try {\n                  while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                    // NOOP\n                  }\n                } finally {\n                  dis.close();\n                }\n              } finally {\n                fis.close();\n              }\n            } catch (IOException ioe) {\n              throw new BuildException(\"IO error computing checksum of file: \"\n                  + jarFile, ioe);\n            }\n            final byte[] checksumBytes = md.digest();\n            final String checksum = createChecksumString(checksumBytes);\n            if (!checksum.equals(expectedChecksum)) {\n              log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \" (expected: \\\"\"\n                  + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\",\n                  Project.MSG_ERR);\n              this.failures = true;\n              return false;\n            }\n            \n          } catch (NoSuchAlgorithmException ae) {\n            throw new BuildException(\"Digest type \" + CHECKSUM_TYPE\n                + \" not supported by your JVM\", ae);\n          }\n        }\n      } else if (skipSnapshotsChecksum) {\n        log(\"Skipping jar because it is a SNAPSHOT : \"\n            + jarFile.getAbsolutePath(), Project.MSG_INFO);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<File, LicenseType>();\n    List<File> expectedLocations = new ArrayList<File>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e833dc7058b15055673a0a806f483ea82de37dd","date":1449183825,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","sourceNew":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n    \n    if (!skipChecksum) {\n      boolean skipDueToSnapshot = skipSnapshotsChecksum && jarFile.getName().contains(\"-SNAPSHOT\");\n      if (!skipDueToSnapshot && !matchesRegexChecksum(jarFile, skipRegexChecksum)) {\n        // validate the jar matches against our expected hash\n        final File checksumFile = new File(licenseDirectory, jarFile.getName()\n            + \".\" + CHECKSUM_TYPE);\n        if (!(checksumFile.exists() && checksumFile.canRead())) {\n          log(\"MISSING \" + CHECKSUM_TYPE + \" checksum file for: \"\n              + jarFile.getPath(), Project.MSG_ERR);\n          log(\"EXPECTED \" + CHECKSUM_TYPE + \" checksum file : \"\n              + checksumFile.getPath(), Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        } else {\n          final String expectedChecksum = readChecksumFile(checksumFile);\n          try {\n            final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n            byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n            try {\n              FileInputStream fis = new FileInputStream(jarFile);\n              try {\n                DigestInputStream dis = new DigestInputStream(fis, md);\n                try {\n                  while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                    // NOOP\n                  }\n                } finally {\n                  dis.close();\n                }\n              } finally {\n                fis.close();\n              }\n            } catch (IOException ioe) {\n              throw new BuildException(\"IO error computing checksum of file: \"\n                  + jarFile, ioe);\n            }\n            final byte[] checksumBytes = md.digest();\n            final String checksum = createChecksumString(checksumBytes);\n            if (!checksum.equals(expectedChecksum)) {\n              log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \" (expected: \\\"\"\n                  + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\",\n                  Project.MSG_ERR);\n              this.failures = true;\n              return false;\n            }\n            \n          } catch (NoSuchAlgorithmException ae) {\n            throw new BuildException(\"Digest type \" + CHECKSUM_TYPE\n                + \" not supported by your JVM\", ae);\n          }\n        }\n      } else if (skipDueToSnapshot) {\n        log(\"Skipping jar because it is a SNAPSHOT : \"\n            + jarFile.getAbsolutePath(), Project.MSG_INFO);\n      } else {\n        log(\"Skipping jar because it matches regex pattern: \"\n            + jarFile.getAbsolutePath() + \" pattern: \" + skipRegexChecksum.pattern(), Project.MSG_INFO);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<>();\n    List<File> expectedLocations = new ArrayList<>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n    \n    if (!skipChecksum) {\n      if (!skipSnapshotsChecksum || !jarFile.getName().contains(\"-SNAPSHOT\")) {\n        // validate the jar matches against our expected hash\n        final File checksumFile = new File(licenseDirectory, jarFile.getName()\n            + \".\" + CHECKSUM_TYPE);\n        if (!(checksumFile.exists() && checksumFile.canRead())) {\n          log(\"MISSING \" + CHECKSUM_TYPE + \" checksum file for: \"\n              + jarFile.getPath(), Project.MSG_ERR);\n          log(\"EXPECTED \" + CHECKSUM_TYPE + \" checksum file : \"\n              + checksumFile.getPath(), Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        } else {\n          final String expectedChecksum = readChecksumFile(checksumFile);\n          try {\n            final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n            byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n            try {\n              FileInputStream fis = new FileInputStream(jarFile);\n              try {\n                DigestInputStream dis = new DigestInputStream(fis, md);\n                try {\n                  while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                    // NOOP\n                  }\n                } finally {\n                  dis.close();\n                }\n              } finally {\n                fis.close();\n              }\n            } catch (IOException ioe) {\n              throw new BuildException(\"IO error computing checksum of file: \"\n                  + jarFile, ioe);\n            }\n            final byte[] checksumBytes = md.digest();\n            final String checksum = createChecksumString(checksumBytes);\n            if (!checksum.equals(expectedChecksum)) {\n              log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \" (expected: \\\"\"\n                  + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\",\n                  Project.MSG_ERR);\n              this.failures = true;\n              return false;\n            }\n            \n          } catch (NoSuchAlgorithmException ae) {\n            throw new BuildException(\"Digest type \" + CHECKSUM_TYPE\n                + \" not supported by your JVM\", ae);\n          }\n        }\n      } else if (skipSnapshotsChecksum) {\n        log(\"Skipping jar because it is a SNAPSHOT : \"\n            + jarFile.getAbsolutePath(), Project.MSG_INFO);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<>();\n    List<File> expectedLocations = new ArrayList<>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ffe681f212e5073c69955b4ad22946794c84940","date":1560182863,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","sourceNew":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n    \n    if (!skipChecksum) {\n      boolean skipDueToSnapshot = skipSnapshotsChecksum && jarFile.getName().contains(\"-SNAPSHOT\");\n      if (!skipDueToSnapshot && !matchesRegexChecksum(jarFile, skipRegexChecksum)) {\n        // validate the jar matches against our expected hash\n        final File checksumFile = new File(licenseDirectory, jarFile.getName()\n            + \".\" + CHECKSUM_TYPE);\n        if (!(checksumFile.exists() && checksumFile.canRead())) {\n          log(\"MISSING \" + CHECKSUM_TYPE + \" checksum file for: \"\n              + jarFile.getPath(), Project.MSG_ERR);\n          log(\"EXPECTED \" + CHECKSUM_TYPE + \" checksum file : \"\n              + checksumFile.getPath(), Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        } else {\n          final String expectedChecksum = readChecksumFile(checksumFile);\n          try {\n            final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n            byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n            try {\n              FileInputStream fis = new FileInputStream(jarFile);\n              try {\n                DigestInputStream dis = new DigestInputStream(fis, md);\n                try {\n                  while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                    // NOOP\n                  }\n                } finally {\n                  dis.close();\n                }\n              } finally {\n                fis.close();\n              }\n            } catch (IOException ioe) {\n              throw new BuildException(\"IO error computing checksum of file: \"\n                  + jarFile, ioe);\n            }\n            final byte[] checksumBytes = md.digest();\n            final String checksum = createChecksumString(checksumBytes);\n            if (!checksum.equals(expectedChecksum)) {\n              log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \" (expected: \\\"\"\n                  + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\",\n                  Project.MSG_ERR);\n              this.failures = true;\n              return false;\n            }\n            \n          } catch (NoSuchAlgorithmException ae) {\n            throw new BuildException(\"Digest type \" + CHECKSUM_TYPE\n                + \" not supported by your JVM\", ae);\n          }\n        }\n      } else if (skipDueToSnapshot) {\n        log(\"Skipping jar because it is a SNAPSHOT : \"\n            + jarFile.getAbsolutePath(), Project.MSG_INFO);\n      } else {\n        log(\"Skipping jar because it matches regex pattern: \"\n            + jarFile.getAbsolutePath() + \" pattern: \" + skipRegexChecksum.pattern(), Project.MSG_INFO);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<>();\n    List<File> expectedLocations = new ArrayList<>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\"MISSING LICENSE for the following file:\\n  \").append(jarFile.getAbsolutePath()).append(\"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n    \n    if (!skipChecksum) {\n      boolean skipDueToSnapshot = skipSnapshotsChecksum && jarFile.getName().contains(\"-SNAPSHOT\");\n      if (!skipDueToSnapshot && !matchesRegexChecksum(jarFile, skipRegexChecksum)) {\n        // validate the jar matches against our expected hash\n        final File checksumFile = new File(licenseDirectory, jarFile.getName()\n            + \".\" + CHECKSUM_TYPE);\n        if (!(checksumFile.exists() && checksumFile.canRead())) {\n          log(\"MISSING \" + CHECKSUM_TYPE + \" checksum file for: \"\n              + jarFile.getPath(), Project.MSG_ERR);\n          log(\"EXPECTED \" + CHECKSUM_TYPE + \" checksum file : \"\n              + checksumFile.getPath(), Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        } else {\n          final String expectedChecksum = readChecksumFile(checksumFile);\n          try {\n            final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n            byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n            try {\n              FileInputStream fis = new FileInputStream(jarFile);\n              try {\n                DigestInputStream dis = new DigestInputStream(fis, md);\n                try {\n                  while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                    // NOOP\n                  }\n                } finally {\n                  dis.close();\n                }\n              } finally {\n                fis.close();\n              }\n            } catch (IOException ioe) {\n              throw new BuildException(\"IO error computing checksum of file: \"\n                  + jarFile, ioe);\n            }\n            final byte[] checksumBytes = md.digest();\n            final String checksum = createChecksumString(checksumBytes);\n            if (!checksum.equals(expectedChecksum)) {\n              log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \" (expected: \\\"\"\n                  + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\",\n                  Project.MSG_ERR);\n              this.failures = true;\n              return false;\n            }\n            \n          } catch (NoSuchAlgorithmException ae) {\n            throw new BuildException(\"Digest type \" + CHECKSUM_TYPE\n                + \" not supported by your JVM\", ae);\n          }\n        }\n      } else if (skipDueToSnapshot) {\n        log(\"Skipping jar because it is a SNAPSHOT : \"\n            + jarFile.getAbsolutePath(), Project.MSG_INFO);\n      } else {\n        log(\"Skipping jar because it matches regex pattern: \"\n            + jarFile.getAbsolutePath() + \" pattern: \" + skipRegexChecksum.pattern(), Project.MSG_INFO);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<>();\n    List<File> expectedLocations = new ArrayList<>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\n          \"MISSING LICENSE for the following file:\\n  \" + jarFile.getAbsolutePath()\n          + \"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e025cf1c07150c8db28879d785db17eb3a66ca9f","date":1598788864,"type":4,"author":"Dawid Weiss","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/LicenseCheckTask#checkJarFile(File).mjava","sourceNew":null,"sourceOld":"  /**\n   * Check a single JAR file.\n   */\n  private boolean checkJarFile(File jarFile) {\n    log(\"Scanning: \" + jarFile.getPath(), verboseLevel);\n    \n    if (!skipChecksum) {\n      boolean skipDueToSnapshot = skipSnapshotsChecksum && jarFile.getName().contains(\"-SNAPSHOT\");\n      if (!skipDueToSnapshot && !matchesRegexChecksum(jarFile, skipRegexChecksum)) {\n        // validate the jar matches against our expected hash\n        final File checksumFile = new File(licenseDirectory, jarFile.getName()\n            + \".\" + CHECKSUM_TYPE);\n        if (!(checksumFile.exists() && checksumFile.canRead())) {\n          log(\"MISSING \" + CHECKSUM_TYPE + \" checksum file for: \"\n              + jarFile.getPath(), Project.MSG_ERR);\n          log(\"EXPECTED \" + CHECKSUM_TYPE + \" checksum file : \"\n              + checksumFile.getPath(), Project.MSG_ERR);\n          this.failures = true;\n          return false;\n        } else {\n          final String expectedChecksum = readChecksumFile(checksumFile);\n          try {\n            final MessageDigest md = MessageDigest.getInstance(CHECKSUM_TYPE);\n            byte[] buf = new byte[CHECKSUM_BUFFER_SIZE];\n            try {\n              FileInputStream fis = new FileInputStream(jarFile);\n              try {\n                DigestInputStream dis = new DigestInputStream(fis, md);\n                try {\n                  while (dis.read(buf, 0, CHECKSUM_BUFFER_SIZE) != -1) {\n                    // NOOP\n                  }\n                } finally {\n                  dis.close();\n                }\n              } finally {\n                fis.close();\n              }\n            } catch (IOException ioe) {\n              throw new BuildException(\"IO error computing checksum of file: \"\n                  + jarFile, ioe);\n            }\n            final byte[] checksumBytes = md.digest();\n            final String checksum = createChecksumString(checksumBytes);\n            if (!checksum.equals(expectedChecksum)) {\n              log(\"CHECKSUM FAILED for \" + jarFile.getPath() + \" (expected: \\\"\"\n                  + expectedChecksum + \"\\\" was: \\\"\" + checksum + \"\\\")\",\n                  Project.MSG_ERR);\n              this.failures = true;\n              return false;\n            }\n            \n          } catch (NoSuchAlgorithmException ae) {\n            throw new BuildException(\"Digest type \" + CHECKSUM_TYPE\n                + \" not supported by your JVM\", ae);\n          }\n        }\n      } else if (skipDueToSnapshot) {\n        log(\"Skipping jar because it is a SNAPSHOT : \"\n            + jarFile.getAbsolutePath(), Project.MSG_INFO);\n      } else {\n        log(\"Skipping jar because it matches regex pattern: \"\n            + jarFile.getAbsolutePath() + \" pattern: \" + skipRegexChecksum.pattern(), Project.MSG_INFO);\n      }\n    }\n    \n    // Get the expected license path base from the mapper and search for license files.\n    Map<File, LicenseType> foundLicenses = new LinkedHashMap<>();\n    List<File> expectedLocations = new ArrayList<>();\nouter:\n    for (String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {\n      for (LicenseType licenseType : LicenseType.values()) {\n        File licensePath = new File(licenseDirectory, mappedPath + licenseType.licenseFileSuffix());\n        if (licensePath.exists()) {\n          foundLicenses.put(licensePath, licenseType);\n          log(\" FOUND \" + licenseType.name() + \" license at \" + licensePath.getPath(), \n              verboseLevel);\n          // We could continue scanning here to detect duplicate associations?\n          break outer;\n        } else {\n          expectedLocations.add(licensePath);\n        }\n      }\n    }\n\n    // Check for NOTICE files.\n    for (Map.Entry<File, LicenseType> e : foundLicenses.entrySet()) {\n      LicenseType license = e.getValue();\n      String licensePath = e.getKey().getName();\n      String baseName = licensePath.substring(\n          0, licensePath.length() - license.licenseFileSuffix().length());\n      File noticeFile = new File(licenseDirectory, baseName + license.noticeFileSuffix());\n\n      if (noticeFile.exists()) {\n        log(\" FOUND NOTICE file at \" + noticeFile.getAbsolutePath(), verboseLevel);\n      } else {\n        if (license.isNoticeRequired()) {\n            this.failures = true;\n            log(\"MISSING NOTICE for the license file:\\n  \"\n                + licensePath + \"\\n  Expected location below:\\n  \"\n                + noticeFile.getAbsolutePath(), Project.MSG_ERR);\n        }\n      }\n    }\n\n    // In case there is something missing, complain.\n    if (foundLicenses.isEmpty()) {\n      this.failures = true;\n      StringBuilder message = new StringBuilder();\n      message.append(\"MISSING LICENSE for the following file:\\n  \").append(jarFile.getAbsolutePath()).append(\"\\n  Expected locations below:\\n\");\n      for (File location : expectedLocations) {\n        message.append(\"  => \").append(location.getAbsolutePath()).append(\"\\n\");\n      }\n      log(message.toString(), Project.MSG_ERR);\n      return false;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["f9d6165e8b8a6195f41e7363a6f11e98045dd58b"],"2ffe681f212e5073c69955b4ad22946794c84940":["6e833dc7058b15055673a0a806f483ea82de37dd"],"e025cf1c07150c8db28879d785db17eb3a66ca9f":["2ffe681f212e5073c69955b4ad22946794c84940"],"d3a107512eb86932c2d2d250017aff89f7a876de":["2495c89d72babf74bc9fdbb3938474704876a710","5f503a82102feb003545f46c969da131db63ff0a"],"f9d6165e8b8a6195f41e7363a6f11e98045dd58b":["5f503a82102feb003545f46c969da131db63ff0a"],"2495c89d72babf74bc9fdbb3938474704876a710":["0dc336cf0d57e7e3a9fb0de2d61bb4563940c29d"],"5f503a82102feb003545f46c969da131db63ff0a":["2495c89d72babf74bc9fdbb3938474704876a710"],"aba371508186796cc6151d8223a5b4e16d02e26e":["0dc336cf0d57e7e3a9fb0de2d61bb4563940c29d","2495c89d72babf74bc9fdbb3938474704876a710"],"0dc336cf0d57e7e3a9fb0de2d61bb4563940c29d":["be658e3695ce5dfe92a3ad3d6531cfc987ae8935"],"6e833dc7058b15055673a0a806f483ea82de37dd":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"be658e3695ce5dfe92a3ad3d6531cfc987ae8935":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["0dc336cf0d57e7e3a9fb0de2d61bb4563940c29d","2495c89d72babf74bc9fdbb3938474704876a710"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e025cf1c07150c8db28879d785db17eb3a66ca9f"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6e833dc7058b15055673a0a806f483ea82de37dd"],"2ffe681f212e5073c69955b4ad22946794c84940":["e025cf1c07150c8db28879d785db17eb3a66ca9f"],"e025cf1c07150c8db28879d785db17eb3a66ca9f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d3a107512eb86932c2d2d250017aff89f7a876de":[],"f9d6165e8b8a6195f41e7363a6f11e98045dd58b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"2495c89d72babf74bc9fdbb3938474704876a710":["d3a107512eb86932c2d2d250017aff89f7a876de","5f503a82102feb003545f46c969da131db63ff0a","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"5f503a82102feb003545f46c969da131db63ff0a":["d3a107512eb86932c2d2d250017aff89f7a876de","f9d6165e8b8a6195f41e7363a6f11e98045dd58b"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"0dc336cf0d57e7e3a9fb0de2d61bb4563940c29d":["2495c89d72babf74bc9fdbb3938474704876a710","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"6e833dc7058b15055673a0a806f483ea82de37dd":["2ffe681f212e5073c69955b4ad22946794c84940"],"be658e3695ce5dfe92a3ad3d6531cfc987ae8935":["0dc336cf0d57e7e3a9fb0de2d61bb4563940c29d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["be658e3695ce5dfe92a3ad3d6531cfc987ae8935"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3a107512eb86932c2d2d250017aff89f7a876de","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}