{"path":"modules/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","commits":[{"id":"89f15687f60bd49cd3d9de427e85c17fd9397d61","date":1309381327,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults)\n  throws ClassCastException, IllegalArgumentException {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.getNumResults(); // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children (and the residue over \n      // non included chilren)\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          double resResidue = tmpToReturnAACO.residue + tfrAACO.residue;\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          while (indexIntoTmpToReturn < tmpToReturnAACO.ordinals.length) {\n            resResidue += tmpToReturnAACO.values[indexIntoTmpToReturn++];\n          }\n          while (indexIntoTFR < tfrAACO.ordinals.length) {\n            resResidue += tfrAACO.values[indexIntoTFR++];\n          }\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals, resResidue));\n        } // endof need to merge both AACO -- children and residue for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults)\n  throws ClassCastException, IllegalArgumentException {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.getNumResults(); // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children (and the residue over \n      // non included chilren)\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          double resResidue = tmpToReturnAACO.residue + tfrAACO.residue;\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          while (indexIntoTmpToReturn < tmpToReturnAACO.ordinals.length) {\n            resResidue += tmpToReturnAACO.values[indexIntoTmpToReturn++];\n          }\n          while (indexIntoTFR < tfrAACO.ordinals.length) {\n            resResidue += tfrAACO.values[indexIntoTFR++];\n          }\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals, resResidue));\n        } // endof need to merge both AACO -- children and residue for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults)\n  throws ClassCastException, IllegalArgumentException {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.getNumResults(); // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children (and the residue over \n      // non included chilren)\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          double resResidue = tmpToReturnAACO.residue + tfrAACO.residue;\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          while (indexIntoTmpToReturn < tmpToReturnAACO.ordinals.length) {\n            resResidue += tmpToReturnAACO.values[indexIntoTmpToReturn++];\n          }\n          while (indexIntoTFR < tfrAACO.ordinals.length) {\n            resResidue += tfrAACO.values[indexIntoTFR++];\n          }\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals, resResidue));\n        } // endof need to merge both AACO -- children and residue for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","sourceNew":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults)\n  throws ClassCastException, IllegalArgumentException {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.getNumResults(); // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children (and the residue over \n      // non included chilren)\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          double resResidue = tmpToReturnAACO.residue + tfrAACO.residue;\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          while (indexIntoTmpToReturn < tmpToReturnAACO.ordinals.length) {\n            resResidue += tmpToReturnAACO.values[indexIntoTmpToReturn++];\n          }\n          while (indexIntoTFR < tfrAACO.ordinals.length) {\n            resResidue += tfrAACO.values[indexIntoTFR++];\n          }\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals, resResidue));\n        } // endof need to merge both AACO -- children and residue for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","sourceOld":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults)\n  throws ClassCastException, IllegalArgumentException {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.getNumResults(); // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children (and the residue over \n      // non included chilren)\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          double resResidue = tmpToReturnAACO.residue + tfrAACO.residue;\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          while (indexIntoTmpToReturn < tmpToReturnAACO.ordinals.length) {\n            resResidue += tmpToReturnAACO.values[indexIntoTmpToReturn++];\n          }\n          while (indexIntoTFR < tfrAACO.ordinals.length) {\n            resResidue += tfrAACO.values[indexIntoTFR++];\n          }\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals, resResidue));\n        } // endof need to merge both AACO -- children and residue for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["89f15687f60bd49cd3d9de427e85c17fd9397d61"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","89f15687f60bd49cd3d9de427e85c17fd9397d61"],"89f15687f60bd49cd3d9de427e85c17fd9397d61":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","89f15687f60bd49cd3d9de427e85c17fd9397d61"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d083e83f225b11e5fdd900e83d26ddb385b6955c","89f15687f60bd49cd3d9de427e85c17fd9397d61","817d8435e9135b756f08ce6710ab0baac51bdf88"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"89f15687f60bd49cd3d9de427e85c17fd9397d61":["b89678825b68eccaf09e6ab71675fc0b0af1e099","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}