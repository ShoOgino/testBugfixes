{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetFieldValueCollection#getNextLevelValuesToRefine().mjava","commits":[{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetFieldValueCollection#getNextLevelValuesToRefine().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns the appropriate sub-list of the explicit values that need to be refined, \n   * based on the {@link FacetParams#FACET_OFFSET} &amp; {@link FacetParams#FACET_LIMIT} \n   * for this field.\n   *\n   * @see #getExplicitValuesList\n   * @see List#subList\n   */\n  public List<PivotFacetValue> getNextLevelValuesToRefine() {\n    final int numRefinableValues = getExplicitValuesListSize();\n    if (facetFieldOffset < numRefinableValues) {\n      final int offsetPlusCount = (facetFieldLimit >= 0) \n        ? Math.min(facetFieldLimit + facetFieldOffset, numRefinableValues) \n        : numRefinableValues;\n      return getExplicitValuesList().subList(facetFieldOffset,  offsetPlusCount);\n    } else {\n      return Collections.<PivotFacetValue>emptyList();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8db8ed65f6d4c4092be7fe23d820b481b8dec407"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8db8ed65f6d4c4092be7fe23d820b481b8dec407","date":1541215952,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetFieldValueCollection#getNextLevelValuesToRefine().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetFieldValueCollection#getNextLevelValuesToRefine().mjava","sourceNew":"  /**\n   * Returns the appropriate sub-list of the explicit values that need to be refined, \n   * based on the {@link FacetParams#FACET_OFFSET} &amp; {@link FacetParams#FACET_LIMIT} \n   * for this field.\n   *\n   * @see #getExplicitValuesList\n   * @see List#subList\n   */\n  public List<PivotFacetValue> getNextLevelValuesToRefine() {\n    final int numRefinableValues = getExplicitValuesListSize();\n    if (numRefinableValues < facetFieldOffset) {\n      return Collections.<PivotFacetValue>emptyList();\n    }\n    \n    final int offsetPlusCount = (facetFieldLimit >= 0) \n      ? Math.min(facetFieldLimit + facetFieldOffset, numRefinableValues) \n      : numRefinableValues;\n    \n    if (1 < facetFieldMinimumCount && facetFieldSort.equals(FacetParams.FACET_SORT_INDEX)) {\n      // we have to skip any values that (still) don't meet the mincount\n      //\n      // TODO: in theory we could avoid this extra check by trimming sooner (SOLR-6331)\n      // but since that's a destructive op that blows away the `valuesMap` which we (might?) still need\n      // (and pre-emptively skips the offsets) we're avoiding re-working that optimization\n      // for now until/unless someone gives it more careful thought...\n      final List<PivotFacetValue> results = new ArrayList<>(numRefinableValues);\n      for (PivotFacetValue pivotValue : explicitValues) {\n        if (pivotValue.getCount() >= facetFieldMinimumCount) {\n          results.add(pivotValue);\n          if (numRefinableValues <= results.size()) {\n            break;\n          }\n        }\n      }\n      return results;\n    }\n    \n    // in the non \"sort==count OR mincount==1\" situation, we can just return the first N values\n    // because any viable candidate is already in the top N\n    return getExplicitValuesList().subList(facetFieldOffset,  offsetPlusCount);\n  }\n\n","sourceOld":"  /**\n   * Returns the appropriate sub-list of the explicit values that need to be refined, \n   * based on the {@link FacetParams#FACET_OFFSET} &amp; {@link FacetParams#FACET_LIMIT} \n   * for this field.\n   *\n   * @see #getExplicitValuesList\n   * @see List#subList\n   */\n  public List<PivotFacetValue> getNextLevelValuesToRefine() {\n    final int numRefinableValues = getExplicitValuesListSize();\n    if (facetFieldOffset < numRefinableValues) {\n      final int offsetPlusCount = (facetFieldLimit >= 0) \n        ? Math.min(facetFieldLimit + facetFieldOffset, numRefinableValues) \n        : numRefinableValues;\n      return getExplicitValuesList().subList(facetFieldOffset,  offsetPlusCount);\n    } else {\n      return Collections.<PivotFacetValue>emptyList();\n    }\n  }\n\n","bugFix":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8db8ed65f6d4c4092be7fe23d820b481b8dec407":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8db8ed65f6d4c4092be7fe23d820b481b8dec407"]},"commit2Childs":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["8db8ed65f6d4c4092be7fe23d820b481b8dec407"],"8db8ed65f6d4c4092be7fe23d820b481b8dec407":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}