{"path":"solr/test-framework/src/java/org/apache/solr/cloud/SocketProxy.Bridge.Pump#run().mjava","commits":[{"id":"6e36353d7461af8d2329a78a71457cf8e3c1e88f","date":1411572107,"type":1,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/SocketProxy.Bridge.Pump#run().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SocketProxy.Bridge.Pump#run().mjava","sourceNew":"      public void run() {\n        byte[] buf = new byte[1024];\n        try {\n          InputStream in = src.getInputStream();\n          OutputStream out = destination.getOutputStream();\n          while (true) {\n            int len = in.read(buf);\n            if (len == -1) {\n              log.debug(\"read eof from:\" + src);\n              break;\n            }\n            pause.get().await();\n            out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          log.debug(\"read/write failed, reason: \" + e.getLocalizedMessage());\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        }\n      }\n\n","sourceOld":"      public void run() {\n        byte[] buf = new byte[1024];\n        try {\n          InputStream in = src.getInputStream();\n          OutputStream out = destination.getOutputStream();\n          while (true) {\n            int len = in.read(buf);\n            if (len == -1) {\n              log.debug(\"read eof from:\" + src);\n              break;\n            }\n            pause.get().await();\n            out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          log.debug(\"read/write failed, reason: \" + e.getLocalizedMessage());\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1280741c654e60d3590156727fd5d8daa141efb7","date":1420244446,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/SocketProxy.Bridge.Pump#run().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/SocketProxy.Bridge.Pump#run().mjava","sourceNew":"      public void run() {\n        byte[] buf = new byte[1024];\n\n        try {\n          src.setSoTimeout(10 * 1000);\n        } catch (SocketException e) {\n          log.error(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n          throw new RuntimeException(e);\n        }\n\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n          in = src.getInputStream();\n          out = destination.getOutputStream();\n          while (true) {\n            int len = -1;\n            try {\n              len = in.read(buf);\n            } catch (SocketTimeoutException ste) {\n              log.warn(ste+\" when reading from \"+src);\n            }\n\n            if (len == -1) {\n              log.debug(\"read eof from:\" + src);\n              break;\n            }\n            pause.get().await();\n            if (len > 0)\n              out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          log.debug(\"read/write failed, reason: \" + e.getLocalizedMessage());\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        } finally {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing InputStream on socket: \"+src);\n            }\n          }\n          if (out != null) {\n            try {\n              out.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing OutputStream on socket: \"+destination);\n            }\n          }\n        }\n      }\n\n","sourceOld":"      public void run() {\n        byte[] buf = new byte[1024];\n        try {\n          InputStream in = src.getInputStream();\n          OutputStream out = destination.getOutputStream();\n          while (true) {\n            int len = in.read(buf);\n            if (len == -1) {\n              log.debug(\"read eof from:\" + src);\n              break;\n            }\n            pause.get().await();\n            out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          log.debug(\"read/write failed, reason: \" + e.getLocalizedMessage());\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        }\n      }\n\n","bugFix":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05d1c262da1d1f850b159395fc65d7925919dc22","date":1428418196,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/SocketProxy.Bridge.Pump#run().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/SocketProxy.Bridge.Pump#run().mjava","sourceNew":"      public void run() {\n        byte[] buf = new byte[1024];\n\n        try {\n          src.setSoTimeout(PUMP_SOCKET_TIMEOUT_MS);\n        } catch (SocketException e) {\n          log.error(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n          throw new RuntimeException(e);\n        }\n\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n          in = src.getInputStream();\n          out = destination.getOutputStream();\n          while (true) {\n            int len = -1;\n            try {\n              len = in.read(buf);\n            } catch (SocketTimeoutException ste) {\n              log.warn(ste+\" when reading from \"+src);\n            }\n\n            if (len == -1) {\n              log.debug(\"read eof from:\" + src);\n              break;\n            }\n            pause.get().await();\n            if (len > 0)\n              out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          log.debug(\"read/write failed, reason: \" + e.getLocalizedMessage());\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        } finally {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing InputStream on socket: \"+src);\n            }\n          }\n          if (out != null) {\n            try {\n              out.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing OutputStream on socket: \"+destination);\n            }\n          }\n        }\n      }\n\n","sourceOld":"      public void run() {\n        byte[] buf = new byte[1024];\n\n        try {\n          src.setSoTimeout(10 * 1000);\n        } catch (SocketException e) {\n          log.error(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n          throw new RuntimeException(e);\n        }\n\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n          in = src.getInputStream();\n          out = destination.getOutputStream();\n          while (true) {\n            int len = -1;\n            try {\n              len = in.read(buf);\n            } catch (SocketTimeoutException ste) {\n              log.warn(ste+\" when reading from \"+src);\n            }\n\n            if (len == -1) {\n              log.debug(\"read eof from:\" + src);\n              break;\n            }\n            pause.get().await();\n            if (len > 0)\n              out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          log.debug(\"read/write failed, reason: \" + e.getLocalizedMessage());\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        } finally {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing InputStream on socket: \"+src);\n            }\n          }\n          if (out != null) {\n            try {\n              out.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing OutputStream on socket: \"+destination);\n            }\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"303c984eeb49292308544e0eb8a9ae04708230a7","date":1487535266,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/SocketProxy.Bridge.Pump#run().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/SocketProxy.Bridge.Pump#run().mjava","sourceNew":"      public void run() {\n        byte[] buf = new byte[1024];\n\n        try {\n          src.setSoTimeout(PUMP_SOCKET_TIMEOUT_MS);\n        } catch (SocketException e) {\n          if (e.getMessage().equals(\"Socket is closed\")) {\n            log.warn(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n            return;\n          }\n          log.error(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n          throw new RuntimeException(e);\n        }\n\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n          in = src.getInputStream();\n          out = destination.getOutputStream();\n          while (true) {\n            int len = -1;\n            try {\n              len = in.read(buf);\n            } catch (SocketTimeoutException ste) {\n              log.warn(ste+\" when reading from \"+src);\n            }\n\n            if (len == -1) {\n              log.debug(\"read eof from:\" + src);\n              break;\n            }\n            pause.get().await();\n            if (len > 0)\n              out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          log.debug(\"read/write failed, reason: \" + e.getLocalizedMessage());\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        } finally {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing InputStream on socket: \"+src);\n            }\n          }\n          if (out != null) {\n            try {\n              out.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing OutputStream on socket: \"+destination);\n            }\n          }\n        }\n      }\n\n","sourceOld":"      public void run() {\n        byte[] buf = new byte[1024];\n\n        try {\n          src.setSoTimeout(PUMP_SOCKET_TIMEOUT_MS);\n        } catch (SocketException e) {\n          log.error(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n          throw new RuntimeException(e);\n        }\n\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n          in = src.getInputStream();\n          out = destination.getOutputStream();\n          while (true) {\n            int len = -1;\n            try {\n              len = in.read(buf);\n            } catch (SocketTimeoutException ste) {\n              log.warn(ste+\" when reading from \"+src);\n            }\n\n            if (len == -1) {\n              log.debug(\"read eof from:\" + src);\n              break;\n            }\n            pause.get().await();\n            if (len > 0)\n              out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          log.debug(\"read/write failed, reason: \" + e.getLocalizedMessage());\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        } finally {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing InputStream on socket: \"+src);\n            }\n          }\n          if (out != null) {\n            try {\n              out.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing OutputStream on socket: \"+destination);\n            }\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":5,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/SocketProxy.Bridge.Pump#run().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/SocketProxy.Bridge.Pump#run().mjava","sourceNew":"      public void run() {\n        byte[] buf = new byte[1024];\n\n        try {\n          src.setSoTimeout(PUMP_SOCKET_TIMEOUT_MS);\n        } catch (SocketException e) {\n          if (e.getMessage().equals(\"Socket is closed\")) {\n            log.warn(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n            return;\n          }\n          log.error(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n          throw new RuntimeException(e);\n        }\n\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n          in = src.getInputStream();\n          out = destination.getOutputStream();\n          while (true) {\n            int len = -1;\n            try {\n              len = in.read(buf);\n            } catch (SocketTimeoutException ste) {\n              log.warn(ste+\" when reading from \"+src);\n            }\n\n            if (len == -1) {\n              log.debug(\"read eof from:\" + src);\n              break;\n            }\n            pause.get().await();\n            if (len > 0)\n              out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          log.debug(\"read/write failed, reason: \" + e.getLocalizedMessage());\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        } finally {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing InputStream on socket: \"+src);\n            }\n          }\n          if (out != null) {\n            try {\n              out.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing OutputStream on socket: \"+destination);\n            }\n          }\n        }\n      }\n\n","sourceOld":"      public void run() {\n        byte[] buf = new byte[1024];\n\n        try {\n          src.setSoTimeout(PUMP_SOCKET_TIMEOUT_MS);\n        } catch (SocketException e) {\n          if (e.getMessage().equals(\"Socket is closed\")) {\n            log.warn(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n            return;\n          }\n          log.error(\"Failed to set socket timeout on \"+src+\" due to: \"+e);\n          throw new RuntimeException(e);\n        }\n\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n          in = src.getInputStream();\n          out = destination.getOutputStream();\n          while (true) {\n            int len = -1;\n            try {\n              len = in.read(buf);\n            } catch (SocketTimeoutException ste) {\n              log.warn(ste+\" when reading from \"+src);\n            }\n\n            if (len == -1) {\n              log.debug(\"read eof from:\" + src);\n              break;\n            }\n            pause.get().await();\n            if (len > 0)\n              out.write(buf, 0, len);\n          }\n        } catch (Exception e) {\n          log.debug(\"read/write failed, reason: \" + e.getLocalizedMessage());\n          try {\n            if (!receiveSocket.isClosed()) {\n              // for halfClose, on read/write failure if we close the\n              // remote end will see a close at the same time.\n              close();\n            }\n          } catch (Exception ignore) {}\n        } finally {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing InputStream on socket: \"+src);\n            }\n          }\n          if (out != null) {\n            try {\n              out.close();\n            } catch (Exception exc) {\n              log.debug(exc+\" when closing OutputStream on socket: \"+destination);\n            }\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["303c984eeb49292308544e0eb8a9ae04708230a7"],"303c984eeb49292308544e0eb8a9ae04708230a7":["05d1c262da1d1f850b159395fc65d7925919dc22"],"05d1c262da1d1f850b159395fc65d7925919dc22":["1280741c654e60d3590156727fd5d8daa141efb7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6e36353d7461af8d2329a78a71457cf8e3c1e88f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"1280741c654e60d3590156727fd5d8daa141efb7":["6e36353d7461af8d2329a78a71457cf8e3c1e88f"]},"commit2Childs":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"303c984eeb49292308544e0eb8a9ae04708230a7":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"05d1c262da1d1f850b159395fc65d7925919dc22":["303c984eeb49292308544e0eb8a9ae04708230a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6e36353d7461af8d2329a78a71457cf8e3c1e88f"],"6e36353d7461af8d2329a78a71457cf8e3c1e88f":["1280741c654e60d3590156727fd5d8daa141efb7"],"1280741c654e60d3590156727fd5d8daa141efb7":["05d1c262da1d1f850b159395fc65d7925919dc22"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}