{"path":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","commits":[{"id":"4dbfe3d3dc9ac9bda8ee276ce539e571f3125052","date":1401862284,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        int waitCnt = 0;\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.fail != null) {\n            fail(checkBackupStatus.fail);\n          }\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Backup success not detected:\" + checkBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        TestUtil.rm(snapDir);\n      }\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile,\n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient.shutdown();\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n\n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      String backupName;\n      String cmd;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName, String command) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n        this.cmd = command;\n      }\n      BackupThread(String backupName, String command) {\n        this.backupName = backupName;\n        addNumberToKeepInRequest = false;\n        this.cmd = command;\n      }\n      @Override\n      public void run() {\n        String masterUrl = null;\n        if(backupName != null) {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              \"&name=\" +  backupName;\n        } else {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        }\n\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    class CheckDeleteBackupStatus {\n      String response = null;\n      boolean success = false;\n      String fail = null;\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n      };\n    }\n\n    class CheckBackupStatus {\n      String fail = null;\n      String response = null;\n      boolean success = false;\n      String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n\n      CheckBackupStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);\n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        int waitCnt = 0;\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.fail != null) {\n            fail(checkBackupStatus.fail);\n          }\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Backup success not detected:\" + checkBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        for (int i = 0; i < 2; i++) {\n          BackupThread deleteBackupThread = new BackupThread(backupNames[i], ReplicationHandler.CMD_DELETE_BACKUP);\n          deleteBackupThread.start();\n          int waitCnt = 0;\n          CheckDeleteBackupStatus checkDeleteBackupStatus = new CheckDeleteBackupStatus();\n          while (true) {\n            checkDeleteBackupStatus.fetchStatus();\n            if (checkDeleteBackupStatus.fail != null) {\n              fail(checkDeleteBackupStatus.fail);\n            }\n            if (checkDeleteBackupStatus.success) {\n              break;\n            }\n            Thread.sleep(200);\n            if (waitCnt == 20) {\n              fail(\"Delete Backup success not detected:\" + checkDeleteBackupStatus.response);\n            }\n            waitCnt++;\n          }\n\n          if (deleteBackupThread.fail != null) {\n            fail(deleteBackupThread.fail);\n          }\n        }\n      }\n\n    } finally {\n      if(!namedBackup) {\n        TestUtil.rm(snapDir);\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34d359645acebeba5edce0f1186d99aa81bbe546","date":1402921077,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        TestUtil.rm(snapDir);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        int waitCnt = 0;\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.fail != null) {\n            fail(checkBackupStatus.fail);\n          }\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Backup success not detected:\" + checkBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        TestUtil.rm(snapDir);\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        TestUtil.rm(snapDir);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        int waitCnt = 0;\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.fail != null) {\n            fail(checkBackupStatus.fail);\n          }\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Backup success not detected:\" + checkBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        TestUtil.rm(snapDir);\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbc3688252d4a8045d69a164236b2cf87b721f17","date":1409846185,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        org.apache.lucene.util.IOUtils.rm(snapDir);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        TestUtil.rm(snapDir);\n      }\n    }\n  }\n\n","bugFix":["4dbfe3d3dc9ac9bda8ee276ce539e571f3125052"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile().toPath());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        Path toDelete[] = new Path[snapDir.length];\n        for (int i = 0; i < snapDir.length; i++) {\n          toDelete[i] = snapDir[i].toPath();\n        }\n        org.apache.lucene.util.IOUtils.rm(toDelete);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        org.apache.lucene.util.IOUtils.rm(snapDir);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["e48bb0af7b982aecd8dbafdbeded231282bfdee2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5b847bb03f0ad90d50073e48e452f3346df87482","date":1413504427,"type":3,"author":"Tomas Eduardo Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupCommand backupCommand;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupCommand.runCommand();\n\n        File dataDir = new File(master.getDataDir());\n\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n        }\n\n        if (backupCommand.fail != null) {\n          fail(backupCommand.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile().toPath());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        Path toDelete[] = new Path[snapDir.length];\n        for (int i = 0; i < snapDir.length; i++) {\n          toDelete[i] = snapDir[i].toPath();\n        }\n        org.apache.lucene.util.IOUtils.rm(toDelete);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile().toPath());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        Path toDelete[] = new Path[snapDir.length];\n        for (int i = 0; i < snapDir.length; i++) {\n          toDelete[i] = snapDir[i].toPath();\n        }\n        org.apache.lucene.util.IOUtils.rm(toDelete);\n      }\n    }\n  }\n\n","bugFix":["4dbfe3d3dc9ac9bda8ee276ce539e571f3125052"],"bugIntro":["e48bb0af7b982aecd8dbafdbeded231282bfdee2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupCommand backupCommand;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupCommand.runCommand();\n\n        File dataDir = new File(master.getDataDir());\n\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n        }\n\n        if (backupCommand.fail != null) {\n          fail(backupCommand.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile().toPath());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        Path toDelete[] = new Path[snapDir.length];\n        for (int i = 0; i < snapDir.length; i++) {\n          toDelete[i] = snapDir[i].toPath();\n        }\n        org.apache.lucene.util.IOUtils.rm(toDelete);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile().toPath());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        Path toDelete[] = new Path[snapDir.length];\n        for (int i = 0; i < snapDir.length; i++) {\n          toDelete[i] = snapDir[i].toPath();\n        }\n        org.apache.lucene.util.IOUtils.rm(toDelete);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5939c5b1ac54c5b24bd7dbcaf6c68b510470e2c6","date":1423132645,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs();\n\n    Path[] snapDir = new Path[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupCommand backupCommand;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupCommand.runCommand();\n        if (backupCommand.fail != null) {\n          fail(backupCommand.fail);\n        }\n\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n        while (!checkBackupStatus.success) {\n          checkBackupStatus.fetchStatus();\n          Thread.sleep(1000);\n        }\n        if (i == 0) {\n          firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n        }\n\n        if (!namedBackup) {\n          snapDir[i] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n        } else {\n          snapDir[i] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName).iterator().next();\n        }\n        verify(snapDir[i], nDocs);\n\n      }\n\n      if (!namedBackup && Files.exists(snapDir[0])) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        for (int i = 0; i < snapDir.length; i++) {\n          org.apache.lucene.util.IOUtils.rm(snapDir[i]);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupCommand backupCommand;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupCommand.runCommand();\n\n        File dataDir = new File(master.getDataDir());\n\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n        }\n\n        if (backupCommand.fail != null) {\n          fail(backupCommand.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile().toPath());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        Path toDelete[] = new Path[snapDir.length];\n        for (int i = 0; i < snapDir.length; i++) {\n          toDelete[i] = snapDir[i].toPath();\n        }\n        org.apache.lucene.util.IOUtils.rm(toDelete);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["e48bb0af7b982aecd8dbafdbeded231282bfdee2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e48bb0af7b982aecd8dbafdbeded231282bfdee2","date":1423717438,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs();\n\n    Path[] snapDir = new Path[2];\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[2];\n    }\n    for (int i = 0; i < 2; i++) {\n      BackupCommand backupCommand;\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n      } else {\n        backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n        backupNames[i] = backupName;\n      }\n      backupCommand.runCommand();\n      if (backupCommand.fail != null) {\n        fail(backupCommand.fail);\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        snapDir[i] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n      } else {\n        snapDir[i] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName).iterator().next();\n      }\n      verify(snapDir[i], nDocs);\n\n    }\n\n    if (!namedBackup && Files.exists(snapDir[0])) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n\n    //Test Deletion of named backup\n    if(namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs();\n\n    Path[] snapDir = new Path[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupCommand backupCommand;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupCommand.runCommand();\n        if (backupCommand.fail != null) {\n          fail(backupCommand.fail);\n        }\n\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n        while (!checkBackupStatus.success) {\n          checkBackupStatus.fetchStatus();\n          Thread.sleep(1000);\n        }\n        if (i == 0) {\n          firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n        }\n\n        if (!namedBackup) {\n          snapDir[i] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n        } else {\n          snapDir[i] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName).iterator().next();\n        }\n        verify(snapDir[i], nDocs);\n\n      }\n\n      if (!namedBackup && Files.exists(snapDir[0])) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        for (int i = 0; i < snapDir.length; i++) {\n          org.apache.lucene.util.IOUtils.rm(snapDir[i]);\n        }\n      }\n    }\n  }\n\n","bugFix":["5939c5b1ac54c5b24bd7dbcaf6c68b510470e2c6","4dbfe3d3dc9ac9bda8ee276ce539e571f3125052","5b847bb03f0ad90d50073e48e452f3346df87482","f4abec28b874149a7223e32cc7a01704c27790de"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d430d59b42be8455e21334e887dea80642775691","date":1423733834,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs();\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    snapDir[0] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      BackupCommand backupCommand;\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n      } else {\n        backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n        backupNames[i] = backupName;\n      }\n      backupCommand.runCommand();\n      if (backupCommand.fail != null) {\n        fail(backupCommand.fail);\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        snapDir[i+1] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n      } else {\n        snapDir[i+1] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName).iterator().next();\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      Iterator<Path> iter = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator();\n      while (iter.hasNext()) {\n        iter.next();\n        count ++;\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      }\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs();\n\n    Path[] snapDir = new Path[2];\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[2];\n    }\n    for (int i = 0; i < 2; i++) {\n      BackupCommand backupCommand;\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n      } else {\n        backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n        backupNames[i] = backupName;\n      }\n      backupCommand.runCommand();\n      if (backupCommand.fail != null) {\n        fail(backupCommand.fail);\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        snapDir[i] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n      } else {\n        snapDir[i] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName).iterator().next();\n      }\n      verify(snapDir[i], nDocs);\n\n    }\n\n    if (!namedBackup && Files.exists(snapDir[0])) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n\n    //Test Deletion of named backup\n    if(namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    }\n  }\n\n","bugFix":null,"bugIntro":["c33988a449fe12f4d5790093a188f5e696c03bb4","9d32699b9d6d5982ddfd5f25843ae42adf37c22c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c33988a449fe12f4d5790093a188f5e696c03bb4","date":1423737057,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs();\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    snapDir[0] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      BackupCommand backupCommand;\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n      } else {\n        backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n        backupNames[i] = backupName;\n      }\n      backupCommand.runCommand();\n      if (backupCommand.fail != null) {\n        fail(backupCommand.fail);\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        snapDir[i+1] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n      } else {\n        snapDir[i+1] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName).iterator().next();\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      Iterator<Path> iter = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator();\n      while (iter.hasNext()) {\n        iter.next();\n        count ++;\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs();\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    snapDir[0] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      BackupCommand backupCommand;\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n      } else {\n        backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n        backupNames[i] = backupName;\n      }\n      backupCommand.runCommand();\n      if (backupCommand.fail != null) {\n        fail(backupCommand.fail);\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        snapDir[i+1] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n      } else {\n        snapDir[i+1] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName).iterator().next();\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      Iterator<Path> iter = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator();\n      while (iter.hasNext()) {\n        iter.next();\n        count ++;\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      }\n\n    }\n  }\n\n","bugFix":["d430d59b42be8455e21334e887dea80642775691"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d32699b9d6d5982ddfd5f25843ae42adf37c22c","date":1424850267,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs();\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n      snapDir[0] = stream.iterator().next();\n    }\n\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      BackupCommand backupCommand;\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n      } else {\n        backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n        backupNames[i] = backupName;\n      }\n      backupCommand.runCommand();\n      if (backupCommand.fail != null) {\n        fail(backupCommand.fail);\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      } else {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName)) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          iter.next();\n          count ++;\n        }\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs();\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    snapDir[0] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      BackupCommand backupCommand;\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n      } else {\n        backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n        backupNames[i] = backupName;\n      }\n      backupCommand.runCommand();\n      if (backupCommand.fail != null) {\n        fail(backupCommand.fail);\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        snapDir[i+1] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n      } else {\n        snapDir[i+1] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName).iterator().next();\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      Iterator<Path> iter = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator();\n      while (iter.hasNext()) {\n        iter.next();\n        count ++;\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","bugFix":["d430d59b42be8455e21334e887dea80642775691"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs();\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n      snapDir[0] = stream.iterator().next();\n    }\n\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      BackupCommand backupCommand;\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n      } else {\n        backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n        backupNames[i] = backupName;\n      }\n      backupCommand.runCommand();\n      if (backupCommand.fail != null) {\n        fail(backupCommand.fail);\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      } else {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName)) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          iter.next();\n          count ++;\n        }\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs();\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    snapDir[0] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      BackupCommand backupCommand;\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n      } else {\n        backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n        backupNames[i] = backupName;\n      }\n      backupCommand.runCommand();\n      if (backupCommand.fail != null) {\n        fail(backupCommand.fail);\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        snapDir[i+1] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator().next();\n      } else {\n        snapDir[i+1] = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName).iterator().next();\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      Iterator<Path> iter = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\").iterator();\n      while (iter.hasNext()) {\n        iter.next();\n        count ++;\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b13106276bb5ea342253dbf6aae7b675adb38d3","date":1428054414,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs(masterClient);\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n      snapDir[0] = stream.iterator().next();\n    }\n\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        if (addNumberToKeepInRequest) {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&\" + backupKeepParamName + \"=2\");\n        } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"\");\n        }\n      } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&name=\" +  backupName);\n        backupNames[i] = backupName;\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      } else {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName)) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          iter.next();\n          count ++;\n        }\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs();\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n      snapDir[0] = stream.iterator().next();\n    }\n\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      BackupCommand backupCommand;\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n      } else {\n        backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n        backupNames[i] = backupName;\n      }\n      backupCommand.runCommand();\n      if (backupCommand.fail != null) {\n        fail(backupCommand.fail);\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      } else {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName)) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          iter.next();\n          count ++;\n        }\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","date":1428091986,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs(masterClient);\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n      snapDir[0] = stream.iterator().next();\n    }\n\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        if (addNumberToKeepInRequest) {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&\" + backupKeepParamName + \"=2\");\n        } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"\");\n        }\n      } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&name=\" +  backupName);\n        backupNames[i] = backupName;\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      } else {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName)) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          iter.next();\n          count ++;\n        }\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs();\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n      snapDir[0] = stream.iterator().next();\n    }\n\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      BackupCommand backupCommand;\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        backupCommand = new BackupCommand(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n      } else {\n        backupCommand = new BackupCommand(backupName, ReplicationHandler.CMD_BACKUP);\n        backupNames[i] = backupName;\n      }\n      backupCommand.runCommand();\n      if (backupCommand.fail != null) {\n        fail(backupCommand.fail);\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      } else {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName)) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          iter.next();\n          count ++;\n        }\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b","date":1466705968,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = BackupRestoreUtils.indexDocs(masterClient, DEFAULT_TEST_COLLECTION_NAME, docsSeed);\n\n    //Confirm if completed\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n      snapDir[0] = stream.iterator().next();\n    }\n\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        if (addNumberToKeepInRequest) {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&\" + backupKeepParamName + \"=2\");\n        } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"\");\n        }\n      } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&name=\" +  backupName);\n        backupNames[i] = backupName;\n      }\n\n     checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      } else {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName)) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          iter.next();\n          count ++;\n        }\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs(masterClient);\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n      snapDir[0] = stream.iterator().next();\n    }\n\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        if (addNumberToKeepInRequest) {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&\" + backupKeepParamName + \"=2\");\n        } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"\");\n        }\n      } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&name=\" +  backupName);\n        backupNames[i] = backupName;\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      } else {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName)) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          iter.next();\n          count ++;\n        }\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = BackupRestoreUtils.indexDocs(masterClient, DEFAULT_TEST_COLLECTION_NAME, docsSeed);\n\n    //Confirm if completed\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n      snapDir[0] = stream.iterator().next();\n    }\n\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        if (addNumberToKeepInRequest) {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&\" + backupKeepParamName + \"=2\");\n        } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"\");\n        }\n      } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&name=\" +  backupName);\n        backupNames[i] = backupName;\n      }\n\n     checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      } else {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName)) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          iter.next();\n          count ++;\n        }\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = indexDocs(masterClient);\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n      snapDir[0] = stream.iterator().next();\n    }\n\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        if (addNumberToKeepInRequest) {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&\" + backupKeepParamName + \"=2\");\n        } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"\");\n        }\n      } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&name=\" +  backupName);\n        backupNames[i] = backupName;\n      }\n\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      } else {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName)) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          iter.next();\n          count ++;\n        }\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec54bd926c45854b5a1599685b0f7d2bfbfe177f","date":1573838246,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n    final BackupStatusChecker backupStatus\n      = new BackupStatusChecker(masterClient, \"/\" + DEFAULT_TEST_CORENAME + \"/replication\");\n\n    String lastBackupDir = backupStatus.checkBackupSuccess();\n    assertNull(\"Already have a successful backup\",\n               lastBackupDir);\n\n    final Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    \n    int nDocs = BackupRestoreUtils.indexDocs(masterClient, DEFAULT_TEST_COLLECTION_NAME, docsSeed);\n\n    lastBackupDir = backupStatus.waitForDifferentBackupDir(lastBackupDir, 30);\n    snapDir[0] = Paths.get(master.getDataDir(), lastBackupDir);\n\n    final boolean namedBackup = random().nextBoolean();\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20) + \"_\" + i;\n      if (!namedBackup) {\n        if (addNumberToKeepInRequest) {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&\" + backupKeepParamName + \"=2\");\n        } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"\");\n        }\n        lastBackupDir = backupStatus.waitForDifferentBackupDir(lastBackupDir, 30);\n      } else {\n        runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&name=\" +  backupName);\n        lastBackupDir = backupStatus.waitForBackupSuccess(backupName, 30);\n        backupNames[i] = backupName;\n      }\n      snapDir[i+1] = Paths.get(master.getDataDir(), lastBackupDir);\n      verify(snapDir[i+1], nDocs);\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      final List<String> remainingBackups = new ArrayList<>();\n      \n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          remainingBackups.add(iter.next().getFileName().toString());\n        }\n      }\n\n      // Depending on the use of backupKeepParamName there should either be 2 or 1 backups remaining\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(remainingBackups.toString(),\n                     2, remainingBackups.size());\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(remainingBackups.toString(),\n                     1, remainingBackups.size());\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = BackupRestoreUtils.indexDocs(masterClient, DEFAULT_TEST_COLLECTION_NAME, docsSeed);\n\n    //Confirm if completed\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n      snapDir[0] = stream.iterator().next();\n    }\n\n    boolean namedBackup = random().nextBoolean();\n    String firstBackupTimestamp = null;\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if (!namedBackup) {\n        if (addNumberToKeepInRequest) {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&\" + backupKeepParamName + \"=2\");\n        } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"\");\n        }\n      } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&name=\" +  backupName);\n        backupNames[i] = backupName;\n      }\n\n     checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, firstBackupTimestamp);\n      while (!checkBackupStatus.success) {\n        checkBackupStatus.fetchStatus();\n        Thread.sleep(1000);\n      }\n      if (i == 0) {\n        firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n      }\n\n      if (!namedBackup) {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      } else {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot.\" + backupName)) {\n          snapDir[i+1] = stream.iterator().next();\n        }\n      }\n      verify(snapDir[i+1], nDocs);\n\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      int count =0;\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          iter.next();\n          count ++;\n        }\n      }\n\n      //There will be 2 backups, otherwise 1\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(2, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(1, count);\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e","date":1596664368,"type":3,"author":"Marcus","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n    final BackupStatusChecker backupStatus\n      = new BackupStatusChecker(leaderClient, \"/\" + DEFAULT_TEST_CORENAME + \"/replication\");\n\n    String lastBackupDir = backupStatus.checkBackupSuccess();\n    assertNull(\"Already have a successful backup\",\n               lastBackupDir);\n\n    final Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    \n    int nDocs = BackupRestoreUtils.indexDocs(leaderClient, DEFAULT_TEST_COLLECTION_NAME, docsSeed);\n\n    lastBackupDir = backupStatus.waitForDifferentBackupDir(lastBackupDir, 30);\n    snapDir[0] = Paths.get(leader.getDataDir(), lastBackupDir);\n\n    final boolean namedBackup = random().nextBoolean();\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20) + \"_\" + i;\n      if (!namedBackup) {\n        if (addNumberToKeepInRequest) {\n          runBackupCommand(leaderJetty, ReplicationHandler.CMD_BACKUP, \"&\" + backupKeepParamName + \"=2\");\n        } else {\n          runBackupCommand(leaderJetty, ReplicationHandler.CMD_BACKUP, \"\");\n        }\n        lastBackupDir = backupStatus.waitForDifferentBackupDir(lastBackupDir, 30);\n      } else {\n        runBackupCommand(leaderJetty, ReplicationHandler.CMD_BACKUP, \"&name=\" +  backupName);\n        lastBackupDir = backupStatus.waitForBackupSuccess(backupName, 30);\n        backupNames[i] = backupName;\n      }\n      snapDir[i+1] = Paths.get(leader.getDataDir(), lastBackupDir);\n      verify(snapDir[i+1], nDocs);\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      final List<String> remainingBackups = new ArrayList<>();\n      \n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(leader.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          remainingBackups.add(iter.next().getFileName().toString());\n        }\n      }\n\n      // Depending on the use of backupKeepParamName there should either be 2 or 1 backups remaining\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(remainingBackups.toString(),\n                     2, remainingBackups.size());\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(remainingBackups.toString(),\n                     1, remainingBackups.size());\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n    final BackupStatusChecker backupStatus\n      = new BackupStatusChecker(masterClient, \"/\" + DEFAULT_TEST_CORENAME + \"/replication\");\n\n    String lastBackupDir = backupStatus.checkBackupSuccess();\n    assertNull(\"Already have a successful backup\",\n               lastBackupDir);\n\n    final Path[] snapDir = new Path[5]; //One extra for the backup on commit\n    //First snapshot location\n    \n    int nDocs = BackupRestoreUtils.indexDocs(masterClient, DEFAULT_TEST_COLLECTION_NAME, docsSeed);\n\n    lastBackupDir = backupStatus.waitForDifferentBackupDir(lastBackupDir, 30);\n    snapDir[0] = Paths.get(master.getDataDir(), lastBackupDir);\n\n    final boolean namedBackup = random().nextBoolean();\n\n    String[] backupNames = null;\n    if (namedBackup) {\n      backupNames = new String[4];\n    }\n    for (int i = 0; i < 4; i++) {\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20) + \"_\" + i;\n      if (!namedBackup) {\n        if (addNumberToKeepInRequest) {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&\" + backupKeepParamName + \"=2\");\n        } else {\n          runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"\");\n        }\n        lastBackupDir = backupStatus.waitForDifferentBackupDir(lastBackupDir, 30);\n      } else {\n        runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, \"&name=\" +  backupName);\n        lastBackupDir = backupStatus.waitForBackupSuccess(backupName, 30);\n        backupNames[i] = backupName;\n      }\n      snapDir[i+1] = Paths.get(master.getDataDir(), lastBackupDir);\n      verify(snapDir[i+1], nDocs);\n    }\n\n    \n    //Test Deletion of named backup\n    if (namedBackup) {\n      testDeleteNamedBackup(backupNames);\n    } else {\n      //5 backups got created. 4 explicitly and one because a commit was called.\n      // Only the last two should still exist.\n      final List<String> remainingBackups = new ArrayList<>();\n      \n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(master.getDataDir()), \"snapshot*\")) {\n        Iterator<Path> iter = stream.iterator();\n        while (iter.hasNext()) {\n          remainingBackups.add(iter.next().getFileName().toString());\n        }\n      }\n\n      // Depending on the use of backupKeepParamName there should either be 2 or 1 backups remaining\n      if (backupKeepParamName.equals(ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM)) {\n        assertEquals(remainingBackups.toString(),\n                     2, remainingBackups.size());\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 2.\");\n        }\n      } else {\n        assertEquals(remainingBackups.toString(),\n                     1, remainingBackups.size());\n\n        if (Files.exists(snapDir[0]) || Files.exists(snapDir[1]) || Files.exists(snapDir[2])\n            || Files.exists(snapDir[3])) {\n          fail(\"Backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["ec54bd926c45854b5a1599685b0f7d2bfbfe177f"],"c33988a449fe12f4d5790093a188f5e696c03bb4":["d430d59b42be8455e21334e887dea80642775691"],"34d359645acebeba5edce0f1186d99aa81bbe546":["4dbfe3d3dc9ac9bda8ee276ce539e571f3125052"],"5939c5b1ac54c5b24bd7dbcaf6c68b510470e2c6":["5b847bb03f0ad90d50073e48e452f3346df87482"],"9d32699b9d6d5982ddfd5f25843ae42adf37c22c":["c33988a449fe12f4d5790093a188f5e696c03bb4"],"5b847bb03f0ad90d50073e48e452f3346df87482":["f4abec28b874149a7223e32cc7a01704c27790de"],"f4abec28b874149a7223e32cc7a01704c27790de":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["4dbfe3d3dc9ac9bda8ee276ce539e571f3125052","34d359645acebeba5edce0f1186d99aa81bbe546"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7b13106276bb5ea342253dbf6aae7b675adb38d3","a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["c33988a449fe12f4d5790093a188f5e696c03bb4","9d32699b9d6d5982ddfd5f25843ae42adf37c22c"],"d430d59b42be8455e21334e887dea80642775691":["e48bb0af7b982aecd8dbafdbeded231282bfdee2"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["f4abec28b874149a7223e32cc7a01704c27790de","5b847bb03f0ad90d50073e48e452f3346df87482"],"ec54bd926c45854b5a1599685b0f7d2bfbfe177f":["a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["34d359645acebeba5edce0f1186d99aa81bbe546"],"a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b":["7b13106276bb5ea342253dbf6aae7b675adb38d3"],"4dbfe3d3dc9ac9bda8ee276ce539e571f3125052":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","7b13106276bb5ea342253dbf6aae7b675adb38d3"],"e48bb0af7b982aecd8dbafdbeded231282bfdee2":["5939c5b1ac54c5b24bd7dbcaf6c68b510470e2c6"],"7b13106276bb5ea342253dbf6aae7b675adb38d3":["9d32699b9d6d5982ddfd5f25843ae42adf37c22c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"]},"commit2Childs":{"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c33988a449fe12f4d5790093a188f5e696c03bb4":["9d32699b9d6d5982ddfd5f25843ae42adf37c22c","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"34d359645acebeba5edce0f1186d99aa81bbe546":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","cbc3688252d4a8045d69a164236b2cf87b721f17"],"5939c5b1ac54c5b24bd7dbcaf6c68b510470e2c6":["e48bb0af7b982aecd8dbafdbeded231282bfdee2"],"5b847bb03f0ad90d50073e48e452f3346df87482":["5939c5b1ac54c5b24bd7dbcaf6c68b510470e2c6","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"9d32699b9d6d5982ddfd5f25843ae42adf37c22c":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","7b13106276bb5ea342253dbf6aae7b675adb38d3"],"f4abec28b874149a7223e32cc7a01704c27790de":["5b847bb03f0ad90d50073e48e452f3346df87482","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c"],"d430d59b42be8455e21334e887dea80642775691":["c33988a449fe12f4d5790093a188f5e696c03bb4"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"ec54bd926c45854b5a1599685b0f7d2bfbfe177f":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["f4abec28b874149a7223e32cc7a01704c27790de"],"a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","ec54bd926c45854b5a1599685b0f7d2bfbfe177f"],"4dbfe3d3dc9ac9bda8ee276ce539e571f3125052":["34d359645acebeba5edce0f1186d99aa81bbe546","c6f080a2ab37c464dd98db173f6cbf10dc74f211"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4dbfe3d3dc9ac9bda8ee276ce539e571f3125052"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":[],"e48bb0af7b982aecd8dbafdbeded231282bfdee2":["d430d59b42be8455e21334e887dea80642775691"],"7b13106276bb5ea342253dbf6aae7b675adb38d3":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0a22eafe3f72a4c2945eaad9547e6c78816978f4","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}