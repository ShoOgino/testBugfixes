{"path":"lucene/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n    char[] charBuffer;\n    final boolean preUTF8 = format < FORMAT_UTF8_LENGTH_IN_BYTES;\n\n    // init the buffers\n    if (preUTF8) {\n      charBuffer = new char[10];\n      byteBuffer = null;\n    } else {\n      charBuffer = null;\n      byteBuffer = new byte[20];\n    }\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      if (preUTF8) {\n        // Term stored as java chars\n        if (charBuffer.length < totalLength) {\n          charBuffer = ArrayUtil.grow(charBuffer, totalLength);\n        }\n        tvf.readChars(charBuffer, start, deltaLength);\n        term = new String(charBuffer, 0, totalLength);\n      } else {\n        // Term stored as utf8 bytes\n        if (byteBuffer.length < totalLength) {\n          byteBuffer = ArrayUtil.grow(byteBuffer, totalLength);\n        }\n        tvf.readBytes(byteBuffer, start, deltaLength);\n        term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      }\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n    char[] charBuffer;\n    final boolean preUTF8 = format < FORMAT_UTF8_LENGTH_IN_BYTES;\n\n    // init the buffers\n    if (preUTF8) {\n      charBuffer = new char[10];\n      byteBuffer = null;\n    } else {\n      charBuffer = null;\n      byteBuffer = new byte[20];\n    }\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      if (preUTF8) {\n        // Term stored as java chars\n        if (charBuffer.length < totalLength) {\n          charBuffer = ArrayUtil.grow(charBuffer, totalLength);\n        }\n        tvf.readChars(charBuffer, start, deltaLength);\n        term = new String(charBuffer, 0, totalLength);\n      } else {\n        // Term stored as utf8 bytes\n        if (byteBuffer.length < totalLength) {\n          byteBuffer = ArrayUtil.grow(byteBuffer, totalLength);\n        }\n        tvf.readBytes(byteBuffer, start, deltaLength);\n        term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      }\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6267e1ce56c2eec111425690cd04e251b6f14952","date":1275222352,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    byte bits = tvf.readByte();\n    storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n    storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n\n    // init the buffer\n    byteBuffer = new byte[20];\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      // Term stored as utf8 bytes\n      if (byteBuffer.length < totalLength) {\n        byteBuffer = ArrayUtil.grow(byteBuffer, totalLength);\n      }\n      tvf.readBytes(byteBuffer, start, deltaLength);\n      term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (!mapper.isIgnoringPositions()) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (!mapper.isIgnoringOffsets()) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n    char[] charBuffer;\n    final boolean preUTF8 = format < FORMAT_UTF8_LENGTH_IN_BYTES;\n\n    // init the buffers\n    if (preUTF8) {\n      charBuffer = new char[10];\n      byteBuffer = null;\n    } else {\n      charBuffer = null;\n      byteBuffer = new byte[20];\n    }\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      if (preUTF8) {\n        // Term stored as java chars\n        if (charBuffer.length < totalLength) {\n          charBuffer = ArrayUtil.grow(charBuffer, totalLength);\n        }\n        tvf.readChars(charBuffer, start, deltaLength);\n        term = new String(charBuffer, 0, totalLength);\n      } else {\n        // Term stored as utf8 bytes\n        if (byteBuffer.length < totalLength) {\n          byteBuffer = ArrayUtil.grow(byteBuffer, totalLength);\n        }\n        tvf.readBytes(byteBuffer, start, deltaLength);\n        term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      }\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f29ba80b723649f5feb7e37afe1a558dd2c1304","date":1278318805,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    byte bits = tvf.readByte();\n    storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n    storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n\n    // init the buffer\n    byteBuffer = new byte[20];\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final BytesRef term = new BytesRef(totalLength);\n      \n      // Term stored as utf8 bytes\n      if (byteBuffer.length < totalLength) {\n        byteBuffer = ArrayUtil.grow(byteBuffer, totalLength);\n      }\n      tvf.readBytes(byteBuffer, start, deltaLength);\n      System.arraycopy(byteBuffer, 0, term.bytes, 0, totalLength);\n      term.length = totalLength;\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (!mapper.isIgnoringPositions()) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (!mapper.isIgnoringOffsets()) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    byte bits = tvf.readByte();\n    storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n    storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n\n    // init the buffer\n    byteBuffer = new byte[20];\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      // Term stored as utf8 bytes\n      if (byteBuffer.length < totalLength) {\n        byteBuffer = ArrayUtil.grow(byteBuffer, totalLength);\n      }\n      tvf.readBytes(byteBuffer, start, deltaLength);\n      term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (!mapper.isIgnoringPositions()) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (!mapper.isIgnoringOffsets()) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    byte bits = tvf.readByte();\n    storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n    storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n\n    // init the buffer\n    byteBuffer = new byte[20];\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final BytesRef term = new BytesRef(totalLength);\n      \n      // Term stored as utf8 bytes\n      if (byteBuffer.length < totalLength) {\n        byteBuffer = ArrayUtil.grow(byteBuffer, totalLength);\n      }\n      tvf.readBytes(byteBuffer, start, deltaLength);\n      System.arraycopy(byteBuffer, 0, term.bytes, 0, totalLength);\n      term.length = totalLength;\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (!mapper.isIgnoringPositions()) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (!mapper.isIgnoringOffsets()) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    byte bits = tvf.readByte();\n    storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n    storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n\n    // init the buffer\n    byteBuffer = new byte[20];\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      // Term stored as utf8 bytes\n      if (byteBuffer.length < totalLength) {\n        byteBuffer = ArrayUtil.grow(byteBuffer, totalLength);\n      }\n      tvf.readBytes(byteBuffer, start, deltaLength);\n      term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (!mapper.isIgnoringPositions()) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (!mapper.isIgnoringOffsets()) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","sourceNew":null,"sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    byte bits = tvf.readByte();\n    storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n    storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n\n    // init the buffer\n    byteBuffer = new byte[20];\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final BytesRef term = new BytesRef(totalLength);\n      \n      // Term stored as utf8 bytes\n      if (byteBuffer.length < totalLength) {\n        byteBuffer = ArrayUtil.grow(byteBuffer, totalLength);\n      }\n      tvf.readBytes(byteBuffer, start, deltaLength);\n      System.arraycopy(byteBuffer, 0, term.bytes, 0, totalLength);\n      term.length = totalLength;\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (!mapper.isIgnoringPositions()) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (!mapper.isIgnoringOffsets()) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6267e1ce56c2eec111425690cd04e251b6f14952":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["6267e1ce56c2eec111425690cd04e251b6f14952"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc749c053615f5871f3b95715fe292f34e70a53":["4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"5f4e87790277826a2aea119328600dfb07761f32":["6267e1ce56c2eec111425690cd04e251b6f14952","4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc749c053615f5871f3b95715fe292f34e70a53"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"6267e1ce56c2eec111425690cd04e251b6f14952":["4f29ba80b723649f5feb7e37afe1a558dd2c1304","5f4e87790277826a2aea119328600dfb07761f32"],"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["3cc749c053615f5871f3b95715fe292f34e70a53","5f4e87790277826a2aea119328600dfb07761f32"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"3cc749c053615f5871f3b95715fe292f34e70a53":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5f4e87790277826a2aea119328600dfb07761f32":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["6267e1ce56c2eec111425690cd04e251b6f14952"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5f4e87790277826a2aea119328600dfb07761f32","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}