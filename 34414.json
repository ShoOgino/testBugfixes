{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","commits":[{"id":"33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a","date":1341524239,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Iterable[#-extends-IndexableField],Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segmentInfo == null) {\n      initSegmentInfo();\n    }\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(Iterable<? extends IndexableField> doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segmentInfo == null) {\n      initSegmentInfo();\n    }\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d028314cced5858683a1bb4741423d0f934257b","date":1346596535,"type":1,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Iterable[#-extends-IndexableField],Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segmentInfo == null) {\n      initSegmentInfo();\n    }\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(Iterable<? extends IndexableField> doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segmentInfo == null) {\n      initSegmentInfo();\n    }\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"978de4e2d23054c6624dd5928ddeb734dca68eec","date":1370592803,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segmentInfo == null) {\n      initSegmentInfo();\n    }\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert writer.testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segmentInfo == null) {\n      initSegmentInfo();\n    }\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7af110b00ea8df9429309d83e38e0533d82e144f","date":1376924768,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort(filesToDelete);\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segmentInfo == null) {\n      initSegmentInfo();\n    }\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort(filesToDelete);\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segmentInfo == null) {\n      initSegmentInfo();\n    }\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort(filesToDelete);\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (segmentInfo == null) {\n      initSegmentInfo();\n    }\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort();\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"52c7e49be259508735752fba88085255014a6ecf","date":1398706273,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort(filesToDelete);\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3394716f52b34ab259ad5247e7595d9f9db6e935","date":1398791921,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort(filesToDelete);\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument(fieldInfos);\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    success = false;\n    try {\n      consumer.finishDocument();\n      success = true;\n    } finally {\n      if (!success) {\n        abort(filesToDelete);\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6b7c6630218ed9693cdb8643276513f9f0043f4","date":1406648084,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    reserveDoc();\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":["98a04f56464afdffd4c430d6c47a0c868a38354e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4","date":1414017220,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    reserveDoc();\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    assert testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    reserveDoc();\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9299079153fd7895bf3cf6835cf7019af2ba89b3","date":1417813477,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException, AbortingException {\n    testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    reserveDoc();\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        // mark document as deleted\n        deleteDocID(docState.docID);\n        numDocsInRAM++;\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException {\n    testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    reserveDoc();\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        if (!aborting) {\n          // mark document as deleted\n          deleteDocID(docState.docID);\n          numDocsInRAM++;\n        } else {\n          abort(filesToDelete);\n        }\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98b44240f64a2d6935543ff25faee750b29204eb","date":1424972040,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException, AbortingException {\n    testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    reserveDoc();\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        // mark document as deleted\n        deleteDocID(docState.docID);\n        numDocsInRAM++;\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException, AbortingException {\n    testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    reserveDoc();\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        // mark document as deleted\n        deleteDocID(docState.docID);\n        numDocsInRAM++;\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"acf0fc8b8488d15344408e0ed0ab484f4a3e1bf2","date":1424979404,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException, AbortingException {\n    testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    reserveOneDoc();\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        // mark document as deleted\n        deleteDocID(docState.docID);\n        numDocsInRAM++;\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException, AbortingException {\n    testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    reserveDoc();\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        // mark document as deleted\n        deleteDocID(docState.docID);\n        numDocsInRAM++;\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98a04f56464afdffd4c430d6c47a0c868a38354e","date":1424985833,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException, AbortingException {\n    testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    reserveOneDoc();\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        // mark document as deleted\n        deleteDocID(docState.docID);\n        numDocsInRAM++;\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException, AbortingException {\n    testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    reserveDoc();\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        // mark document as deleted\n        deleteDocID(docState.docID);\n        numDocsInRAM++;\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":["d6b7c6630218ed9693cdb8643276513f9f0043f4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException, AbortingException {\n    testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    reserveOneDoc();\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        // mark document as deleted\n        deleteDocID(docState.docID);\n        numDocsInRAM++;\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException, AbortingException {\n    testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    reserveDoc();\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        // mark document as deleted\n        deleteDocID(docState.docID);\n        numDocsInRAM++;\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(Iterable[#-extends-IndexableField],Analyzer,Term).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#updateDocument(IndexDocument,Analyzer,Term).mjava","sourceNew":"  public void updateDocument(Iterable<? extends IndexableField> doc, Analyzer analyzer, Term delTerm) throws IOException, AbortingException {\n    testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    reserveOneDoc();\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        // mark document as deleted\n        deleteDocID(docState.docID);\n        numDocsInRAM++;\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","sourceOld":"  public void updateDocument(IndexDocument doc, Analyzer analyzer, Term delTerm) throws IOException, AbortingException {\n    testPoint(\"DocumentsWriterPerThread addDocument start\");\n    assert deleteQueue != null;\n    reserveOneDoc();\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n    docState.docID = numDocsInRAM;\n    if (INFO_VERBOSE && infoStream.isEnabled(\"DWPT\")) {\n      infoStream.message(\"DWPT\", Thread.currentThread().getName() + \" update delTerm=\" + delTerm + \" docID=\" + docState.docID + \" seg=\" + segmentInfo.name);\n    }\n    // Even on exception, the document is still added (but marked\n    // deleted), so we don't need to un-reserve at that point.\n    // Aborting exceptions will actually \"lose\" more than one\n    // document, so the counter will be \"wrong\" in that case, but\n    // it's very hard to fix (we can't easily distinguish aborting\n    // vs non-aborting exceptions):\n    boolean success = false;\n    try {\n      try {\n        consumer.processDocument();\n      } finally {\n        docState.clear();\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        // mark document as deleted\n        deleteDocID(docState.docID);\n        numDocsInRAM++;\n      }\n    }\n    finishDocument(delTerm);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7af110b00ea8df9429309d83e38e0533d82e144f":["978de4e2d23054c6624dd5928ddeb734dca68eec"],"978de4e2d23054c6624dd5928ddeb734dca68eec":["1d028314cced5858683a1bb4741423d0f934257b"],"98a04f56464afdffd4c430d6c47a0c868a38354e":["9299079153fd7895bf3cf6835cf7019af2ba89b3","acf0fc8b8488d15344408e0ed0ab484f4a3e1bf2"],"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4":["d6b7c6630218ed9693cdb8643276513f9f0043f4"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["7af110b00ea8df9429309d83e38e0533d82e144f","3394716f52b34ab259ad5247e7595d9f9db6e935"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["978de4e2d23054c6624dd5928ddeb734dca68eec","7af110b00ea8df9429309d83e38e0533d82e144f"],"31d4861802ca404d78ca1d15f4550eec415b9199":["978de4e2d23054c6624dd5928ddeb734dca68eec","7af110b00ea8df9429309d83e38e0533d82e144f"],"3394716f52b34ab259ad5247e7595d9f9db6e935":["7af110b00ea8df9429309d83e38e0533d82e144f","52c7e49be259508735752fba88085255014a6ecf"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["9299079153fd7895bf3cf6835cf7019af2ba89b3","98a04f56464afdffd4c430d6c47a0c868a38354e"],"1d028314cced5858683a1bb4741423d0f934257b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a"],"33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"acf0fc8b8488d15344408e0ed0ab484f4a3e1bf2":["98b44240f64a2d6935543ff25faee750b29204eb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6b7c6630218ed9693cdb8643276513f9f0043f4":["3394716f52b34ab259ad5247e7595d9f9db6e935"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4"],"52c7e49be259508735752fba88085255014a6ecf":["7af110b00ea8df9429309d83e38e0533d82e144f"],"98b44240f64a2d6935543ff25faee750b29204eb":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["98a04f56464afdffd4c430d6c47a0c868a38354e"]},"commit2Childs":{"7af110b00ea8df9429309d83e38e0533d82e144f":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","3394716f52b34ab259ad5247e7595d9f9db6e935","52c7e49be259508735752fba88085255014a6ecf"],"978de4e2d23054c6624dd5928ddeb734dca68eec":["7af110b00ea8df9429309d83e38e0533d82e144f","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"98a04f56464afdffd4c430d6c47a0c868a38354e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"3394716f52b34ab259ad5247e7595d9f9db6e935":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","d6b7c6630218ed9693cdb8643276513f9f0043f4"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"1d028314cced5858683a1bb4741423d0f934257b":["978de4e2d23054c6624dd5928ddeb734dca68eec"],"33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a":["1d028314cced5858683a1bb4741423d0f934257b"],"acf0fc8b8488d15344408e0ed0ab484f4a3e1bf2":["98a04f56464afdffd4c430d6c47a0c868a38354e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1d028314cced5858683a1bb4741423d0f934257b","33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a"],"d6b7c6630218ed9693cdb8643276513f9f0043f4":["9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["98a04f56464afdffd4c430d6c47a0c868a38354e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","98b44240f64a2d6935543ff25faee750b29204eb"],"52c7e49be259508735752fba88085255014a6ecf":["3394716f52b34ab259ad5247e7595d9f9db6e935"],"98b44240f64a2d6935543ff25faee750b29204eb":["acf0fc8b8488d15344408e0ed0ab484f4a3e1bf2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}