{"path":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","commits":[{"id":"facd440f562ba04187b82c36465181d6ba7030fa","date":1181183679,"type":0,"author":"Doron Cohen","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"/dev/null","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new HitCollector() {\n      public void collect(int doc, float score) {\n        //System.out.println(\"doc=\"+doc);\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(s.getIndexReader());\n            TestCase.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.skipTo(i));\n            TestCase.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.doc(),doc,scorer.doc());\n            float skipToScore = scorer.score();\n            TestCase.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            TestCase.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    });\n    Weight w = q.weight(s);\n    Scorer scorer = w.scorer(s.getIndexReader());\n    boolean more = scorer.skipTo(lastDoc[0]+1);\n    if (more) \n      TestCase.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.doc(),more);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b52f4d438f568f7beafda3cf347790a4bfe32928","b52f4d438f568f7beafda3cf347790a4bfe32928"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"63bc3238545c6012bd44f5d294077997f236bc4e","date":1233087321,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new MultiReaderHitCollector() {\n      private int base = -1;\n      public void collect(int doc, float score) {\n        //System.out.println(\"doc=\"+doc);\n        doc = doc + base;\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(s.getIndexReader());\n            TestCase.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.skipTo(i));\n            TestCase.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.doc(),doc,scorer.doc());\n            float skipToScore = scorer.score();\n            TestCase.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            TestCase.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n    });\n    Weight w = q.weight(s);\n    Scorer scorer = w.scorer(s.getIndexReader());\n    boolean more = scorer.skipTo(lastDoc[0]+1);\n    if (more) \n      TestCase.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.doc(),more);\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new HitCollector() {\n      public void collect(int doc, float score) {\n        //System.out.println(\"doc=\"+doc);\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(s.getIndexReader());\n            TestCase.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.skipTo(i));\n            TestCase.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.doc(),doc,scorer.doc());\n            float skipToScore = scorer.score();\n            TestCase.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            TestCase.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    });\n    Weight w = q.weight(s);\n    Scorer scorer = w.scorer(s.getIndexReader());\n    boolean more = scorer.skipTo(lastDoc[0]+1);\n    if (more) \n      TestCase.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.doc(),more);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"64714133cf5ec732e3bbceee63351bb9af0117dc","date":1239647636,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        doc = doc + base;\n        float score = scorer.score();\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(s.getIndexReader());\n            TestCase.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.skipTo(i));\n            TestCase.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.doc(),doc,scorer.doc());\n            float skipToScore = scorer.score();\n            TestCase.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            TestCase.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n    });\n    Weight w = q.weight(s);\n    Scorer scorer = w.scorer(s.getIndexReader());\n    boolean more = scorer.skipTo(lastDoc[0]+1);\n    if (more) \n      TestCase.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.doc(),more);\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new MultiReaderHitCollector() {\n      private int base = -1;\n      public void collect(int doc, float score) {\n        //System.out.println(\"doc=\"+doc);\n        doc = doc + base;\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(s.getIndexReader());\n            TestCase.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.skipTo(i));\n            TestCase.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.doc(),doc,scorer.doc());\n            float skipToScore = scorer.score();\n            TestCase.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            TestCase.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n    });\n    Weight w = q.weight(s);\n    Scorer scorer = w.scorer(s.getIndexReader());\n    boolean more = scorer.skipTo(lastDoc[0]+1);\n    if (more) \n      TestCase.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.doc(),more);\n  }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30a558487f2298c2c19ceca9103c1b6865d64708","date":1244393921,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        doc = doc + base;\n        float score = scorer.score();\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(s.getIndexReader());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n    });\n    Weight w = q.weight(s);\n    Scorer scorer = w.scorer(s.getIndexReader());\n    boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n    if (more) \n      Assert.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        doc = doc + base;\n        float score = scorer.score();\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(s.getIndexReader());\n            TestCase.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.skipTo(i));\n            TestCase.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.doc(),doc,scorer.doc());\n            float skipToScore = scorer.score();\n            TestCase.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            TestCase.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n    });\n    Weight w = q.weight(s);\n    Scorer scorer = w.scorer(s.getIndexReader());\n    boolean more = scorer.skipTo(lastDoc[0]+1);\n    if (more) \n      TestCase.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.doc(),more);\n  }\n\n","bugFix":null,"bugIntro":["b52f4d438f568f7beafda3cf347790a4bfe32928","b52f4d438f568f7beafda3cf347790a4bfe32928"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"052fac7830290bd38a04cddee1a121ee07656b56","date":1245780702,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        doc = doc + base;\n        float score = scorer.score();\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            QueryWeight w = q.queryWeight(s);\n            Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    QueryWeight w = q.queryWeight(s);\n    Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n    boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n    if (more) \n      Assert.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        doc = doc + base;\n        float score = scorer.score();\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(s.getIndexReader());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n    });\n    Weight w = q.weight(s);\n    Scorer scorer = w.scorer(s.getIndexReader());\n    boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n    if (more) \n      Assert.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d6c98c690b593cea727f68742684c979ead1a0a","date":1248688202,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        doc = doc + base;\n        float score = scorer.score();\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            QueryWeight w = q.queryWeight(s);\n            Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    QueryWeight w = q.queryWeight(s);\n    Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n    if (scorer != null) {\n      boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n      if (more) \n        Assert.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        doc = doc + base;\n        float score = scorer.score();\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            QueryWeight w = q.queryWeight(s);\n            Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    QueryWeight w = q.queryWeight(s);\n    Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n    boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n    if (more) \n      Assert.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe941135bdfc28c81e20b4d21422f8726af34925","date":1250040150,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        doc = doc + base;\n        float score = scorer.score();\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    Weight w = q.weight(s);\n    Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n    if (scorer != null) {\n      boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n      if (more) \n        Assert.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        doc = doc + base;\n        float score = scorer.score();\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            QueryWeight w = q.queryWeight(s);\n            Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    QueryWeight w = q.queryWeight(s);\n    Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n    if (scorer != null) {\n      boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n      if (more) \n        Assert.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e69f59b863731d864bf3047235e718f0f88f8841","date":1250105498,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.reader = reader;\n        lastDoc[0] = -1;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    \n    IndexReader[] readers = s.getIndexReader().getSequentialSubReaders();\n    for(int i = 0; i < readers.length; i++) {\n      IndexReader reader = readers[i];\n      Weight w = q.weight(s);\n      Scorer scorer = w.scorer(reader, true, false);\n      \n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n  \n        if (more && lastDoc[0] != -1) \n          Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private int base = 0;\n      private Scorer scorer;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        doc = doc + base;\n        float score = scorer.score();\n        try {\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        base = docBase;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    Weight w = q.weight(s);\n    Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n    if (scorer != null) {\n      boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n      if (more) \n        Assert.assertFalse(\"query's last doc was \"+lastDoc[0]+\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ffe619bf5bbe00453bab7103c36fd38c8417f6c","date":1250619947,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.reader = reader;\n        lastDoc[0] = -1;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    \n    List readerList = new ArrayList();\n    ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n    IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);\n    for(int i = 0; i < readers.length; i++) {\n      IndexReader reader = readers[i];\n      Weight w = q.weight(s);\n      Scorer scorer = w.scorer(reader, true, false);\n      \n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n  \n        if (more && lastDoc[0] != -1) \n          Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.reader = reader;\n        lastDoc[0] = -1;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    \n    IndexReader[] readers = s.getIndexReader().getSequentialSubReaders();\n    for(int i = 0; i < readers.length; i++) {\n      IndexReader reader = readers[i];\n      Weight w = q.weight(s);\n      Scorer scorer = w.scorer(reader, true, false);\n      \n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n  \n        if (more && lastDoc[0] != -1) \n          Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"131a9e895609b4da33662dc087e0bc6303e1e29c","date":1255458397,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.reader = reader;\n        lastDoc[0] = -1;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    \n    List<IndexReader> readerList = new ArrayList<IndexReader>();\n    ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n    IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);\n    for(int i = 0; i < readers.length; i++) {\n      IndexReader reader = readers[i];\n      Weight w = q.weight(s);\n      Scorer scorer = w.scorer(reader, true, false);\n      \n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n  \n        if (more && lastDoc[0] != -1) \n          Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.reader = reader;\n        lastDoc[0] = -1;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    \n    List readerList = new ArrayList();\n    ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n    IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);\n    for(int i = 0; i < readers.length; i++) {\n      IndexReader reader = readers[i];\n      Weight w = q.weight(s);\n      Scorer scorer = w.scorer(reader, true, false);\n      \n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n  \n        if (more && lastDoc[0] != -1) \n          Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1326054a8d3aa66382d49decc7f330955c9c6f71","date":1257386139,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.reader = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    \n    List<IndexReader> readerList = new ArrayList<IndexReader>();\n    ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n    IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);\n    for(int i = 0; i < readers.length; i++) {\n      IndexReader reader = readers[i];\n      Weight w = q.weight(s);\n      Scorer scorer = w.scorer(reader, true, false);\n      \n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n  \n        if (more && lastDoc[0] != -1) \n          Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.reader = reader;\n        lastDoc[0] = -1;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    \n    List<IndexReader> readerList = new ArrayList<IndexReader>();\n    ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n    IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);\n    for(int i = 0; i < readers.length; i++) {\n      IndexReader reader = readers[i];\n      Weight w = q.weight(s);\n      Scorer scorer = w.scorer(reader, true, false);\n      \n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n  \n        if (more && lastDoc[0] != -1) \n          Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e450c7d50c2fc84c963d0d7ade9d3217d868064d","date":1259932067,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.reader = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    \n    List<IndexReader> readerList = new ArrayList<IndexReader>();\n    ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n    IndexReader[] readers = readerList.toArray(new IndexReader[0]);\n    for(int i = 0; i < readers.length; i++) {\n      IndexReader reader = readers[i];\n      Weight w = q.weight(s);\n      Scorer scorer = w.scorer(reader, true, false);\n      \n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n  \n        if (more && lastDoc[0] != -1) \n          Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.reader = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    \n    List<IndexReader> readerList = new ArrayList<IndexReader>();\n    ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n    IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);\n    for(int i = 0; i < readers.length; i++) {\n      IndexReader reader = readers[i];\n      Weight w = q.weight(s);\n      Scorer scorer = w.scorer(reader, true, false);\n      \n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n  \n        if (more && lastDoc[0] != -1) \n          Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f5d8d97303550346f85fd577f90d64cf196cebd1","date":1262890343,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.reader = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n    \n    List<IndexReader> readerList = new ArrayList<IndexReader>();\n    ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n    IndexReader[] readers = readerList.toArray(new IndexReader[0]);\n    for(int i = 0; i < readers.length; i++) {\n      IndexReader reader = readers[i];\n      Weight w = q.weight(s);\n      Scorer scorer = w.scorer(reader, true, false);\n      \n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n  \n        if (more && lastDoc[0] != -1) \n          Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["b52f4d438f568f7beafda3cf347790a4bfe32928","b52f4d438f568f7beafda3cf347790a4bfe32928"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"1ffe619bf5bbe00453bab7103c36fd38c8417f6c":["e69f59b863731d864bf3047235e718f0f88f8841"],"64714133cf5ec732e3bbceee63351bb9af0117dc":["63bc3238545c6012bd44f5d294077997f236bc4e"],"e69f59b863731d864bf3047235e718f0f88f8841":["fe941135bdfc28c81e20b4d21422f8726af34925"],"131a9e895609b4da33662dc087e0bc6303e1e29c":["1ffe619bf5bbe00453bab7103c36fd38c8417f6c"],"fe941135bdfc28c81e20b4d21422f8726af34925":["8d6c98c690b593cea727f68742684c979ead1a0a"],"e450c7d50c2fc84c963d0d7ade9d3217d868064d":["1326054a8d3aa66382d49decc7f330955c9c6f71"],"63bc3238545c6012bd44f5d294077997f236bc4e":["facd440f562ba04187b82c36465181d6ba7030fa"],"facd440f562ba04187b82c36465181d6ba7030fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1326054a8d3aa66382d49decc7f330955c9c6f71":["131a9e895609b4da33662dc087e0bc6303e1e29c"],"30a558487f2298c2c19ceca9103c1b6865d64708":["64714133cf5ec732e3bbceee63351bb9af0117dc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8d6c98c690b593cea727f68742684c979ead1a0a":["052fac7830290bd38a04cddee1a121ee07656b56"],"f5d8d97303550346f85fd577f90d64cf196cebd1":["e450c7d50c2fc84c963d0d7ade9d3217d868064d"],"052fac7830290bd38a04cddee1a121ee07656b56":["30a558487f2298c2c19ceca9103c1b6865d64708"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["f5d8d97303550346f85fd577f90d64cf196cebd1"]},"commit2Childs":{"1ffe619bf5bbe00453bab7103c36fd38c8417f6c":["131a9e895609b4da33662dc087e0bc6303e1e29c"],"64714133cf5ec732e3bbceee63351bb9af0117dc":["30a558487f2298c2c19ceca9103c1b6865d64708"],"e69f59b863731d864bf3047235e718f0f88f8841":["1ffe619bf5bbe00453bab7103c36fd38c8417f6c"],"fe941135bdfc28c81e20b4d21422f8726af34925":["e69f59b863731d864bf3047235e718f0f88f8841"],"131a9e895609b4da33662dc087e0bc6303e1e29c":["1326054a8d3aa66382d49decc7f330955c9c6f71"],"e450c7d50c2fc84c963d0d7ade9d3217d868064d":["f5d8d97303550346f85fd577f90d64cf196cebd1"],"63bc3238545c6012bd44f5d294077997f236bc4e":["64714133cf5ec732e3bbceee63351bb9af0117dc"],"facd440f562ba04187b82c36465181d6ba7030fa":["63bc3238545c6012bd44f5d294077997f236bc4e"],"1326054a8d3aa66382d49decc7f330955c9c6f71":["e450c7d50c2fc84c963d0d7ade9d3217d868064d"],"30a558487f2298c2c19ceca9103c1b6865d64708":["052fac7830290bd38a04cddee1a121ee07656b56"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["facd440f562ba04187b82c36465181d6ba7030fa"],"8d6c98c690b593cea727f68742684c979ead1a0a":["fe941135bdfc28c81e20b4d21422f8726af34925"],"f5d8d97303550346f85fd577f90d64cf196cebd1":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"052fac7830290bd38a04cddee1a121ee07656b56":["8d6c98c690b593cea727f68742684c979ead1a0a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}