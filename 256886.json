{"path":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","commits":[{"id":"e230a61047bc041516c811baa08a7174d6f8322a","date":1306175633,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1b3a24d5d9b47345473ff564f5cc127a7b526b4","date":1306277076,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToChars(spare).toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e230a61047bc041516c811baa08a7174d6f8322a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a1b3a24d5d9b47345473ff564f5cc127a7b526b4":["e230a61047bc041516c811baa08a7174d6f8322a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a1b3a24d5d9b47345473ff564f5cc127a7b526b4"]},"commit2Childs":{"e230a61047bc041516c811baa08a7174d6f8322a":["a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e230a61047bc041516c811baa08a7174d6f8322a"],"a1b3a24d5d9b47345473ff564f5cc127a7b526b4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}