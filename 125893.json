{"path":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","commits":[{"id":"b1add9ddc0005b07550d4350720aac22dc9886b3","date":1295549635,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","pathOld":"/dev/null","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (!omitTF) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipInterval) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // TODO: this is somewhat wasteful; eg if no terms in\n      // this block will use skip data, we don't need to\n      // write this:\n      final long skipFP = skipOut.getFilePointer();\n      indexBytesWriter.writeVLong(skipFP);\n      lastSkipFP = skipFP;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","pathOld":"/dev/null","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (!omitTF) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipInterval) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // TODO: this is somewhat wasteful; eg if no terms in\n      // this block will use skip data, we don't need to\n      // write this:\n      final long skipFP = skipOut.getFilePointer();\n      indexBytesWriter.writeVLong(skipFP);\n      lastSkipFP = skipFP;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","pathOld":"/dev/null","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (!omitTF) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipInterval) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // TODO: this is somewhat wasteful; eg if no terms in\n      // this block will use skip data, we don't need to\n      // write this:\n      final long skipFP = skipOut.getFilePointer();\n      indexBytesWriter.writeVLong(skipFP);\n      lastSkipFP = skipFP;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aff28d83336d21b964812b94574b7e8cea46a3cc","date":1297437050,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (!omitTF) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipMinimum) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // TODO: this is somewhat wasteful; eg if no terms in\n      // this block will use skip data, we don't need to\n      // write this:\n      final long skipFP = skipOut.getFilePointer();\n      indexBytesWriter.writeVLong(skipFP);\n      lastSkipFP = skipFP;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (!omitTF) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipInterval) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // TODO: this is somewhat wasteful; eg if no terms in\n      // this block will use skip data, we don't need to\n      // write this:\n      final long skipFP = skipOut.getFilePointer();\n      indexBytesWriter.writeVLong(skipFP);\n      lastSkipFP = skipFP;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b02ab28f4a5f9d03621ae130b7dd96af1f302ed8","date":1297945369,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (!omitTF) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipMinimum) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // lazily write an absolute delta if a term in this block requires skip data.\n      lastSkipFP = 0;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (!omitTF) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipMinimum) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // TODO: this is somewhat wasteful; eg if no terms in\n      // this block will use skip data, we don't need to\n      // write this:\n      final long skipFP = skipOut.getFilePointer();\n      indexBytesWriter.writeVLong(skipFP);\n      lastSkipFP = skipFP;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (!omitTF) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipMinimum) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // lazily write an absolute delta if a term in this block requires skip data.\n      lastSkipFP = 0;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (!omitTF) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipInterval) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // TODO: this is somewhat wasteful; eg if no terms in\n      // this block will use skip data, we don't need to\n      // write this:\n      final long skipFP = skipOut.getFilePointer();\n      indexBytesWriter.writeVLong(skipFP);\n      lastSkipFP = skipFP;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (!omitTF) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipMinimum) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // lazily write an absolute delta if a term in this block requires skip data.\n      lastSkipFP = 0;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (!omitTF) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipInterval) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // TODO: this is somewhat wasteful; eg if no terms in\n      // this block will use skip data, we don't need to\n      // write this:\n      final long skipFP = skipOut.getFilePointer();\n      indexBytesWriter.writeVLong(skipFP);\n      lastSkipFP = skipFP;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2afd23a6f1242190c3409d8d81d5c5912d607fc9","date":1310477482,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (indexOptions != IndexOptions.DOCS_ONLY) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n    }\n\n    if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipMinimum) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // lazily write an absolute delta if a term in this block requires skip data.\n      lastSkipFP = 0;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (!omitTF) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipMinimum) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // lazily write an absolute delta if a term in this block requires skip data.\n      lastSkipFP = 0;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/sep/SepPostingsWriterImpl#finishTerm(TermStats).mjava","sourceNew":null,"sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    // TODO: -- wasteful we are counting this in two places?\n    assert stats.docFreq > 0;\n    assert stats.docFreq == df;\n\n    final boolean isFirstTerm = pendingTermCount == 0;  \n    //System.out.println(\"SepW.finishTerm: isFirstTerm=\" + isFirstTerm);\n\n    docIndex.write(indexBytesWriter, isFirstTerm);\n    //System.out.println(\"  docIndex=\" + docIndex);\n\n    if (indexOptions != IndexOptions.DOCS_ONLY) {\n      freqIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  freqIndex=\" + freqIndex);\n    }\n\n    if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n      posIndex.write(indexBytesWriter, isFirstTerm);\n      //System.out.println(\"  posIndex=\" + posIndex);\n      if (storePayloads) {\n        if (isFirstTerm) {\n          indexBytesWriter.writeVLong(payloadStart);\n        } else {\n          indexBytesWriter.writeVLong(payloadStart - lastPayloadStart);\n        }\n        lastPayloadStart = payloadStart;\n        //System.out.println(\"  payloadFP=\" + payloadStart);\n      }\n    }\n\n    if (df >= skipMinimum) {\n      //System.out.println(\"  skipFP=\" + skipStart);\n      final long skipFP = skipOut.getFilePointer();\n      skipListWriter.writeSkip(skipOut);\n      //System.out.println(\"   writeSkip @ \" + indexBytesWriter.getFilePointer());\n      if (isFirstTerm) {\n        indexBytesWriter.writeVLong(skipFP);\n      } else {\n        indexBytesWriter.writeVLong(skipFP - lastSkipFP);\n      }\n      lastSkipFP = skipFP;\n    } else if (isFirstTerm) {\n      // lazily write an absolute delta if a term in this block requires skip data.\n      lastSkipFP = 0;\n    }\n\n    lastDocID = 0;\n    df = 0;\n    pendingTermCount++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["2afd23a6f1242190c3409d8d81d5c5912d607fc9"],"2afd23a6f1242190c3409d8d81d5c5912d607fc9":["b02ab28f4a5f9d03621ae130b7dd96af1f302ed8"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["29ef99d61cda9641b6250bf9567329a6e65f901d","b02ab28f4a5f9d03621ae130b7dd96af1f302ed8"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b1add9ddc0005b07550d4350720aac22dc9886b3"],"aff28d83336d21b964812b94574b7e8cea46a3cc":["b1add9ddc0005b07550d4350720aac22dc9886b3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b1add9ddc0005b07550d4350720aac22dc9886b3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b1add9ddc0005b07550d4350720aac22dc9886b3"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["e79a6d080bdd5b2a8f56342cf571b5476de04180","b02ab28f4a5f9d03621ae130b7dd96af1f302ed8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"b02ab28f4a5f9d03621ae130b7dd96af1f302ed8":["aff28d83336d21b964812b94574b7e8cea46a3cc"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2afd23a6f1242190c3409d8d81d5c5912d607fc9":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":[],"29ef99d61cda9641b6250bf9567329a6e65f901d":["f1bdbf92da222965b46c0a942c3857ba56e5c638"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["29ef99d61cda9641b6250bf9567329a6e65f901d","b1add9ddc0005b07550d4350720aac22dc9886b3","e79a6d080bdd5b2a8f56342cf571b5476de04180"],"aff28d83336d21b964812b94574b7e8cea46a3cc":["b02ab28f4a5f9d03621ae130b7dd96af1f302ed8"],"b1add9ddc0005b07550d4350720aac22dc9886b3":["29ef99d61cda9641b6250bf9567329a6e65f901d","aff28d83336d21b964812b94574b7e8cea46a3cc","e79a6d080bdd5b2a8f56342cf571b5476de04180"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"b02ab28f4a5f9d03621ae130b7dd96af1f302ed8":["2afd23a6f1242190c3409d8d81d5c5912d607fc9","f1bdbf92da222965b46c0a942c3857ba56e5c638","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f1bdbf92da222965b46c0a942c3857ba56e5c638","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}