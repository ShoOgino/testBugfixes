{"path":"solr/core/src/java/org/apache/solr/api/V2HttpCall#resolveDocCollection(String).mjava","commits":[{"id":"8e81b6aab54e3749e1502c221e0bc9dbd3f91e15","date":1525806607,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#resolveDocCollection(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Lookup the collection from the collection string (maybe comma delimited).\n   * Also sets {@link #collectionsList} by side-effect.\n   * if {@code secondTry} is false then we'll potentially recursively try this all one more time while ensuring\n   * the alias and collection info is sync'ed from ZK.\n   */\n  protected DocCollection resolveDocCollection(String collectionStr) {\n    if (!cores.isZooKeeperAware()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Solr not running in cloud mode \");\n    }\n    ZkStateReader zkStateReader = cores.getZkController().getZkStateReader();\n\n    Supplier<DocCollection> logic = () -> {\n      this.collectionsList = resolveCollectionListOrAlias(collectionStr); // side-effect\n      String collectionName = collectionsList.get(0); // first\n      //TODO an option to choose another collection in the list if can't find a local replica of the first?\n\n      return zkStateReader.getClusterState().getCollectionOrNull(collectionName);\n    };\n\n    DocCollection docCollection = logic.get();\n    if (docCollection != null) {\n      return docCollection;\n    }\n    // ensure our view is up to date before trying again\n    try {\n      zkStateReader.aliasesManager.update();\n      zkStateReader.forceUpdateCollection(collectionsList.get(0));\n    } catch (Exception e) {\n      log.error(\"Error trying to update state while resolving collection.\", e);\n      //don't propagate exception on purpose\n    }\n    return logic.get();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"813335f324f8bd40ae4d83d8391674b42b536cc0","date":1555591986,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#resolveDocCollection(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#resolveDocCollection(String).mjava","sourceNew":"  /**\n   * Lookup the collection from the collection string (maybe comma delimited).\n   * Also sets {@link #collectionsList} by side-effect.\n   * if {@code secondTry} is false then we'll potentially recursively try this all one more time while ensuring\n   * the alias and collection info is sync'ed from ZK.\n   */\n  protected DocCollection resolveDocCollection(String collectionStr) {\n    if (!cores.isZooKeeperAware()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Solr not running in cloud mode \");\n    }\n    ZkStateReader zkStateReader = cores.getZkController().getZkStateReader();\n\n    Supplier<DocCollection> logic = () -> {\n      this.collectionsList = resolveCollectionListOrAlias(collectionStr); // side-effect\n      if (collectionsList.size() > 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Request must be sent to a single collection \" +\n            \"or an alias that points to a single collection,\" +\n            \" but '\" + collectionStr + \"' resolves to \" + this.collectionsList);\n      }\n      String collectionName = collectionsList.get(0); // first\n      //TODO an option to choose another collection in the list if can't find a local replica of the first?\n\n      return zkStateReader.getClusterState().getCollectionOrNull(collectionName);\n    };\n\n    DocCollection docCollection = logic.get();\n    if (docCollection != null) {\n      return docCollection;\n    }\n    // ensure our view is up to date before trying again\n    try {\n      zkStateReader.aliasesManager.update();\n      zkStateReader.forceUpdateCollection(collectionsList.get(0));\n    } catch (Exception e) {\n      log.error(\"Error trying to update state while resolving collection.\", e);\n      //don't propagate exception on purpose\n    }\n    return logic.get();\n  }\n\n","sourceOld":"  /**\n   * Lookup the collection from the collection string (maybe comma delimited).\n   * Also sets {@link #collectionsList} by side-effect.\n   * if {@code secondTry} is false then we'll potentially recursively try this all one more time while ensuring\n   * the alias and collection info is sync'ed from ZK.\n   */\n  protected DocCollection resolveDocCollection(String collectionStr) {\n    if (!cores.isZooKeeperAware()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Solr not running in cloud mode \");\n    }\n    ZkStateReader zkStateReader = cores.getZkController().getZkStateReader();\n\n    Supplier<DocCollection> logic = () -> {\n      this.collectionsList = resolveCollectionListOrAlias(collectionStr); // side-effect\n      String collectionName = collectionsList.get(0); // first\n      //TODO an option to choose another collection in the list if can't find a local replica of the first?\n\n      return zkStateReader.getClusterState().getCollectionOrNull(collectionName);\n    };\n\n    DocCollection docCollection = logic.get();\n    if (docCollection != null) {\n      return docCollection;\n    }\n    // ensure our view is up to date before trying again\n    try {\n      zkStateReader.aliasesManager.update();\n      zkStateReader.forceUpdateCollection(collectionsList.get(0));\n    } catch (Exception e) {\n      log.error(\"Error trying to update state while resolving collection.\", e);\n      //don't propagate exception on purpose\n    }\n    return logic.get();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8e81b6aab54e3749e1502c221e0bc9dbd3f91e15":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"813335f324f8bd40ae4d83d8391674b42b536cc0":["8e81b6aab54e3749e1502c221e0bc9dbd3f91e15"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["813335f324f8bd40ae4d83d8391674b42b536cc0"]},"commit2Childs":{"8e81b6aab54e3749e1502c221e0bc9dbd3f91e15":["813335f324f8bd40ae4d83d8391674b42b536cc0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8e81b6aab54e3749e1502c221e0bc9dbd3f91e15"],"813335f324f8bd40ae4d83d8391674b42b536cc0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}