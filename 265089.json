{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(long[],byte[]).mjava","commits":[{"id":"9fc0d60683b47b5d922124c31f57c8b34734f9e6","date":1480846684,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(long[],byte[]).mjava","pathOld":"/dev/null","sourceNew":"  /** Packs the two arrays, representing a balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n\n    int numLeaves = leafBlockFPs.length;\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by OneDimensionBKDWriter).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      int levelCount = 2;\n      while (true) {\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    /** Reused while packing the index */\n    RAMOutputStream writeBuffer = new RAMOutputStream();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, 0l, blocks, 1, lastSplitValues, new boolean[numDims], false);\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(long[],byte[]).mjava","pathOld":"/dev/null","sourceNew":"  /** Packs the two arrays, representing a balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n\n    int numLeaves = leafBlockFPs.length;\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by OneDimensionBKDWriter).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      int levelCount = 2;\n      while (true) {\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    /** Reused while packing the index */\n    RAMOutputStream writeBuffer = new RAMOutputStream();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, 0l, blocks, 1, lastSplitValues, new boolean[numDims], false);\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(long[],byte[]).mjava","sourceNew":"  /** Packs the two arrays, representing a balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n\n    int numLeaves = leafBlockFPs.length;\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by OneDimensionBKDWriter).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numIndexDims == 1 && numLeaves > 1) {\n      int levelCount = 2;\n      while (true) {\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    /** Reused while packing the index */\n    RAMOutputStream writeBuffer = new RAMOutputStream();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numIndexDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, 0l, blocks, 1, lastSplitValues, new boolean[numIndexDims], false);\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","sourceOld":"  /** Packs the two arrays, representing a balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n\n    int numLeaves = leafBlockFPs.length;\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by OneDimensionBKDWriter).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      int levelCount = 2;\n      while (true) {\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    /** Reused while packing the index */\n    RAMOutputStream writeBuffer = new RAMOutputStream();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, 0l, blocks, 1, lastSplitValues, new boolean[numDims], false);\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"409da428f28953cf35fddd5c9ff5c7e4f5439863","date":1547556145,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(long[],byte[]).mjava","sourceNew":"  /** Packs the two arrays, representing a balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n\n    int numLeaves = leafBlockFPs.length;\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by OneDimensionBKDWriter).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numIndexDims == 1 && numLeaves > 1) {\n      int levelCount = 2;\n      while (true) {\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    /** Reused while packing the index */\n    ByteBuffersDataOutput writeBuffer = ByteBuffersDataOutput.newResettableInstance();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numIndexDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, 0l, blocks, 1, lastSplitValues, new boolean[numIndexDims], false);\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","sourceOld":"  /** Packs the two arrays, representing a balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n\n    int numLeaves = leafBlockFPs.length;\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by OneDimensionBKDWriter).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numIndexDims == 1 && numLeaves > 1) {\n      int levelCount = 2;\n      while (true) {\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    /** Reused while packing the index */\n    RAMOutputStream writeBuffer = new RAMOutputStream();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numIndexDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, 0l, blocks, 1, lastSplitValues, new boolean[numIndexDims], false);\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7","date":1588412059,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(long[],byte[]).mjava","sourceNew":"  /** Packs the two arrays, representing a semi-balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    int numLeaves = leafBlockFPs.length;\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree.\n    // In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    int lastFullLevel = 31 - Integer.numberOfLeadingZeros(numLeaves);\n    int leavesFullLevel = 1 << lastFullLevel;\n    int leavesPartialLevel = 2 * (numLeaves - leavesFullLevel);\n    if (leavesPartialLevel != 0) {\n      // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n      // at read-time, so that we can still delta code them on disk at write:\n      long[] newLeafBlockFPs = new long[numLeaves];\n      System.arraycopy(leafBlockFPs, leavesPartialLevel, newLeafBlockFPs, 0, numLeaves - leavesPartialLevel);\n      System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, numLeaves - leavesPartialLevel, leavesPartialLevel);\n      leafBlockFPs = newLeafBlockFPs;\n    }\n    /** Reused while packing the index */\n    ByteBuffersDataOutput writeBuffer = ByteBuffersDataOutput.newResettableInstance();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numIndexDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, 0l, blocks, 1, lastSplitValues, new boolean[numIndexDims], false);\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","sourceOld":"  /** Packs the two arrays, representing a balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n\n    int numLeaves = leafBlockFPs.length;\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by OneDimensionBKDWriter).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numIndexDims == 1 && numLeaves > 1) {\n      int levelCount = 2;\n      while (true) {\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    /** Reused while packing the index */\n    ByteBuffersDataOutput writeBuffer = ByteBuffersDataOutput.newResettableInstance();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numIndexDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, 0l, blocks, 1, lastSplitValues, new boolean[numIndexDims], false);\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"125e5eeb7e933deec0cc0510c2368fe1ec7c36ce","date":1589215155,"type":5,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(BKDTreeLeafNodes).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(long[],byte[]).mjava","sourceNew":"  /** Packs the two arrays, representing a semi-balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(BKDTreeLeafNodes leafNodes) throws IOException {\n    /** Reused while packing the index */\n    ByteBuffersDataOutput writeBuffer = ByteBuffersDataOutput.newResettableInstance();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numIndexDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafNodes, 0l, blocks, lastSplitValues, new boolean[numIndexDims], false,\n        0, leafNodes.numLeaves());\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","sourceOld":"  /** Packs the two arrays, representing a semi-balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    int numLeaves = leafBlockFPs.length;\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree.\n    // In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    int lastFullLevel = 31 - Integer.numberOfLeadingZeros(numLeaves);\n    int leavesFullLevel = 1 << lastFullLevel;\n    int leavesPartialLevel = 2 * (numLeaves - leavesFullLevel);\n    if (leavesPartialLevel != 0) {\n      // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n      // at read-time, so that we can still delta code them on disk at write:\n      long[] newLeafBlockFPs = new long[numLeaves];\n      System.arraycopy(leafBlockFPs, leavesPartialLevel, newLeafBlockFPs, 0, numLeaves - leavesPartialLevel);\n      System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, numLeaves - leavesPartialLevel, leavesPartialLevel);\n      leafBlockFPs = newLeafBlockFPs;\n    }\n    /** Reused while packing the index */\n    ByteBuffersDataOutput writeBuffer = ByteBuffersDataOutput.newResettableInstance();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numIndexDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, 0l, blocks, 1, lastSplitValues, new boolean[numIndexDims], false);\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["f6652c943595e92c187ee904c382863013eae28f"],"f6652c943595e92c187ee904c382863013eae28f":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"125e5eeb7e933deec0cc0510c2368fe1ec7c36ce":["d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"9856095f7afb5a607bf5e65077615ed91273508c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["125e5eeb7e933deec0cc0510c2368fe1ec7c36ce"]},"commit2Childs":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["f6652c943595e92c187ee904c382863013eae28f","9856095f7afb5a607bf5e65077615ed91273508c"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7"],"f6652c943595e92c187ee904c382863013eae28f":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9fc0d60683b47b5d922124c31f57c8b34734f9e6","9856095f7afb5a607bf5e65077615ed91273508c"],"125e5eeb7e933deec0cc0510c2368fe1ec7c36ce":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d3929a60a731a8848bb9bc0bbfd3c5e3d59195e7":["125e5eeb7e933deec0cc0510c2368fe1ec7c36ce"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}