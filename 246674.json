{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimNodeStateProvider#getReplicaMetricsValues(String,Collection[String]).mjava","commits":[{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimNodeStateProvider#getReplicaMetricsValues(String,Collection[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimNodeStateProvider#getReplicaMetricsValues(String,Collection[String]).mjava","sourceNew":"  /**\n   * Simulate getting replica metrics values. This uses per-replica properties set in\n   * {@link SimClusterStateProvider#simSetCollectionValue(String, String, Object, boolean, boolean)} and\n   * similar methods.\n   * @param node node id\n   * @param tags metrics names\n   * @return map of metrics names / values\n   */\n  public Map<String, Object> getReplicaMetricsValues(String node, Collection<String> tags) {\n    if (!liveNodesSet.contains(node)) {\n      throw new RuntimeException(\"non-live node \" + node);\n    }\n    Map<String, Object> values = new HashMap<>();\n    for (String tag : tags) {\n      Matcher m = METRIC_KEY_PATTERN.matcher(tag);\n      if (!m.matches() || m.groupCount() < 2) {\n        log.warn(\"Invalid metrics: tag: \" + tag);\n        continue;\n      }\n      String registryName = m.group(1);\n      String key = m.group(3) != null ? m.group(2) + m.group(3) : m.group(2);\n      if (!registryName.startsWith(\"solr.core.\")) {\n        // skip - this is probably solr.node or solr.jvm metric\n        continue;\n      }\n      m = REGISTRY_PATTERN.matcher(registryName);\n\n      if (!m.matches()) {\n        log.warn(\"Invalid registry name: \" + registryName);\n        continue;\n      }\n      String collection = m.group(1);\n      String shard = m.group(2);\n      String replica = m.group(3);\n      List<ReplicaInfo> replicas = clusterStateProvider.simGetReplicaInfos(collection, shard);\n      replicas.forEach(r -> {\n        if (r.getNode().equals(node) && r.getCore().endsWith(replica)) {\n          Object value = r.getVariables().get(key);\n          if (value != null) {\n            values.put(tag, value);\n          } else {\n            value = r.getVariables().get(tag);\n            if (value != null) {\n              values.put(tag, value);\n            }\n          }\n        }\n      });\n    }\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Simulate getting replica metrics values. This uses per-replica properties set in\n   * {@link SimClusterStateProvider#simSetCollectionValue(String, String, Object, boolean, boolean)} and\n   * similar methods.\n   * @param node node id\n   * @param tags metrics names\n   * @return map of metrics names / values\n   */\n  public Map<String, Object> getReplicaMetricsValues(String node, Collection<String> tags) {\n    if (!liveNodesSet.contains(node)) {\n      throw new RuntimeException(\"non-live node \" + node);\n    }\n    Map<String, Object> values = new HashMap<>();\n    for (String tag : tags) {\n      Matcher m = METRIC_KEY_PATTERN.matcher(tag);\n      if (!m.matches() || m.groupCount() < 2) {\n        log.warn(\"Invalid metrics: tag: \" + tag);\n        continue;\n      }\n      String registryName = m.group(1);\n      String key = m.group(3) != null ? m.group(2) + m.group(3) : m.group(2);\n      if (!registryName.startsWith(\"solr.core.\")) {\n        // skip - this is probably solr.node or solr.jvm metric\n        continue;\n      }\n      m = REGISTRY_PATTERN.matcher(registryName);\n\n      if (!m.matches()) {\n        log.warn(\"Invalid registry name: \" + registryName);\n        continue;\n      }\n      String collection = m.group(1);\n      String shard = m.group(2);\n      String replica = m.group(3);\n      List<ReplicaInfo> replicas = clusterStateProvider.simGetReplicaInfos(collection, shard);\n      replicas.forEach(r -> {\n        if (r.getNode().equals(node) && r.getCore().endsWith(replica)) {\n          Object value = r.getVariables().get(key);\n          if (value != null) {\n            values.put(tag, value);\n          } else {\n            value = r.getVariables().get(tag);\n            if (value != null) {\n              values.put(tag, value);\n            }\n          }\n        }\n      });\n    }\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e35f2dde06b35aa9904949a3a93fabd090371077","date":1587906921,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimNodeStateProvider#getReplicaMetricsValues(String,Collection[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimNodeStateProvider#getReplicaMetricsValues(String,Collection[String]).mjava","sourceNew":"  /**\n   * Simulate getting replica metrics values. This uses per-replica properties set in\n   * {@link SimClusterStateProvider#simSetCollectionValue(String, String, Object, boolean, boolean)} and\n   * similar methods.\n   * @param node node id\n   * @param tags metrics names\n   * @return map of metrics names / values\n   */\n  public Map<String, Object> getReplicaMetricsValues(String node, Collection<String> tags) {\n    if (!liveNodesSet.contains(node)) {\n      throw new RuntimeException(\"non-live node \" + node);\n    }\n    Map<String, Object> values = new HashMap<>();\n    for (String tag : tags) {\n      Matcher m = METRIC_KEY_PATTERN.matcher(tag);\n      if (!m.matches() || m.groupCount() < 2) {\n        log.warn(\"Invalid metrics: tag: {}\", tag);\n        continue;\n      }\n      String registryName = m.group(1);\n      String key = m.group(3) != null ? m.group(2) + m.group(3) : m.group(2);\n      if (!registryName.startsWith(\"solr.core.\")) {\n        // skip - this is probably solr.node or solr.jvm metric\n        continue;\n      }\n      m = REGISTRY_PATTERN.matcher(registryName);\n\n      if (!m.matches()) {\n        log.warn(\"Invalid registry name: {}\", registryName);\n        continue;\n      }\n      String collection = m.group(1);\n      String shard = m.group(2);\n      String replica = m.group(3);\n      List<ReplicaInfo> replicas = clusterStateProvider.simGetReplicaInfos(collection, shard);\n      replicas.forEach(r -> {\n        if (r.getNode().equals(node) && r.getCore().endsWith(replica)) {\n          Object value = r.getVariables().get(key);\n          if (value != null) {\n            values.put(tag, value);\n          } else {\n            value = r.getVariables().get(tag);\n            if (value != null) {\n              values.put(tag, value);\n            }\n          }\n        }\n      });\n    }\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Simulate getting replica metrics values. This uses per-replica properties set in\n   * {@link SimClusterStateProvider#simSetCollectionValue(String, String, Object, boolean, boolean)} and\n   * similar methods.\n   * @param node node id\n   * @param tags metrics names\n   * @return map of metrics names / values\n   */\n  public Map<String, Object> getReplicaMetricsValues(String node, Collection<String> tags) {\n    if (!liveNodesSet.contains(node)) {\n      throw new RuntimeException(\"non-live node \" + node);\n    }\n    Map<String, Object> values = new HashMap<>();\n    for (String tag : tags) {\n      Matcher m = METRIC_KEY_PATTERN.matcher(tag);\n      if (!m.matches() || m.groupCount() < 2) {\n        log.warn(\"Invalid metrics: tag: \" + tag);\n        continue;\n      }\n      String registryName = m.group(1);\n      String key = m.group(3) != null ? m.group(2) + m.group(3) : m.group(2);\n      if (!registryName.startsWith(\"solr.core.\")) {\n        // skip - this is probably solr.node or solr.jvm metric\n        continue;\n      }\n      m = REGISTRY_PATTERN.matcher(registryName);\n\n      if (!m.matches()) {\n        log.warn(\"Invalid registry name: \" + registryName);\n        continue;\n      }\n      String collection = m.group(1);\n      String shard = m.group(2);\n      String replica = m.group(3);\n      List<ReplicaInfo> replicas = clusterStateProvider.simGetReplicaInfos(collection, shard);\n      replicas.forEach(r -> {\n        if (r.getNode().equals(node) && r.getCore().endsWith(replica)) {\n          Object value = r.getVariables().get(key);\n          if (value != null) {\n            values.put(tag, value);\n          } else {\n            value = r.getVariables().get(tag);\n            if (value != null) {\n              values.put(tag, value);\n            }\n          }\n        }\n      });\n    }\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd","date":1594731683,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimNodeStateProvider#getReplicaMetricsValues(String,Collection[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimNodeStateProvider#getReplicaMetricsValues(String,Collection[String]).mjava","sourceNew":"  /**\n   * Simulate getting replica metrics values. This uses per-replica properties set in\n   * {@link SimClusterStateProvider#simSetCollectionValue(String, String, Object, boolean, boolean)} and\n   * similar methods.\n   * @param node node id\n   * @param tags metrics names\n   * @return map of metrics names / values\n   */\n  public Map<String, Object> getReplicaMetricsValues(String node, Collection<String> tags) {\n    if (!liveNodesSet.contains(node)) {\n      throw new RuntimeException(\"non-live node \" + node);\n    }\n    Map<String, Object> values = new HashMap<>();\n    for (String tag : tags) {\n      Matcher m = METRIC_KEY_PATTERN.matcher(tag);\n      if (!m.matches() || m.groupCount() < 2) {\n        log.warn(\"Invalid metrics: tag: {}\", tag);\n        continue;\n      }\n      String registryName = m.group(1);\n      String key = m.group(3) != null ? m.group(2) + m.group(3) : m.group(2);\n      if (!registryName.startsWith(\"solr.core.\")) {\n        // skip - this is probably solr.node or solr.jvm metric\n        continue;\n      }\n      m = REGISTRY_PATTERN.matcher(registryName);\n\n      if (!m.matches()) {\n        log.warn(\"Invalid registry name: {}\", registryName);\n        continue;\n      }\n      String collection = m.group(1);\n      String shard = m.group(2);\n      String replica = m.group(3);\n      List<Replica> replicas = clusterStateProvider.simGetReplicaInfos(collection, shard);\n      replicas.forEach(r -> {\n        if (r.getNodeName().equals(node) && r.getCoreName().endsWith(replica)) {\n          Object value = r.getProperties().get(key);\n          if (value != null) {\n            values.put(tag, value);\n          } else {\n            value = r.getProperties().get(tag);\n            if (value != null) {\n              values.put(tag, value);\n            }\n          }\n        }\n      });\n    }\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Simulate getting replica metrics values. This uses per-replica properties set in\n   * {@link SimClusterStateProvider#simSetCollectionValue(String, String, Object, boolean, boolean)} and\n   * similar methods.\n   * @param node node id\n   * @param tags metrics names\n   * @return map of metrics names / values\n   */\n  public Map<String, Object> getReplicaMetricsValues(String node, Collection<String> tags) {\n    if (!liveNodesSet.contains(node)) {\n      throw new RuntimeException(\"non-live node \" + node);\n    }\n    Map<String, Object> values = new HashMap<>();\n    for (String tag : tags) {\n      Matcher m = METRIC_KEY_PATTERN.matcher(tag);\n      if (!m.matches() || m.groupCount() < 2) {\n        log.warn(\"Invalid metrics: tag: {}\", tag);\n        continue;\n      }\n      String registryName = m.group(1);\n      String key = m.group(3) != null ? m.group(2) + m.group(3) : m.group(2);\n      if (!registryName.startsWith(\"solr.core.\")) {\n        // skip - this is probably solr.node or solr.jvm metric\n        continue;\n      }\n      m = REGISTRY_PATTERN.matcher(registryName);\n\n      if (!m.matches()) {\n        log.warn(\"Invalid registry name: {}\", registryName);\n        continue;\n      }\n      String collection = m.group(1);\n      String shard = m.group(2);\n      String replica = m.group(3);\n      List<ReplicaInfo> replicas = clusterStateProvider.simGetReplicaInfos(collection, shard);\n      replicas.forEach(r -> {\n        if (r.getNode().equals(node) && r.getCore().endsWith(replica)) {\n          Object value = r.getVariables().get(key);\n          if (value != null) {\n            values.put(tag, value);\n          } else {\n            value = r.getVariables().get(tag);\n            if (value != null) {\n              values.put(tag, value);\n            }\n          }\n        }\n      });\n    }\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimNodeStateProvider#getReplicaMetricsValues(String,Collection[String]).mjava","sourceNew":null,"sourceOld":"  /**\n   * Simulate getting replica metrics values. This uses per-replica properties set in\n   * {@link SimClusterStateProvider#simSetCollectionValue(String, String, Object, boolean, boolean)} and\n   * similar methods.\n   * @param node node id\n   * @param tags metrics names\n   * @return map of metrics names / values\n   */\n  public Map<String, Object> getReplicaMetricsValues(String node, Collection<String> tags) {\n    if (!liveNodesSet.contains(node)) {\n      throw new RuntimeException(\"non-live node \" + node);\n    }\n    Map<String, Object> values = new HashMap<>();\n    for (String tag : tags) {\n      Matcher m = METRIC_KEY_PATTERN.matcher(tag);\n      if (!m.matches() || m.groupCount() < 2) {\n        log.warn(\"Invalid metrics: tag: {}\", tag);\n        continue;\n      }\n      String registryName = m.group(1);\n      String key = m.group(3) != null ? m.group(2) + m.group(3) : m.group(2);\n      if (!registryName.startsWith(\"solr.core.\")) {\n        // skip - this is probably solr.node or solr.jvm metric\n        continue;\n      }\n      m = REGISTRY_PATTERN.matcher(registryName);\n\n      if (!m.matches()) {\n        log.warn(\"Invalid registry name: {}\", registryName);\n        continue;\n      }\n      String collection = m.group(1);\n      String shard = m.group(2);\n      String replica = m.group(3);\n      List<Replica> replicas = clusterStateProvider.simGetReplicaInfos(collection, shard);\n      replicas.forEach(r -> {\n        if (r.getNodeName().equals(node) && r.getCoreName().endsWith(replica)) {\n          Object value = r.getProperties().get(key);\n          if (value != null) {\n            values.put(tag, value);\n          } else {\n            value = r.getProperties().get(tag);\n            if (value != null) {\n              values.put(tag, value);\n            }\n          }\n        }\n      });\n    }\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["e35f2dde06b35aa9904949a3a93fabd090371077"],"3f504512a03d978990cbff30db0522b354e846db":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e35f2dde06b35aa9904949a3a93fabd090371077":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"e35f2dde06b35aa9904949a3a93fabd090371077":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["e35f2dde06b35aa9904949a3a93fabd090371077"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}