{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    // Simple optimization: if the doc store we are using\n    // has been closed and is in now compound format (but\n    // wasn't when we started), then we will switch to the\n    // compound format as well:\n    final String mergeDocStoreSegment = merge.info.getDocStoreSegment(); \n    if (mergeDocStoreSegment != null && !merge.info.getDocStoreIsCompoundFile()) {\n      final int size = segmentInfos.size();\n      for(int i=0;i<size;i++) {\n        final SegmentInfo info = segmentInfos.info(i);\n        final String docStoreSegment = info.getDocStoreSegment();\n        if (docStoreSegment != null &&\n            docStoreSegment.equals(mergeDocStoreSegment) && \n            info.getDocStoreIsCompoundFile()) {\n          merge.info.setDocStoreIsCompoundFile(true);\n          break;\n        }\n      }\n    }\n\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    // Simple optimization: if the doc store we are using\n    // has been closed and is in now compound format (but\n    // wasn't when we started), then we will switch to the\n    // compound format as well:\n    final String mergeDocStoreSegment = merge.info.getDocStoreSegment(); \n    if (mergeDocStoreSegment != null && !merge.info.getDocStoreIsCompoundFile()) {\n      final int size = segmentInfos.size();\n      for(int i=0;i<size;i++) {\n        final SegmentInfo info = segmentInfos.info(i);\n        final String docStoreSegment = info.getDocStoreSegment();\n        if (docStoreSegment != null &&\n            docStoreSegment.equals(mergeDocStoreSegment) && \n            info.getDocStoreIsCompoundFile()) {\n          merge.info.setDocStoreIsCompoundFile(true);\n          break;\n        }\n      }\n    }\n\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    // Simple optimization: if the doc store we are using\n    // has been closed and is in now compound format (but\n    // wasn't when we started), then we will switch to the\n    // compound format as well:\n    final String mergeDocStoreSegment = merge.info.getDocStoreSegment(); \n    if (mergeDocStoreSegment != null && !merge.info.getDocStoreIsCompoundFile()) {\n      final int size = segmentInfos.size();\n      for(int i=0;i<size;i++) {\n        final SegmentInfo info = segmentInfos.info(i);\n        final String docStoreSegment = info.getDocStoreSegment();\n        if (docStoreSegment != null &&\n            docStoreSegment.equals(mergeDocStoreSegment) && \n            info.getDocStoreIsCompoundFile()) {\n          merge.info.setDocStoreIsCompoundFile(true);\n          break;\n        }\n      }\n    }\n    \n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    // Simple optimization: if the doc store we are using\n    // has been closed and is in now compound format (but\n    // wasn't when we started), then we will switch to the\n    // compound format as well:\n    final String mergeDocStoreSegment = merge.info.getDocStoreSegment(); \n    if (mergeDocStoreSegment != null && !merge.info.getDocStoreIsCompoundFile()) {\n      final int size = segmentInfos.size();\n      for(int i=0;i<size;i++) {\n        final SegmentInfo info = segmentInfos.info(i);\n        final String docStoreSegment = info.getDocStoreSegment();\n        if (docStoreSegment != null &&\n            docStoreSegment.equals(mergeDocStoreSegment) && \n            info.getDocStoreIsCompoundFile()) {\n          merge.info.setDocStoreIsCompoundFile(true);\n          break;\n        }\n      }\n    }\n\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["c0716ddfa41d3662d014c42086a700ad78fc5dcb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0716ddfa41d3662d014c42086a700ad78fc5dcb","date":1275676935,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    // Simple optimization: if the doc store we are using\n    // has been closed and is in now compound format (but\n    // wasn't when we started), then we will switch to the\n    // compound format as well:\n    final String mergeDocStoreSegment = merge.info.getDocStoreSegment(); \n    if (mergeDocStoreSegment != null && !merge.info.getDocStoreIsCompoundFile()) {\n      final int size = segmentInfos.size();\n      for(int i=0;i<size;i++) {\n        final SegmentInfo info = segmentInfos.info(i);\n        final String docStoreSegment = info.getDocStoreSegment();\n        if (docStoreSegment != null &&\n            docStoreSegment.equals(mergeDocStoreSegment) && \n            info.getDocStoreIsCompoundFile()) {\n          merge.info.setDocStoreIsCompoundFile(true);\n          break;\n        }\n      }\n    }\n    \n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf","955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9b832cbed6eb3d54a8bb9339296bdda8eeb53014","date":1279708040,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    // nocommit\n    //docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"334c1175813aea771a71728cd2c4ee4754fd0603","date":1279710173,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    // nocommit\n    //docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fe956d65251358d755c56f14fe8380644790e47","date":1279711318,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    // nocommit\n    //docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"833a7987bc1c94455fde83e3311f72bddedcfb93","date":1279951470,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    // nocommit\n    //docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    // nocommit\n    //docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"53a31399f2471493d67b19a95c028a74e0113b6a","date":1289817072,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize) {\n      // cascade the optimize:\n      segmentsToOptimize.add(merge.info);\n    }\n    return true;\n  }\n\n","sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ab1f5591dc05f1f2b5407d809c9699f75554a32","date":1290008586,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize) {\n      // cascade the optimize:\n      segmentsToOptimize.add(merge.info);\n    }\n    return true;\n  }\n\n","sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5","date":1290247889,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n    setMergeDocStoreIsCompoundFile(merge);\n\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize) {\n      // cascade the optimize:\n      segmentsToOptimize.add(merge.info);\n    }\n    return true;\n  }\n\n","sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize) {\n      // cascade the optimize:\n      segmentsToOptimize.add(merge.info);\n    }\n    return true;\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n    setMergeDocStoreIsCompoundFile(merge);\n\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize) {\n      // cascade the optimize:\n      segmentsToOptimize.add(merge.info);\n    }\n    return true;\n  }\n\n","sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    setMergeDocStoreIsCompoundFile(merge);\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize) {\n      // cascade the optimize:\n      segmentsToOptimize.add(merge.info);\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44fcbde6fb2ac44ee3b45e013e54a42911e689ff","date":1292065621,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n      \n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n    setMergeDocStoreIsCompoundFile(merge);\n\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n    \n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n    \n    // remove pending deletes of the segments \n    // that were merged, moving them onto the segment just\n    // before the merged segment\n    // Lock order: IW -> BD\n    bufferedDeletes.commitMerge(merge);\n\n    if (merge.optimize) {\n      // cascade the optimize:\n      segmentsToOptimize.add(merge.info);\n    }\n    return true;\n  }\n\n","sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n    setMergeDocStoreIsCompoundFile(merge);\n\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize) {\n      // cascade the optimize:\n      segmentsToOptimize.add(merge.info);\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n      \n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n    setMergeDocStoreIsCompoundFile(merge);\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n    \n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n    \n    // remove pending deletes of the segments \n    // that were merged, moving them onto the segment just\n    // before the merged segment\n    // Lock order: IW -> BD\n    bufferedDeletes.commitMerge(merge);\n\n    if (merge.optimize) {\n      // cascade the optimize:\n      segmentsToOptimize.add(merge.info);\n    }\n    return true;\n  }\n\n","sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n    setMergeDocStoreIsCompoundFile(merge);\n\n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize) {\n      // cascade the optimize:\n      segmentsToOptimize.add(merge.info);\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentMerger,int,SegmentReader).mjava","sourceNew":null,"sourceOld":"  /* FIXME if we want to support non-contiguous segment merges */\n  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentMerger merger, int mergedDocCount, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream != null)\n      message(\"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream != null)\n        message(\"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n\n      deleter.refresh(merge.info.name);\n      return false;\n    }\n\n    final int start = ensureContiguousMerge(merge);\n\n    commitMergedDeletes(merge, mergedReader);\n    // nocommit\n    //docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);\n      \n    merge.info.setHasProx(merger.hasProx());\n\n    segmentInfos.subList(start, start + merge.segments.size()).clear();\n    assert !segmentInfos.contains(merge.info);\n    segmentInfos.add(start, merge.info);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.optimize)\n      segmentsToOptimize.add(merge.info);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5"],"9ab1f5591dc05f1f2b5407d809c9699f75554a32":["334c1175813aea771a71728cd2c4ee4754fd0603","53a31399f2471493d67b19a95c028a74e0113b6a"],"8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5":["53a31399f2471493d67b19a95c028a74e0113b6a"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["3bb13258feba31ab676502787ab2e1779f129b7a","44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"334c1175813aea771a71728cd2c4ee4754fd0603":["9b832cbed6eb3d54a8bb9339296bdda8eeb53014"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["833a7987bc1c94455fde83e3311f72bddedcfb93","44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"9b832cbed6eb3d54a8bb9339296bdda8eeb53014":["c0716ddfa41d3662d014c42086a700ad78fc5dcb"],"c0716ddfa41d3662d014c42086a700ad78fc5dcb":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"53a31399f2471493d67b19a95c028a74e0113b6a":["334c1175813aea771a71728cd2c4ee4754fd0603"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8fe956d65251358d755c56f14fe8380644790e47":["c0716ddfa41d3662d014c42086a700ad78fc5dcb"],"3bb13258feba31ab676502787ab2e1779f129b7a":["9ab1f5591dc05f1f2b5407d809c9699f75554a32","8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"833a7987bc1c94455fde83e3311f72bddedcfb93":["8fe956d65251358d755c56f14fe8380644790e47"]},"commit2Childs":{"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9ab1f5591dc05f1f2b5407d809c9699f75554a32":["3bb13258feba31ab676502787ab2e1779f129b7a"],"8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff","3bb13258feba31ab676502787ab2e1779f129b7a"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["c0716ddfa41d3662d014c42086a700ad78fc5dcb"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":[],"334c1175813aea771a71728cd2c4ee4754fd0603":["9ab1f5591dc05f1f2b5407d809c9699f75554a32","53a31399f2471493d67b19a95c028a74e0113b6a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"9b832cbed6eb3d54a8bb9339296bdda8eeb53014":["334c1175813aea771a71728cd2c4ee4754fd0603"],"c0716ddfa41d3662d014c42086a700ad78fc5dcb":["9b832cbed6eb3d54a8bb9339296bdda8eeb53014","8fe956d65251358d755c56f14fe8380644790e47"],"53a31399f2471493d67b19a95c028a74e0113b6a":["9ab1f5591dc05f1f2b5407d809c9699f75554a32","8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"8fe956d65251358d755c56f14fe8380644790e47":["833a7987bc1c94455fde83e3311f72bddedcfb93"],"3bb13258feba31ab676502787ab2e1779f129b7a":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"833a7987bc1c94455fde83e3311f72bddedcfb93":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}