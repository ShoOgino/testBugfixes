{"path":"lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase#getAllTaxonomyFacetLabels(TaxonomyReader,FacetsCollector).mjava","commits":[{"id":"2b0ae449d456c3d95466275e466ca402ce36f52b","date":1601304937,"type":0,"author":"goankur","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase#getAllTaxonomyFacetLabels(TaxonomyReader,FacetsCollector).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Utility method that uses {@link FacetLabelReader} to get facet labels\n   * for each hit in {@link MatchingDocs}. The method returns {@code List<List<FacetLabel>>}\n   * where outer list has one entry per document and inner list has all {@link FacetLabel}\n   * entries that belong to a document. The inner list may be empty if no {@link FacetLabel}\n   * are found for a hit.\n   *\n   * @param taxoReader {@link TaxonomyReader} used to read taxonomy during search. This instance is expected to be open for reading.\n   * @param fc         {@link FacetsCollector} A collector with matching hits.\n   * @return {@code List<List<FacetLabel>} where outer list has one non-null entry per document\n   * and inner list contain all {@link FacetLabel} entries that belong to a document.\n   * @throws IOException when a low-level IO issue occurs.\n   */\n  public List<List<FacetLabel>> getAllTaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsCollector fc) throws IOException {\n    List<List<FacetLabel>> actualLabels = new ArrayList<>();\n    TaxonomyFacetLabels taxoLabels = new TaxonomyFacetLabels(taxoReader, FacetsConfig.DEFAULT_INDEX_FIELD_NAME);\n\n    for (MatchingDocs m : fc.getMatchingDocs()) {\n      FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);\n\n      DocIdSetIterator disi = m.bits.iterator();\n      while (disi.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        List<FacetLabel> facetLabels = new ArrayList<>();\n        int docId = disi.docID();\n        FacetLabel facetLabel = facetLabelReader.nextFacetLabel(docId);\n        while (facetLabel != null) {\n          facetLabels.add(facetLabel);\n          facetLabel = facetLabelReader.nextFacetLabel(docId);\n        }\n        actualLabels.add(facetLabels);\n      }\n    }\n    return actualLabels;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd0530170c04ef91ee4e20f01089697adb70a98d","date":1601486478,"type":5,"author":"goankur","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase#getAllTaxonomyFacetLabels(String,TaxonomyReader,FacetsCollector).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase#getAllTaxonomyFacetLabels(TaxonomyReader,FacetsCollector).mjava","sourceNew":"  /**\n   * Utility method that uses {@link FacetLabelReader} to get facet labels\n   * for each hit in {@link MatchingDocs}. The method returns {@code List<List<FacetLabel>>}\n   * where outer list has one entry per document and inner list has all {@link FacetLabel}\n   * entries that belong to a document. The inner list may be empty if no {@link FacetLabel}\n   * are found for a hit.\n   *\n   * @param taxoReader {@link TaxonomyReader} used to read taxonomy during search. This instance is expected to be open for reading.\n   * @param fc         {@link FacetsCollector} A collector with matching hits.\n   * @param dimension  facet dimension for which labels are requested. A null value fetches labels for all dimensions.\n   * @return {@code List<List<FacetLabel>} where outer list has one non-null entry per document.\n   * and inner list contain all {@link FacetLabel} entries that belong to a document.\n   * @throws IOException when a low-level IO issue occurs.\n   */\n  public List<List<FacetLabel>> getAllTaxonomyFacetLabels(String dimension, TaxonomyReader taxoReader, FacetsCollector fc) throws IOException {\n    List<List<FacetLabel>> actualLabels = new ArrayList<>();\n    TaxonomyFacetLabels taxoLabels = new TaxonomyFacetLabels(taxoReader, FacetsConfig.DEFAULT_INDEX_FIELD_NAME);\n    for (MatchingDocs m : fc.getMatchingDocs()) {\n      FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);\n      DocIdSetIterator disi = m.bits.iterator();\n      while (disi.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        actualLabels.add(allFacetLabels(disi.docID(), dimension, facetLabelReader));\n      }\n    }\n    return actualLabels;\n  }\n\n","sourceOld":"  /**\n   * Utility method that uses {@link FacetLabelReader} to get facet labels\n   * for each hit in {@link MatchingDocs}. The method returns {@code List<List<FacetLabel>>}\n   * where outer list has one entry per document and inner list has all {@link FacetLabel}\n   * entries that belong to a document. The inner list may be empty if no {@link FacetLabel}\n   * are found for a hit.\n   *\n   * @param taxoReader {@link TaxonomyReader} used to read taxonomy during search. This instance is expected to be open for reading.\n   * @param fc         {@link FacetsCollector} A collector with matching hits.\n   * @return {@code List<List<FacetLabel>} where outer list has one non-null entry per document\n   * and inner list contain all {@link FacetLabel} entries that belong to a document.\n   * @throws IOException when a low-level IO issue occurs.\n   */\n  public List<List<FacetLabel>> getAllTaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsCollector fc) throws IOException {\n    List<List<FacetLabel>> actualLabels = new ArrayList<>();\n    TaxonomyFacetLabels taxoLabels = new TaxonomyFacetLabels(taxoReader, FacetsConfig.DEFAULT_INDEX_FIELD_NAME);\n\n    for (MatchingDocs m : fc.getMatchingDocs()) {\n      FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);\n\n      DocIdSetIterator disi = m.bits.iterator();\n      while (disi.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n        List<FacetLabel> facetLabels = new ArrayList<>();\n        int docId = disi.docID();\n        FacetLabel facetLabel = facetLabelReader.nextFacetLabel(docId);\n        while (facetLabel != null) {\n          facetLabels.add(facetLabel);\n          facetLabel = facetLabelReader.nextFacetLabel(docId);\n        }\n        actualLabels.add(facetLabels);\n      }\n    }\n    return actualLabels;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bd0530170c04ef91ee4e20f01089697adb70a98d":["2b0ae449d456c3d95466275e466ca402ce36f52b"],"2b0ae449d456c3d95466275e466ca402ce36f52b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd0530170c04ef91ee4e20f01089697adb70a98d"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2b0ae449d456c3d95466275e466ca402ce36f52b"],"bd0530170c04ef91ee4e20f01089697adb70a98d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2b0ae449d456c3d95466275e466ca402ce36f52b":["bd0530170c04ef91ee4e20f01089697adb70a98d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}