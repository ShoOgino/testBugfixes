{"path":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.MergePointVisitor#compare(byte[],byte[]).mjava","commits":[{"id":"ee299c4e4c019174aa433f564b5de03a7a40e00d","date":1456264115,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.MergePointVisitor#compare(byte[],byte[]).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n      while (nextQueryPoint != null) {\n        scratch.bytes = minPackedValue;\n        int cmpMin = nextQueryPoint.compareTo(scratch);\n        if (cmpMin < 0) {\n          // query point is before the start of this cell\n          nextQueryPoint = iterator.next();\n          continue;\n        }\n        scratch.bytes = maxPackedValue;\n        int cmpMax = nextQueryPoint.compareTo(scratch);\n        if (cmpMax > 0) {\n          // query point is after the end of this cell\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n\n        if (cmpMin == 0 && cmpMax == 0) {\n          // NOTE: we only hit this if we are on a cell whose min and max values are exactly equal to our point,\n          // which can easily happen if many (> 1024) docs share this one value\n          return Relation.CELL_INSIDE_QUERY;\n        } else {\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      }\n\n      // We exhausted all points in the query:\n      return Relation.CELL_OUTSIDE_QUERY;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868f63baffb79407d4b49f3c0be8dc4725ffc6e1","date":1456423715,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.MergePointVisitor#compare(byte[],byte[]).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n      while (nextQueryPoint != null) {\n        scratch.bytes = minPackedValue;\n        int cmpMin = nextQueryPoint.compareTo(scratch);\n        if (cmpMin < 0) {\n          // query point is before the start of this cell\n          nextQueryPoint = iterator.next();\n          continue;\n        }\n        scratch.bytes = maxPackedValue;\n        int cmpMax = nextQueryPoint.compareTo(scratch);\n        if (cmpMax > 0) {\n          // query point is after the end of this cell\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n\n        if (cmpMin == 0 && cmpMax == 0) {\n          // NOTE: we only hit this if we are on a cell whose min and max values are exactly equal to our point,\n          // which can easily happen if many (> 1024) docs share this one value\n          return Relation.CELL_INSIDE_QUERY;\n        } else {\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      }\n\n      // We exhausted all points in the query:\n      return Relation.CELL_OUTSIDE_QUERY;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c18695b5c27b72d1fdc966eee5e01d07a81b5c52","date":1456532984,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.MergePointVisitor#compare(byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.MergePointVisitor#compare(byte[],byte[]).mjava","sourceNew":"    @Override\n    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n      \n      // NOTE: this is messy ... we need it in cases where a single vistor (us) is shared across multiple leaf readers\n      // (e.g. SlowCompositeReaderWrapper), in which case we need to reset our iterator to re-start the merge sort.  Maybe we should instead\n      // add an explicit .start() to IntersectVisitor, and clarify the semantics that in the 1D case all cells will be visited in order?\n      if (StringHelper.compare(bytesPerDim, lastMaxPackedValue, 0, minPackedValue, 0) > 0) {    \n        resetIterator();\n      }\n      System.arraycopy(maxPackedValue, 0, lastMaxPackedValue, 0, bytesPerDim);\n\n      while (nextQueryPoint != null) {\n        scratch.bytes = minPackedValue;\n        int cmpMin = nextQueryPoint.compareTo(scratch);\n        if (cmpMin < 0) {\n          // query point is before the start of this cell\n          nextQueryPoint = iterator.next();\n          continue;\n        }\n        scratch.bytes = maxPackedValue;\n        int cmpMax = nextQueryPoint.compareTo(scratch);\n        if (cmpMax > 0) {\n          // query point is after the end of this cell\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n\n        if (cmpMin == 0 && cmpMax == 0) {\n          // NOTE: we only hit this if we are on a cell whose min and max values are exactly equal to our point,\n          // which can easily happen if many (> 1024) docs share this one value\n          return Relation.CELL_INSIDE_QUERY;\n        } else {\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      }\n\n      // We exhausted all points in the query:\n      return Relation.CELL_OUTSIDE_QUERY;\n    }\n\n","sourceOld":"    @Override\n    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n      while (nextQueryPoint != null) {\n        scratch.bytes = minPackedValue;\n        int cmpMin = nextQueryPoint.compareTo(scratch);\n        if (cmpMin < 0) {\n          // query point is before the start of this cell\n          nextQueryPoint = iterator.next();\n          continue;\n        }\n        scratch.bytes = maxPackedValue;\n        int cmpMax = nextQueryPoint.compareTo(scratch);\n        if (cmpMax > 0) {\n          // query point is after the end of this cell\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n\n        if (cmpMin == 0 && cmpMax == 0) {\n          // NOTE: we only hit this if we are on a cell whose min and max values are exactly equal to our point,\n          // which can easily happen if many (> 1024) docs share this one value\n          return Relation.CELL_INSIDE_QUERY;\n        } else {\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      }\n\n      // We exhausted all points in the query:\n      return Relation.CELL_OUTSIDE_QUERY;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.MergePointVisitor#compare(byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.MergePointVisitor#compare(byte[],byte[]).mjava","sourceNew":"    @Override\n    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n      \n      // NOTE: this is messy ... we need it in cases where a single vistor (us) is shared across multiple leaf readers\n      // (e.g. SlowCompositeReaderWrapper), in which case we need to reset our iterator to re-start the merge sort.  Maybe we should instead\n      // add an explicit .start() to IntersectVisitor, and clarify the semantics that in the 1D case all cells will be visited in order?\n      if (StringHelper.compare(bytesPerDim, lastMaxPackedValue, 0, minPackedValue, 0) > 0) {    \n        resetIterator();\n      }\n      System.arraycopy(maxPackedValue, 0, lastMaxPackedValue, 0, bytesPerDim);\n\n      while (nextQueryPoint != null) {\n        scratch.bytes = minPackedValue;\n        int cmpMin = nextQueryPoint.compareTo(scratch);\n        if (cmpMin < 0) {\n          // query point is before the start of this cell\n          nextQueryPoint = iterator.next();\n          continue;\n        }\n        scratch.bytes = maxPackedValue;\n        int cmpMax = nextQueryPoint.compareTo(scratch);\n        if (cmpMax > 0) {\n          // query point is after the end of this cell\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n\n        if (cmpMin == 0 && cmpMax == 0) {\n          // NOTE: we only hit this if we are on a cell whose min and max values are exactly equal to our point,\n          // which can easily happen if many (> 1024) docs share this one value\n          return Relation.CELL_INSIDE_QUERY;\n        } else {\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      }\n\n      // We exhausted all points in the query:\n      return Relation.CELL_OUTSIDE_QUERY;\n    }\n\n","sourceOld":"    @Override\n    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n      while (nextQueryPoint != null) {\n        scratch.bytes = minPackedValue;\n        int cmpMin = nextQueryPoint.compareTo(scratch);\n        if (cmpMin < 0) {\n          // query point is before the start of this cell\n          nextQueryPoint = iterator.next();\n          continue;\n        }\n        scratch.bytes = maxPackedValue;\n        int cmpMax = nextQueryPoint.compareTo(scratch);\n        if (cmpMax > 0) {\n          // query point is after the end of this cell\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n\n        if (cmpMin == 0 && cmpMax == 0) {\n          // NOTE: we only hit this if we are on a cell whose min and max values are exactly equal to our point,\n          // which can easily happen if many (> 1024) docs share this one value\n          return Relation.CELL_INSIDE_QUERY;\n        } else {\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      }\n\n      // We exhausted all points in the query:\n      return Relation.CELL_OUTSIDE_QUERY;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f","date":1456936072,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.MergePointVisitor#compare(byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.MergePointVisitor#compare(byte[],byte[]).mjava","sourceNew":"    @Override\n    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n      while (nextQueryPoint != null) {\n        scratch.bytes = minPackedValue;\n        int cmpMin = nextQueryPoint.compareTo(scratch);\n        if (cmpMin < 0) {\n          // query point is before the start of this cell\n          nextQueryPoint = iterator.next();\n          continue;\n        }\n        scratch.bytes = maxPackedValue;\n        int cmpMax = nextQueryPoint.compareTo(scratch);\n        if (cmpMax > 0) {\n          // query point is after the end of this cell\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n\n        if (cmpMin == 0 && cmpMax == 0) {\n          // NOTE: we only hit this if we are on a cell whose min and max values are exactly equal to our point,\n          // which can easily happen if many (> 1024) docs share this one value\n          return Relation.CELL_INSIDE_QUERY;\n        } else {\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      }\n\n      // We exhausted all points in the query:\n      return Relation.CELL_OUTSIDE_QUERY;\n    }\n\n","sourceOld":"    @Override\n    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n      \n      // NOTE: this is messy ... we need it in cases where a single vistor (us) is shared across multiple leaf readers\n      // (e.g. SlowCompositeReaderWrapper), in which case we need to reset our iterator to re-start the merge sort.  Maybe we should instead\n      // add an explicit .start() to IntersectVisitor, and clarify the semantics that in the 1D case all cells will be visited in order?\n      if (StringHelper.compare(bytesPerDim, lastMaxPackedValue, 0, minPackedValue, 0) > 0) {    \n        resetIterator();\n      }\n      System.arraycopy(maxPackedValue, 0, lastMaxPackedValue, 0, bytesPerDim);\n\n      while (nextQueryPoint != null) {\n        scratch.bytes = minPackedValue;\n        int cmpMin = nextQueryPoint.compareTo(scratch);\n        if (cmpMin < 0) {\n          // query point is before the start of this cell\n          nextQueryPoint = iterator.next();\n          continue;\n        }\n        scratch.bytes = maxPackedValue;\n        int cmpMax = nextQueryPoint.compareTo(scratch);\n        if (cmpMax > 0) {\n          // query point is after the end of this cell\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n\n        if (cmpMin == 0 && cmpMax == 0) {\n          // NOTE: we only hit this if we are on a cell whose min and max values are exactly equal to our point,\n          // which can easily happen if many (> 1024) docs share this one value\n          return Relation.CELL_INSIDE_QUERY;\n        } else {\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      }\n\n      // We exhausted all points in the query:\n      return Relation.CELL_OUTSIDE_QUERY;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.MergePointVisitor#compare(byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.MergePointVisitor#compare(byte[],byte[]).mjava","sourceNew":"    @Override\n    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n      while (nextQueryPoint != null) {\n        scratch.bytes = minPackedValue;\n        int cmpMin = nextQueryPoint.compareTo(scratch);\n        if (cmpMin < 0) {\n          // query point is before the start of this cell\n          nextQueryPoint = iterator.next();\n          continue;\n        }\n        scratch.bytes = maxPackedValue;\n        int cmpMax = nextQueryPoint.compareTo(scratch);\n        if (cmpMax > 0) {\n          // query point is after the end of this cell\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n\n        if (cmpMin == 0 && cmpMax == 0) {\n          // NOTE: we only hit this if we are on a cell whose min and max values are exactly equal to our point,\n          // which can easily happen if many (> 1024) docs share this one value\n          return Relation.CELL_INSIDE_QUERY;\n        } else {\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      }\n\n      // We exhausted all points in the query:\n      return Relation.CELL_OUTSIDE_QUERY;\n    }\n\n","sourceOld":"    @Override\n    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n      \n      // NOTE: this is messy ... we need it in cases where a single vistor (us) is shared across multiple leaf readers\n      // (e.g. SlowCompositeReaderWrapper), in which case we need to reset our iterator to re-start the merge sort.  Maybe we should instead\n      // add an explicit .start() to IntersectVisitor, and clarify the semantics that in the 1D case all cells will be visited in order?\n      if (StringHelper.compare(bytesPerDim, lastMaxPackedValue, 0, minPackedValue, 0) > 0) {    \n        resetIterator();\n      }\n      System.arraycopy(maxPackedValue, 0, lastMaxPackedValue, 0, bytesPerDim);\n\n      while (nextQueryPoint != null) {\n        scratch.bytes = minPackedValue;\n        int cmpMin = nextQueryPoint.compareTo(scratch);\n        if (cmpMin < 0) {\n          // query point is before the start of this cell\n          nextQueryPoint = iterator.next();\n          continue;\n        }\n        scratch.bytes = maxPackedValue;\n        int cmpMax = nextQueryPoint.compareTo(scratch);\n        if (cmpMax > 0) {\n          // query point is after the end of this cell\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n\n        if (cmpMin == 0 && cmpMax == 0) {\n          // NOTE: we only hit this if we are on a cell whose min and max values are exactly equal to our point,\n          // which can easily happen if many (> 1024) docs share this one value\n          return Relation.CELL_INSIDE_QUERY;\n        } else {\n          return Relation.CELL_CROSSES_QUERY;\n        }\n      }\n\n      // We exhausted all points in the query:\n      return Relation.CELL_OUTSIDE_QUERY;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["868f63baffb79407d4b49f3c0be8dc4725ffc6e1","c18695b5c27b72d1fdc966eee5e01d07a81b5c52"],"ee299c4e4c019174aa433f564b5de03a7a40e00d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"868f63baffb79407d4b49f3c0be8dc4725ffc6e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ee299c4e4c019174aa433f564b5de03a7a40e00d"],"c18695b5c27b72d1fdc966eee5e01d07a81b5c52":["868f63baffb79407d4b49f3c0be8dc4725ffc6e1"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["af2638813028b254a88b418ebeafb541afb49653","adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["c18695b5c27b72d1fdc966eee5e01d07a81b5c52"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"ee299c4e4c019174aa433f564b5de03a7a40e00d":["868f63baffb79407d4b49f3c0be8dc4725ffc6e1"],"868f63baffb79407d4b49f3c0be8dc4725ffc6e1":["af2638813028b254a88b418ebeafb541afb49653","c18695b5c27b72d1fdc966eee5e01d07a81b5c52"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ee299c4e4c019174aa433f564b5de03a7a40e00d","868f63baffb79407d4b49f3c0be8dc4725ffc6e1"],"c18695b5c27b72d1fdc966eee5e01d07a81b5c52":["af2638813028b254a88b418ebeafb541afb49653","adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}