{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#getSubShardLeaders(DocCollection,String,String,SolrInputDocument).mjava","commits":[{"id":"9d70e774cb25c8a8d2c3e5e84200f235f9168d87","date":1553016391,"type":1,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#getSubShardLeaders(DocCollection,String,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getSubShardLeaders(DocCollection,String,String,SolrInputDocument).mjava","sourceNew":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#SPLITSHARD} */\n  protected List<SolrCmdDistributor.Node> getSubShardLeaders(DocCollection coll, String shardId, String docId, SolrInputDocument doc) {\n    Collection<Slice> allSlices = coll.getSlices();\n    List<SolrCmdDistributor.Node> nodes = null;\n    for (Slice aslice : allSlices) {\n      final Slice.State state = aslice.getState();\n      if (state == Slice.State.CONSTRUCTION || state == Slice.State.RECOVERY)  {\n        DocRouter.Range myRange = coll.getSlice(shardId).getRange();\n        if (myRange == null) myRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        boolean isSubset = aslice.getRange() != null && aslice.getRange().isSubsetOf(myRange);\n        if (isSubset &&\n            (docId == null // in case of deletes\n                || coll.getRouter().isTargetSlice(docId, doc, req.getParams(), aslice.getName(), coll))) {\n          Replica sliceLeader = aslice.getLeader();\n          // slice leader can be null because node/shard is created zk before leader election\n          if (sliceLeader != null && zkController.getClusterState().liveNodesContain(sliceLeader.getNodeName()))  {\n            if (nodes == null) nodes = new ArrayList<>();\n            ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(sliceLeader);\n            nodes.add(new SolrCmdDistributor.StdNode(nodeProps, coll.getName(), aslice.getName()));\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#SPLITSHARD} */\n  private List<Node> getSubShardLeaders(DocCollection coll, String shardId, String docId, SolrInputDocument doc) {\n    Collection<Slice> allSlices = coll.getSlices();\n    List<Node> nodes = null;\n    for (Slice aslice : allSlices) {\n      final Slice.State state = aslice.getState();\n      if (state == Slice.State.CONSTRUCTION || state == Slice.State.RECOVERY)  {\n        DocRouter.Range myRange = coll.getSlice(shardId).getRange();\n        if (myRange == null) myRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        boolean isSubset = aslice.getRange() != null && aslice.getRange().isSubsetOf(myRange);\n        if (isSubset &&\n            (docId == null // in case of deletes\n            || coll.getRouter().isTargetSlice(docId, doc, req.getParams(), aslice.getName(), coll))) {\n          Replica sliceLeader = aslice.getLeader();\n          // slice leader can be null because node/shard is created zk before leader election\n          if (sliceLeader != null && zkController.getClusterState().liveNodesContain(sliceLeader.getNodeName()))  {\n            if (nodes == null) nodes = new ArrayList<>();\n            ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(sliceLeader);\n            nodes.add(new StdNode(nodeProps, coll.getName(), aslice.getName()));\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"88922bf68f0b509aba218f1b9e7ef5981b4d13bc","date":1570820823,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#getSubShardLeaders(DocCollection,String,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#getSubShardLeaders(DocCollection,String,String,SolrInputDocument).mjava","sourceNew":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#SPLITSHARD} */\n  protected List<SolrCmdDistributor.Node> getSubShardLeaders(DocCollection coll, String shardId, String docId, SolrInputDocument doc) {\n    Collection<Slice> allSlices = coll.getSlices();\n    List<SolrCmdDistributor.Node> nodes = null;\n    for (Slice aslice : allSlices) {\n      final Slice.State state = aslice.getState();\n      if (state == Slice.State.CONSTRUCTION || state == Slice.State.RECOVERY)  {\n        DocRouter.Range myRange = coll.getSlice(shardId).getRange();\n        if (myRange == null) myRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        boolean isSubset = aslice.getRange() != null && aslice.getRange().isSubsetOf(myRange);\n        if (isSubset &&\n            (docId == null // in case of deletes\n                || coll.getRouter().isTargetSlice(docId, doc, req.getParams(), aslice.getName(), coll))) {\n          Replica sliceLeader = aslice.getLeader();\n          // slice leader can be null because node/shard is created zk before leader election\n          if (sliceLeader != null && clusterState.liveNodesContain(sliceLeader.getNodeName()))  {\n            if (nodes == null) nodes = new ArrayList<>();\n            ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(sliceLeader);\n            nodes.add(new SolrCmdDistributor.StdNode(nodeProps, coll.getName(), aslice.getName()));\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#SPLITSHARD} */\n  protected List<SolrCmdDistributor.Node> getSubShardLeaders(DocCollection coll, String shardId, String docId, SolrInputDocument doc) {\n    Collection<Slice> allSlices = coll.getSlices();\n    List<SolrCmdDistributor.Node> nodes = null;\n    for (Slice aslice : allSlices) {\n      final Slice.State state = aslice.getState();\n      if (state == Slice.State.CONSTRUCTION || state == Slice.State.RECOVERY)  {\n        DocRouter.Range myRange = coll.getSlice(shardId).getRange();\n        if (myRange == null) myRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        boolean isSubset = aslice.getRange() != null && aslice.getRange().isSubsetOf(myRange);\n        if (isSubset &&\n            (docId == null // in case of deletes\n                || coll.getRouter().isTargetSlice(docId, doc, req.getParams(), aslice.getName(), coll))) {\n          Replica sliceLeader = aslice.getLeader();\n          // slice leader can be null because node/shard is created zk before leader election\n          if (sliceLeader != null && zkController.getClusterState().liveNodesContain(sliceLeader.getNodeName()))  {\n            if (nodes == null) nodes = new ArrayList<>();\n            ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(sliceLeader);\n            nodes.add(new SolrCmdDistributor.StdNode(nodeProps, coll.getName(), aslice.getName()));\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#getSubShardLeaders(DocCollection,String,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#getSubShardLeaders(DocCollection,String,String,SolrInputDocument).mjava","sourceNew":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#SPLITSHARD} */\n  protected List<SolrCmdDistributor.Node> getSubShardLeaders(DocCollection coll, String shardId, String docId, SolrInputDocument doc) {\n    Collection<Slice> allSlices = coll.getSlices();\n    List<SolrCmdDistributor.Node> nodes = null;\n    for (Slice aslice : allSlices) {\n      final Slice.State state = aslice.getState();\n      if (state == Slice.State.CONSTRUCTION || state == Slice.State.RECOVERY)  {\n        DocRouter.Range myRange = coll.getSlice(shardId).getRange();\n        if (myRange == null) myRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        boolean isSubset = aslice.getRange() != null && aslice.getRange().isSubsetOf(myRange);\n        if (isSubset &&\n            (docId == null // in case of deletes\n                || coll.getRouter().isTargetSlice(docId, doc, req.getParams(), aslice.getName(), coll))) {\n          Replica sliceLeader = aslice.getLeader();\n          // slice leader can be null because node/shard is created zk before leader election\n          if (sliceLeader != null && clusterState.liveNodesContain(sliceLeader.getNodeName()))  {\n            if (nodes == null) nodes = new ArrayList<>();\n            ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(sliceLeader);\n            nodes.add(new SolrCmdDistributor.StdNode(nodeProps, coll.getName(), aslice.getName()));\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#SPLITSHARD} */\n  protected List<SolrCmdDistributor.Node> getSubShardLeaders(DocCollection coll, String shardId, String docId, SolrInputDocument doc) {\n    Collection<Slice> allSlices = coll.getSlices();\n    List<SolrCmdDistributor.Node> nodes = null;\n    for (Slice aslice : allSlices) {\n      final Slice.State state = aslice.getState();\n      if (state == Slice.State.CONSTRUCTION || state == Slice.State.RECOVERY)  {\n        DocRouter.Range myRange = coll.getSlice(shardId).getRange();\n        if (myRange == null) myRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        boolean isSubset = aslice.getRange() != null && aslice.getRange().isSubsetOf(myRange);\n        if (isSubset &&\n            (docId == null // in case of deletes\n                || coll.getRouter().isTargetSlice(docId, doc, req.getParams(), aslice.getName(), coll))) {\n          Replica sliceLeader = aslice.getLeader();\n          // slice leader can be null because node/shard is created zk before leader election\n          if (sliceLeader != null && zkController.getClusterState().liveNodesContain(sliceLeader.getNodeName()))  {\n            if (nodes == null) nodes = new ArrayList<>();\n            ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(sliceLeader);\n            nodes.add(new SolrCmdDistributor.StdNode(nodeProps, coll.getName(), aslice.getName()));\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"88922bf68f0b509aba218f1b9e7ef5981b4d13bc":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["88922bf68f0b509aba218f1b9e7ef5981b4d13bc"],"b0b597c65628ca9e73913a07e81691f8229bae35":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87","88922bf68f0b509aba218f1b9e7ef5981b4d13bc"]},"commit2Childs":{"88922bf68f0b509aba218f1b9e7ef5981b4d13bc":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["88922bf68f0b509aba218f1b9e7ef5981b4d13bc","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}