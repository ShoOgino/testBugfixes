{"path":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","commits":[{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","sourceNew":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = EvaluatorBag.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return EvaluatorBag.dateMathParser.parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return DataImporter.DATE_TIME_FORMAT.get().parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = EvaluatorBag.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return EvaluatorBag.dateMathParser.parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return DataImporter.DATE_TIME_FORMAT.get().parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","sourceNew":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = EvaluatorBag.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return EvaluatorBag.dateMathParser.parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return DataImporter.DATE_TIME_FORMAT.get().parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = EvaluatorBag.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return EvaluatorBag.dateMathParser.parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return DataImporter.DATE_TIME_FORMAT.get().parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c7b0ae5716b6c2044195a818e9ae58205175659","date":1353342230,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","sourceNew":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return DateFormatEvaluator.getDateMathParser().parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = EvaluatorBag.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return EvaluatorBag.dateMathParser.parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return DataImporter.DATE_TIME_FORMAT.get().parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c56959837396924832a5c1f8c1670111913c6e9b","date":1353354232,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","sourceNew":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return DateFormatEvaluator.getDateMathParser(Locale.ROOT).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return DateFormatEvaluator.getDateMathParser().parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","sourceNew":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return DateFormatEvaluator.getDateMathParser(Locale.ROOT).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = EvaluatorBag.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return EvaluatorBag.dateMathParser.parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return DataImporter.DATE_TIME_FORMAT.get().parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7a5f8ae2b11a88c74aa83a1735dc38a37e931ac","date":1357584861,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","sourceNew":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return DateFormatEvaluator.getDateMathParser(Locale.ROOT, TimeZone.getDefault()).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return DateFormatEvaluator.getDateMathParser(Locale.ROOT).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","sourceNew":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return DateFormatEvaluator.getDateMathParser(Locale.ROOT, TimeZone.getDefault()).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return DateFormatEvaluator.getDateMathParser(Locale.ROOT).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0c3d81a07652af7c4ca5568fbe7282722c32a40","date":1398935464,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","sourceNew":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return new DateMathParser(TimeZone.getDefault(), Locale.ROOT).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return DateFormatEvaluator.getDateMathParser(Locale.ROOT, TimeZone.getDefault()).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","bugFix":null,"bugIntro":["ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29","date":1463148204,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","sourceNew":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = m.group(1);\n      //TODO refactor DateMathParser.parseMath a bit to have a static method for this logic.\n      if (expr.startsWith(\"NOW\")) {\n        expr = expr.substring(\"NOW\".length());\n      }\n      try {\n        // DWS TODO: is this TimeZone the right default for us?  Deserves explanation if so.\n        return new DateMathParser(TimeZone.getDefault()).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return new DateMathParser(TimeZone.getDefault(), Locale.ROOT).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","bugFix":["b0c3d81a07652af7c4ca5568fbe7282722c32a40","4d4f1b2c5601680b01c4bb95a43fe6fb73f03103"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","sourceNew":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = m.group(1);\n      //TODO refactor DateMathParser.parseMath a bit to have a static method for this logic.\n      if (expr.startsWith(\"NOW\")) {\n        expr = expr.substring(\"NOW\".length());\n      }\n      try {\n        // DWS TODO: is this TimeZone the right default for us?  Deserves explanation if so.\n        return new DateMathParser(TimeZone.getDefault()).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return new DateMathParser(TimeZone.getDefault(), Locale.ROOT).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","sourceNew":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = m.group(1);\n      //TODO refactor DateMathParser.parseMath a bit to have a static method for this logic.\n      if (expr.startsWith(\"NOW\")) {\n        expr = expr.substring(\"NOW\".length());\n      }\n      try {\n        // DWS TODO: is this TimeZone the right default for us?  Deserves explanation if so.\n        return new DateMathParser(TimeZone.getDefault()).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return new DateMathParser(TimeZone.getDefault(), Locale.ROOT).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","sourceNew":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = m.group(1);\n      //TODO refactor DateMathParser.parseMath a bit to have a static method for this logic.\n      if (expr.startsWith(\"NOW\")) {\n        expr = expr.substring(\"NOW\".length());\n      }\n      try {\n        // DWS TODO: is this TimeZone the right default for us?  Deserves explanation if so.\n        return new DateMathParser(TimeZone.getDefault()).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = null;\n      expr = m.group(1).replaceAll(\"NOW\", \"\");\n      try {\n        return new DateMathParser(TimeZone.getDefault(), Locale.ROOT).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b","date":1598712724,"type":4,"author":"Alexandre Rafalovitch","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor#getDate(String).mjava","sourceNew":null,"sourceOld":"  /**\n   * Get the Date object corresponding to the given string.\n   *\n   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function\n   * @return a Date instance corresponding to the input string\n   */\n  private Date getDate(String dateStr) {\n    if (dateStr == null)\n      return null;\n\n    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);\n    if (m.find()) {\n      Object o = context.resolve(m.group(1));\n      if (o instanceof Date)  return (Date)o;\n      dateStr = (String) o;\n    } else  {\n      dateStr = context.replaceTokens(dateStr);\n    }\n    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);\n    if (m.find()) {\n      String expr = m.group(1);\n      //TODO refactor DateMathParser.parseMath a bit to have a static method for this logic.\n      if (expr.startsWith(\"NOW\")) {\n        expr = expr.substring(\"NOW\".length());\n      }\n      try {\n        // DWS TODO: is this TimeZone the right default for us?  Deserves explanation if so.\n        return new DateMathParser(TimeZone.getDefault()).parseMath(expr);\n      } catch (ParseException exp) {\n        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n                \"Invalid expression for date\", exp);\n      }\n    }\n    try {\n      return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).parse(dateStr);\n    } catch (ParseException exp) {\n      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,\n              \"Invalid expression for date\", exp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","f7a5f8ae2b11a88c74aa83a1735dc38a37e931ac"],"f7a5f8ae2b11a88c74aa83a1735dc38a37e931ac":["c56959837396924832a5c1f8c1670111913c6e9b"],"7c7b0ae5716b6c2044195a818e9ae58205175659":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"407687e67faf6e1f02a211ca078d8e3eed631027":["c26f00b574427b55127e869b935845554afde1fa","c56959837396924832a5c1f8c1670111913c6e9b"],"0ad30c6a479e764150a3316e57263319775f1df2":["b0c3d81a07652af7c4ca5568fbe7282722c32a40","ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29"],"c56959837396924832a5c1f8c1670111913c6e9b":["7c7b0ae5716b6c2044195a818e9ae58205175659"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b0c3d81a07652af7c4ca5568fbe7282722c32a40","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["b0c3d81a07652af7c4ca5568fbe7282722c32a40","0ad30c6a479e764150a3316e57263319775f1df2"],"ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29":["b0c3d81a07652af7c4ca5568fbe7282722c32a40"],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"b0c3d81a07652af7c4ca5568fbe7282722c32a40":["f7a5f8ae2b11a88c74aa83a1735dc38a37e931ac"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"f7a5f8ae2b11a88c74aa83a1735dc38a37e931ac":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b0c3d81a07652af7c4ca5568fbe7282722c32a40"],"7c7b0ae5716b6c2044195a818e9ae58205175659":["c56959837396924832a5c1f8c1670111913c6e9b"],"c26f00b574427b55127e869b935845554afde1fa":["7c7b0ae5716b6c2044195a818e9ae58205175659","407687e67faf6e1f02a211ca078d8e3eed631027"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"c56959837396924832a5c1f8c1670111913c6e9b":["f7a5f8ae2b11a88c74aa83a1735dc38a37e931ac","407687e67faf6e1f02a211ca078d8e3eed631027"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"],"ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29":["0ad30c6a479e764150a3316e57263319775f1df2"],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b0c3d81a07652af7c4ca5568fbe7282722c32a40":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}