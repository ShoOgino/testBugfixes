{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider,IsClosed).mjava","commits":[{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":1,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider,IsClosed).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","sourceNew":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider, IsClosed higherLevelIsClosed) {\n    this.zkServerAddress = zkServerAddress;\n    this.higherLevelIsClosed = higherLevelIsClosed;\n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    this.zkClientConnectionStrategy = strat;\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout, new IsClosed() {\n      \n      @Override\n      public boolean isClosed() {\n        return SolrZkClient.this.isClosed();\n      }\n    });\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect, new IsClosed() {\n          \n          @Override\n          public boolean isClosed() {\n            return SolrZkClient.this.isClosed();\n          }\n        });\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          zooKeeper -> {\n            SolrZooKeeper oldKeeper = keeper;\n            keeper = zooKeeper;\n            try {\n              closeKeeper(oldKeeper);\n            } finally {\n              if (isClosed) {\n                // we may have been closed\n                closeKeeper(SolrZkClient.this.keeper);\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","sourceOld":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    this.zkClientConnectionStrategy = strat;\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          zooKeeper -> {\n            SolrZooKeeper oldKeeper = keeper;\n            keeper = zooKeeper;\n            try {\n              closeKeeper(oldKeeper);\n            } finally {\n              if (isClosed) {\n                // we may have been closed\n                closeKeeper(SolrZkClient.this.keeper);\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider,IsClosed).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider,IsClosed).mjava","sourceNew":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider, IsClosed higherLevelIsClosed) {\n    this.zkServerAddress = zkServerAddress;\n    this.higherLevelIsClosed = higherLevelIsClosed;\n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    this.zkClientConnectionStrategy = strat;\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout, new IsClosed() {\n\n      @Override\n      public boolean isClosed() {\n        return SolrZkClient.this.isClosed();\n      }\n    });\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect, new IsClosed() {\n\n          @Override\n          public boolean isClosed() {\n            return SolrZkClient.this.isClosed();\n          }\n        });\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          zooKeeper -> {\n            SolrZooKeeper oldKeeper = keeper;\n            keeper = zooKeeper;\n            try {\n              closeKeeper(oldKeeper);\n            } finally {\n              if (isClosed) {\n                // we may have been closed\n                closeKeeper(SolrZkClient.this.keeper);\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","sourceOld":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider, IsClosed higherLevelIsClosed) {\n    this.zkServerAddress = zkServerAddress;\n    this.higherLevelIsClosed = higherLevelIsClosed;\n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    this.zkClientConnectionStrategy = strat;\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout, new IsClosed() {\n      \n      @Override\n      public boolean isClosed() {\n        return SolrZkClient.this.isClosed();\n      }\n    });\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect, new IsClosed() {\n          \n          @Override\n          public boolean isClosed() {\n            return SolrZkClient.this.isClosed();\n          }\n        });\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          zooKeeper -> {\n            SolrZooKeeper oldKeeper = keeper;\n            keeper = zooKeeper;\n            try {\n              closeKeeper(oldKeeper);\n            } finally {\n              if (isClosed) {\n                // we may have been closed\n                closeKeeper(SolrZkClient.this.keeper);\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1778938cb7fb298e6e07a43e2d5acaf552d61518","date":1559609435,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider,IsClosed).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider,IsClosed).mjava","sourceNew":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider, IsClosed higherLevelIsClosed) {\n    this.zkServerAddress = zkServerAddress;\n    this.higherLevelIsClosed = higherLevelIsClosed;\n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    this.zkClientConnectionStrategy = strat;\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout, new IsClosed() {\n\n      @Override\n      public boolean isClosed() {\n        return SolrZkClient.this.isClosed();\n      }\n    });\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect, new IsClosed() {\n\n          @Override\n          public boolean isClosed() {\n            return SolrZkClient.this.isClosed();\n          }\n        });\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          zooKeeper -> {\n            SolrZooKeeper oldKeeper = keeper;\n            keeper = zooKeeper;\n            try {\n              closeKeeper(oldKeeper);\n            } finally {\n              if (isClosed) {\n                // we may have been closed\n                closeKeeper(SolrZkClient.this.keeper);\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      zkConnManagerCallbackExecutor.shutdown();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","sourceOld":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider, IsClosed higherLevelIsClosed) {\n    this.zkServerAddress = zkServerAddress;\n    this.higherLevelIsClosed = higherLevelIsClosed;\n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    this.zkClientConnectionStrategy = strat;\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout, new IsClosed() {\n\n      @Override\n      public boolean isClosed() {\n        return SolrZkClient.this.isClosed();\n      }\n    });\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect, new IsClosed() {\n\n          @Override\n          public boolean isClosed() {\n            return SolrZkClient.this.isClosed();\n          }\n        });\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          zooKeeper -> {\n            SolrZooKeeper oldKeeper = keeper;\n            keeper = zooKeeper;\n            try {\n              closeKeeper(oldKeeper);\n            } finally {\n              if (isClosed) {\n                // we may have been closed\n                closeKeeper(SolrZkClient.this.keeper);\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"1778938cb7fb298e6e07a43e2d5acaf552d61518":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1778938cb7fb298e6e07a43e2d5acaf552d61518"]},"commit2Childs":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["1778938cb7fb298e6e07a43e2d5acaf552d61518"],"1778938cb7fb298e6e07a43e2d5acaf552d61518":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}