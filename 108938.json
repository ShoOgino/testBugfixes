{"path":"src/common/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","commits":[{"id":"e3602d5eab954caecc726ab136ad580ac1ceb917","date":1228676831,"type":1,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/common/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Integer.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue queue = new PQueue(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (Object o : queue.getValues()) {\n          if (o==null) continue;\n          CacheEntry<K,V> ce = (CacheEntry)o;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Integer.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue queue = new PQueue(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (Object o : queue.getValues()) {\n          if (o==null) continue;\n          CacheEntry<K,V> ce = (CacheEntry)o;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46c2e69e24fdb80c38cccc44674ea27a8d993f49","date":1258574434,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/common/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"src/common/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue queue = new PQueue(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (Object o : queue.getValues()) {\n          if (o==null) continue;\n          CacheEntry<K,V> ce = (CacheEntry)o;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Integer.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue queue = new PQueue(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (Object o : queue.getValues()) {\n          if (o==null) continue;\n          CacheEntry<K,V> ce = (CacheEntry)o;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":["516bcb3c0d409157f56056e1ecd5e5361ca4ae0b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/common/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"src/common/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue queue = new PQueue(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (Object o : queue.getValues()) {\n          if (o==null) continue;\n          CacheEntry<K,V> ce = (CacheEntry)o;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue queue = new PQueue(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (Object o : queue.getValues()) {\n          if (o==null) continue;\n          CacheEntry<K,V> ce = (CacheEntry)o;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"46c2e69e24fdb80c38cccc44674ea27a8d993f49":["e3602d5eab954caecc726ab136ad580ac1ceb917"],"e3602d5eab954caecc726ab136ad580ac1ceb917":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["46c2e69e24fdb80c38cccc44674ea27a8d993f49"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"46c2e69e24fdb80c38cccc44674ea27a8d993f49":["ad94625fb8d088209f46650c8097196fec67f00c"],"e3602d5eab954caecc726ab136ad580ac1ceb917":["46c2e69e24fdb80c38cccc44674ea27a8d993f49"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["e3602d5eab954caecc726ab136ad580ac1ceb917"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}