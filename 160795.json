{"path":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seekCeil(BytesRef,boolean).mjava","commits":[{"id":"fd9cc9d77712aba3662f24632df7539ab75e3667","date":1309095238,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seekCeil(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seekCeil(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == internedFieldName && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != internedFieldName) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t2 == null || !t2.field().equals(internedFieldName);\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == internedFieldName && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != internedFieldName) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t2 == null || !t2.field().equals(internedFieldName);\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seekCeil(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seekCeil(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == internedFieldName && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != internedFieldName) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t2 == null || !t2.field().equals(internedFieldName);\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != fieldInfo.name) {\n          assert t2 == null || !t2.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seekCeil(BytesRef,boolean).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public SeekStatus seekCeil(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == internedFieldName && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != internedFieldName) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t2 == null || !t2.field().equals(internedFieldName);\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#seekCeil(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seekCeil(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seekCeil(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == internedFieldName && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != internedFieldName) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t2 == null || !t2.field().equals(internedFieldName);\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seekCeil(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == internedFieldName && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != internedFieldName) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t2 == null || !t2.field().equals(internedFieldName);\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["fd9cc9d77712aba3662f24632df7539ab75e3667"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2553b00f699380c64959ccb27991289aae87be2e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fd9cc9d77712aba3662f24632df7539ab75e3667"],"fd9cc9d77712aba3662f24632df7539ab75e3667":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fd9cc9d77712aba3662f24632df7539ab75e3667"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2553b00f699380c64959ccb27991289aae87be2e","fd9cc9d77712aba3662f24632df7539ab75e3667","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"2553b00f699380c64959ccb27991289aae87be2e":[],"fd9cc9d77712aba3662f24632df7539ab75e3667":["7b91922b55d15444d554721b352861d028eb8278","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}