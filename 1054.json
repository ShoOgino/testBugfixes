{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","commits":[{"id":"b4e444678504caf66a8060b1d514383aa4feac0c","date":1457399659,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      //System.err.println(\"    computing X bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          final double l = r * m + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom0 = 0.5 / m;\n          final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n          addPoint(boundsInfo, bounds, thePoint);\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\"Not x quadratic\");\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          final double l = r * m + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom0 = 0.5 / m;\n          final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n          addPoint(boundsInfo, bounds, thePoint);\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      //System.err.println(\"    computing X bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          final double l = r * m + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom0 = 0.5 / m;\n          final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n          addPoint(boundsInfo, bounds, thePoint);\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\"Not x quadratic\");\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          final double l = r * m + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom0 = 0.5 / m;\n          final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n          addPoint(boundsInfo, bounds, thePoint);\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c4f41e3b4e4e625f690a303a00795c8b9c08e86","date":1460703671,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      //System.err.println(\"    computing X bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\"Not x quadratic\");\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      //System.err.println(\"    computing X bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          final double l = r * m + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom0 = 0.5 / m;\n          final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n          addPoint(boundsInfo, bounds, thePoint);\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\"Not x quadratic\");\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          final double l = r * m + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom0 = 0.5 / m;\n          final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n          addPoint(boundsInfo, bounds, thePoint);\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"db12cd131bb09d6eb63c19894fedc4a125bdf63a","date":1470810555,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      //System.err.println(\"    computing X bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\"Not x quadratic\");\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","bugFix":["d8f71af177fad4bbfdf462d318247e573faac27f","f64b7098768253180859cd8faeae6b1a185b06ed"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      //System.err.println(\"    computing X bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\"Not x quadratic\");\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      //System.err.println(\"    computing X bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\"Not x quadratic\");\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44c3a4ebfa1a780298de8b00afc0722c16233080","date":1522505029,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        if (points.length > 0) {\n          boundsInfo.addZValue(points[0]);\n        }\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","date":1583186777,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        if (points.length > 0) {\n          boundsInfo.addZValue(points[0]);\n        }\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.xyScaling *planetModel.xyScaling + z*z*planetModel.zScaling *planetModel.zScaling);\n    final double abSquared = planetModel.xyScaling * planetModel.xyScaling;\n    final double cSquared = planetModel.zScaling * planetModel.zScaling;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/xyScaling^2 + y^2/xyScaling^2 + z^2/zScaling^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/xyScaling^2,2y/xyScaling^2,2z/zScaling^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/xyScaling^2\n      // 0 = l*B + m*2y/xyScaling^2\n      // 0 = l*C + m*2z/zScaling^2\n      // Ax + By + Cz + D = 0\n      // x^2/xyScaling^2 + y^2/xyScaling^2 + z^2/zScaling^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * xyScaling^2 ) / (2 * m)\n      // y = (-l*B * xyScaling^2) / ( 2 * m)\n      // z = (-l*C * zScaling^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * xyScaling^2 ) / (2 * m)) + B * ((-l*B * xyScaling^2) / ( 2 * m)) + C * ((-l*C * zScaling^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * xyScaling^2 ) / (2 * m))^2/xyScaling^2 + ((-l*B * xyScaling^2) / ( 2 * m))^2/xyScaling^2 + ((-l*C * zScaling^2)/ (2 * m))^2/zScaling^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * xyScaling^2 ) / (2 * m)) + B * ((-l*B * xyScaling^2) / ( 2 * m)) + C * ((-l*C * zScaling^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * xyScaling^2 ) + B * (-l*B * xyScaling^2) + C * (-l*C * zScaling^2) + D * 2 * m = 0\n      // A * xyScaling^2 - l*A^2* xyScaling^2 - B^2 * l * xyScaling^2 - C^2 * l * zScaling^2 + D * 2 * m = 0\n      // - l *(A^2* xyScaling^2 + B^2 * xyScaling^2 + C^2 * zScaling^2) + (A * xyScaling^2 + D * 2 * m) = 0\n      // l = (A * xyScaling^2 + D * 2 * m) / (A^2* xyScaling^2 + B^2 * xyScaling^2 + C^2 * zScaling^2)\n      // l = A * xyScaling^2 / (A^2* xyScaling^2 + B^2 * xyScaling^2 + C^2 * zScaling^2) + m * 2 * D / (A^2* xyScaling^2 + B^2 * xyScaling^2 + C^2 * zScaling^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* xyScaling^2 + B^2 * xyScaling^2 + C^2 * zScaling^2)\n      // \n      // Then:\n      // \n      // l = A * xyScaling^2 * k + m * 2 * D * k\n      // l = k * (A*xyScaling^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*xyScaling^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * xyScaling^2 ) / (2 * m))^2/xyScaling^2 + ((-l*B * xyScaling^2) / ( 2 * m))^2/xyScaling^2 + ((-l*C * zScaling^2)/ (2 * m))^2/zScaling^2 - 1 = 0\n      // ((1 - l*A) * xyScaling^2 )^2/xyScaling^2 + (-l*B * xyScaling^2)^2/xyScaling^2 + (-l*C * zScaling^2)^2/zScaling^2 = 4 * m^2\n      // (1 - l*A)^2 * xyScaling^2 + (-l*B)^2 * xyScaling^2 + (-l*C)^2 * zScaling^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * xyScaling^2 + l^2*B^2 * xyScaling^2 + l^2*C^2 * zScaling^2 = 4 * m^2\n      // xyScaling^2 - 2*A*xyScaling^2*l + A^2*xyScaling^2*l^2 + B^2*xyScaling^2*l^2 + C^2*zScaling^2*l^2 - 4*m^2 = 0\n      // \n      // (zScaling) Substitute for l, l^2\n      //\n      // xyScaling^2 - 2*A*xyScaling^2*(r*m + q) + A^2*xyScaling^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*xyScaling^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*zScaling^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // xyScaling^2 - 2*A*xyScaling^2*r*m - 2*A*xyScaling^2*q + A^2*xyScaling^2*r^2*m^2 + 2*A^2*xyScaling^2*r*q*m +\n      //        A^2*xyScaling^2*q^2 + B^2*xyScaling^2*r^2*m^2 + 2*B^2*xyScaling^2*r*q*m + B^2*xyScaling^2*q^2 + C^2*zScaling^2*r^2*m^2 + 2*C^2*zScaling^2*r*q*m + C^2*zScaling^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*xyScaling^2*r^2 + B^2*xyScaling^2*r^2 + C^2*zScaling^2*r^2 - 4] +\n      // m * [- 2*A*xyScaling^2*r + 2*A^2*xyScaling^2*r*q + 2*B^2*xyScaling^2*r*q + 2*C^2*zScaling^2*r*q] +\n      // [xyScaling^2 - 2*A*xyScaling^2*q + A^2*xyScaling^2*q^2 + B^2*xyScaling^2*q^2 + C^2*zScaling^2*q^2]  =  0\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = ((1 - l*A) * xyScaling^2 ) / (2 * m)\n            // y = (-l*B * xyScaling^2) / ( 2 * m)\n            // z = (-l*C * zScaling^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint.x*thePoint.x*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint.y*thePoint.y*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint.z*thePoint.z*planetModel.inverseZScaling*planetModel.inverseZScaling);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = ((1 - l*A) * xyScaling^2 ) / (2 * m)\n            // y = (-l*B * xyScaling^2) / ( 2 * m)\n            // z = (-l*C * zScaling^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint1.y*thePoint1.y*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint1.z*thePoint1.z*planetModel.inverseZScaling*planetModel.inverseZScaling);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint2.y*thePoint2.y*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint2.z*thePoint2.z*planetModel.inverseZScaling*planetModel.inverseZScaling);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - zScaling / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * xyScaling^2 ) / (2 * m)\n        // y = (-l*B * xyScaling^2) / ( 2 * m)\n        // z = (-l*C * zScaling^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint.y*thePoint.y*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint.z*thePoint.z*planetModel.inverseZScaling*planetModel.inverseZScaling);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/xyScaling^2 + y^2/xyScaling^2 + z^2/zScaling^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/xyScaling^2,2y/xyScaling^2,2z/zScaling^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/xyScaling^2\n      // 1 = l*B + m*2y/xyScaling^2\n      // 0 = l*C + m*2z/zScaling^2\n      // Ax + By + Cz + D = 0\n      // x^2/xyScaling^2 + y^2/xyScaling^2 + z^2/zScaling^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * xyScaling^2 ) / (2 * m)\n      // y = ((1 - l*B) * xyScaling^2) / ( 2 * m)\n      // z = (-l*C * zScaling^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * xyScaling^2 ) / (2 * m)) + B * (((1 - l*B) * xyScaling^2) / ( 2 * m)) + C * ((-l*C * zScaling^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * xyScaling^2 ) / (2 * m))^2/xyScaling^2 + (((1 - l*B) * xyScaling^2) / ( 2 * m))^2/xyScaling^2 + ((-l*C * zScaling^2)/ (2 * m))^2/zScaling^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * xyScaling^2 ) / (2 * m)) + B * (((1 - l*B) * xyScaling^2) / ( 2 * m)) + C * ((-l*C * zScaling^2)/ (2 * m)) + D = 0\n      // A * (-l*A * xyScaling^2 ) + B * ((1-l*B) * xyScaling^2) + C * (-l*C * zScaling^2) + D * 2 * m = 0\n      // -A^2*l*xyScaling^2 + B*xyScaling^2 - l*B^2*xyScaling^2 - C^2*l*zScaling^2 + D*2*m = 0\n      // - l *(A^2* xyScaling^2 + B^2 * xyScaling^2 + C^2 * zScaling^2) + (B * xyScaling^2 + D * 2 * m) = 0\n      // l = (B * xyScaling^2 + D * 2 * m) / (A^2* xyScaling^2 + B^2 * xyScaling^2 + C^2 * zScaling^2)\n      // l = B * xyScaling^2 / (A^2* xyScaling^2 + B^2 * xyScaling^2 + C^2 * zScaling^2) + m * 2 * D / (A^2* xyScaling^2 + B^2 * xyScaling^2 + C^2 * zScaling^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* xyScaling^2 + B^2 * xyScaling^2 + C^2 * zScaling^2)\n      // \n      // Then:\n      // \n      // l = B * xyScaling^2 * k + m * 2 * D * k\n      // l = k * (B*xyScaling^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*xyScaling^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * xyScaling^2 ) / (2 * m))^2/xyScaling^2 + (((1 - l*B) * xyScaling^2) / ( 2 * m))^2/xyScaling^2 + ((-l*C * zScaling^2)/ (2 * m))^2/zScaling^2 - 1 = 0\n      // (-l*A * xyScaling^2 )^2/xyScaling^2 + ((1 - l*B) * xyScaling^2)^2/xyScaling^2 + (-l*C * zScaling^2)^2/zScaling^2 = 4 * m^2\n      // (-l*A)^2 * xyScaling^2 + (1 - l*B)^2 * xyScaling^2 + (-l*C)^2 * zScaling^2 = 4 * m^2\n      // l^2*A^2 * xyScaling^2 + (1 - 2*l*B + l^2*B^2) * xyScaling^2 + l^2*C^2 * zScaling^2 = 4 * m^2\n      // A^2*xyScaling^2*l^2 + xyScaling^2 - 2*B*xyScaling^2*l + B^2*xyScaling^2*l^2 + C^2*zScaling^2*l^2 - 4*m^2 = 0\n      // \n      // (zScaling) Substitute for l, l^2\n      //\n      // A^2*xyScaling^2*(r^2 * m^2 + 2*r*m*q + q^2) + xyScaling^2 - 2*B*xyScaling^2*(r*m + q) + B^2*xyScaling^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*zScaling^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*xyScaling^2*r^2*m^2 + 2*A^2*xyScaling^2*r*q*m + A^2*xyScaling^2*q^2 + xyScaling^2 - 2*B*xyScaling^2*r*m - 2*B*xyScaling^2*q + B^2*xyScaling^2*r^2*m^2 +\n      //    2*B^2*xyScaling^2*r*q*m + B^2*xyScaling^2*q^2 + C^2*zScaling^2*r^2*m^2 + 2*C^2*zScaling^2*r*q*m + C^2*zScaling^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*xyScaling^2*r^2 + B^2*xyScaling^2*r^2 + C^2*zScaling^2*r^2 - 4] +\n      // m * [2*A^2*xyScaling^2*r*q - 2*B*xyScaling^2*r + 2*B^2*xyScaling^2*r*q + 2*C^2*zScaling^2*r*q] +\n      // [A^2*xyScaling^2*q^2 + xyScaling^2 - 2*B*xyScaling^2*q + B^2*xyScaling^2*q^2 + C^2*zScaling^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = (-l*A * xyScaling^2 ) / (2 * m)\n            // y = ((1.0-l*B) * xyScaling^2) / ( 2 * m)\n            // z = (-l*C * zScaling^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint.x*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint.y*thePoint.y*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint.z*thePoint.z*planetModel.inverseZScaling*planetModel.inverseZScaling);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = (-l*A * xyScaling^2 ) / (2 * m)\n            // y = ((1.0-l*B) * xyScaling^2) / ( 2 * m)\n            // z = (-l*C * zScaling^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint1.y*thePoint1.y*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint1.z*thePoint1.z*planetModel.inverseZScaling*planetModel.inverseZScaling);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint2.y*thePoint2.y*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint2.z*thePoint2.z*planetModel.inverseZScaling*planetModel.inverseZScaling);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - zScaling / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * xyScaling^2 ) / (2 * m)\n        // y = ((1-l*B) * xyScaling^2) / ( 2 * m)\n        // z = (-l*C * zScaling^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint.y*thePoint.y*planetModel.inverseXYScaling*planetModel.inverseXYScaling + thePoint.z*thePoint.z*planetModel.inverseZScaling*planetModel.inverseZScaling);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        if (points.length > 0) {\n          boundsInfo.addZValue(points[0]);\n        }\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = ((1 - l*A) * ab^2 ) / (2 * m)\n            // y = (-l*B * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=n B=0 C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addXValue(-D/A);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          // Valid?\n          if (Math.abs(m) >= MINIMUM_RESOLUTION) {\n            final double l = r * m + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom0 = 0.5 / m;\n            final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n            addPoint(boundsInfo, bounds, thePoint);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          if (Math.abs(m1) >= MINIMUM_RESOLUTION || Math.abs(m2) >= MINIMUM_RESOLUTION) {\n            final double l1 = r * m1 + q;\n            final double l2 = r * m2 + q;\n            // x = (-l*A * ab^2 ) / (2 * m)\n            // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n            // z = (-l*C * c^2)/ (2 * m)\n            final double denom1 = 0.5 / m1;\n            final double denom2 = 0.5 / m2;\n            final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n            final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n            //Math is not quite accurate enough for this\n            //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n            //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n            //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n            //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n            //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n            addPoint(boundsInfo, bounds, thePoint1);\n            addPoint(boundsInfo, bounds, thePoint2);\n          } else {\n            // This is a plane of the form A=0 B=n C=0.  We can set a bound only by noting the D value.\n            boundsInfo.addYValue(-D/B);\n          }\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"44c3a4ebfa1a780298de8b00afc0722c16233080":["db12cd131bb09d6eb63c19894fedc4a125bdf63a"],"db12cd131bb09d6eb63c19894fedc4a125bdf63a":["0c4f41e3b4e4e625f690a303a00795c8b9c08e86"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["44c3a4ebfa1a780298de8b00afc0722c16233080"],"b4e444678504caf66a8060b1d514383aa4feac0c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["0c4f41e3b4e4e625f690a303a00795c8b9c08e86","db12cd131bb09d6eb63c19894fedc4a125bdf63a"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["0c4f41e3b4e4e625f690a303a00795c8b9c08e86","db12cd131bb09d6eb63c19894fedc4a125bdf63a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"],"0c4f41e3b4e4e625f690a303a00795c8b9c08e86":["b4e444678504caf66a8060b1d514383aa4feac0c"]},"commit2Childs":{"44c3a4ebfa1a780298de8b00afc0722c16233080":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"],"db12cd131bb09d6eb63c19894fedc4a125bdf63a":["44c3a4ebfa1a780298de8b00afc0722c16233080","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b4e444678504caf66a8060b1d514383aa4feac0c"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b4e444678504caf66a8060b1d514383aa4feac0c":["0c4f41e3b4e4e625f690a303a00795c8b9c08e86"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"0c4f41e3b4e4e625f690a303a00795c8b9c08e86":["db12cd131bb09d6eb63c19894fedc4a125bdf63a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}