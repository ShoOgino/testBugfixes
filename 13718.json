{"path":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","sourceNew":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField( String source, String dest, int maxChars )\n  {\n    boolean sourceIsPattern = isWildCard(source);\n    boolean destIsPattern   = isWildCard(dest);\n\n    log.debug(\"copyField source='\"+source+\"' dest='\"+dest+\"' maxChars='\"+maxChars);\n    SchemaField d = getFieldOrNull(dest);\n    if(d == null){\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField destination :'\"+dest+\"' does not exist\" );\n    }\n\n    if(sourceIsPattern) {\n      if( destIsPattern ) {\n        DynamicField df = null;\n        for( DynamicField dd : dynamicFields ) {\n          if( dd.regex.equals( dest ) ) {\n            df = dd;\n            break;\n          }\n        }\n        if( df == null ) {\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n        }\n        registerDynamicCopyField(new DynamicDestCopy(source, df, maxChars ));\n      }\n      else {\n        registerDynamicCopyField(new DynamicCopy(source, d, maxChars));\n      }\n    } \n    else if( destIsPattern ) {\n      String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n    }\n    else {\n      // retrieve the field to force an exception if it doesn't exist\n      SchemaField f = getField(source);\n\n      List<CopyField> copyFieldList = copyFieldsMap.get(source);\n      if (copyFieldList == null) {\n        copyFieldList = new ArrayList<CopyField>();\n        copyFieldsMap.put(source, copyFieldList);\n      }\n      copyFieldList.add(new CopyField(f, d, maxChars));\n\n      copyFieldTargetCounts.put(d, (copyFieldTargetCounts.containsKey(d) ? copyFieldTargetCounts.get(d) + 1 : 1));\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField( String source, String dest, int maxChars )\n  {\n    boolean sourceIsPattern = isWildCard(source);\n    boolean destIsPattern   = isWildCard(dest);\n\n    log.debug(\"copyField source='\"+source+\"' dest='\"+dest+\"' maxChars='\"+maxChars);\n    SchemaField d = getFieldOrNull(dest);\n    if(d == null){\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField destination :'\"+dest+\"' does not exist\" );\n    }\n\n    if(sourceIsPattern) {\n      if( destIsPattern ) {\n        DynamicField df = null;\n        for( DynamicField dd : dynamicFields ) {\n          if( dd.regex.equals( dest ) ) {\n            df = dd;\n            break;\n          }\n        }\n        if( df == null ) {\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n        }\n        registerDynamicCopyField(new DynamicDestCopy(source, df, maxChars ));\n      }\n      else {\n        registerDynamicCopyField(new DynamicCopy(source, d, maxChars));\n      }\n    } \n    else if( destIsPattern ) {\n      String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n    }\n    else {\n      // retrieve the field to force an exception if it doesn't exist\n      SchemaField f = getField(source);\n\n      List<CopyField> copyFieldList = copyFieldsMap.get(source);\n      if (copyFieldList == null) {\n        copyFieldList = new ArrayList<CopyField>();\n        copyFieldsMap.put(source, copyFieldList);\n      }\n      copyFieldList.add(new CopyField(f, d, maxChars));\n\n      copyFieldTargetCounts.put(d, (copyFieldTargetCounts.containsKey(d) ? copyFieldTargetCounts.get(d) + 1 : 1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","sourceNew":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField( String source, String dest, int maxChars )\n  {\n    boolean sourceIsPattern = isWildCard(source);\n    boolean destIsPattern   = isWildCard(dest);\n\n    log.debug(\"copyField source='\"+source+\"' dest='\"+dest+\"' maxChars='\"+maxChars);\n    SchemaField d = getFieldOrNull(dest);\n    if(d == null){\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField destination :'\"+dest+\"' does not exist\" );\n    }\n\n    if(sourceIsPattern) {\n      if( destIsPattern ) {\n        DynamicField df = null;\n        for( DynamicField dd : dynamicFields ) {\n          if( dd.regex.equals( dest ) ) {\n            df = dd;\n            break;\n          }\n        }\n        if( df == null ) {\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n        }\n        registerDynamicCopyField(new DynamicDestCopy(source, df, maxChars ));\n      }\n      else {\n        registerDynamicCopyField(new DynamicCopy(source, d, maxChars));\n      }\n    } \n    else if( destIsPattern ) {\n      String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n    }\n    else {\n      // retrieve the field to force an exception if it doesn't exist\n      SchemaField f = getField(source);\n\n      List<CopyField> copyFieldList = copyFieldsMap.get(source);\n      if (copyFieldList == null) {\n        copyFieldList = new ArrayList<CopyField>();\n        copyFieldsMap.put(source, copyFieldList);\n      }\n      copyFieldList.add(new CopyField(f, d, maxChars));\n\n      copyFieldTargetCounts.put(d, (copyFieldTargetCounts.containsKey(d) ? copyFieldTargetCounts.get(d) + 1 : 1));\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField( String source, String dest, int maxChars )\n  {\n    boolean sourceIsPattern = isWildCard(source);\n    boolean destIsPattern   = isWildCard(dest);\n\n    log.debug(\"copyField source='\"+source+\"' dest='\"+dest+\"' maxChars='\"+maxChars);\n    SchemaField d = getFieldOrNull(dest);\n    if(d == null){\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField destination :'\"+dest+\"' does not exist\" );\n    }\n\n    if(sourceIsPattern) {\n      if( destIsPattern ) {\n        DynamicField df = null;\n        for( DynamicField dd : dynamicFields ) {\n          if( dd.regex.equals( dest ) ) {\n            df = dd;\n            break;\n          }\n        }\n        if( df == null ) {\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n        }\n        registerDynamicCopyField(new DynamicDestCopy(source, df, maxChars ));\n      }\n      else {\n        registerDynamicCopyField(new DynamicCopy(source, d, maxChars));\n      }\n    } \n    else if( destIsPattern ) {\n      String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n    }\n    else {\n      // retrieve the field to force an exception if it doesn't exist\n      SchemaField f = getField(source);\n\n      List<CopyField> copyFieldList = copyFieldsMap.get(source);\n      if (copyFieldList == null) {\n        copyFieldList = new ArrayList<CopyField>();\n        copyFieldsMap.put(source, copyFieldList);\n      }\n      copyFieldList.add(new CopyField(f, d, maxChars));\n\n      copyFieldTargetCounts.put(d, (copyFieldTargetCounts.containsKey(d) ? copyFieldTargetCounts.get(d) + 1 : 1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","sourceNew":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField( String source, String dest, int maxChars )\n  {\n    boolean sourceIsPattern = isWildCard(source);\n    boolean destIsPattern   = isWildCard(dest);\n\n    log.debug(\"copyField source='\"+source+\"' dest='\"+dest+\"' maxChars='\"+maxChars);\n    SchemaField d = getFieldOrNull(dest);\n    if(d == null){\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField destination :'\"+dest+\"' does not exist\" );\n    }\n\n    if(sourceIsPattern) {\n      if( destIsPattern ) {\n        DynamicField df = null;\n        for( DynamicField dd : dynamicFields ) {\n          if( dd.regex.equals( dest ) ) {\n            df = dd;\n            break;\n          }\n        }\n        if( df == null ) {\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n        }\n        registerDynamicCopyField(new DynamicDestCopy(source, df, maxChars ));\n      }\n      else {\n        registerDynamicCopyField(new DynamicCopy(source, d, maxChars));\n      }\n    } \n    else if( destIsPattern ) {\n      String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n    }\n    else {\n      // retrieve the field to force an exception if it doesn't exist\n      SchemaField f = getField(source);\n\n      List<CopyField> copyFieldList = copyFieldsMap.get(source);\n      if (copyFieldList == null) {\n        copyFieldList = new ArrayList<CopyField>();\n        copyFieldsMap.put(source, copyFieldList);\n      }\n      copyFieldList.add(new CopyField(f, d, maxChars));\n\n      copyFieldTargetCounts.put(d, (copyFieldTargetCounts.containsKey(d) ? copyFieldTargetCounts.get(d) + 1 : 1));\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField( String source, String dest, int maxChars )\n  {\n    boolean sourceIsPattern = isWildCard(source);\n    boolean destIsPattern   = isWildCard(dest);\n\n    log.debug(\"copyField source='\"+source+\"' dest='\"+dest+\"' maxChars='\"+maxChars);\n    SchemaField d = getFieldOrNull(dest);\n    if(d == null){\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField destination :'\"+dest+\"' does not exist\" );\n    }\n\n    if(sourceIsPattern) {\n      if( destIsPattern ) {\n        DynamicField df = null;\n        for( DynamicField dd : dynamicFields ) {\n          if( dd.regex.equals( dest ) ) {\n            df = dd;\n            break;\n          }\n        }\n        if( df == null ) {\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n        }\n        registerDynamicCopyField(new DynamicDestCopy(source, df, maxChars ));\n      }\n      else {\n        registerDynamicCopyField(new DynamicCopy(source, d, maxChars));\n      }\n    } \n    else if( destIsPattern ) {\n      String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n    }\n    else {\n      // retrieve the field to force an exception if it doesn't exist\n      SchemaField f = getField(source);\n\n      List<CopyField> copyFieldList = copyFieldsMap.get(source);\n      if (copyFieldList == null) {\n        copyFieldList = new ArrayList<CopyField>();\n        copyFieldsMap.put(source, copyFieldList);\n      }\n      copyFieldList.add(new CopyField(f, d, maxChars));\n\n      copyFieldTargetCounts.put(d, (copyFieldTargetCounts.containsKey(d) ? copyFieldTargetCounts.get(d) + 1 : 1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37","date":1362545433,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","sourceNew":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(\"copyField source='\" + source + \"' dest='\" + dest + \"' maxChars=\" + maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    \n    if (null == destSchemaField || null == sourceSchemaField) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField && (null != sourceSchemaField || sourceIsDynamicFieldReference)) break;\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsDynamicFieldReference) {\n      String msg = \"copyField source :'\" + source + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsDynamicFieldReference) {\n      if (null != destDynamicField) { // source & dest: dynamic field references\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: dynamic field reference; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else {                          \n      if (null != destDynamicField) { // source: explicit field; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source is also dynamic with an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields \n        List<CopyField> copyFieldList = copyFieldsMap.get(source);\n        if (copyFieldList == null) {\n          copyFieldList = new ArrayList<CopyField>();\n          copyFieldsMap.put(source, copyFieldList);\n        }\n        copyFieldList.add(new CopyField(sourceSchemaField, destSchemaField, maxChars));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField( String source, String dest, int maxChars )\n  {\n    boolean sourceIsPattern = isWildCard(source);\n    boolean destIsPattern   = isWildCard(dest);\n\n    log.debug(\"copyField source='\"+source+\"' dest='\"+dest+\"' maxChars='\"+maxChars);\n    SchemaField d = getFieldOrNull(dest);\n    if(d == null){\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField destination :'\"+dest+\"' does not exist\" );\n    }\n\n    if(sourceIsPattern) {\n      if( destIsPattern ) {\n        DynamicField df = null;\n        for( DynamicField dd : dynamicFields ) {\n          if( dd.regex.equals( dest ) ) {\n            df = dd;\n            break;\n          }\n        }\n        if( df == null ) {\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n        }\n        registerDynamicCopyField(new DynamicDestCopy(source, df, maxChars ));\n      }\n      else {\n        registerDynamicCopyField(new DynamicCopy(source, d, maxChars));\n      }\n    } \n    else if( destIsPattern ) {\n      String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n    }\n    else {\n      // retrieve the field to force an exception if it doesn't exist\n      SchemaField f = getField(source);\n\n      List<CopyField> copyFieldList = copyFieldsMap.get(source);\n      if (copyFieldList == null) {\n        copyFieldList = new ArrayList<CopyField>();\n        copyFieldsMap.put(source, copyFieldList);\n      }\n      copyFieldList.add(new CopyField(f, d, maxChars));\n\n      copyFieldTargetCounts.put(d, (copyFieldTargetCounts.containsKey(d) ? copyFieldTargetCounts.get(d) + 1 : 1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b","date":1363161710,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","sourceNew":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(\"copyField source='\" + source + \"' dest='\" + dest + \"' maxChars=\" + maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    boolean sourceIsExplicitFieldGlob = false;\n    \n    if (null == sourceSchemaField && isValidFieldGlob(source)) {\n      Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n      for (String field : fields.keySet()) {\n        if (pattern.matcher(field).matches()) {\n          sourceIsExplicitFieldGlob = true;\n          break;\n        }\n      }\n    }\n    \n    if (null == destSchemaField || (null == sourceSchemaField && ! sourceIsExplicitFieldGlob)) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField \n            && (null != sourceSchemaField || sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob)) {\n          break;\n        }\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n      String msg = \"copyField source :'\" + source + \"' doesn't match any explicit field or dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob) {\n      if (null != destDynamicField) { // source: dynamic field ref or explicit field glob; dest: dynamic field ref\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: dynamic field reference; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else {                          \n      if (null != destDynamicField) { // source: explicit field; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source also has an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields \n        List<CopyField> copyFieldList = copyFieldsMap.get(source);\n        if (copyFieldList == null) {\n          copyFieldList = new ArrayList<CopyField>();\n          copyFieldsMap.put(source, copyFieldList);\n        }\n        copyFieldList.add(new CopyField(sourceSchemaField, destSchemaField, maxChars));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(\"copyField source='\" + source + \"' dest='\" + dest + \"' maxChars=\" + maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    \n    if (null == destSchemaField || null == sourceSchemaField) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField && (null != sourceSchemaField || sourceIsDynamicFieldReference)) break;\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsDynamicFieldReference) {\n      String msg = \"copyField source :'\" + source + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsDynamicFieldReference) {\n      if (null != destDynamicField) { // source & dest: dynamic field references\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: dynamic field reference; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else {                          \n      if (null != destDynamicField) { // source: explicit field; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source is also dynamic with an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields \n        List<CopyField> copyFieldList = copyFieldsMap.get(source);\n        if (copyFieldList == null) {\n          copyFieldList = new ArrayList<CopyField>();\n          copyFieldsMap.put(source, copyFieldList);\n        }\n        copyFieldList.add(new CopyField(sourceSchemaField, destSchemaField, maxChars));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd","date":1364185773,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","sourceNew":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(COPY_FIELD + \" \" + SOURCE + \"='\" + source + \"' \" + DESTINATION + \"='\" + dest\n              + \"' \" + MAX_CHARS + \"=\" + maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    boolean sourceIsExplicitFieldGlob = false;\n    \n    if (null == sourceSchemaField && isValidFieldGlob(source)) {\n      Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n      for (String field : fields.keySet()) {\n        if (pattern.matcher(field).matches()) {\n          sourceIsExplicitFieldGlob = true;\n          break;\n        }\n      }\n    }\n    \n    if (null == destSchemaField || (null == sourceSchemaField && ! sourceIsExplicitFieldGlob)) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField \n            && (null != sourceSchemaField || sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob)) {\n          break;\n        }\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n      String msg = \"copyField source :'\" + source + \"' doesn't match any explicit field or dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob) {\n      if (null != destDynamicField) { // source: dynamic field ref or explicit field glob; dest: dynamic field ref\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: dynamic field reference; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else {                          \n      if (null != destDynamicField) { // source: explicit field; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source also has an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields \n        List<CopyField> copyFieldList = copyFieldsMap.get(source);\n        if (copyFieldList == null) {\n          copyFieldList = new ArrayList<CopyField>();\n          copyFieldsMap.put(source, copyFieldList);\n        }\n        copyFieldList.add(new CopyField(sourceSchemaField, destSchemaField, maxChars));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(\"copyField source='\" + source + \"' dest='\" + dest + \"' maxChars=\" + maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    boolean sourceIsExplicitFieldGlob = false;\n    \n    if (null == sourceSchemaField && isValidFieldGlob(source)) {\n      Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n      for (String field : fields.keySet()) {\n        if (pattern.matcher(field).matches()) {\n          sourceIsExplicitFieldGlob = true;\n          break;\n        }\n      }\n    }\n    \n    if (null == destSchemaField || (null == sourceSchemaField && ! sourceIsExplicitFieldGlob)) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField \n            && (null != sourceSchemaField || sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob)) {\n          break;\n        }\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n      String msg = \"copyField source :'\" + source + \"' doesn't match any explicit field or dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob) {\n      if (null != destDynamicField) { // source: dynamic field ref or explicit field glob; dest: dynamic field ref\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: dynamic field reference; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else {                          \n      if (null != destDynamicField) { // source: explicit field; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source also has an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields \n        List<CopyField> copyFieldList = copyFieldsMap.get(source);\n        if (copyFieldList == null) {\n          copyFieldList = new ArrayList<CopyField>();\n          copyFieldsMap.put(source, copyFieldList);\n        }\n        copyFieldList.add(new CopyField(sourceSchemaField, destSchemaField, maxChars));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ffc85dcae82df80f2f3c30a15ab55c4948dbaf8f","date":1364531614,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","sourceNew":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(COPY_FIELD + \" \" + SOURCE + \"='\" + source + \"' \" + DESTINATION + \"='\" + dest\n              + \"' \" + MAX_CHARS + \"=\" + maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    boolean sourceIsExplicitFieldGlob = false;\n\n\n    final String invalidGlobMessage = \"is an invalid glob: either it contains more than one asterisk,\"\n                                    + \" or the asterisk occurs neither at the start nor at the end.\";\n    final boolean sourceIsGlob = isValidFieldGlob(source);\n    if (source.contains(\"*\") && ! sourceIsGlob) {\n      String msg = \"copyField source :'\" + source + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (dest.contains(\"*\") && ! isValidFieldGlob(dest)) {\n      String msg = \"copyField dest :'\" + dest + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n\n    if (null == sourceSchemaField && sourceIsGlob) {\n      Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n      for (String field : fields.keySet()) {\n        if (pattern.matcher(field).matches()) {\n          sourceIsExplicitFieldGlob = true;\n          break;\n        }\n      }\n    }\n    \n    if (null == destSchemaField || (null == sourceSchemaField && ! sourceIsExplicitFieldGlob)) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField \n            && (null != sourceSchemaField || sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob)) {\n          break;\n        }\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsGlob && ! sourceIsDynamicFieldReference) {\n      String msg = \"copyField source :'\" + source + \"' is not a glob and doesn't match any explicit field or dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsDynamicFieldReference || sourceIsGlob) {\n      if (null != destDynamicField) { // source: glob or no-asterisk dynamic field ref; dest: dynamic field ref\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: glob or no-asterisk dynamic field ref; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else {                          \n      if (null != destDynamicField) { // source: explicit field; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source also has an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields \n        List<CopyField> copyFieldList = copyFieldsMap.get(source);\n        if (copyFieldList == null) {\n          copyFieldList = new ArrayList<CopyField>();\n          copyFieldsMap.put(source, copyFieldList);\n        }\n        copyFieldList.add(new CopyField(sourceSchemaField, destSchemaField, maxChars));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(COPY_FIELD + \" \" + SOURCE + \"='\" + source + \"' \" + DESTINATION + \"='\" + dest\n              + \"' \" + MAX_CHARS + \"=\" + maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    boolean sourceIsExplicitFieldGlob = false;\n    \n    if (null == sourceSchemaField && isValidFieldGlob(source)) {\n      Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n      for (String field : fields.keySet()) {\n        if (pattern.matcher(field).matches()) {\n          sourceIsExplicitFieldGlob = true;\n          break;\n        }\n      }\n    }\n    \n    if (null == destSchemaField || (null == sourceSchemaField && ! sourceIsExplicitFieldGlob)) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField \n            && (null != sourceSchemaField || sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob)) {\n          break;\n        }\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n      String msg = \"copyField source :'\" + source + \"' doesn't match any explicit field or dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob) {\n      if (null != destDynamicField) { // source: dynamic field ref or explicit field glob; dest: dynamic field ref\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: dynamic field reference; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else {                          \n      if (null != destDynamicField) { // source: explicit field; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source also has an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields \n        List<CopyField> copyFieldList = copyFieldsMap.get(source);\n        if (copyFieldList == null) {\n          copyFieldList = new ArrayList<CopyField>();\n          copyFieldsMap.put(source, copyFieldList);\n        }\n        copyFieldList.add(new CopyField(sourceSchemaField, destSchemaField, maxChars));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","sourceNew":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(COPY_FIELD + \" \" + SOURCE + \"='\" + source + \"' \" + DESTINATION + \"='\" + dest\n              + \"' \" + MAX_CHARS + \"=\" + maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    boolean sourceIsExplicitFieldGlob = false;\n\n\n    final String invalidGlobMessage = \"is an invalid glob: either it contains more than one asterisk,\"\n                                    + \" or the asterisk occurs neither at the start nor at the end.\";\n    final boolean sourceIsGlob = isValidFieldGlob(source);\n    if (source.contains(\"*\") && ! sourceIsGlob) {\n      String msg = \"copyField source :'\" + source + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (dest.contains(\"*\") && ! isValidFieldGlob(dest)) {\n      String msg = \"copyField dest :'\" + dest + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n\n    if (null == sourceSchemaField && sourceIsGlob) {\n      Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n      for (String field : fields.keySet()) {\n        if (pattern.matcher(field).matches()) {\n          sourceIsExplicitFieldGlob = true;\n          break;\n        }\n      }\n    }\n    \n    if (null == destSchemaField || (null == sourceSchemaField && ! sourceIsExplicitFieldGlob)) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField \n            && (null != sourceSchemaField || sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob)) {\n          break;\n        }\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsGlob && ! sourceIsDynamicFieldReference) {\n      String msg = \"copyField source :'\" + source + \"' is not a glob and doesn't match any explicit field or dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsDynamicFieldReference || sourceIsGlob) {\n      if (null != destDynamicField) { // source: glob or no-asterisk dynamic field ref; dest: dynamic field ref\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: glob or no-asterisk dynamic field ref; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else {                          \n      if (null != destDynamicField) { // source: explicit field; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source also has an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields \n        List<CopyField> copyFieldList = copyFieldsMap.get(source);\n        if (copyFieldList == null) {\n          copyFieldList = new ArrayList<>();\n          copyFieldsMap.put(source, copyFieldList);\n        }\n        copyFieldList.add(new CopyField(sourceSchemaField, destSchemaField, maxChars));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(COPY_FIELD + \" \" + SOURCE + \"='\" + source + \"' \" + DESTINATION + \"='\" + dest\n              + \"' \" + MAX_CHARS + \"=\" + maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    boolean sourceIsExplicitFieldGlob = false;\n\n\n    final String invalidGlobMessage = \"is an invalid glob: either it contains more than one asterisk,\"\n                                    + \" or the asterisk occurs neither at the start nor at the end.\";\n    final boolean sourceIsGlob = isValidFieldGlob(source);\n    if (source.contains(\"*\") && ! sourceIsGlob) {\n      String msg = \"copyField source :'\" + source + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (dest.contains(\"*\") && ! isValidFieldGlob(dest)) {\n      String msg = \"copyField dest :'\" + dest + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n\n    if (null == sourceSchemaField && sourceIsGlob) {\n      Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n      for (String field : fields.keySet()) {\n        if (pattern.matcher(field).matches()) {\n          sourceIsExplicitFieldGlob = true;\n          break;\n        }\n      }\n    }\n    \n    if (null == destSchemaField || (null == sourceSchemaField && ! sourceIsExplicitFieldGlob)) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField \n            && (null != sourceSchemaField || sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob)) {\n          break;\n        }\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsGlob && ! sourceIsDynamicFieldReference) {\n      String msg = \"copyField source :'\" + source + \"' is not a glob and doesn't match any explicit field or dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsDynamicFieldReference || sourceIsGlob) {\n      if (null != destDynamicField) { // source: glob or no-asterisk dynamic field ref; dest: dynamic field ref\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: glob or no-asterisk dynamic field ref; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else {                          \n      if (null != destDynamicField) { // source: explicit field; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source also has an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields \n        List<CopyField> copyFieldList = copyFieldsMap.get(source);\n        if (copyFieldList == null) {\n          copyFieldList = new ArrayList<CopyField>();\n          copyFieldsMap.put(source, copyFieldList);\n        }\n        copyFieldList.add(new CopyField(sourceSchemaField, destSchemaField, maxChars));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7bb58d2ce7b2165163519bdd7b33b8fc3a71362","date":1420491039,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","sourceNew":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(COPY_FIELD + \" \" + SOURCE + \"='\" + source + \"' \" + DESTINATION + \"='\" + dest\n              + \"' \" + MAX_CHARS + \"=\" + maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    boolean sourceIsExplicitFieldGlob = false;\n\n\n    final String invalidGlobMessage = \"is an invalid glob: either it contains more than one asterisk,\"\n                                    + \" or the asterisk occurs neither at the start nor at the end.\";\n    final boolean sourceIsGlob = isValidFieldGlob(source);\n    if (source.contains(\"*\") && ! sourceIsGlob) {\n      String msg = \"copyField source :'\" + source + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (dest.contains(\"*\") && ! isValidFieldGlob(dest)) {\n      String msg = \"copyField dest :'\" + dest + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n\n    if (null == sourceSchemaField && sourceIsGlob) {\n      Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n      for (String field : fields.keySet()) {\n        if (pattern.matcher(field).matches()) {\n          sourceIsExplicitFieldGlob = true;\n          break;\n        }\n      }\n    }\n    \n    if (null == destSchemaField || (null == sourceSchemaField && ! sourceIsExplicitFieldGlob)) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField \n            && (null != sourceSchemaField || sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob)) {\n          break;\n        }\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsGlob && ! sourceIsDynamicFieldReference) {\n      String msg = \"copyField source :'\" + source + \"' is not a glob and doesn't match any explicit field or dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsGlob) {\n      if (null != destDynamicField) { // source: glob ; dest: dynamic field ref\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: glob ; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else if (sourceIsDynamicFieldReference) {\n        if (null != destDynamicField) {  // source: no-asterisk dynamic field ref ; dest: dynamic field ref\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {                        // source: no-asterisk dynamic field ref ; dest: explicit field\n          sourceSchemaField = getField(source);\n          registerExplicitSrcAndDestFields(source, maxChars, destSchemaField, sourceSchemaField);\n        }\n    } else {\n      if (null != destDynamicField) { // source: explicit field ; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {                    // source: explicit field ; dest: dynamic field with an asterisk\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source also has an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields\n        registerExplicitSrcAndDestFields(source, maxChars, destSchemaField, sourceSchemaField);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(COPY_FIELD + \" \" + SOURCE + \"='\" + source + \"' \" + DESTINATION + \"='\" + dest\n              + \"' \" + MAX_CHARS + \"=\" + maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    boolean sourceIsExplicitFieldGlob = false;\n\n\n    final String invalidGlobMessage = \"is an invalid glob: either it contains more than one asterisk,\"\n                                    + \" or the asterisk occurs neither at the start nor at the end.\";\n    final boolean sourceIsGlob = isValidFieldGlob(source);\n    if (source.contains(\"*\") && ! sourceIsGlob) {\n      String msg = \"copyField source :'\" + source + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (dest.contains(\"*\") && ! isValidFieldGlob(dest)) {\n      String msg = \"copyField dest :'\" + dest + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n\n    if (null == sourceSchemaField && sourceIsGlob) {\n      Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n      for (String field : fields.keySet()) {\n        if (pattern.matcher(field).matches()) {\n          sourceIsExplicitFieldGlob = true;\n          break;\n        }\n      }\n    }\n    \n    if (null == destSchemaField || (null == sourceSchemaField && ! sourceIsExplicitFieldGlob)) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField \n            && (null != sourceSchemaField || sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob)) {\n          break;\n        }\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsGlob && ! sourceIsDynamicFieldReference) {\n      String msg = \"copyField source :'\" + source + \"' is not a glob and doesn't match any explicit field or dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsDynamicFieldReference || sourceIsGlob) {\n      if (null != destDynamicField) { // source: glob or no-asterisk dynamic field ref; dest: dynamic field ref\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: glob or no-asterisk dynamic field ref; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else {                          \n      if (null != destDynamicField) { // source: explicit field; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source also has an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields \n        List<CopyField> copyFieldList = copyFieldsMap.get(source);\n        if (copyFieldList == null) {\n          copyFieldList = new ArrayList<>();\n          copyFieldsMap.put(source, copyFieldList);\n        }\n        copyFieldList.add(new CopyField(sourceSchemaField, destSchemaField, maxChars));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9df8125ba9193a2e2e285ed92157810b1952a244","date":1587326330,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","sourceNew":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(\"{} {}='{}' {}='{}' {}='{}'\", COPY_FIELD, SOURCE, source, DESTINATION, dest\n              ,MAX_CHARS, maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    boolean sourceIsExplicitFieldGlob = false;\n\n\n    final String invalidGlobMessage = \"is an invalid glob: either it contains more than one asterisk,\"\n                                    + \" or the asterisk occurs neither at the start nor at the end.\";\n    final boolean sourceIsGlob = isValidFieldGlob(source);\n    if (source.contains(\"*\") && ! sourceIsGlob) {\n      String msg = \"copyField source :'\" + source + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (dest.contains(\"*\") && ! isValidFieldGlob(dest)) {\n      String msg = \"copyField dest :'\" + dest + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n\n    if (null == sourceSchemaField && sourceIsGlob) {\n      Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n      for (String field : fields.keySet()) {\n        if (pattern.matcher(field).matches()) {\n          sourceIsExplicitFieldGlob = true;\n          break;\n        }\n      }\n    }\n    \n    if (null == destSchemaField || (null == sourceSchemaField && ! sourceIsExplicitFieldGlob)) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField \n            && (null != sourceSchemaField || sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob)) {\n          break;\n        }\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsGlob && ! sourceIsDynamicFieldReference) {\n      String msg = \"copyField source :'\" + source + \"' is not a glob and doesn't match any explicit field or dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsGlob) {\n      if (null != destDynamicField) { // source: glob ; dest: dynamic field ref\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: glob ; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else if (sourceIsDynamicFieldReference) {\n        if (null != destDynamicField) {  // source: no-asterisk dynamic field ref ; dest: dynamic field ref\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {                        // source: no-asterisk dynamic field ref ; dest: explicit field\n          sourceSchemaField = getField(source);\n          registerExplicitSrcAndDestFields(source, maxChars, destSchemaField, sourceSchemaField);\n        }\n    } else {\n      if (null != destDynamicField) { // source: explicit field ; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {                    // source: explicit field ; dest: dynamic field with an asterisk\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source also has an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields\n        registerExplicitSrcAndDestFields(source, maxChars, destSchemaField, sourceSchemaField);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(COPY_FIELD + \" \" + SOURCE + \"='\" + source + \"' \" + DESTINATION + \"='\" + dest\n              + \"' \" + MAX_CHARS + \"=\" + maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    boolean sourceIsExplicitFieldGlob = false;\n\n\n    final String invalidGlobMessage = \"is an invalid glob: either it contains more than one asterisk,\"\n                                    + \" or the asterisk occurs neither at the start nor at the end.\";\n    final boolean sourceIsGlob = isValidFieldGlob(source);\n    if (source.contains(\"*\") && ! sourceIsGlob) {\n      String msg = \"copyField source :'\" + source + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (dest.contains(\"*\") && ! isValidFieldGlob(dest)) {\n      String msg = \"copyField dest :'\" + dest + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n\n    if (null == sourceSchemaField && sourceIsGlob) {\n      Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n      for (String field : fields.keySet()) {\n        if (pattern.matcher(field).matches()) {\n          sourceIsExplicitFieldGlob = true;\n          break;\n        }\n      }\n    }\n    \n    if (null == destSchemaField || (null == sourceSchemaField && ! sourceIsExplicitFieldGlob)) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField \n            && (null != sourceSchemaField || sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob)) {\n          break;\n        }\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsGlob && ! sourceIsDynamicFieldReference) {\n      String msg = \"copyField source :'\" + source + \"' is not a glob and doesn't match any explicit field or dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsGlob) {\n      if (null != destDynamicField) { // source: glob ; dest: dynamic field ref\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: glob ; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else if (sourceIsDynamicFieldReference) {\n        if (null != destDynamicField) {  // source: no-asterisk dynamic field ref ; dest: dynamic field ref\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {                        // source: no-asterisk dynamic field ref ; dest: explicit field\n          sourceSchemaField = getField(source);\n          registerExplicitSrcAndDestFields(source, maxChars, destSchemaField, sourceSchemaField);\n        }\n    } else {\n      if (null != destDynamicField) { // source: explicit field ; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {                    // source: explicit field ; dest: dynamic field with an asterisk\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source also has an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields\n        registerExplicitSrcAndDestFields(source, maxChars, destSchemaField, sourceSchemaField);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2ed9b72e5fa27a7bd4857f222ca815341979d4a","date":1594879524,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#registerCopyField(String,String,int).mjava","sourceNew":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   *\n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(\"{} {}='{}' {}='{}' {}='{}'\", COPY_FIELD, SOURCE, source, DESTINATION, dest\n              ,MAX_CHARS, maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n\n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n\n    boolean sourceIsDynamicFieldReference = false;\n    boolean sourceIsExplicitFieldGlob = false;\n\n\n    final String invalidGlobMessage = \"is an invalid glob: either it contains more than one asterisk,\"\n                                    + \" or the asterisk occurs neither at the start nor at the end.\";\n    final boolean sourceIsGlob = isValidFieldGlob(source);\n    if (source.contains(\"*\") && ! sourceIsGlob) {\n      String msg = \"copyField source :'\" + source + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (dest.contains(\"*\") && ! isValidFieldGlob(dest)) {\n      String msg = \"copyField dest :'\" + dest + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n\n    if (null == sourceSchemaField && sourceIsGlob) {\n      Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n      for (String field : fields.keySet()) {\n        if (pattern.matcher(field).matches()) {\n          sourceIsExplicitFieldGlob = true;\n          break;\n        }\n      }\n    }\n\n    if (null == destSchemaField || (null == sourceSchemaField && ! sourceIsExplicitFieldGlob)) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField\n            && (null != sourceSchemaField || sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob)) {\n          break;\n        }\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsGlob && ! sourceIsDynamicFieldReference) {\n      String msg = \"copyField source :'\" + source + \"' is not a glob and doesn't match any explicit field or dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsGlob) {\n      if (null != destDynamicField) { // source: glob ; dest: dynamic field ref\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: glob ; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else if (sourceIsDynamicFieldReference) {\n        if (null != destDynamicField) {  // source: no-asterisk dynamic field ref ; dest: dynamic field ref\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {                        // source: no-asterisk dynamic field ref ; dest: explicit field\n          sourceSchemaField = getField(source);\n          registerExplicitSrcAndDestFields(source, maxChars, destSchemaField, sourceSchemaField);\n        }\n    } else {\n      if (null != destDynamicField) { // source: explicit field ; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {                    // source: explicit field ; dest: dynamic field with an asterisk\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source also has an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields\n        registerExplicitSrcAndDestFields(source, maxChars, destSchemaField, sourceSchemaField);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * NOTE: this function is not thread safe.  However, it is safe to use within the standard\n   * <code>inform( SolrCore core )</code> function for <code>SolrCoreAware</code> classes.\n   * Outside <code>inform</code>, this could potentially throw a ConcurrentModificationException\n   * </p>\n   * \n   * @see SolrCoreAware\n   */\n  public void registerCopyField(String source, String dest, int maxChars) {\n    log.debug(\"{} {}='{}' {}='{}' {}='{}'\", COPY_FIELD, SOURCE, source, DESTINATION, dest\n              ,MAX_CHARS, maxChars);\n\n    DynamicField destDynamicField = null;\n    SchemaField destSchemaField = fields.get(dest);\n    SchemaField sourceSchemaField = fields.get(source);\n    \n    DynamicField sourceDynamicBase = null;\n    DynamicField destDynamicBase = null;\n    \n    boolean sourceIsDynamicFieldReference = false;\n    boolean sourceIsExplicitFieldGlob = false;\n\n\n    final String invalidGlobMessage = \"is an invalid glob: either it contains more than one asterisk,\"\n                                    + \" or the asterisk occurs neither at the start nor at the end.\";\n    final boolean sourceIsGlob = isValidFieldGlob(source);\n    if (source.contains(\"*\") && ! sourceIsGlob) {\n      String msg = \"copyField source :'\" + source + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (dest.contains(\"*\") && ! isValidFieldGlob(dest)) {\n      String msg = \"copyField dest :'\" + dest + \"' \" + invalidGlobMessage;\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n\n    if (null == sourceSchemaField && sourceIsGlob) {\n      Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n      for (String field : fields.keySet()) {\n        if (pattern.matcher(field).matches()) {\n          sourceIsExplicitFieldGlob = true;\n          break;\n        }\n      }\n    }\n    \n    if (null == destSchemaField || (null == sourceSchemaField && ! sourceIsExplicitFieldGlob)) {\n      // Go through dynamicFields array only once, collecting info for both source and dest fields, if needed\n      for (DynamicField dynamicField : dynamicFields) {\n        if (null == sourceSchemaField && ! sourceIsDynamicFieldReference && ! sourceIsExplicitFieldGlob) {\n          if (dynamicField.matches(source)) {\n            sourceIsDynamicFieldReference = true;\n            if ( ! source.equals(dynamicField.getRegex())) {\n              sourceDynamicBase = dynamicField;\n            }\n          }\n        }\n        if (null == destSchemaField) {\n          if (dest.equals(dynamicField.getRegex())) {\n            destDynamicField = dynamicField;\n            destSchemaField = dynamicField.prototype;\n          } else if (dynamicField.matches(dest)) {\n            destSchemaField = dynamicField.makeSchemaField(dest);\n            destDynamicField = new DynamicField(destSchemaField);\n            destDynamicBase = dynamicField;\n          }\n        }\n        if (null != destSchemaField \n            && (null != sourceSchemaField || sourceIsDynamicFieldReference || sourceIsExplicitFieldGlob)) {\n          break;\n        }\n      }\n    }\n    if (null == sourceSchemaField && ! sourceIsGlob && ! sourceIsDynamicFieldReference) {\n      String msg = \"copyField source :'\" + source + \"' is not a glob and doesn't match any explicit field or dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (null == destSchemaField) {\n      String msg = \"copyField dest :'\" + dest + \"' is not an explicit field and doesn't match a dynamicField.\";\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    if (sourceIsGlob) {\n      if (null != destDynamicField) { // source: glob ; dest: dynamic field ref\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n        incrementCopyFieldTargetCount(destSchemaField);\n      } else {                        // source: glob ; dest: explicit field\n        destDynamicField = new DynamicField(destSchemaField);\n        registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, null));\n        incrementCopyFieldTargetCount(destSchemaField);\n      }\n    } else if (sourceIsDynamicFieldReference) {\n        if (null != destDynamicField) {  // source: no-asterisk dynamic field ref ; dest: dynamic field ref\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {                        // source: no-asterisk dynamic field ref ; dest: explicit field\n          sourceSchemaField = getField(source);\n          registerExplicitSrcAndDestFields(source, maxChars, destSchemaField, sourceSchemaField);\n        }\n    } else {\n      if (null != destDynamicField) { // source: explicit field ; dest: dynamic field reference\n        if (destDynamicField.pattern instanceof DynamicReplacement.DynamicPattern.NameEquals) {\n          // Dynamic dest with no asterisk is acceptable\n          registerDynamicCopyField(new DynamicCopy(source, destDynamicField, maxChars, sourceDynamicBase, destDynamicBase));\n          incrementCopyFieldTargetCount(destSchemaField);\n        } else {                    // source: explicit field ; dest: dynamic field with an asterisk\n          String msg = \"copyField only supports a dynamic destination with an asterisk \"\n                     + \"if the source also has an asterisk\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {                        // source & dest: explicit fields\n        registerExplicitSrcAndDestFields(source, maxChars, destSchemaField, sourceSchemaField);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ffc85dcae82df80f2f3c30a15ab55c4948dbaf8f"],"f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd":["f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"ffc85dcae82df80f2f3c30a15ab55c4948dbaf8f":["d2fa053a06c9c158f82d8e8b53b9a95031f43ebd"],"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["9df8125ba9193a2e2e285ed92157810b1952a244"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a7bb58d2ce7b2165163519bdd7b33b8fc3a71362":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"],"9df8125ba9193a2e2e285ed92157810b1952a244":["a7bb58d2ce7b2165163519bdd7b33b8fc3a71362"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a7bb58d2ce7b2165163519bdd7b33b8fc3a71362"],"f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b":["d2fa053a06c9c158f82d8e8b53b9a95031f43ebd"],"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd":["ffc85dcae82df80f2f3c30a15ab55c4948dbaf8f"],"c26f00b574427b55127e869b935845554afde1fa":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"ffc85dcae82df80f2f3c30a15ab55c4948dbaf8f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a7bb58d2ce7b2165163519bdd7b33b8fc3a71362":["9df8125ba9193a2e2e285ed92157810b1952a244"],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"9df8125ba9193a2e2e285ed92157810b1952a244":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}