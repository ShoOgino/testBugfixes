{"path":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(TokenStream,BooleanClause.Occur,String,boolean,int).mjava","commits":[{"id":"e52c30617998e1bc2a946cc226f52e9b35162b1e","date":1483438353,"type":0,"author":"Matt Weber","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(TokenStream,BooleanClause.Occur,String,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a query from a token stream.\n   *\n   * @param source     the token stream to create the query from\n   * @param operator   default boolean operator used for this query\n   * @param field      field to create queries against\n   * @param quoted     true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(TokenStream source, BooleanClause.Occur operator, String field, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n\n    // Build an appropriate query based on the analysis chain.\n    try (CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      PositionLengthAttribute posLenAtt = stream.addAttribute(PositionLengthAttribute.class);\n\n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n      boolean isGraph = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n\n        int positionLength = posLenAtt.getPositionLength();\n        if (!isGraph && positionLength > 1) {\n          isGraph = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (isGraph) {\n        // graph\n        return analyzeGraph(stream, operator, field, quoted, phraseSlop);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["70a5a9d222a882b030ff4a1d87e44b75403b893a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(TokenStream,BooleanClause.Occur,String,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a query from a token stream.\n   *\n   * @param source     the token stream to create the query from\n   * @param operator   default boolean operator used for this query\n   * @param field      field to create queries against\n   * @param quoted     true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(TokenStream source, BooleanClause.Occur operator, String field, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n\n    // Build an appropriate query based on the analysis chain.\n    try (CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      PositionLengthAttribute posLenAtt = stream.addAttribute(PositionLengthAttribute.class);\n\n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n      boolean isGraph = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n\n        int positionLength = posLenAtt.getPositionLength();\n        if (!isGraph && positionLength > 1) {\n          isGraph = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (isGraph) {\n        // graph\n        return analyzeGraph(stream, operator, field, quoted, phraseSlop);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e0d75d7d3cda2b33e79d0eb0e716169cebec4db","date":1486463279,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(TokenStream,BooleanClause.Occur,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(TokenStream,BooleanClause.Occur,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from a token stream.\n   *\n   * @param source     the token stream to create the query from\n   * @param operator   default boolean operator used for this query\n   * @param field      field to create queries against\n   * @param quoted     true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(TokenStream source, BooleanClause.Occur operator, String field, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n\n    // Build an appropriate query based on the analysis chain.\n    try (CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      PositionLengthAttribute posLenAtt = stream.addAttribute(PositionLengthAttribute.class);\n\n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n      boolean isGraph = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n\n        int positionLength = posLenAtt.getPositionLength();\n        if (!isGraph && positionLength > 1) {\n          isGraph = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (isGraph) {\n        // graph\n        if (quoted) {\n          return analyzeGraphPhrase(stream, operator, field, phraseSlop);\n        } else {\n          return analyzeGraphBoolean(field, stream, operator);\n        }\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from a token stream.\n   *\n   * @param source     the token stream to create the query from\n   * @param operator   default boolean operator used for this query\n   * @param field      field to create queries against\n   * @param quoted     true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(TokenStream source, BooleanClause.Occur operator, String field, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n\n    // Build an appropriate query based on the analysis chain.\n    try (CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      PositionLengthAttribute posLenAtt = stream.addAttribute(PositionLengthAttribute.class);\n\n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n      boolean isGraph = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n\n        int positionLength = posLenAtt.getPositionLength();\n        if (!isGraph && positionLength > 1) {\n          isGraph = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (isGraph) {\n        // graph\n        return analyzeGraph(stream, operator, field, quoted, phraseSlop);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70a5a9d222a882b030ff4a1d87e44b75403b893a","date":1487758607,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(TokenStream,BooleanClause.Occur,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(TokenStream,BooleanClause.Occur,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from a token stream.\n   *\n   * @param source     the token stream to create the query from\n   * @param operator   default boolean operator used for this query\n   * @param field      field to create queries against\n   * @param quoted     true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(TokenStream source, BooleanClause.Occur operator, String field, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n\n    // Build an appropriate query based on the analysis chain.\n    try (CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      PositionLengthAttribute posLenAtt = stream.addAttribute(PositionLengthAttribute.class);\n\n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n      boolean isGraph = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n\n        int positionLength = posLenAtt.getPositionLength();\n        if (enableGraphQueries && positionLength > 1) {\n          isGraph = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (isGraph) {\n        // graph\n        if (quoted) {\n          return analyzeGraphPhrase(stream, operator, field, phraseSlop);\n        } else {\n          return analyzeGraphBoolean(field, stream, operator);\n        }\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from a token stream.\n   *\n   * @param source     the token stream to create the query from\n   * @param operator   default boolean operator used for this query\n   * @param field      field to create queries against\n   * @param quoted     true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(TokenStream source, BooleanClause.Occur operator, String field, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n\n    // Build an appropriate query based on the analysis chain.\n    try (CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      PositionLengthAttribute posLenAtt = stream.addAttribute(PositionLengthAttribute.class);\n\n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n      boolean isGraph = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n\n        int positionLength = posLenAtt.getPositionLength();\n        if (!isGraph && positionLength > 1) {\n          isGraph = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (isGraph) {\n        // graph\n        if (quoted) {\n          return analyzeGraphPhrase(stream, operator, field, phraseSlop);\n        } else {\n          return analyzeGraphBoolean(field, stream, operator);\n        }\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","bugFix":["e52c30617998e1bc2a946cc226f52e9b35162b1e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d79fd791e91f49ce8026885d7b8ac62bee4c8126","date":1487768721,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(TokenStream,BooleanClause.Occur,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(TokenStream,BooleanClause.Occur,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from a token stream.\n   *\n   * @param source     the token stream to create the query from\n   * @param operator   default boolean operator used for this query\n   * @param field      field to create queries against\n   * @param quoted     true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(TokenStream source, BooleanClause.Occur operator, String field, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n\n    // Build an appropriate query based on the analysis chain.\n    try (CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      PositionLengthAttribute posLenAtt = stream.addAttribute(PositionLengthAttribute.class);\n\n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n      boolean isGraph = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n\n        int positionLength = posLenAtt.getPositionLength();\n        if (enableGraphQueries && positionLength > 1) {\n          isGraph = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (isGraph) {\n        // graph\n        if (quoted) {\n          return analyzeGraphPhrase(stream, field, phraseSlop);\n        } else {\n          return analyzeGraphBoolean(field, stream, operator);\n        }\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from a token stream.\n   *\n   * @param source     the token stream to create the query from\n   * @param operator   default boolean operator used for this query\n   * @param field      field to create queries against\n   * @param quoted     true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(TokenStream source, BooleanClause.Occur operator, String field, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n\n    // Build an appropriate query based on the analysis chain.\n    try (CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      PositionLengthAttribute posLenAtt = stream.addAttribute(PositionLengthAttribute.class);\n\n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n      boolean isGraph = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n\n        int positionLength = posLenAtt.getPositionLength();\n        if (enableGraphQueries && positionLength > 1) {\n          isGraph = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (isGraph) {\n        // graph\n        if (quoted) {\n          return analyzeGraphPhrase(stream, operator, field, phraseSlop);\n        } else {\n          return analyzeGraphBoolean(field, stream, operator);\n        }\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e52c30617998e1bc2a946cc226f52e9b35162b1e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"70a5a9d222a882b030ff4a1d87e44b75403b893a":["7e0d75d7d3cda2b33e79d0eb0e716169cebec4db"],"d79fd791e91f49ce8026885d7b8ac62bee4c8126":["70a5a9d222a882b030ff4a1d87e44b75403b893a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d79fd791e91f49ce8026885d7b8ac62bee4c8126"],"7e0d75d7d3cda2b33e79d0eb0e716169cebec4db":["e52c30617998e1bc2a946cc226f52e9b35162b1e"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e52c30617998e1bc2a946cc226f52e9b35162b1e"]},"commit2Childs":{"e52c30617998e1bc2a946cc226f52e9b35162b1e":["7e0d75d7d3cda2b33e79d0eb0e716169cebec4db","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e52c30617998e1bc2a946cc226f52e9b35162b1e","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"70a5a9d222a882b030ff4a1d87e44b75403b893a":["d79fd791e91f49ce8026885d7b8ac62bee4c8126"],"d79fd791e91f49ce8026885d7b8ac62bee4c8126":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7e0d75d7d3cda2b33e79d0eb0e716169cebec4db":["70a5a9d222a882b030ff4a1d87e44b75403b893a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}