{"path":"solr/core/src/test/org/apache/solr/util/OrderedExecutorTest#testLockWhenQueueIsFull().mjava","commits":[{"id":"defa11d88d50ec356d5e7428f1ebc89623e840ac","date":1527653148,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/util/OrderedExecutorTest#testLockWhenQueueIsFull().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testLockWhenQueueIsFull() {\n    OrderedExecutor orderedExecutor = new OrderedExecutor(10, ExecutorUtil.newMDCAwareCachedThreadPool(\"testLockWhenQueueIsFull\"));\n    IntBox intBox = new IntBox();\n    long t = System.nanoTime();\n    orderedExecutor.execute(1, () -> {\n      try {\n        Thread.sleep(500L);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n      intBox.value++;\n    });\n    assertTrue(System.nanoTime() - t < 100 * 1000000);\n\n    t = System.nanoTime();\n    orderedExecutor.execute(1, () -> {\n      intBox.value++;\n    });\n    assertTrue(System.nanoTime() - t > 300 * 1000000);\n    orderedExecutor.shutdownAndAwaitTermination();\n    assertEquals(intBox.value, 2);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75ed8f3680408b9cf2575d925b99ff3ac45254e8","date":1549488732,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/util/OrderedExecutorTest#testLockWhenQueueIsFull().mjava","pathOld":"solr/core/src/test/org/apache/solr/util/OrderedExecutorTest#testLockWhenQueueIsFull().mjava","sourceNew":"  @Test\n  public void testLockWhenQueueIsFull() {\n    final ExecutorService controlExecutor = ExecutorUtil.newMDCAwareCachedThreadPool(\"testLockWhenQueueIsFull_control\");\n    final OrderedExecutor orderedExecutor = new OrderedExecutor\n      (10, ExecutorUtil.newMDCAwareCachedThreadPool(\"testLockWhenQueueIsFull_test\"));\n    \n    try {\n      // AAA and BBB events will both depend on the use of the same lockId\n      final BlockingQueue<String> events = new ArrayBlockingQueue<>(2);\n      final Integer lockId = 1;\n      \n      // AAA enters executor first so it should execute first (even though it's waiting on latch)\n      final CountDownLatch latchAAA = new CountDownLatch(1);\n      orderedExecutor.execute(lockId, () -> {\n          try {\n            if (latchAAA.await(120, TimeUnit.SECONDS)) {\n              events.add(\"AAA\");\n            } else {\n              events.add(\"AAA Timed Out\");\n            }\n          } catch (InterruptedException e) {\n            log.error(\"Interrupt in AAA worker\", e);\n            Thread.currentThread().interrupt();\n          }\n        });\n      // BBB doesn't care about the latch, but because it uses the same lockId, it's blocked on AAA\n      // so we execute it in a background thread...\n      controlExecutor.execute(() -> {\n          orderedExecutor.execute(lockId, () -> {\n              events.add(\"BBB\");\n            });\n        });\n      \n      // now if we release the latchAAA, AAA should be garunteed to fire first, then BBB\n      latchAAA.countDown();\n      try {\n        assertEquals(\"AAA\", events.poll(120, TimeUnit.SECONDS));\n        assertEquals(\"BBB\", events.poll(120, TimeUnit.SECONDS));\n      } catch (InterruptedException e) {\n        log.error(\"Interrupt polling event queue\", e);\n        Thread.currentThread().interrupt();\n        fail(\"interupt while trying to poll event queue\");\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(controlExecutor);\n      orderedExecutor.shutdownAndAwaitTermination();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testLockWhenQueueIsFull() {\n    OrderedExecutor orderedExecutor = new OrderedExecutor(10, ExecutorUtil.newMDCAwareCachedThreadPool(\"testLockWhenQueueIsFull\"));\n    IntBox intBox = new IntBox();\n    long t = System.nanoTime();\n    orderedExecutor.execute(1, () -> {\n      try {\n        Thread.sleep(500L);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n      intBox.value++;\n    });\n    assertTrue(System.nanoTime() - t < 100 * 1000000);\n\n    t = System.nanoTime();\n    orderedExecutor.execute(1, () -> {\n      intBox.value++;\n    });\n    assertTrue(System.nanoTime() - t > 300 * 1000000);\n    orderedExecutor.shutdownAndAwaitTermination();\n    assertEquals(intBox.value, 2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"defa11d88d50ec356d5e7428f1ebc89623e840ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"75ed8f3680408b9cf2575d925b99ff3ac45254e8":["defa11d88d50ec356d5e7428f1ebc89623e840ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["75ed8f3680408b9cf2575d925b99ff3ac45254e8"]},"commit2Childs":{"defa11d88d50ec356d5e7428f1ebc89623e840ac":["75ed8f3680408b9cf2575d925b99ff3ac45254e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["defa11d88d50ec356d5e7428f1ebc89623e840ac"],"75ed8f3680408b9cf2575d925b99ff3ac45254e8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}