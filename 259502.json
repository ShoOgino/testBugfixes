{"path":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","commits":[{"id":"e3ce1ef883d26aa73919aa2d53991726e96caa13","date":1445421402,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 0.1 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          BKDUtil.intToBytes(values[dim], scratch, dim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new BKDReader.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = BKDUtil.bytesToInt(packedValue, dim);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public BKDReader.Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = BKDUtil.bytesToInt(minPacked, dim);\n                int max = BKDUtil.bytesToInt(maxPacked, dim);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return BKDReader.Relation.QUERY_OUTSIDE_CELL;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return BKDReader.Relation.QUERY_CROSSES_CELL;\n              } else {\n                return BKDReader.Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 0.1 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          BKDUtil.intToBytes(values[dim], scratch, dim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = BKDUtil.bytesToInt(packedValue, dim);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = BKDUtil.bytesToInt(minPacked, dim);\n                int max = BKDUtil.bytesToInt(maxPacked, dim);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.QUERY_OUTSIDE_CELL;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.QUERY_CROSSES_CELL;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 0.1 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          BKDUtil.intToBytes(values[dim], scratch, dim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new BKDReader.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = BKDUtil.bytesToInt(packedValue, dim);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public BKDReader.Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = BKDUtil.bytesToInt(minPacked, dim);\n                int max = BKDUtil.bytesToInt(maxPacked, dim);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return BKDReader.Relation.QUERY_OUTSIDE_CELL;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return BKDReader.Relation.QUERY_CROSSES_CELL;\n              } else {\n                return BKDReader.Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 0.1 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          BKDUtil.intToBytes(values[dim], scratch, dim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = BKDUtil.bytesToInt(packedValue, dim);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = BKDUtil.bytesToInt(minPacked, dim);\n                int max = BKDUtil.bytesToInt(maxPacked, dim);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 0.1 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          BKDUtil.intToBytes(values[dim], scratch, dim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = BKDUtil.bytesToInt(packedValue, dim);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = BKDUtil.bytesToInt(minPacked, dim);\n                int max = BKDUtil.bytesToInt(maxPacked, dim);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.QUERY_OUTSIDE_CELL;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.QUERY_CROSSES_CELL;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1786be6a11f9cf5e48ce84869d1bb71e9c02f966","date":1448381196,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          BKDUtil.intToBytes(values[dim], scratch, dim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = BKDUtil.bytesToInt(packedValue, dim);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = BKDUtil.bytesToInt(minPacked, dim);\n                int max = BKDUtil.bytesToInt(maxPacked, dim);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 0.1 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          BKDUtil.intToBytes(values[dim], scratch, dim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = BKDUtil.bytesToInt(packedValue, dim);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = BKDUtil.bytesToInt(minPacked, dim);\n                int max = BKDUtil.bytesToInt(maxPacked, dim);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          NumericUtils.intToBytes(values[dim], scratch, dim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.bytesToInt(packedValue, dim);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.bytesToInt(minPacked, dim);\n                int max = NumericUtils.bytesToInt(maxPacked, dim);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          BKDUtil.intToBytes(values[dim], scratch, dim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = BKDUtil.bytesToInt(packedValue, dim);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = BKDUtil.bytesToInt(minPacked, dim);\n                int max = BKDUtil.bytesToInt(maxPacked, dim);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ecf331f9d7bdd234863d2df2bb5c1f019979422f","date":1452250335,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToBytes(values[dim], scratch, dim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.bytesToInt(minPackedValue, dim));\n          assertEquals(maxValue[dim], NumericUtils.bytesToInt(maxPackedValue, dim));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.bytesToInt(packedValue, dim);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.bytesToInt(minPacked, dim);\n                int max = NumericUtils.bytesToInt(maxPacked, dim);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          NumericUtils.intToBytes(values[dim], scratch, dim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.bytesToInt(packedValue, dim);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.bytesToInt(minPacked, dim);\n                int max = NumericUtils.bytesToInt(maxPacked, dim);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f226a8b088dd9c8f6ab287a77237c4aa00a238e5","date":1456187572,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.bytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.bytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.bytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.bytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.bytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToBytes(values[dim], scratch, dim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.bytesToInt(minPackedValue, dim));\n          assertEquals(maxValue[dim], NumericUtils.bytesToInt(maxPackedValue, dim));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.bytesToInt(packedValue, dim);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.bytesToInt(minPacked, dim);\n                int max = NumericUtils.bytesToInt(maxPacked, dim);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"419a8f52c6635419beb951255cacbbb281044c57","date":1456189353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.bytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.bytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.bytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.bytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.bytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToBytes(values[dim], scratch, dim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.bytesToInt(minPackedValue, dim));\n          assertEquals(maxValue[dim], NumericUtils.bytesToInt(maxPackedValue, dim));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.bytesToInt(packedValue, dim);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.bytesToInt(minPacked, dim);\n                int max = NumericUtils.bytesToInt(maxPacked, dim);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"251c5b33f0a2c8988550b63c78ed22b0e84524e5","date":1456961997,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.bytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.bytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.bytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.bytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.bytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.bytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.bytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.bytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.bytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.bytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb","date":1457059932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.bytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.bytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.bytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.bytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.bytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["f226a8b088dd9c8f6ab287a77237c4aa00a238e5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.bytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.bytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.bytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.bytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.bytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca","date":1457777566,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB, randomPointCount());\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"416f9e28900210be57b69bc12e2954fb98ed7ebe","date":1458479803,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB, randomPointCount(true), true);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB, randomPointCount());\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f3d902d9e126b838f492796a117a4d9e532d597a","date":1458810839,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB, numDocs, true);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB, randomPointCount(true), true);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numIndexDims, 4, maxPointsInLeafNode, maxMB, numDocs, true);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numIndexDims=\" + numIndexDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numIndexDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numIndexDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, 4, maxPointsInLeafNode, maxMB, numDocs, true);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78bdc7d6906146edb12a1a6c1f765ba680ed5124","date":1549523533,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numIndexDims, 4, maxPointsInLeafNode, maxMB, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numIndexDims=\" + numIndexDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numIndexDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numIndexDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numIndexDims, 4, maxPointsInLeafNode, maxMB, numDocs, true);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numIndexDims=\" + numIndexDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numIndexDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numIndexDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbc55bb1f9b4422860b0f903e6af8082280e7b72","date":1571986943,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numIndexDims, 4, maxPointsInLeafNode, maxMB, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numIndexDims=\" + numIndexDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, randomBoolean());\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numIndexDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numIndexDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numIndexDims, 4, maxPointsInLeafNode, maxMB, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numIndexDims=\" + numIndexDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numIndexDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numIndexDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numIndexDims, 4, maxPointsInLeafNode, maxMB, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numIndexDims=\" + numIndexDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in, randomBoolean());\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numIndexDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numIndexDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numIndexDims, 4, maxPointsInLeafNode, maxMB, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numIndexDims=\" + numIndexDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, randomBoolean());\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numIndexDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numIndexDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6b1fd50f847900ca47783ea832846d60e81f990","date":1591769592,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numIndexDims, 4, maxPointsInLeafNode, maxMB, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numIndexDims=\" + numIndexDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numIndexDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numIndexDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numIndexDims, 4, maxPointsInLeafNode, maxMB, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numIndexDims=\" + numIndexDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in, randomBoolean());\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numIndexDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numIndexDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testRandomIntsNDims().mjava","sourceNew":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", new BKDConfig(numDims, numIndexDims, 4, maxPointsInLeafNode), maxMB, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numIndexDims=\" + numIndexDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numIndexDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numIndexDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomIntsNDims() throws Exception {\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numIndexDims, 4, maxPointsInLeafNode, maxMB, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDims=\" + numDims + \" numIndexDims=\" + numIndexDims + \" numDocs=\" + numDocs);\n      }\n      int[][] docs = new int[numDocs][];\n      byte[] scratch = new byte[4*numDims];\n      int[] minValue = new int[numDims];\n      int[] maxValue = new int[numDims];\n      Arrays.fill(minValue, Integer.MAX_VALUE);\n      Arrays.fill(maxValue, Integer.MIN_VALUE);\n      for(int docID=0;docID<numDocs;docID++) {\n        int[] values = new int[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = random().nextInt();\n          if (values[dim] < minValue[dim]) {\n            minValue[dim] = values[dim];\n          }\n          if (values[dim] > maxValue[dim]) {\n            maxValue[dim] = values[dim];\n          }\n          NumericUtils.intToSortableBytes(values[dim], scratch, dim * Integer.BYTES);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in);\n\n        byte[] minPackedValue = r.getMinPackedValue();\n        byte[] maxPackedValue = r.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          assertEquals(minValue[dim], NumericUtils.sortableBytesToInt(minPackedValue, dim * Integer.BYTES));\n          assertEquals(maxValue[dim], NumericUtils.sortableBytesToInt(maxPackedValue, dim * Integer.BYTES));\n        }\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          int[] queryMin = new int[numDims];\n          int[] queryMax = new int[numDims];    \n          for(int dim=0;dim<numIndexDims;dim++) {\n            queryMin[dim] = random().nextInt();\n            queryMax[dim] = random().nextInt();\n            if (queryMin[dim] > queryMax[dim]) {\n              int x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int x = NumericUtils.sortableBytesToInt(packedValue, dim * Integer.BYTES);\n                if (x < queryMin[dim] || x > queryMax[dim]) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                int min = NumericUtils.sortableBytesToInt(minPacked, dim * Integer.BYTES);\n                int max = NumericUtils.sortableBytesToInt(maxPacked, dim * Integer.BYTES);\n                assert max >= min;\n\n                if (max < queryMin[dim] || min > queryMax[dim]) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min < queryMin[dim] || max > queryMax[dim]) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            int[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numIndexDims;dim++) {\n              int x = docValues[dim];\n              if (x < queryMin[dim] || x > queryMax[dim]) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"1786be6a11f9cf5e48ce84869d1bb71e9c02f966":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"ecf331f9d7bdd234863d2df2bb5c1f019979422f":["770342641f7b505eaa8dccdc666158bff2419109"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["d6b1fd50f847900ca47783ea832846d60e81f990"],"f6652c943595e92c187ee904c382863013eae28f":["f3d902d9e126b838f492796a117a4d9e532d597a"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["f6652c943595e92c187ee904c382863013eae28f"],"419a8f52c6635419beb951255cacbbb281044c57":["ecf331f9d7bdd234863d2df2bb5c1f019979422f","f226a8b088dd9c8f6ab287a77237c4aa00a238e5"],"f226a8b088dd9c8f6ab287a77237c4aa00a238e5":["ecf331f9d7bdd234863d2df2bb5c1f019979422f"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"770342641f7b505eaa8dccdc666158bff2419109":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["419a8f52c6635419beb951255cacbbb281044c57"],"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"d6b1fd50f847900ca47783ea832846d60e81f990":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["419a8f52c6635419beb951255cacbbb281044c57","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"f3d902d9e126b838f492796a117a4d9e532d597a":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["251c5b33f0a2c8988550b63c78ed22b0e84524e5"]},"commit2Childs":{"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"1786be6a11f9cf5e48ce84869d1bb71e9c02f966":["770342641f7b505eaa8dccdc666158bff2419109"],"ecf331f9d7bdd234863d2df2bb5c1f019979422f":["419a8f52c6635419beb951255cacbbb281044c57","f226a8b088dd9c8f6ab287a77237c4aa00a238e5"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"419a8f52c6635419beb951255cacbbb281044c57":["251c5b33f0a2c8988550b63c78ed22b0e84524e5","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"f226a8b088dd9c8f6ab287a77237c4aa00a238e5":["419a8f52c6635419beb951255cacbbb281044c57"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"770342641f7b505eaa8dccdc666158bff2419109":["ecf331f9d7bdd234863d2df2bb5c1f019979422f"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"d6b1fd50f847900ca47783ea832846d60e81f990":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["d6b1fd50f847900ca47783ea832846d60e81f990"],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["f3d902d9e126b838f492796a117a4d9e532d597a"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca"],"f3d902d9e126b838f492796a117a4d9e532d597a":["f6652c943595e92c187ee904c382863013eae28f"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}