{"path":"solr/core/src/test/org/apache/solr/cloud/rule/RulesTest#testPortRuleInPresenceOfClusterPolicy().mjava","commits":[{"id":"217314a66df11e4013ff43c4027a4d64b6931148","date":1502866906,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/rule/RulesTest#testPortRuleInPresenceOfClusterPolicy().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testPortRuleInPresenceOfClusterPolicy() throws Exception  {\n    JettySolrRunner jetty = cluster.getRandomJetty(random());\n    String port = Integer.toString(jetty.getLocalPort());\n\n    // this cluster policy prohibits having any replicas on a node with the above port\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'replica': 0, 'port':'\" + port + \"'}\" +\n        \"    ]\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cluster.getSolrClient().request(req);\n\n    // but this collection is created with a replica placement rule that says all replicas must be created\n    // on a node with above port (in direct conflict with the cluster policy)\n    String rulesColl = \"portRuleColl2\";\n    CollectionAdminRequest.createCollectionWithImplicitRouter(rulesColl, \"conf\", \"shard1\", 2)\n        .setRule(\"port:\" + port)\n        .setSnitch(\"class:ImplicitSnitch\")\n        .process(cluster.getSolrClient());\n\n    // now we assert that the replica placement rule is used instead of the cluster policy\n    DocCollection rulesCollection = getCollectionState(rulesColl);\n    List list = (List) rulesCollection.get(\"rule\");\n    assertEquals(1, list.size());\n    assertEquals(port, ((Map) list.get(0)).get(\"port\"));\n    list = (List) rulesCollection.get(\"snitch\");\n    assertEquals(1, list.size());\n    assertEquals ( \"ImplicitSnitch\", ((Map)list.get(0)).get(\"class\"));\n\n    boolean allOnExpectedPort = rulesCollection.getReplicas().stream().allMatch(replica -> replica.getNodeName().contains(port));\n    assertTrue(\"Not all replicas were found to be on port: \" + port + \". Collection state is: \" + rulesCollection, allOnExpectedPort);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c00aac053fdd75193eb8b6d45b64c26c3b586d5b","date":1503143818,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/rule/RulesTest#testPortRuleInPresenceOfClusterPolicy().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testPortRuleInPresenceOfClusterPolicy() throws Exception  {\n    JettySolrRunner jetty = cluster.getRandomJetty(random());\n    String port = Integer.toString(jetty.getLocalPort());\n\n    // this cluster policy prohibits having any replicas on a node with the above port\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'replica': 0, 'port':'\" + port + \"'}\" +\n        \"    ]\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cluster.getSolrClient().request(req);\n\n    // but this collection is created with a replica placement rule that says all replicas must be created\n    // on a node with above port (in direct conflict with the cluster policy)\n    String rulesColl = \"portRuleColl2\";\n    CollectionAdminRequest.createCollectionWithImplicitRouter(rulesColl, \"conf\", \"shard1\", 2)\n        .setRule(\"port:\" + port)\n        .setSnitch(\"class:ImplicitSnitch\")\n        .process(cluster.getSolrClient());\n\n    // now we assert that the replica placement rule is used instead of the cluster policy\n    DocCollection rulesCollection = getCollectionState(rulesColl);\n    List list = (List) rulesCollection.get(\"rule\");\n    assertEquals(1, list.size());\n    assertEquals(port, ((Map) list.get(0)).get(\"port\"));\n    list = (List) rulesCollection.get(\"snitch\");\n    assertEquals(1, list.size());\n    assertEquals ( \"ImplicitSnitch\", ((Map)list.get(0)).get(\"class\"));\n\n    boolean allOnExpectedPort = rulesCollection.getReplicas().stream().allMatch(replica -> replica.getNodeName().contains(port));\n    assertTrue(\"Not all replicas were found to be on port: \" + port + \". Collection state is: \" + rulesCollection, allOnExpectedPort);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89948af0461fead48f44ba8fb7866f107ce83f22","date":1545157711,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/rule/RulesTest#testPortRuleInPresenceOfClusterPolicy().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/rule/RulesTest#testPortRuleInPresenceOfClusterPolicy().mjava","sourceNew":"  @Test\n  public void testPortRuleInPresenceOfClusterPolicy() throws Exception  {\n    JettySolrRunner jetty = cluster.getRandomJetty(random());\n    String port = Integer.toString(jetty.getLocalPort());\n\n    // this cluster policy prohibits having any replicas on a node with the above port\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'replica': 0, 'port':'\" + port + \"'}\" +\n        \"    ]\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cluster.getSolrClient().request(req);\n\n    // but this collection is created with a replica placement rule that says all replicas must be created\n    // on a node with above port (in direct conflict with the cluster policy)\n    String rulesColl = \"portRuleColl2\";\n    CollectionAdminRequest.createCollectionWithImplicitRouter(rulesColl, \"conf\", \"shard1\", 2)\n        .setRule(\"port:\" + port)\n        .setSnitch(\"class:ImplicitSnitch\")\n        .process(cluster.getSolrClient());\n\n    // now we assert that the replica placement rule is used instead of the cluster policy\n    DocCollection rulesCollection = getCollectionState(rulesColl);\n    List list = (List) rulesCollection.get(\"rule\");\n    assertEquals(1, list.size());\n    assertEquals(port, ((Map) list.get(0)).get(\"port\"));\n    list = (List) rulesCollection.get(\"snitch\");\n    assertEquals(1, list.size());\n    assertEquals ( \"ImplicitSnitch\", ((Map)list.get(0)).get(\"class\"));\n\n    boolean allOnExpectedPort = rulesCollection.getReplicas().stream().allMatch(replica -> replica.getNodeName().contains(port));\n    assertTrue(\"Not all replicas were found to be on port: \" + port + \". Collection state is: \" + rulesCollection, allOnExpectedPort);\n  }\n\n","sourceOld":"  @Test\n  public void testPortRuleInPresenceOfClusterPolicy() throws Exception  {\n    JettySolrRunner jetty = cluster.getRandomJetty(random());\n    String port = Integer.toString(jetty.getLocalPort());\n\n    // this cluster policy prohibits having any replicas on a node with the above port\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'replica': 0, 'port':'\" + port + \"'}\" +\n        \"    ]\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cluster.getSolrClient().request(req);\n\n    // but this collection is created with a replica placement rule that says all replicas must be created\n    // on a node with above port (in direct conflict with the cluster policy)\n    String rulesColl = \"portRuleColl2\";\n    CollectionAdminRequest.createCollectionWithImplicitRouter(rulesColl, \"conf\", \"shard1\", 2)\n        .setRule(\"port:\" + port)\n        .setSnitch(\"class:ImplicitSnitch\")\n        .process(cluster.getSolrClient());\n\n    // now we assert that the replica placement rule is used instead of the cluster policy\n    DocCollection rulesCollection = getCollectionState(rulesColl);\n    List list = (List) rulesCollection.get(\"rule\");\n    assertEquals(1, list.size());\n    assertEquals(port, ((Map) list.get(0)).get(\"port\"));\n    list = (List) rulesCollection.get(\"snitch\");\n    assertEquals(1, list.size());\n    assertEquals ( \"ImplicitSnitch\", ((Map)list.get(0)).get(\"class\"));\n\n    boolean allOnExpectedPort = rulesCollection.getReplicas().stream().allMatch(replica -> replica.getNodeName().contains(port));\n    assertTrue(\"Not all replicas were found to be on port: \" + port + \". Collection state is: \" + rulesCollection, allOnExpectedPort);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eade42881b2b73694a2b065cce4d6367a1870676","date":1564191666,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/rule/RulesTest#testPortRuleInPresenceOfClusterPolicy().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/rule/RulesTest#testPortRuleInPresenceOfClusterPolicy().mjava","sourceNew":"  @Test\n  public void testPortRuleInPresenceOfClusterPolicy() throws Exception  {\n    JettySolrRunner jetty = cluster.getRandomJetty(random());\n    String port = Integer.toString(jetty.getLocalPort());\n\n    // this cluster policy prohibits having any replicas on a node with the above port\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'replica': 0, 'port':'\" + port + \"'}\" +\n        \"    ]\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cluster.getSolrClient().request(req);\n\n    // but this collection is created with a replica placement rule that says all replicas must be created\n    // on a node with above port (in direct conflict with the cluster policy)\n    String rulesColl = \"portRuleColl2\";\n    CollectionAdminRequest.createCollectionWithImplicitRouter(rulesColl, \"conf\", \"shard1\", 2)\n        .setRule(\"port:\" + port)\n        .setSnitch(\"class:ImplicitSnitch\")\n        .process(cluster.getSolrClient());\n    \n    waitForState(\"Collection should have followed port rule w/ImplicitSnitch, not cluster policy\",\n                 rulesColl, (liveNodes, rulesCollection) -> {\n                   // first sanity check that the collection exists & the rules/snitch are listed\n                   if (null == rulesCollection) {\n                     return false;\n                   } else {\n                     List list = (List) rulesCollection.get(\"rule\");\n                     if (null == list || 1 != list.size()) {\n                       return false;\n                     }\n                     if (! port.equals(((Map) list.get(0)).get(\"port\"))) {\n                       return false;\n                     }\n                     list = (List) rulesCollection.get(\"snitch\");\n                     if (null == list || 1 != list.size()) {\n                       return false;\n                     }\n                     if (! \"ImplicitSnitch\".equals(((Map)list.get(0)).get(\"class\"))) {\n                       return false;\n                     }\n                   }\n                   if (2 != rulesCollection.getReplicas().size()) {\n                     return false;\n                   }\n                   // now sanity check that the rules were *obeyed*\n                   // (and the contradictory policy was ignored)\n                   return rulesCollection.getReplicas().stream().allMatch\n                     (replica -> (replica.getNodeName().contains(port) &&\n                                  replica.isActive(liveNodes)));\n                 });\n  }\n\n","sourceOld":"  @Test\n  public void testPortRuleInPresenceOfClusterPolicy() throws Exception  {\n    JettySolrRunner jetty = cluster.getRandomJetty(random());\n    String port = Integer.toString(jetty.getLocalPort());\n\n    // this cluster policy prohibits having any replicas on a node with the above port\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'replica': 0, 'port':'\" + port + \"'}\" +\n        \"    ]\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cluster.getSolrClient().request(req);\n\n    // but this collection is created with a replica placement rule that says all replicas must be created\n    // on a node with above port (in direct conflict with the cluster policy)\n    String rulesColl = \"portRuleColl2\";\n    CollectionAdminRequest.createCollectionWithImplicitRouter(rulesColl, \"conf\", \"shard1\", 2)\n        .setRule(\"port:\" + port)\n        .setSnitch(\"class:ImplicitSnitch\")\n        .process(cluster.getSolrClient());\n\n    // now we assert that the replica placement rule is used instead of the cluster policy\n    DocCollection rulesCollection = getCollectionState(rulesColl);\n    List list = (List) rulesCollection.get(\"rule\");\n    assertEquals(1, list.size());\n    assertEquals(port, ((Map) list.get(0)).get(\"port\"));\n    list = (List) rulesCollection.get(\"snitch\");\n    assertEquals(1, list.size());\n    assertEquals ( \"ImplicitSnitch\", ((Map)list.get(0)).get(\"class\"));\n\n    boolean allOnExpectedPort = rulesCollection.getReplicas().stream().allMatch(replica -> replica.getNodeName().contains(port));\n    assertTrue(\"Not all replicas were found to be on port: \" + port + \". Collection state is: \" + rulesCollection, allOnExpectedPort);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/rule/RulesTest#testPortRuleInPresenceOfClusterPolicy().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/rule/RulesTest#testPortRuleInPresenceOfClusterPolicy().mjava","sourceNew":"  @Test\n  public void testPortRuleInPresenceOfClusterPolicy() throws Exception  {\n    JettySolrRunner jetty = cluster.getRandomJetty(random());\n    String port = Integer.toString(jetty.getLocalPort());\n\n    // this cluster policy prohibits having any replicas on a node with the above port\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'replica': 0, 'port':'\" + port + \"'}\" +\n        \"    ]\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cluster.getSolrClient().request(req);\n\n    // but this collection is created with a replica placement rule that says all replicas must be created\n    // on a node with above port (in direct conflict with the cluster policy)\n    String rulesColl = \"portRuleColl2\";\n    CollectionAdminRequest.createCollectionWithImplicitRouter(rulesColl, \"conf\", \"shard1\", 2)\n        .setRule(\"port:\" + port)\n        .setSnitch(\"class:ImplicitSnitch\")\n        .process(cluster.getSolrClient());\n    \n    waitForState(\"Collection should have followed port rule w/ImplicitSnitch, not cluster policy\",\n                 rulesColl, (liveNodes, rulesCollection) -> {\n                   // first sanity check that the collection exists & the rules/snitch are listed\n                   if (null == rulesCollection) {\n                     return false;\n                   } else {\n                     List list = (List) rulesCollection.get(\"rule\");\n                     if (null == list || 1 != list.size()) {\n                       return false;\n                     }\n                     if (! port.equals(((Map) list.get(0)).get(\"port\"))) {\n                       return false;\n                     }\n                     list = (List) rulesCollection.get(\"snitch\");\n                     if (null == list || 1 != list.size()) {\n                       return false;\n                     }\n                     if (! \"ImplicitSnitch\".equals(((Map)list.get(0)).get(\"class\"))) {\n                       return false;\n                     }\n                   }\n                   if (2 != rulesCollection.getReplicas().size()) {\n                     return false;\n                   }\n                   // now sanity check that the rules were *obeyed*\n                   // (and the contradictory policy was ignored)\n                   return rulesCollection.getReplicas().stream().allMatch\n                     (replica -> (replica.getNodeName().contains(port) &&\n                                  replica.isActive(liveNodes)));\n                 });\n  }\n\n","sourceOld":"  @Test\n  public void testPortRuleInPresenceOfClusterPolicy() throws Exception  {\n    JettySolrRunner jetty = cluster.getRandomJetty(random());\n    String port = Integer.toString(jetty.getLocalPort());\n\n    // this cluster policy prohibits having any replicas on a node with the above port\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'replica': 0, 'port':'\" + port + \"'}\" +\n        \"    ]\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cluster.getSolrClient().request(req);\n\n    // but this collection is created with a replica placement rule that says all replicas must be created\n    // on a node with above port (in direct conflict with the cluster policy)\n    String rulesColl = \"portRuleColl2\";\n    CollectionAdminRequest.createCollectionWithImplicitRouter(rulesColl, \"conf\", \"shard1\", 2)\n        .setRule(\"port:\" + port)\n        .setSnitch(\"class:ImplicitSnitch\")\n        .process(cluster.getSolrClient());\n\n    // now we assert that the replica placement rule is used instead of the cluster policy\n    DocCollection rulesCollection = getCollectionState(rulesColl);\n    List list = (List) rulesCollection.get(\"rule\");\n    assertEquals(1, list.size());\n    assertEquals(port, ((Map) list.get(0)).get(\"port\"));\n    list = (List) rulesCollection.get(\"snitch\");\n    assertEquals(1, list.size());\n    assertEquals ( \"ImplicitSnitch\", ((Map)list.get(0)).get(\"class\"));\n\n    boolean allOnExpectedPort = rulesCollection.getReplicas().stream().allMatch(replica -> replica.getNodeName().contains(port));\n    assertTrue(\"Not all replicas were found to be on port: \" + port + \". Collection state is: \" + rulesCollection, allOnExpectedPort);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/rule/RulesTest#testPortRuleInPresenceOfClusterPolicy().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/rule/RulesTest#testPortRuleInPresenceOfClusterPolicy().mjava","sourceNew":"  @Test\n  public void testPortRuleInPresenceOfClusterPolicy() throws Exception  {\n    JettySolrRunner jetty = cluster.getRandomJetty(random());\n    String port = Integer.toString(jetty.getLocalPort());\n\n    // this cluster policy prohibits having any replicas on a node with the above port\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'replica': 0, 'port':'\" + port + \"'}\" +\n        \"    ]\" +\n        \"}\";\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cluster.getSolrClient().request(req);\n\n    // but this collection is created with a replica placement rule that says all replicas must be created\n    // on a node with above port (in direct conflict with the cluster policy)\n    String rulesColl = \"portRuleColl2\";\n    CollectionAdminRequest.createCollectionWithImplicitRouter(rulesColl, \"conf\", \"shard1\", 2)\n        .setRule(\"port:\" + port)\n        .setSnitch(\"class:ImplicitSnitch\")\n        .process(cluster.getSolrClient());\n    \n    waitForState(\"Collection should have followed port rule w/ImplicitSnitch, not cluster policy\",\n                 rulesColl, (liveNodes, rulesCollection) -> {\n                   // first sanity check that the collection exists & the rules/snitch are listed\n                   if (null == rulesCollection) {\n                     return false;\n                   } else {\n                     @SuppressWarnings({\"rawtypes\"})\n                     List list = (List) rulesCollection.get(\"rule\");\n                     if (null == list || 1 != list.size()) {\n                       return false;\n                     }\n                     if (! port.equals(((Map) list.get(0)).get(\"port\"))) {\n                       return false;\n                     }\n                     list = (List) rulesCollection.get(\"snitch\");\n                     if (null == list || 1 != list.size()) {\n                       return false;\n                     }\n                     if (! \"ImplicitSnitch\".equals(((Map)list.get(0)).get(\"class\"))) {\n                       return false;\n                     }\n                   }\n                   if (2 != rulesCollection.getReplicas().size()) {\n                     return false;\n                   }\n                   // now sanity check that the rules were *obeyed*\n                   // (and the contradictory policy was ignored)\n                   return rulesCollection.getReplicas().stream().allMatch\n                     (replica -> (replica.getNodeName().contains(port) &&\n                                  replica.isActive(liveNodes)));\n                 });\n  }\n\n","sourceOld":"  @Test\n  public void testPortRuleInPresenceOfClusterPolicy() throws Exception  {\n    JettySolrRunner jetty = cluster.getRandomJetty(random());\n    String port = Integer.toString(jetty.getLocalPort());\n\n    // this cluster policy prohibits having any replicas on a node with the above port\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'replica': 0, 'port':'\" + port + \"'}\" +\n        \"    ]\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cluster.getSolrClient().request(req);\n\n    // but this collection is created with a replica placement rule that says all replicas must be created\n    // on a node with above port (in direct conflict with the cluster policy)\n    String rulesColl = \"portRuleColl2\";\n    CollectionAdminRequest.createCollectionWithImplicitRouter(rulesColl, \"conf\", \"shard1\", 2)\n        .setRule(\"port:\" + port)\n        .setSnitch(\"class:ImplicitSnitch\")\n        .process(cluster.getSolrClient());\n    \n    waitForState(\"Collection should have followed port rule w/ImplicitSnitch, not cluster policy\",\n                 rulesColl, (liveNodes, rulesCollection) -> {\n                   // first sanity check that the collection exists & the rules/snitch are listed\n                   if (null == rulesCollection) {\n                     return false;\n                   } else {\n                     List list = (List) rulesCollection.get(\"rule\");\n                     if (null == list || 1 != list.size()) {\n                       return false;\n                     }\n                     if (! port.equals(((Map) list.get(0)).get(\"port\"))) {\n                       return false;\n                     }\n                     list = (List) rulesCollection.get(\"snitch\");\n                     if (null == list || 1 != list.size()) {\n                       return false;\n                     }\n                     if (! \"ImplicitSnitch\".equals(((Map)list.get(0)).get(\"class\"))) {\n                       return false;\n                     }\n                   }\n                   if (2 != rulesCollection.getReplicas().size()) {\n                     return false;\n                   }\n                   // now sanity check that the rules were *obeyed*\n                   // (and the contradictory policy was ignored)\n                   return rulesCollection.getReplicas().stream().allMatch\n                     (replica -> (replica.getNodeName().contains(port) &&\n                                  replica.isActive(liveNodes)));\n                 });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/rule/RulesTest#testPortRuleInPresenceOfClusterPolicy().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testPortRuleInPresenceOfClusterPolicy() throws Exception  {\n    JettySolrRunner jetty = cluster.getRandomJetty(random());\n    String port = Integer.toString(jetty.getLocalPort());\n\n    // this cluster policy prohibits having any replicas on a node with the above port\n    String setClusterPolicyCommand = \"{\" +\n        \" 'set-cluster-policy': [\" +\n        \"      {'replica': 0, 'port':'\" + port + \"'}\" +\n        \"    ]\" +\n        \"}\";\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setClusterPolicyCommand);\n    cluster.getSolrClient().request(req);\n\n    // but this collection is created with a replica placement rule that says all replicas must be created\n    // on a node with above port (in direct conflict with the cluster policy)\n    String rulesColl = \"portRuleColl2\";\n    CollectionAdminRequest.createCollectionWithImplicitRouter(rulesColl, \"conf\", \"shard1\", 2)\n        .setRule(\"port:\" + port)\n        .setSnitch(\"class:ImplicitSnitch\")\n        .process(cluster.getSolrClient());\n    \n    waitForState(\"Collection should have followed port rule w/ImplicitSnitch, not cluster policy\",\n                 rulesColl, (liveNodes, rulesCollection) -> {\n                   // first sanity check that the collection exists & the rules/snitch are listed\n                   if (null == rulesCollection) {\n                     return false;\n                   } else {\n                     @SuppressWarnings({\"rawtypes\"})\n                     List list = (List) rulesCollection.get(\"rule\");\n                     if (null == list || 1 != list.size()) {\n                       return false;\n                     }\n                     if (! port.equals(((Map) list.get(0)).get(\"port\"))) {\n                       return false;\n                     }\n                     list = (List) rulesCollection.get(\"snitch\");\n                     if (null == list || 1 != list.size()) {\n                       return false;\n                     }\n                     if (! \"ImplicitSnitch\".equals(((Map)list.get(0)).get(\"class\"))) {\n                       return false;\n                     }\n                   }\n                   if (2 != rulesCollection.getReplicas().size()) {\n                     return false;\n                   }\n                   // now sanity check that the rules were *obeyed*\n                   // (and the contradictory policy was ignored)\n                   return rulesCollection.getReplicas().stream().allMatch\n                     (replica -> (replica.getNodeName().contains(port) &&\n                                  replica.isActive(liveNodes)));\n                 });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c00aac053fdd75193eb8b6d45b64c26c3b586d5b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","217314a66df11e4013ff43c4027a4d64b6931148"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["eade42881b2b73694a2b065cce4d6367a1870676"],"217314a66df11e4013ff43c4027a4d64b6931148":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3f504512a03d978990cbff30db0522b354e846db":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"89948af0461fead48f44ba8fb7866f107ce83f22":["217314a66df11e4013ff43c4027a4d64b6931148"],"f8061ddd97f3352007d927dae445884a6f3d857b":["89948af0461fead48f44ba8fb7866f107ce83f22","eade42881b2b73694a2b065cce4d6367a1870676"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"eade42881b2b73694a2b065cce4d6367a1870676":["89948af0461fead48f44ba8fb7866f107ce83f22"]},"commit2Childs":{"c00aac053fdd75193eb8b6d45b64c26c3b586d5b":[],"217314a66df11e4013ff43c4027a4d64b6931148":["c00aac053fdd75193eb8b6d45b64c26c3b586d5b","89948af0461fead48f44ba8fb7866f107ce83f22"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c00aac053fdd75193eb8b6d45b64c26c3b586d5b","217314a66df11e4013ff43c4027a4d64b6931148"],"89948af0461fead48f44ba8fb7866f107ce83f22":["f8061ddd97f3352007d927dae445884a6f3d857b","eade42881b2b73694a2b065cce4d6367a1870676"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"eade42881b2b73694a2b065cce4d6367a1870676":["aa2585c33d5d66a1c837c312221eb55ddb3c4300","f8061ddd97f3352007d927dae445884a6f3d857b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c00aac053fdd75193eb8b6d45b64c26c3b586d5b","f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}