{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","sourceNew":"  void add(Node<?> item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  void add(Node<?> item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f492fe129985750df09c8dac738aecc503158bb3","date":1464099630,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","sourceNew":"  // nocommit can we remove the sync'd\n  synchronized long add(Node<?> newNode) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the new node to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, newNode)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, newNode);\n            return seqNo.getAndIncrement();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  void add(Node<?> item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9972d96003bc59c07a44e73de3cdd505dc08fd17","date":1464216081,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","sourceNew":"  synchronized long add(Node<?> newNode) {\n    tail.next = newNode;\n    tail = newNode;\n    return seqNo.getAndIncrement();\n  }\n\n","sourceOld":"  // nocommit can we remove the sync'd\n  synchronized long add(Node<?> newNode) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the new node to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, newNode)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, newNode);\n            return seqNo.getAndIncrement();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"505b6cc8ce3750d0996e0133b20eed5cc00b2abb","date":1464255552,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","sourceNew":"  long add(Node<?> newNode) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail && tailNext == null) {\n        /*\n         * we are in quiescent state and can try to insert the newNode to the\n         * current tail if we fail to insert we just retry the operation since\n         * somebody else has already added its newNode\n         */\n        if (currentTail.casNext(null, newNode)) {\n          /*\n           * now that we are done we need to advance the tail\n           */\n          long mySeqNo = seqNo.getAndIncrement();\n          boolean result = tailUpdater.compareAndSet(this, currentTail, newNode);\n          assert result;\n          return mySeqNo;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  synchronized long add(Node<?> newNode) {\n    tail.next = newNode;\n    tail = newNode;\n    return seqNo.getAndIncrement();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16ebfabc294f23b88b6a39722a02c9d39b353195","date":1464343867,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","sourceNew":"  long add(Node<?> newNode) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail && tailNext == null) {\n        /*\n         * we are in quiescent state and can try to insert the newNode to the\n         * current tail if we fail to insert we just retry the operation since\n         * somebody else has already added its newNode\n         */\n        if (currentTail.casNext(null, newNode)) {\n          /*\n           * now that we are done we need to advance the tail\n           */\n          long seqNo = getNextSequenceNumber();\n          boolean result = tailUpdater.compareAndSet(this, currentTail, newNode);\n          assert result;\n          return seqNo;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  long add(Node<?> newNode) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail && tailNext == null) {\n        /*\n         * we are in quiescent state and can try to insert the newNode to the\n         * current tail if we fail to insert we just retry the operation since\n         * somebody else has already added its newNode\n         */\n        if (currentTail.casNext(null, newNode)) {\n          /*\n           * now that we are done we need to advance the tail\n           */\n          long mySeqNo = seqNo.getAndIncrement();\n          boolean result = tailUpdater.compareAndSet(this, currentTail, newNode);\n          assert result;\n          return mySeqNo;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"122251c49e5a9fa95f056ea257ae3ab452099fc7","date":1464820065,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","sourceNew":"  synchronized long add(Node<?> newNode) {\n    tail.next = newNode;\n    this.tail = newNode;\n    return getNextSequenceNumber();\n  }\n\n","sourceOld":"  long add(Node<?> newNode) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail && tailNext == null) {\n        /*\n         * we are in quiescent state and can try to insert the newNode to the\n         * current tail if we fail to insert we just retry the operation since\n         * somebody else has already added its newNode\n         */\n        if (currentTail.casNext(null, newNode)) {\n          /*\n           * now that we are done we need to advance the tail\n           */\n          long seqNo = getNextSequenceNumber();\n          boolean result = tailUpdater.compareAndSet(this, currentTail, newNode);\n          assert result;\n          return seqNo;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","date":1464821470,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","sourceNew":"  synchronized long add(Node<?> newNode) {\n    tail.next = newNode;\n    this.tail = newNode;\n    return getNextSequenceNumber();\n  }\n\n","sourceOld":"  long add(Node<?> newNode) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail && tailNext == null) {\n        /*\n         * we are in quiescent state and can try to insert the newNode to the\n         * current tail if we fail to insert we just retry the operation since\n         * somebody else has already added its newNode\n         */\n        if (currentTail.casNext(null, newNode)) {\n          /*\n           * now that we are done we need to advance the tail\n           */\n          long seqNo = getNextSequenceNumber();\n          boolean result = tailUpdater.compareAndSet(this, currentTail, newNode);\n          assert result;\n          return seqNo;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","sourceNew":"  synchronized long add(Node<?> newNode) {\n    tail.next = newNode;\n    this.tail = newNode;\n    return getNextSequenceNumber();\n  }\n\n","sourceOld":"  void add(Node<?> item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","sourceNew":"  synchronized long add(Node<?> newNode) {\n    tail.next = newNode;\n    this.tail = newNode;\n    return getNextSequenceNumber();\n  }\n\n","sourceOld":"  void add(Node<?> item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","sourceNew":"  synchronized long add(Node<?> newNode) {\n    tail.next = newNode;\n    this.tail = newNode;\n    return getNextSequenceNumber();\n  }\n\n","sourceOld":"  void add(Node<?> item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34067df01cbbefc83d0b316037fe4e10d89ba6a3","date":1559054674,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","sourceNew":"  synchronized long add(Node<?> newNode) {\n    ensureOpen();\n    tail.next = newNode;\n    this.tail = newNode;\n    return getNextSequenceNumber();\n  }\n\n","sourceOld":"  synchronized long add(Node<?> newNode) {\n    tail.next = newNode;\n    this.tail = newNode;\n    return getNextSequenceNumber();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9","date":1559371943,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","sourceNew":"  synchronized long add(Node<?> newNode) {\n    ensureOpen();\n    tail.next = newNode;\n    this.tail = newNode;\n    return getNextSequenceNumber();\n  }\n\n","sourceOld":"  synchronized long add(Node<?> newNode) {\n    tail.next = newNode;\n    this.tail = newNode;\n    return getNextSequenceNumber();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9":["191128ac5b85671b1671e2c857437694283b6ebf","34067df01cbbefc83d0b316037fe4e10d89ba6a3"],"6483e4260c08168709c02238ae083a51519a28dd":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"191128ac5b85671b1671e2c857437694283b6ebf":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","6483e4260c08168709c02238ae083a51519a28dd"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["505b6cc8ce3750d0996e0133b20eed5cc00b2abb"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["16ebfabc294f23b88b6a39722a02c9d39b353195","122251c49e5a9fa95f056ea257ae3ab452099fc7"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","191128ac5b85671b1671e2c857437694283b6ebf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f492fe129985750df09c8dac738aecc503158bb3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"505b6cc8ce3750d0996e0133b20eed5cc00b2abb":["9972d96003bc59c07a44e73de3cdd505dc08fd17"],"9972d96003bc59c07a44e73de3cdd505dc08fd17":["f492fe129985750df09c8dac738aecc503158bb3"],"34067df01cbbefc83d0b316037fe4e10d89ba6a3":["191128ac5b85671b1671e2c857437694283b6ebf"],"122251c49e5a9fa95f056ea257ae3ab452099fc7":["16ebfabc294f23b88b6a39722a02c9d39b353195"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["6483e4260c08168709c02238ae083a51519a28dd","191128ac5b85671b1671e2c857437694283b6ebf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","f492fe129985750df09c8dac738aecc503158bb3"],"34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","34067df01cbbefc83d0b316037fe4e10d89ba6a3"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","122251c49e5a9fa95f056ea257ae3ab452099fc7"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["6483e4260c08168709c02238ae083a51519a28dd"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"f492fe129985750df09c8dac738aecc503158bb3":["9972d96003bc59c07a44e73de3cdd505dc08fd17"],"505b6cc8ce3750d0996e0133b20eed5cc00b2abb":["16ebfabc294f23b88b6a39722a02c9d39b353195"],"34067df01cbbefc83d0b316037fe4e10d89ba6a3":["34b5cf63f4ff3d985a7fc828c1a0d1624b0176d9"],"9972d96003bc59c07a44e73de3cdd505dc08fd17":["505b6cc8ce3750d0996e0133b20eed5cc00b2abb"],"122251c49e5a9fa95f056ea257ae3ab452099fc7":["b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}