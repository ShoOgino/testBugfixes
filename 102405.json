{"path":"lucene/src/java/org/apache/lucene/util/automaton/fst/FST#readLastTargetArc(Arc[T],Arc[T]).mjava","commits":[{"id":"30898a79d4bce815d5551a8a22c32e88f1972cb9","date":1298740268,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/FST#readLastTargetArc(Arc[T],Arc[T]).mjava","pathOld":"/dev/null","sourceNew":"  /** Follows the <code>follow</code> arc and reads the last\n   *  arc of its target; this changes the provided\n   *  <code>arc</code> (2nd arg) in-place and returns it.\n   * \n   * @return Returns the second argument\n   * (<code>arc</code>). */\n  public Arc<T> readLastTargetArc(Arc<T> follow, Arc<T> arc) throws IOException {\n    //System.out.println(\"readLast\");\n    if (!targetHasArcs(follow)) {\n      //System.out.println(\"  end node\");\n      assert follow.isFinal();\n      arc.label = -1;\n      arc.output = follow.nextFinalOutput;\n      arc.flags = BIT_LAST_ARC;\n      return arc;\n    } else {\n      final BytesReader in = getBytesReader(follow.target);\n      arc.flags = in.readByte();\n      if (arc.flag(BIT_ARCS_AS_FIXED_ARRAY)) {\n        // array: jump straight to end\n        arc.numArcs = in.readVInt();\n        arc.bytesPerArc = in.readByte() & 0xFF;\n        //System.out.println(\"  array numArcs=\" + arc.numArcs + \" bpa=\" + arc.bytesPerArc);\n        arc.posArcsStart = in.pos;\n        arc.arcIdx = arc.numArcs - 2;\n      } else {\n        // non-array: linear scan\n        arc.bytesPerArc = 0;\n        //System.out.println(\"  scan\");\n        while(!arc.isLast()) {\n          // skip this arc:\n          readLabel(in);\n          if (arc.flag(BIT_ARC_HAS_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_ARC_HAS_FINAL_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_STOP_NODE)) {\n          } else if (arc.flag(BIT_TARGET_NEXT)) {\n          } else {\n            in.pos -= 4;\n          }\n          arc.flags = in.readByte();\n        }\n        arc.nextArc = in.pos+1;\n      }\n      readNextRealArc(arc);\n      assert arc.isLast();\n      return arc;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/FST#readLastTargetArc(Arc[T],Arc[T]).mjava","pathOld":"/dev/null","sourceNew":"  /** Follows the <code>follow</code> arc and reads the last\n   *  arc of its target; this changes the provided\n   *  <code>arc</code> (2nd arg) in-place and returns it.\n   * \n   * @return Returns the second argument\n   * (<code>arc</code>). */\n  public Arc<T> readLastTargetArc(Arc<T> follow, Arc<T> arc) throws IOException {\n    //System.out.println(\"readLast\");\n    if (!targetHasArcs(follow)) {\n      //System.out.println(\"  end node\");\n      assert follow.isFinal();\n      arc.label = -1;\n      arc.output = follow.nextFinalOutput;\n      arc.flags = BIT_LAST_ARC;\n      return arc;\n    } else {\n      final BytesReader in = getBytesReader(follow.target);\n      arc.flags = in.readByte();\n      if (arc.flag(BIT_ARCS_AS_FIXED_ARRAY)) {\n        // array: jump straight to end\n        arc.numArcs = in.readVInt();\n        arc.bytesPerArc = in.readByte() & 0xFF;\n        //System.out.println(\"  array numArcs=\" + arc.numArcs + \" bpa=\" + arc.bytesPerArc);\n        arc.posArcsStart = in.pos;\n        arc.arcIdx = arc.numArcs - 2;\n      } else {\n        // non-array: linear scan\n        arc.bytesPerArc = 0;\n        //System.out.println(\"  scan\");\n        while(!arc.isLast()) {\n          // skip this arc:\n          readLabel(in);\n          if (arc.flag(BIT_ARC_HAS_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_ARC_HAS_FINAL_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_STOP_NODE)) {\n          } else if (arc.flag(BIT_TARGET_NEXT)) {\n          } else {\n            in.pos -= 4;\n          }\n          arc.flags = in.readByte();\n        }\n        arc.nextArc = in.pos+1;\n      }\n      readNextRealArc(arc);\n      assert arc.isLast();\n      return arc;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/FST#readLastTargetArc(Arc[T],Arc[T]).mjava","pathOld":"/dev/null","sourceNew":"  /** Follows the <code>follow</code> arc and reads the last\n   *  arc of its target; this changes the provided\n   *  <code>arc</code> (2nd arg) in-place and returns it.\n   * \n   * @return Returns the second argument\n   * (<code>arc</code>). */\n  public Arc<T> readLastTargetArc(Arc<T> follow, Arc<T> arc) throws IOException {\n    //System.out.println(\"readLast\");\n    if (!targetHasArcs(follow)) {\n      //System.out.println(\"  end node\");\n      assert follow.isFinal();\n      arc.label = -1;\n      arc.output = follow.nextFinalOutput;\n      arc.flags = BIT_LAST_ARC;\n      return arc;\n    } else {\n      final BytesReader in = getBytesReader(follow.target);\n      arc.flags = in.readByte();\n      if (arc.flag(BIT_ARCS_AS_FIXED_ARRAY)) {\n        // array: jump straight to end\n        arc.numArcs = in.readVInt();\n        arc.bytesPerArc = in.readByte() & 0xFF;\n        //System.out.println(\"  array numArcs=\" + arc.numArcs + \" bpa=\" + arc.bytesPerArc);\n        arc.posArcsStart = in.pos;\n        arc.arcIdx = arc.numArcs - 2;\n      } else {\n        // non-array: linear scan\n        arc.bytesPerArc = 0;\n        //System.out.println(\"  scan\");\n        while(!arc.isLast()) {\n          // skip this arc:\n          readLabel(in);\n          if (arc.flag(BIT_ARC_HAS_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_ARC_HAS_FINAL_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_STOP_NODE)) {\n          } else if (arc.flag(BIT_TARGET_NEXT)) {\n          } else {\n            in.pos -= 4;\n          }\n          arc.flags = in.readByte();\n        }\n        arc.nextArc = in.pos+1;\n      }\n      readNextRealArc(arc);\n      assert arc.isLast();\n      return arc;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8be6e1e4fbbc94d90b78f175c03ff389b6949373","date":1306674752,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/FST#readLastTargetArc(Arc[T],Arc[T]).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/FST#readLastTargetArc(Arc[T],Arc[T]).mjava","sourceNew":"  /** Follows the <code>follow</code> arc and reads the last\n   *  arc of its target; this changes the provided\n   *  <code>arc</code> (2nd arg) in-place and returns it.\n   * \n   * @return Returns the second argument\n   * (<code>arc</code>). */\n  public Arc<T> readLastTargetArc(Arc<T> follow, Arc<T> arc) throws IOException {\n    //System.out.println(\"readLast\");\n    if (!targetHasArcs(follow)) {\n      //System.out.println(\"  end node\");\n      assert follow.isFinal();\n      arc.label = -1;\n      arc.output = follow.nextFinalOutput;\n      arc.flags = BIT_LAST_ARC;\n      return arc;\n    } else {\n      final BytesReader in = getBytesReader(follow.target);\n      arc.flags = in.readByte();\n      if (arc.flag(BIT_ARCS_AS_FIXED_ARRAY)) {\n        // array: jump straight to end\n        arc.numArcs = in.readVInt();\n        arc.bytesPerArc = in.readByte() & 0xFF;\n        //System.out.println(\"  array numArcs=\" + arc.numArcs + \" bpa=\" + arc.bytesPerArc);\n        arc.posArcsStart = in.pos;\n        arc.arcIdx = arc.numArcs - 2;\n      } else {\n        // non-array: linear scan\n        arc.bytesPerArc = 0;\n        //System.out.println(\"  scan\");\n        while(!arc.isLast()) {\n          // skip this arc:\n          readLabel(in);\n          if (arc.flag(BIT_ARC_HAS_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_ARC_HAS_FINAL_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_STOP_NODE)) {\n          } else if (arc.flag(BIT_TARGET_NEXT)) {\n          } else {\n            in.pos -= 4;\n          }\n          arc.flags = in.readByte();\n        }\n        arc.nextArc = in.pos+1;\n      }\n      readNextRealArc(arc);\n      assert arc.isLast();\n      return arc;\n    }\n  }\n\n","sourceOld":"  /** Follows the <code>follow</code> arc and reads the last\n   *  arc of its target; this changes the provided\n   *  <code>arc</code> (2nd arg) in-place and returns it.\n   * \n   * @return Returns the second argument\n   * (<code>arc</code>). */\n  public Arc<T> readLastTargetArc(Arc<T> follow, Arc<T> arc) throws IOException {\n    //System.out.println(\"readLast\");\n    if (!targetHasArcs(follow)) {\n      //System.out.println(\"  end node\");\n      assert follow.isFinal();\n      arc.label = -1;\n      arc.output = follow.nextFinalOutput;\n      arc.flags = BIT_LAST_ARC;\n      return arc;\n    } else {\n      final BytesReader in = getBytesReader(follow.target);\n      arc.flags = in.readByte();\n      if (arc.flag(BIT_ARCS_AS_FIXED_ARRAY)) {\n        // array: jump straight to end\n        arc.numArcs = in.readVInt();\n        arc.bytesPerArc = in.readByte() & 0xFF;\n        //System.out.println(\"  array numArcs=\" + arc.numArcs + \" bpa=\" + arc.bytesPerArc);\n        arc.posArcsStart = in.pos;\n        arc.arcIdx = arc.numArcs - 2;\n      } else {\n        // non-array: linear scan\n        arc.bytesPerArc = 0;\n        //System.out.println(\"  scan\");\n        while(!arc.isLast()) {\n          // skip this arc:\n          readLabel(in);\n          if (arc.flag(BIT_ARC_HAS_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_ARC_HAS_FINAL_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_STOP_NODE)) {\n          } else if (arc.flag(BIT_TARGET_NEXT)) {\n          } else {\n            in.pos -= 4;\n          }\n          arc.flags = in.readByte();\n        }\n        arc.nextArc = in.pos+1;\n      }\n      readNextRealArc(arc);\n      assert arc.isLast();\n      return arc;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/FST#readLastTargetArc(Arc[T],Arc[T]).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/FST#readLastTargetArc(Arc[T],Arc[T]).mjava","sourceNew":"  /** Follows the <code>follow</code> arc and reads the last\n   *  arc of its target; this changes the provided\n   *  <code>arc</code> (2nd arg) in-place and returns it.\n   * \n   * @return Returns the second argument\n   * (<code>arc</code>). */\n  public Arc<T> readLastTargetArc(Arc<T> follow, Arc<T> arc) throws IOException {\n    //System.out.println(\"readLast\");\n    if (!targetHasArcs(follow)) {\n      //System.out.println(\"  end node\");\n      assert follow.isFinal();\n      arc.label = -1;\n      arc.output = follow.nextFinalOutput;\n      arc.flags = BIT_LAST_ARC;\n      return arc;\n    } else {\n      final BytesReader in = getBytesReader(follow.target);\n      arc.flags = in.readByte();\n      if (arc.flag(BIT_ARCS_AS_FIXED_ARRAY)) {\n        // array: jump straight to end\n        arc.numArcs = in.readVInt();\n        arc.bytesPerArc = in.readByte() & 0xFF;\n        //System.out.println(\"  array numArcs=\" + arc.numArcs + \" bpa=\" + arc.bytesPerArc);\n        arc.posArcsStart = in.pos;\n        arc.arcIdx = arc.numArcs - 2;\n      } else {\n        // non-array: linear scan\n        arc.bytesPerArc = 0;\n        //System.out.println(\"  scan\");\n        while(!arc.isLast()) {\n          // skip this arc:\n          readLabel(in);\n          if (arc.flag(BIT_ARC_HAS_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_ARC_HAS_FINAL_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_STOP_NODE)) {\n          } else if (arc.flag(BIT_TARGET_NEXT)) {\n          } else {\n            in.pos -= 4;\n          }\n          arc.flags = in.readByte();\n        }\n        arc.nextArc = in.pos+1;\n      }\n      readNextRealArc(arc);\n      assert arc.isLast();\n      return arc;\n    }\n  }\n\n","sourceOld":"  /** Follows the <code>follow</code> arc and reads the last\n   *  arc of its target; this changes the provided\n   *  <code>arc</code> (2nd arg) in-place and returns it.\n   * \n   * @return Returns the second argument\n   * (<code>arc</code>). */\n  public Arc<T> readLastTargetArc(Arc<T> follow, Arc<T> arc) throws IOException {\n    //System.out.println(\"readLast\");\n    if (!targetHasArcs(follow)) {\n      //System.out.println(\"  end node\");\n      assert follow.isFinal();\n      arc.label = -1;\n      arc.output = follow.nextFinalOutput;\n      arc.flags = BIT_LAST_ARC;\n      return arc;\n    } else {\n      final BytesReader in = getBytesReader(follow.target);\n      arc.flags = in.readByte();\n      if (arc.flag(BIT_ARCS_AS_FIXED_ARRAY)) {\n        // array: jump straight to end\n        arc.numArcs = in.readVInt();\n        arc.bytesPerArc = in.readByte() & 0xFF;\n        //System.out.println(\"  array numArcs=\" + arc.numArcs + \" bpa=\" + arc.bytesPerArc);\n        arc.posArcsStart = in.pos;\n        arc.arcIdx = arc.numArcs - 2;\n      } else {\n        // non-array: linear scan\n        arc.bytesPerArc = 0;\n        //System.out.println(\"  scan\");\n        while(!arc.isLast()) {\n          // skip this arc:\n          readLabel(in);\n          if (arc.flag(BIT_ARC_HAS_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_ARC_HAS_FINAL_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_STOP_NODE)) {\n          } else if (arc.flag(BIT_TARGET_NEXT)) {\n          } else {\n            in.pos -= 4;\n          }\n          arc.flags = in.readByte();\n        }\n        arc.nextArc = in.pos+1;\n      }\n      readNextRealArc(arc);\n      assert arc.isLast();\n      return arc;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/FST#readLastTargetArc(Arc[T],Arc[T]).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/FST#readLastTargetArc(Arc[T],Arc[T]).mjava","sourceNew":"  /** Follows the <code>follow</code> arc and reads the last\n   *  arc of its target; this changes the provided\n   *  <code>arc</code> (2nd arg) in-place and returns it.\n   * \n   * @return Returns the second argument\n   * (<code>arc</code>). */\n  public Arc<T> readLastTargetArc(Arc<T> follow, Arc<T> arc) throws IOException {\n    //System.out.println(\"readLast\");\n    if (!targetHasArcs(follow)) {\n      //System.out.println(\"  end node\");\n      assert follow.isFinal();\n      arc.label = -1;\n      arc.output = follow.nextFinalOutput;\n      arc.flags = BIT_LAST_ARC;\n      return arc;\n    } else {\n      final BytesReader in = getBytesReader(follow.target);\n      arc.flags = in.readByte();\n      if (arc.flag(BIT_ARCS_AS_FIXED_ARRAY)) {\n        // array: jump straight to end\n        arc.numArcs = in.readVInt();\n        arc.bytesPerArc = in.readByte() & 0xFF;\n        //System.out.println(\"  array numArcs=\" + arc.numArcs + \" bpa=\" + arc.bytesPerArc);\n        arc.posArcsStart = in.pos;\n        arc.arcIdx = arc.numArcs - 2;\n      } else {\n        // non-array: linear scan\n        arc.bytesPerArc = 0;\n        //System.out.println(\"  scan\");\n        while(!arc.isLast()) {\n          // skip this arc:\n          readLabel(in);\n          if (arc.flag(BIT_ARC_HAS_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_ARC_HAS_FINAL_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_STOP_NODE)) {\n          } else if (arc.flag(BIT_TARGET_NEXT)) {\n          } else {\n            in.pos -= 4;\n          }\n          arc.flags = in.readByte();\n        }\n        arc.nextArc = in.pos+1;\n      }\n      readNextRealArc(arc);\n      assert arc.isLast();\n      return arc;\n    }\n  }\n\n","sourceOld":"  /** Follows the <code>follow</code> arc and reads the last\n   *  arc of its target; this changes the provided\n   *  <code>arc</code> (2nd arg) in-place and returns it.\n   * \n   * @return Returns the second argument\n   * (<code>arc</code>). */\n  public Arc<T> readLastTargetArc(Arc<T> follow, Arc<T> arc) throws IOException {\n    //System.out.println(\"readLast\");\n    if (!targetHasArcs(follow)) {\n      //System.out.println(\"  end node\");\n      assert follow.isFinal();\n      arc.label = -1;\n      arc.output = follow.nextFinalOutput;\n      arc.flags = BIT_LAST_ARC;\n      return arc;\n    } else {\n      final BytesReader in = getBytesReader(follow.target);\n      arc.flags = in.readByte();\n      if (arc.flag(BIT_ARCS_AS_FIXED_ARRAY)) {\n        // array: jump straight to end\n        arc.numArcs = in.readVInt();\n        arc.bytesPerArc = in.readByte() & 0xFF;\n        //System.out.println(\"  array numArcs=\" + arc.numArcs + \" bpa=\" + arc.bytesPerArc);\n        arc.posArcsStart = in.pos;\n        arc.arcIdx = arc.numArcs - 2;\n      } else {\n        // non-array: linear scan\n        arc.bytesPerArc = 0;\n        //System.out.println(\"  scan\");\n        while(!arc.isLast()) {\n          // skip this arc:\n          readLabel(in);\n          if (arc.flag(BIT_ARC_HAS_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_ARC_HAS_FINAL_OUTPUT)) {\n            outputs.read(in);\n          }\n          if (arc.flag(BIT_STOP_NODE)) {\n          } else if (arc.flag(BIT_TARGET_NEXT)) {\n          } else {\n            in.pos -= 4;\n          }\n          arc.flags = in.readByte();\n        }\n        arc.nextArc = in.pos+1;\n      }\n      readNextRealArc(arc);\n      assert arc.isLast();\n      return arc;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","30898a79d4bce815d5551a8a22c32e88f1972cb9"],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["30898a79d4bce815d5551a8a22c32e88f1972cb9"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","30898a79d4bce815d5551a8a22c32e88f1972cb9"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["30898a79d4bce815d5551a8a22c32e88f1972cb9","8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"30898a79d4bce815d5551a8a22c32e88f1972cb9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["d619839baa8ce5503e496b94a9e42ad6f079293f","8be6e1e4fbbc94d90b78f175c03ff389b6949373"]},"commit2Childs":{"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["2e10cb22a8bdb44339e282925a29182bb2f3174d"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f","30898a79d4bce815d5551a8a22c32e88f1972cb9"],"30898a79d4bce815d5551a8a22c32e88f1972cb9":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","8be6e1e4fbbc94d90b78f175c03ff389b6949373","d619839baa8ce5503e496b94a9e42ad6f079293f","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}