{"path":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","commits":[{"id":"06e38ae84477e7a7eacea808dc3de9950fce5ccf","date":1470634560,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND) {\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN) {\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND) {\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN) {\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND) {\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN) {\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6ec38868117a0f2ce8dfdcf05fc93beeb566ecd","date":1505838607,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","sourceNew":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND || status == BootstrapStatus.CANCELLED) {\n            log.info(\"CDCR bootstrap \" + (status == BootstrapStatus.NOTFOUND ? \"not found\" : \"cancelled\") + \"in {} seconds\",\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN || status == BootstrapStatus.SUBMITTED) {\n            log.info(\"CDCR bootstrap is \" + (status == BootstrapStatus.UNKNOWN ? \"unknown\" : \"submitted\"),\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND) {\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN) {\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04af4a840c8f501ba34e09e382b8f8ace82aa51e","date":1505847466,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","sourceNew":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND || status == BootstrapStatus.CANCELLED) {\n            log.info(\"CDCR bootstrap \" + (status == BootstrapStatus.NOTFOUND ? \"not found\" : \"cancelled\") + \"in {} seconds\",\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN || status == BootstrapStatus.SUBMITTED) {\n            log.info(\"CDCR bootstrap is \" + (status == BootstrapStatus.UNKNOWN ? \"unknown\" : \"submitted\"),\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND) {\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN) {\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","sourceNew":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND || status == BootstrapStatus.CANCELLED) {\n            log.info(\"CDCR bootstrap \" + (status == BootstrapStatus.NOTFOUND ? \"not found\" : \"cancelled\") + \"in {} seconds\",\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN || status == BootstrapStatus.SUBMITTED) {\n            log.info(\"CDCR bootstrap is \" + (status == BootstrapStatus.UNKNOWN ? \"unknown\" : \"submitted\"),\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND || status == BootstrapStatus.CANCELLED) {\n            log.info(\"CDCR bootstrap \" + (status == BootstrapStatus.NOTFOUND ? \"not found\" : \"cancelled\") + \"in {} seconds\",\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN || status == BootstrapStatus.SUBMITTED) {\n            log.info(\"CDCR bootstrap is \" + (status == BootstrapStatus.UNKNOWN ? \"unknown\" : \"submitted\"),\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6ee2533508e7cceb7551bb7deaeaf89dfa3767b9","date":1523659106,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","sourceNew":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            // issue asynchronous request_recovery to the follower nodes of the shards of target collection\n            sendRequestRecoveryToFollowers(state);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND || status == BootstrapStatus.CANCELLED) {\n            log.info(\"CDCR bootstrap \" + (status == BootstrapStatus.NOTFOUND ? \"not found\" : \"cancelled\") + \"in {} seconds\",\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN || status == BootstrapStatus.SUBMITTED) {\n            log.info(\"CDCR bootstrap is \" + (status == BootstrapStatus.UNKNOWN ? \"unknown\" : \"submitted\"),\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND || status == BootstrapStatus.CANCELLED) {\n            log.info(\"CDCR bootstrap \" + (status == BootstrapStatus.NOTFOUND ? \"not found\" : \"cancelled\") + \"in {} seconds\",\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN || status == BootstrapStatus.SUBMITTED) {\n            log.info(\"CDCR bootstrap is \" + (status == BootstrapStatus.UNKNOWN ? \"unknown\" : \"submitted\"),\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["160430584bb0ed88bd4cb089d89d53a0db81f90e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"160430584bb0ed88bd4cb089d89d53a0db81f90e","date":1565319532,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","sourceNew":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND || status == BootstrapStatus.CANCELLED) {\n            log.info(\"CDCR bootstrap \" + (status == BootstrapStatus.NOTFOUND ? \"not found\" : \"cancelled\") + \"in {} seconds\",\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN || status == BootstrapStatus.SUBMITTED) {\n            log.info(\"CDCR bootstrap is \" + (status == BootstrapStatus.UNKNOWN ? \"unknown\" : \"submitted\"),\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            // issue asynchronous request_recovery to the follower nodes of the shards of target collection\n            sendRequestRecoveryToFollowers(state);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND || status == BootstrapStatus.CANCELLED) {\n            log.info(\"CDCR bootstrap \" + (status == BootstrapStatus.NOTFOUND ? \"not found\" : \"cancelled\") + \"in {} seconds\",\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN || status == BootstrapStatus.SUBMITTED) {\n            log.info(\"CDCR bootstrap is \" + (status == BootstrapStatus.UNKNOWN ? \"unknown\" : \"submitted\"),\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","bugFix":["6ee2533508e7cceb7551bb7deaeaf89dfa3767b9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","sourceNew":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            if (log.isInfoEnabled()) {\n              log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                  checkpoint, collectionName, shard);\n            }\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND || status == BootstrapStatus.CANCELLED) {\n            if (log.isInfoEnabled()) {\n              log.info(\"CDCR bootstrap {} in {} seconds\"\n                  , (status == BootstrapStatus.NOTFOUND ? \"not found\" : \"cancelled\")\n                  , BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            }\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN || status == BootstrapStatus.SUBMITTED) {\n            if (log.isInfoEnabled()) {\n              log.info(\"CDCR bootstrap is {} {}\", (status == BootstrapStatus.UNKNOWN ? \"unknown\" : \"submitted\"),\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            }\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection {} shard: {}\", targetCollection, shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                checkpoint, collectionName, shard);\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND || status == BootstrapStatus.CANCELLED) {\n            log.info(\"CDCR bootstrap \" + (status == BootstrapStatus.NOTFOUND ? \"not found\" : \"cancelled\") + \"in {} seconds\",\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN || status == BootstrapStatus.SUBMITTED) {\n            log.info(\"CDCR bootstrap is \" + (status == BootstrapStatus.UNKNOWN ? \"unknown\" : \"submitted\"),\n                BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection \" + targetCollection + \" shard: \" + shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1","date":1598647393,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/CdcrReplicatorManager.BootstrapStatusRunnable#run().mjava","sourceNew":null,"sourceOld":"    @Override\n    public void run() {\n      int retries = 1;\n      boolean success = false;\n      try {\n        while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n          Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n        }\n        TimeOut timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        while (!timeOut.hasTimedOut()) {\n          if (closed) {\n            log.warn(\"Cancelling waiting for bootstrap on target: {} shard: {} to complete\", targetCollection, shard);\n            state.setBootstrapInProgress(false);\n            break;\n          }\n          BootstrapStatus status = getBoostrapStatus();\n          if (status == BootstrapStatus.RUNNING) {\n            try {\n              log.info(\"CDCR bootstrap running for {} seconds, sleeping for {} ms\",\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS), BOOTSTRAP_RETRY_DELAY_MS);\n              timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          } else if (status == BootstrapStatus.COMPLETED) {\n            log.info(\"CDCR bootstrap successful in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            long checkpoint = CdcrReplicatorManager.this.getCheckpoint(state);\n            if (log.isInfoEnabled()) {\n              log.info(\"Create new update log reader for target {} with checkpoint {} @ {}:{}\", state.getTargetCollection(),\n                  checkpoint, collectionName, shard);\n            }\n            CdcrUpdateLog.CdcrLogReader reader1 = ulog.newLogReader();\n            reader1.seek(checkpoint);\n            success = true;\n            break;\n          } else if (status == BootstrapStatus.FAILED) {\n            log.warn(\"CDCR bootstrap failed in {} seconds\", BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            // let's retry a fixed number of times before giving up\n            if (retries >= MAX_BOOTSTRAP_ATTEMPTS) {\n              log.error(\"Unable to bootstrap the target collection: {}, shard: {} even after {} retries\", targetCollection, shard, retries);\n              break;\n            } else {\n              log.info(\"Retry: {} - Attempting to bootstrap target collection: {} shard: {}\", retries, targetCollection, shard);\n              while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n                Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n              }\n              timeOut = new TimeOut(BOOTSTRAP_TIMEOUT_SECONDS, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n              retries++;\n            }\n          } else if (status == BootstrapStatus.NOTFOUND || status == BootstrapStatus.CANCELLED) {\n            if (log.isInfoEnabled()) {\n              log.info(\"CDCR bootstrap {} in {} seconds\"\n                  , (status == BootstrapStatus.NOTFOUND ? \"not found\" : \"cancelled\")\n                  , BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            }\n            // the leader of the target shard may have changed and therefore there is no record of the\n            // bootstrap process so we must retry the operation\n            while (!closed && sendBootstrapCommand() != BootstrapStatus.SUBMITTED)  {\n              Thread.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n            }\n            retries = 1;\n            timeOut = new TimeOut(6L * 3600L * 3600L, TimeUnit.SECONDS, TimeSource.NANO_TIME); // reset the timer\n          } else if (status == BootstrapStatus.UNKNOWN || status == BootstrapStatus.SUBMITTED) {\n            if (log.isInfoEnabled()) {\n              log.info(\"CDCR bootstrap is {} {}\", (status == BootstrapStatus.UNKNOWN ? \"unknown\" : \"submitted\"),\n                  BOOTSTRAP_TIMEOUT_SECONDS - timeOut.timeLeft(TimeUnit.SECONDS));\n            }\n            // we were not able to query the status on the remote end\n            // so just sleep for a bit and try again\n            timeOut.sleep(BOOTSTRAP_RETRY_DELAY_MS);\n          }\n        }\n      } catch (InterruptedException e) {\n        log.info(\"Bootstrap thread interrupted\");\n        state.reportError(CdcrReplicatorState.ErrorType.INTERNAL);\n        Thread.currentThread().interrupt();\n      } catch (IOException | SolrServerException | SolrException e) {\n        log.error(\"Unable to bootstrap the target collection {} shard: {}\", targetCollection, shard, e);\n        state.reportError(CdcrReplicatorState.ErrorType.BAD_REQUEST);\n      } finally {\n        if (success) {\n          log.info(\"Bootstrap successful, giving the go-ahead to replicator\");\n          state.setBootstrapInProgress(false);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"160430584bb0ed88bd4cb089d89d53a0db81f90e":["6ee2533508e7cceb7551bb7deaeaf89dfa3767b9"],"6ee2533508e7cceb7551bb7deaeaf89dfa3767b9":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"04af4a840c8f501ba34e09e382b8f8ace82aa51e":["06e38ae84477e7a7eacea808dc3de9950fce5ccf","d6ec38868117a0f2ce8dfdcf05fc93beeb566ecd"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["160430584bb0ed88bd4cb089d89d53a0db81f90e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6ec38868117a0f2ce8dfdcf05fc93beeb566ecd":["06e38ae84477e7a7eacea808dc3de9950fce5ccf"],"06e38ae84477e7a7eacea808dc3de9950fce5ccf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["d6ec38868117a0f2ce8dfdcf05fc93beeb566ecd"],"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","06e38ae84477e7a7eacea808dc3de9950fce5ccf"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","06e38ae84477e7a7eacea808dc3de9950fce5ccf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1"]},"commit2Childs":{"160430584bb0ed88bd4cb089d89d53a0db81f90e":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"6ee2533508e7cceb7551bb7deaeaf89dfa3767b9":["160430584bb0ed88bd4cb089d89d53a0db81f90e"],"04af4a840c8f501ba34e09e382b8f8ace82aa51e":[],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["06e38ae84477e7a7eacea808dc3de9950fce5ccf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"06e38ae84477e7a7eacea808dc3de9950fce5ccf":["04af4a840c8f501ba34e09e382b8f8ace82aa51e","d6ec38868117a0f2ce8dfdcf05fc93beeb566ecd","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"d6ec38868117a0f2ce8dfdcf05fc93beeb566ecd":["04af4a840c8f501ba34e09e382b8f8ace82aa51e","1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["6ee2533508e7cceb7551bb7deaeaf89dfa3767b9"],"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["04af4a840c8f501ba34e09e382b8f8ace82aa51e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}