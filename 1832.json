{"path":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","commits":[{"id":"8b48c85d1bf438ef65fbc1abe44f4e2c04a43e00","date":1317931776,"type":1,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TermAllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        groups.add(new BytesRef(_TestUtil.randomRealisticUnicodeString(random)));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n        s.close();\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        groups.add(new BytesRef(_TestUtil.randomRealisticUnicodeString(random)));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = TermAllGroupHeadsCollector.create(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n        s.close();\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"382fe3a6ca9745891afebda9b9a57cc158305545","date":1320952430,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        groups.add(new BytesRef(_TestUtil.randomRealisticUnicodeString(random)));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n        s.close();\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        groups.add(new BytesRef(_TestUtil.randomRealisticUnicodeString(random)));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n        s.close();\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4739c84c362b9673ab5ed3e038ff760c718c30c8","date":1322161679,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      ValueType valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      IndexDocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new IndexDocValuesField(\"group\");\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytes(new BytesRef(groupDoc.group.utf8ToString()), valueType);\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n        s.close();\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        groups.add(new BytesRef(_TestUtil.randomRealisticUnicodeString(random)));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n        s.close();\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["fa0f44f887719e97183771e977cfc4bfb485b766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","date":1323449025,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\");\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytes(new BytesRef(groupDoc.group.utf8ToString()), valueType);\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n        s.close();\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      ValueType valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      IndexDocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new IndexDocValuesField(\"group\");\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytes(new BytesRef(groupDoc.group.utf8ToString()), valueType);\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n        s.close();\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["fa0f44f887719e97183771e977cfc4bfb485b766","cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      ValueType valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      IndexDocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new IndexDocValuesField(\"group\");\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytes(new BytesRef(groupDoc.group.utf8ToString()), valueType);\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      ValueType valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      IndexDocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new IndexDocValuesField(\"group\");\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytes(new BytesRef(groupDoc.group.utf8ToString()), valueType);\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n        s.close();\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\");\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytes(new BytesRef(groupDoc.group.utf8ToString()), valueType);\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\");\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytes(new BytesRef(groupDoc.group.utf8ToString()), valueType);\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n        s.close();\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d638301ad1cfcae567b681b893bc8781f0ee48a5","date":1323801546,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\");\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytes(new BytesRef(groupDoc.group.utf8ToString()), valueType);\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      ValueType valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      IndexDocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new IndexDocValuesField(\"group\");\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytes(new BytesRef(groupDoc.group.utf8ToString()), valueType);\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa0f44f887719e97183771e977cfc4bfb485b766","date":1326668713,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\");\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\");\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytes(new BytesRef(groupDoc.group.utf8ToString()), valueType);\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["4e622d1d7e4496e3a8c1709c84e5be91ced69889","4739c84c362b9673ab5ed3e038ff760c718c30c8","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"bugIntro":["a78a90fc9701e511308346ea29f4f5e548bb39fe","cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2dd6ecb8250c497ed227653279d6a4f470bfbb31","date":1326814483,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowMultiReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(r, \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7528ec8c6e88061e2e6af98c4ae1f72a30f180b2","date":1327854270,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        // nocommit FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowMultiReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8cd232a36e691d3af7035460733f822fb1a5239a","date":1327962711,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        // TODO: FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        // nocommit FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        // TODO: FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final IndexReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowMultiReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowMultiReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fa38e5ecc85303dce7ded93b3cc9a48b3d546d9","date":1327969999,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        // TODO: FieldCache.DEFAULT.purge(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["9274621789ce990dbfef455dabdf026bb3184821"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a78a90fc9701e511308346ea29f4f5e548bb39fe","date":1329489995,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericField id = new NumericField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setValue(groupDoc.sort1.utf8ToString());\n        sort2.setValue(groupDoc.sort2.utf8ToString());\n        sort3.setValue(groupDoc.sort3.utf8ToString());\n        content.setValue(groupDoc.content);\n        id.setValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["fa0f44f887719e97183771e977cfc4bfb485b766","4e622d1d7e4496e3a8c1709c84e5be91ced69889"],"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"200be48c182b79811a4fed24fd2d2ad852f092cb","date":1331204120,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random, 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random, 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random);\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random, 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random.nextInt(3)).append(' ');\n        final int fakeCount = random.nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random)));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random.nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random.nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random.nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random.nextInt(groups.size())),\n            groups.get(random.nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random.nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random.nextInt(3);\n          boolean sortByScoreOnly = random.nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["9274621789ce990dbfef455dabdf026bb3184821","d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["a78a90fc9701e511308346ea29f4f5e548bb39fe","200be48c182b79811a4fed24fd2d2ad852f092cb"],"8fa38e5ecc85303dce7ded93b3cc9a48b3d546d9":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"4739c84c362b9673ab5ed3e038ff760c718c30c8":["382fe3a6ca9745891afebda9b9a57cc158305545"],"8cd232a36e691d3af7035460733f822fb1a5239a":["7528ec8c6e88061e2e6af98c4ae1f72a30f180b2"],"382fe3a6ca9745891afebda9b9a57cc158305545":["8b48c85d1bf438ef65fbc1abe44f4e2c04a43e00"],"8b48c85d1bf438ef65fbc1abe44f4e2c04a43e00":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2dd6ecb8250c497ed227653279d6a4f470bfbb31":["fa0f44f887719e97183771e977cfc4bfb485b766"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["2dd6ecb8250c497ed227653279d6a4f470bfbb31","8cd232a36e691d3af7035460733f822fb1a5239a"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["0e7c2454a6a8237bfd0e953f5b940838408c9055","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["8fa38e5ecc85303dce7ded93b3cc9a48b3d546d9"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"200be48c182b79811a4fed24fd2d2ad852f092cb":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"7528ec8c6e88061e2e6af98c4ae1f72a30f180b2":["2dd6ecb8250c497ed227653279d6a4f470bfbb31"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["4739c84c362b9673ab5ed3e038ff760c718c30c8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["4739c84c362b9673ab5ed3e038ff760c718c30c8"],"fa0f44f887719e97183771e977cfc4bfb485b766":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["200be48c182b79811a4fed24fd2d2ad852f092cb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"8fa38e5ecc85303dce7ded93b3cc9a48b3d546d9":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"4739c84c362b9673ab5ed3e038ff760c718c30c8":["0e7c2454a6a8237bfd0e953f5b940838408c9055","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"8cd232a36e691d3af7035460733f822fb1a5239a":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"382fe3a6ca9745891afebda9b9a57cc158305545":["4739c84c362b9673ab5ed3e038ff760c718c30c8"],"8b48c85d1bf438ef65fbc1abe44f4e2c04a43e00":["382fe3a6ca9745891afebda9b9a57cc158305545"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["8fa38e5ecc85303dce7ded93b3cc9a48b3d546d9"],"2dd6ecb8250c497ed227653279d6a4f470bfbb31":["5cab9a86bd67202d20b6adc463008c8e982b070a","7528ec8c6e88061e2e6af98c4ae1f72a30f180b2"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["fa0f44f887719e97183771e977cfc4bfb485b766"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["38e3b736c7ca086d61b7dbb841c905ee115490da","200be48c182b79811a4fed24fd2d2ad852f092cb"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"200be48c182b79811a4fed24fd2d2ad852f092cb":["38e3b736c7ca086d61b7dbb841c905ee115490da","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"7528ec8c6e88061e2e6af98c4ae1f72a30f180b2":["8cd232a36e691d3af7035460733f822fb1a5239a"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","d638301ad1cfcae567b681b893bc8781f0ee48a5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8b48c85d1bf438ef65fbc1abe44f4e2c04a43e00"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"fa0f44f887719e97183771e977cfc4bfb485b766":["2dd6ecb8250c497ed227653279d6a4f470bfbb31"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}