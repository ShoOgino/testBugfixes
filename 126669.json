{"path":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","sourceNew":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      writer.addDocument(lineFileDocs.nextDoc());\n    }\n  }\n\n","sourceOld":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      writer.addDocument(lineFileDocs.nextDoc());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6550af40a4977993323e8fd3b3222a2402084800","date":1334548895,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","sourceNew":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      writer.addDocument(lineFileDocs.nextDoc());\n    }\n    \n    lineFileDocs.close();\n  }\n\n","sourceOld":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      writer.addDocument(lineFileDocs.nextDoc());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eaa9cc5fd5ad1b5f7be93da05bdbd3ccf4be4bb3","date":1361060670,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","sourceNew":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","sourceOld":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      writer.addDocument(lineFileDocs.nextDoc());\n    }\n    \n    lineFileDocs.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddbb72a33557d2b5bc22ee95daf3281c43560502","date":1361334582,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","sourceNew":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","sourceOld":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      writer.addDocument(lineFileDocs.nextDoc());\n    }\n    \n    lineFileDocs.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c34fec2bc086f82b8ffc8374cf54d0013f94804a","date":1377017456,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","sourceNew":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      // add a numeric dv field sometimes\n      document.removeFields(\"sparsenumeric\");\n      if (random.nextInt(4) == 2) {\n        document.add(new NumericDocValuesField(\"sparsenumeric\", random.nextInt()));\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","sourceOld":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","date":1377034255,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","sourceNew":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      // add a numeric dv field sometimes\n      document.removeFields(\"sparsenumeric\");\n      if (random.nextInt(4) == 2) {\n        document.add(new NumericDocValuesField(\"sparsenumeric\", random.nextInt()));\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","sourceOld":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","sourceNew":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      // add a numeric dv field sometimes\n      document.removeFields(\"sparsenumeric\");\n      if (random.nextInt(4) == 2) {\n        document.add(new NumericDocValuesField(\"sparsenumeric\", random.nextInt()));\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","sourceOld":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d14ffaac9c4a4a2c750bf0cd956506802561e062","date":1402602036,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","sourceNew":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      // add a numeric dv field sometimes\n      document.removeFields(\"sparsenumeric\");\n      if (random.nextInt(4) == 2) {\n        document.add(new NumericDocValuesField(\"sparsenumeric\", random.nextInt()));\n      }\n      // add sortednumeric sometimes\n      document.removeFields(\"sparsesortednum\");\n      if (random.nextInt(5) == 1) {\n        document.add(new SortedNumericDocValuesField(\"sparsesortednum\", random.nextLong()));\n        if (random.nextBoolean()) {\n          document.add(new SortedNumericDocValuesField(\"sparsesortednum\", random.nextLong()));\n        }\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","sourceOld":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      // add a numeric dv field sometimes\n      document.removeFields(\"sparsenumeric\");\n      if (random.nextInt(4) == 2) {\n        document.add(new NumericDocValuesField(\"sparsenumeric\", random.nextInt()));\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","sourceNew":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      // add a numeric dv field sometimes\n      document.removeFields(\"sparsenumeric\");\n      if (random.nextInt(4) == 2) {\n        document.add(new NumericDocValuesField(\"sparsenumeric\", random.nextInt()));\n      }\n      // add sortednumeric sometimes\n      document.removeFields(\"sparsesortednum\");\n      if (random.nextInt(5) == 1) {\n        document.add(new SortedNumericDocValuesField(\"sparsesortednum\", random.nextLong()));\n        if (random.nextBoolean()) {\n          document.add(new SortedNumericDocValuesField(\"sparsesortednum\", random.nextLong()));\n        }\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","sourceOld":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      // add a numeric dv field sometimes\n      document.removeFields(\"sparsenumeric\");\n      if (random.nextInt(4) == 2) {\n        document.add(new NumericDocValuesField(\"sparsenumeric\", random.nextInt()));\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","sourceNew":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, it's realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      // add a numeric dv field sometimes\n      document.removeFields(\"sparsenumeric\");\n      if (random.nextInt(4) == 2) {\n        document.add(new NumericDocValuesField(\"sparsenumeric\", random.nextInt()));\n      }\n      // add sortednumeric sometimes\n      document.removeFields(\"sparsesortednum\");\n      if (random.nextInt(5) == 1) {\n        document.add(new SortedNumericDocValuesField(\"sparsesortednum\", random.nextLong()));\n        if (random.nextBoolean()) {\n          document.add(new SortedNumericDocValuesField(\"sparsesortednum\", random.nextLong()));\n        }\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","sourceOld":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, its realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      // add a numeric dv field sometimes\n      document.removeFields(\"sparsenumeric\");\n      if (random.nextInt(4) == 2) {\n        document.add(new NumericDocValuesField(\"sparsenumeric\", random.nextInt()));\n      }\n      // add sortednumeric sometimes\n      document.removeFields(\"sparsesortednum\");\n      if (random.nextInt(5) == 1) {\n        document.add(new SortedNumericDocValuesField(\"sparsesortednum\", random.nextLong()));\n        if (random.nextBoolean()) {\n          document.add(new SortedNumericDocValuesField(\"sparsesortednum\", random.nextLong()));\n        }\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7a30000e3a8231d6c9558062b7a9c6eab393aa0","date":1422117664,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs#createRandomIndex(int,RandomIndexWriter,long).mjava","sourceNew":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, it's realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      document.removeFields(\"sortedset\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      // add a numeric dv field sometimes\n      document.removeFields(\"sparsenumeric\");\n      if (random.nextInt(4) == 2) {\n        document.add(new NumericDocValuesField(\"sparsenumeric\", random.nextInt()));\n      }\n      // add sortednumeric sometimes\n      document.removeFields(\"sparsesortednum\");\n      if (random.nextInt(5) == 1) {\n        document.add(new SortedNumericDocValuesField(\"sparsesortednum\", random.nextLong()));\n        if (random.nextBoolean()) {\n          document.add(new SortedNumericDocValuesField(\"sparsesortednum\", random.nextLong()));\n        }\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","sourceOld":"  /**\n   * populates a writer with random stuff. this must be fully reproducable with the seed!\n   */\n  public static void createRandomIndex(int numdocs, RandomIndexWriter writer, long seed) throws IOException {\n    Random random = new Random(seed);\n    // primary source for our data is from linefiledocs, it's realistic.\n    LineFileDocs lineFileDocs = new LineFileDocs(random);\n\n    // TODO: we should add other fields that use things like docs&freqs but omit positions,\n    // because linefiledocs doesn't cover all the possibilities.\n    for (int i = 0; i < numdocs; i++) {\n      Document document = lineFileDocs.nextDoc();\n      // grab the title and add some SortedSet instances for fun\n      String title = document.get(\"titleTokenized\");\n      String split[] = title.split(\"\\\\s+\");\n      for (String trash : split) {\n        document.add(new SortedSetDocValuesField(\"sortedset\", new BytesRef(trash)));\n      }\n      // add a numeric dv field sometimes\n      document.removeFields(\"sparsenumeric\");\n      if (random.nextInt(4) == 2) {\n        document.add(new NumericDocValuesField(\"sparsenumeric\", random.nextInt()));\n      }\n      // add sortednumeric sometimes\n      document.removeFields(\"sparsesortednum\");\n      if (random.nextInt(5) == 1) {\n        document.add(new SortedNumericDocValuesField(\"sparsesortednum\", random.nextLong()));\n        if (random.nextBoolean()) {\n          document.add(new SortedNumericDocValuesField(\"sparsesortednum\", random.nextLong()));\n        }\n      }\n      writer.addDocument(document);\n    }\n    \n    lineFileDocs.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["ddbb72a33557d2b5bc22ee95daf3281c43560502","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"6550af40a4977993323e8fd3b3222a2402084800":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"c34fec2bc086f82b8ffc8374cf54d0013f94804a":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["ddbb72a33557d2b5bc22ee95daf3281c43560502","c34fec2bc086f82b8ffc8374cf54d0013f94804a"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["6550af40a4977993323e8fd3b3222a2402084800","eaa9cc5fd5ad1b5f7be93da05bdbd3ccf4be4bb3"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","d14ffaac9c4a4a2c750bf0cd956506802561e062"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["d14ffaac9c4a4a2c750bf0cd956506802561e062"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c7a30000e3a8231d6c9558062b7a9c6eab393aa0":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"eaa9cc5fd5ad1b5f7be93da05bdbd3ccf4be4bb3":["6550af40a4977993323e8fd3b3222a2402084800"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c7a30000e3a8231d6c9558062b7a9c6eab393aa0"],"d14ffaac9c4a4a2c750bf0cd956506802561e062":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["6550af40a4977993323e8fd3b3222a2402084800"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"6550af40a4977993323e8fd3b3222a2402084800":["ddbb72a33557d2b5bc22ee95daf3281c43560502","eaa9cc5fd5ad1b5f7be93da05bdbd3ccf4be4bb3"],"c34fec2bc086f82b8ffc8374cf54d0013f94804a":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","c6f080a2ab37c464dd98db173f6cbf10dc74f211","d14ffaac9c4a4a2c750bf0cd956506802561e062"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","c34fec2bc086f82b8ffc8374cf54d0013f94804a","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["c7a30000e3a8231d6c9558062b7a9c6eab393aa0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"c7a30000e3a8231d6c9558062b7a9c6eab393aa0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"eaa9cc5fd5ad1b5f7be93da05bdbd3ccf4be4bb3":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"d14ffaac9c4a4a2c750bf0cd956506802561e062":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","c6f080a2ab37c464dd98db173f6cbf10dc74f211","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}