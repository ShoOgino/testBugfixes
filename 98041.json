{"path":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/NumericDocValuesFieldSource#getValues(Map,AtomicReaderContext).mjava","commits":[{"id":"6cce7e17930f156b7456ee7fc32f691979f641e2","date":1349444322,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/NumericDocValuesFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public FunctionValues getValues(@SuppressWarnings(\"rawtypes\") Map context, AtomicReaderContext readerContext) throws IOException {\n    final DocValues.Source source = getSource(readerContext.reader(), DocValues.Type.FLOAT_64);\n    final Bits liveDocs = readerContext.reader().getLiveDocs();\n    switch (source.getType()) {\n      case FIXED_INTS_8:\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS:\n        if (source.hasArray()) {\n          final Object valuesArr = source.getArray();\n          if (valuesArr instanceof long[]) {\n            final long[] values = (long[]) source.getArray();\n            return new DVLongValues(this, source, liveDocs) {\n\n              @Override\n              public long longVal(int doc) {\n                return values[doc];\n              }\n\n            };\n          } else if (valuesArr instanceof int[]) {\n            final int[] values = (int[]) source.getArray();\n            return new DVIntValues(this, source, liveDocs) {\n\n              @Override\n              public int intVal(int doc) {\n                return values[doc];\n              }\n\n            };\n          } else if (valuesArr instanceof short[]) {\n            final short[] values = (short[]) source.getArray();\n            return new DVIntValues(this, source, liveDocs) {\n\n              @Override\n              public int intVal(int doc) {\n                return values[doc];\n              }\n\n              @Override\n              public Object objectVal(int doc) {\n                return shortVal(doc);\n              }\n\n            };\n          } else if (valuesArr instanceof byte[]) {\n            final byte[] values = (byte[]) source.getArray();\n            return new DVIntValues(this, source, liveDocs) {\n\n              @Override\n              public int intVal(int doc) {\n                return values[doc];\n              }\n\n              @Override\n              public Object objectVal(int doc) {\n                return byteVal(doc);\n              }\n\n            };\n          }\n        }\n        return new DVLongValues(this, source, liveDocs) {\n\n          @Override\n          public Object objectVal(int doc) {\n            switch (source.getType()) {\n              case FIXED_INTS_8:\n                return byteVal(doc);\n              case FIXED_INTS_16:\n                return shortVal(doc);\n              case FIXED_INTS_32:\n                return intVal(doc);\n              case FIXED_INTS_64:\n              case VAR_INTS:\n                return longVal(doc);\n              default:\n                throw new AssertionError();\n            }\n          }\n\n        };\n      case FLOAT_32:\n      case FLOAT_64:\n        if (source.hasArray()) {\n          final Object valuesArr = source.getArray();\n          if (valuesArr instanceof float[]) {\n            final float[] values = (float[]) valuesArr;\n            return new FloatDocValues(this) {\n\n              @Override\n              public boolean exists(int doc) {\n                return liveDocs == null || liveDocs.get(doc);\n              }\n\n              @Override\n              public boolean bytesVal(int doc, BytesRef target) {\n                source.getBytes(doc, target);\n                return true;\n              }\n\n              @Override\n              public float floatVal(int doc) {\n                return values[doc];\n              }\n\n            };\n          } else if (valuesArr instanceof double[]) {\n            final double[] values = (double[]) valuesArr;\n            return new DVDoubleValues(this, source, liveDocs) {\n\n              @Override\n              public double doubleVal(int doc) {\n                return values[doc];\n              }\n\n            };\n          }\n        }\n        return new DVDoubleValues(this, source, liveDocs) {\n\n          @Override\n          public Object objectVal(int doc) {\n            switch (source.getType()) {\n              case FLOAT_32:\n                return floatVal(doc);\n              case FLOAT_64:\n                return doubleVal(doc);\n              default:\n                throw new AssertionError();\n            }\n          }\n\n        };\n      default:\n        throw new IllegalStateException(getClass().getSimpleName() + \" only works with numeric types, not \" + source.getType());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0837ab0472feecb3a54260729d845f839e1cbd72","date":1358283639,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/NumericDocValuesFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":null,"sourceOld":"  @Override\n  public FunctionValues getValues(@SuppressWarnings(\"rawtypes\") Map context, AtomicReaderContext readerContext) throws IOException {\n    final DocValues.Source source = getSource(readerContext.reader(), DocValues.Type.FLOAT_64);\n    final Bits liveDocs = readerContext.reader().getLiveDocs();\n    switch (source.getType()) {\n      case FIXED_INTS_8:\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS:\n        if (source.hasArray()) {\n          final Object valuesArr = source.getArray();\n          if (valuesArr instanceof long[]) {\n            final long[] values = (long[]) source.getArray();\n            return new DVLongValues(this, source, liveDocs) {\n\n              @Override\n              public long longVal(int doc) {\n                return values[doc];\n              }\n\n            };\n          } else if (valuesArr instanceof int[]) {\n            final int[] values = (int[]) source.getArray();\n            return new DVIntValues(this, source, liveDocs) {\n\n              @Override\n              public int intVal(int doc) {\n                return values[doc];\n              }\n\n            };\n          } else if (valuesArr instanceof short[]) {\n            final short[] values = (short[]) source.getArray();\n            return new DVIntValues(this, source, liveDocs) {\n\n              @Override\n              public int intVal(int doc) {\n                return values[doc];\n              }\n\n              @Override\n              public Object objectVal(int doc) {\n                return shortVal(doc);\n              }\n\n            };\n          } else if (valuesArr instanceof byte[]) {\n            final byte[] values = (byte[]) source.getArray();\n            return new DVIntValues(this, source, liveDocs) {\n\n              @Override\n              public int intVal(int doc) {\n                return values[doc];\n              }\n\n              @Override\n              public Object objectVal(int doc) {\n                return byteVal(doc);\n              }\n\n            };\n          }\n        }\n        return new DVLongValues(this, source, liveDocs) {\n\n          @Override\n          public Object objectVal(int doc) {\n            switch (source.getType()) {\n              case FIXED_INTS_8:\n                return byteVal(doc);\n              case FIXED_INTS_16:\n                return shortVal(doc);\n              case FIXED_INTS_32:\n                return intVal(doc);\n              case FIXED_INTS_64:\n              case VAR_INTS:\n                return longVal(doc);\n              default:\n                throw new AssertionError();\n            }\n          }\n\n        };\n      case FLOAT_32:\n      case FLOAT_64:\n        if (source.hasArray()) {\n          final Object valuesArr = source.getArray();\n          if (valuesArr instanceof float[]) {\n            final float[] values = (float[]) valuesArr;\n            return new FloatDocValues(this) {\n\n              @Override\n              public boolean exists(int doc) {\n                return liveDocs == null || liveDocs.get(doc);\n              }\n\n              @Override\n              public boolean bytesVal(int doc, BytesRef target) {\n                source.getBytes(doc, target);\n                return true;\n              }\n\n              @Override\n              public float floatVal(int doc) {\n                return values[doc];\n              }\n\n            };\n          } else if (valuesArr instanceof double[]) {\n            final double[] values = (double[]) valuesArr;\n            return new DVDoubleValues(this, source, liveDocs) {\n\n              @Override\n              public double doubleVal(int doc) {\n                return values[doc];\n              }\n\n            };\n          }\n        }\n        return new DVDoubleValues(this, source, liveDocs) {\n\n          @Override\n          public Object objectVal(int doc) {\n            switch (source.getType()) {\n              case FLOAT_32:\n                return floatVal(doc);\n              case FLOAT_64:\n                return doubleVal(doc);\n              default:\n                throw new AssertionError();\n            }\n          }\n\n        };\n      default:\n        throw new IllegalStateException(getClass().getSimpleName() + \" only works with numeric types, not \" + source.getType());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/NumericDocValuesFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":null,"sourceOld":"  @Override\n  public FunctionValues getValues(@SuppressWarnings(\"rawtypes\") Map context, AtomicReaderContext readerContext) throws IOException {\n    final DocValues.Source source = getSource(readerContext.reader(), DocValues.Type.FLOAT_64);\n    final Bits liveDocs = readerContext.reader().getLiveDocs();\n    switch (source.getType()) {\n      case FIXED_INTS_8:\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS:\n        if (source.hasArray()) {\n          final Object valuesArr = source.getArray();\n          if (valuesArr instanceof long[]) {\n            final long[] values = (long[]) source.getArray();\n            return new DVLongValues(this, source, liveDocs) {\n\n              @Override\n              public long longVal(int doc) {\n                return values[doc];\n              }\n\n            };\n          } else if (valuesArr instanceof int[]) {\n            final int[] values = (int[]) source.getArray();\n            return new DVIntValues(this, source, liveDocs) {\n\n              @Override\n              public int intVal(int doc) {\n                return values[doc];\n              }\n\n            };\n          } else if (valuesArr instanceof short[]) {\n            final short[] values = (short[]) source.getArray();\n            return new DVIntValues(this, source, liveDocs) {\n\n              @Override\n              public int intVal(int doc) {\n                return values[doc];\n              }\n\n              @Override\n              public Object objectVal(int doc) {\n                return shortVal(doc);\n              }\n\n            };\n          } else if (valuesArr instanceof byte[]) {\n            final byte[] values = (byte[]) source.getArray();\n            return new DVIntValues(this, source, liveDocs) {\n\n              @Override\n              public int intVal(int doc) {\n                return values[doc];\n              }\n\n              @Override\n              public Object objectVal(int doc) {\n                return byteVal(doc);\n              }\n\n            };\n          }\n        }\n        return new DVLongValues(this, source, liveDocs) {\n\n          @Override\n          public Object objectVal(int doc) {\n            switch (source.getType()) {\n              case FIXED_INTS_8:\n                return byteVal(doc);\n              case FIXED_INTS_16:\n                return shortVal(doc);\n              case FIXED_INTS_32:\n                return intVal(doc);\n              case FIXED_INTS_64:\n              case VAR_INTS:\n                return longVal(doc);\n              default:\n                throw new AssertionError();\n            }\n          }\n\n        };\n      case FLOAT_32:\n      case FLOAT_64:\n        if (source.hasArray()) {\n          final Object valuesArr = source.getArray();\n          if (valuesArr instanceof float[]) {\n            final float[] values = (float[]) valuesArr;\n            return new FloatDocValues(this) {\n\n              @Override\n              public boolean exists(int doc) {\n                return liveDocs == null || liveDocs.get(doc);\n              }\n\n              @Override\n              public boolean bytesVal(int doc, BytesRef target) {\n                source.getBytes(doc, target);\n                return true;\n              }\n\n              @Override\n              public float floatVal(int doc) {\n                return values[doc];\n              }\n\n            };\n          } else if (valuesArr instanceof double[]) {\n            final double[] values = (double[]) valuesArr;\n            return new DVDoubleValues(this, source, liveDocs) {\n\n              @Override\n              public double doubleVal(int doc) {\n                return values[doc];\n              }\n\n            };\n          }\n        }\n        return new DVDoubleValues(this, source, liveDocs) {\n\n          @Override\n          public Object objectVal(int doc) {\n            switch (source.getType()) {\n              case FLOAT_32:\n                return floatVal(doc);\n              case FLOAT_64:\n                return doubleVal(doc);\n              default:\n                throw new AssertionError();\n            }\n          }\n\n        };\n      default:\n        throw new IllegalStateException(getClass().getSimpleName() + \" only works with numeric types, not \" + source.getType());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d4d69c535930b5cce125cff868d40f6373dc27d4":["6cce7e17930f156b7456ee7fc32f691979f641e2","0837ab0472feecb3a54260729d845f839e1cbd72"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0837ab0472feecb3a54260729d845f839e1cbd72":["6cce7e17930f156b7456ee7fc32f691979f641e2"],"6cce7e17930f156b7456ee7fc32f691979f641e2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4d69c535930b5cce125cff868d40f6373dc27d4"]},"commit2Childs":{"d4d69c535930b5cce125cff868d40f6373dc27d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6cce7e17930f156b7456ee7fc32f691979f641e2"],"0837ab0472feecb3a54260729d845f839e1cbd72":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"6cce7e17930f156b7456ee7fc32f691979f641e2":["d4d69c535930b5cce125cff868d40f6373dc27d4","0837ab0472feecb3a54260729d845f839e1cbd72"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}