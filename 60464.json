{"path":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","commits":[{"id":"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe","date":1430750405,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","pathOld":"/dev/null","sourceNew":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Set<String>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.liveNodes);\n    Collections.sort(sortedLiveNodes, new Comparator<String>() {\n      @Override\n      public int compare(String n1, String n2) {\n        int result = 0;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n          if (val != 0) {//atleast one non-zero compare break now\n            result = val;\n            break;\n          }\n          if (result == 0) {//if all else is equal, prefer nodes with fewer cores\n            AtomicInteger n1Count = nodeVsCores.get(n1);\n            AtomicInteger n2Count = nodeVsCores.get(n2);\n            int a = n1Count == null ? 0 : n1Count.get();\n            int b = n2Count == null ? 0 : n2Count.get();\n            result = a > b ? 1 : a == b ? 0 : -1;\n          }\n\n        }\n        return result;\n      }\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Set<String> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashSet<>());\n        nodeNames.add(liveNode);\n        Number coreCount = (Number) nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132","c5db0d2513e9e40fad9ff93dd0b4777040e16b53"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec4fc24ecd353171e03bd016c1681cd97476015f","date":1432214672,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.liveNodes);\n    Collections.sort(sortedLiveNodes, new Comparator<String>() {\n      @Override\n      public int compare(String n1, String n2) {\n        int result = 0;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n          if (val != 0) {//atleast one non-zero compare break now\n            result = val;\n            break;\n          }\n          if (result == 0) {//if all else is equal, prefer nodes with fewer cores\n            AtomicInteger n1Count = nodeVsCores.get(n1);\n            AtomicInteger n2Count = nodeVsCores.get(n2);\n            int a = n1Count == null ? 0 : n1Count.get();\n            int b = n2Count == null ? 0 : n2Count.get();\n            result = a > b ? 1 : a == b ? 0 : -1;\n          }\n\n        }\n        return result;\n      }\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Number coreCount = (Number) nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Set<String>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.liveNodes);\n    Collections.sort(sortedLiveNodes, new Comparator<String>() {\n      @Override\n      public int compare(String n1, String n2) {\n        int result = 0;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n          if (val != 0) {//atleast one non-zero compare break now\n            result = val;\n            break;\n          }\n          if (result == 0) {//if all else is equal, prefer nodes with fewer cores\n            AtomicInteger n1Count = nodeVsCores.get(n1);\n            AtomicInteger n2Count = nodeVsCores.get(n2);\n            int a = n1Count == null ? 0 : n1Count.get();\n            int b = n2Count == null ? 0 : n2Count.get();\n            result = a > b ? 1 : a == b ? 0 : -1;\n          }\n\n        }\n        return result;\n      }\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Set<String> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashSet<>());\n        nodeNames.add(liveNode);\n        Number coreCount = (Number) nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5db0d2513e9e40fad9ff93dd0b4777040e16b53","date":1456809587,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.liveNodes);\n    Collections.sort(sortedLiveNodes, new Comparator<String>() {\n      @Override\n      public int compare(String n1, String n2) {\n        int result = 0;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n          if (val != 0) {//atleast one non-zero compare break now\n            result = val;\n            break;\n          }\n          if (result == 0) {//if all else is equal, prefer nodes with fewer cores\n            AtomicInteger n1Count = nodeVsCores.get(n1);\n            AtomicInteger n2Count = nodeVsCores.get(n2);\n            int a = n1Count == null ? 0 : n1Count.get();\n            int b = n2Count == null ? 0 : n2Count.get();\n            result = a > b ? 1 : a == b ? 0 : -1;\n          }\n\n        }\n        return result;\n      }\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Number coreCount = (Number) nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.liveNodes);\n    Collections.sort(sortedLiveNodes, new Comparator<String>() {\n      @Override\n      public int compare(String n1, String n2) {\n        int result = 0;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n          if (val != 0) {//atleast one non-zero compare break now\n            result = val;\n            break;\n          }\n          if (result == 0) {//if all else is equal, prefer nodes with fewer cores\n            AtomicInteger n1Count = nodeVsCores.get(n1);\n            AtomicInteger n2Count = nodeVsCores.get(n2);\n            int a = n1Count == null ? 0 : n1Count.get();\n            int b = n2Count == null ? 0 : n2Count.get();\n            result = a > b ? 1 : a == b ? 0 : -1;\n          }\n\n        }\n        return result;\n      }\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Number coreCount = (Number) nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aac86f15785e5e3d9ad34bb348173b9ef1bfddca","date":1456826501,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.liveNodes);\n    Collections.sort(sortedLiveNodes, new Comparator<String>() {\n      @Override\n      public int compare(String n1, String n2) {\n        int result = 0;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n          if (val != 0) {//atleast one non-zero compare break now\n            result = val;\n            break;\n          }\n          if (result == 0) {//if all else is equal, prefer nodes with fewer cores\n            AtomicInteger n1Count = nodeVsCores.get(n1);\n            AtomicInteger n2Count = nodeVsCores.get(n2);\n            int a = n1Count == null ? 0 : n1Count.get();\n            int b = n2Count == null ? 0 : n2Count.get();\n            result = a > b ? 1 : a == b ? 0 : -1;\n          }\n\n        }\n        return result;\n      }\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Number coreCount = (Number) nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.liveNodes);\n    Collections.sort(sortedLiveNodes, new Comparator<String>() {\n      @Override\n      public int compare(String n1, String n2) {\n        int result = 0;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n          if (val != 0) {//atleast one non-zero compare break now\n            result = val;\n            break;\n          }\n          if (result == 0) {//if all else is equal, prefer nodes with fewer cores\n            AtomicInteger n1Count = nodeVsCores.get(n1);\n            AtomicInteger n2Count = nodeVsCores.get(n2);\n            int a = n1Count == null ? 0 : n1Count.get();\n            int b = n2Count == null ? 0 : n2Count.get();\n            result = a > b ? 1 : a == b ? 0 : -1;\n          }\n\n        }\n        return result;\n      }\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Number coreCount = (Number) nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132","date":1457088757,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, new Comparator<String>() {\n      @Override\n      public int compare(String n1, String n2) {\n        int result = 0;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n          if (val != 0) {//atleast one non-zero compare break now\n            result = val;\n            break;\n          }\n          if (result == 0) {//if all else is equal, prefer nodes with fewer cores\n            AtomicInteger n1Count = nodeVsCores.get(n1);\n            AtomicInteger n2Count = nodeVsCores.get(n2);\n            int a = n1Count == null ? 0 : n1Count.get();\n            int b = n2Count == null ? 0 : n2Count.get();\n            result = a > b ? 1 : a == b ? 0 : -1;\n          }\n\n        }\n        return result;\n      }\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Number coreCount = (Number) nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.liveNodes);\n    Collections.sort(sortedLiveNodes, new Comparator<String>() {\n      @Override\n      public int compare(String n1, String n2) {\n        int result = 0;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n          if (val != 0) {//atleast one non-zero compare break now\n            result = val;\n            break;\n          }\n          if (result == 0) {//if all else is equal, prefer nodes with fewer cores\n            AtomicInteger n1Count = nodeVsCores.get(n1);\n            AtomicInteger n2Count = nodeVsCores.get(n2);\n            int a = n1Count == null ? 0 : n1Count.get();\n            int b = n2Count == null ? 0 : n2Count.get();\n            result = a > b ? 1 : a == b ? 0 : -1;\n          }\n\n        }\n        return result;\n      }\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Number coreCount = (Number) nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (n1, n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Number coreCount = (Number) nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, new Comparator<String>() {\n      @Override\n      public int compare(String n1, String n2) {\n        int result = 0;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n          if (val != 0) {//atleast one non-zero compare break now\n            result = val;\n            break;\n          }\n          if (result == 0) {//if all else is equal, prefer nodes with fewer cores\n            AtomicInteger n1Count = nodeVsCores.get(n1);\n            AtomicInteger n2Count = nodeVsCores.get(n2);\n            int a = n1Count == null ? 0 : n1Count.get();\n            int b = n2Count == null ? 0 : n2Count.get();\n            result = a > b ? 1 : a == b ? 0 : -1;\n          }\n\n        }\n        return result;\n      }\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Number coreCount = (Number) nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e9db5fcef0c59566ad373ff7844f8a985f0017c","date":1467374856,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (n1, n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (n1, n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Number coreCount = (Number) nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (n1, n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (n1, n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Number coreCount = (Number) nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c0991cdd737429f93edd79c794430cfddd9bfc1","date":1496396358,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (String n1, String n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (n1, n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (String n1, String n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (n1, n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (String n1, String n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (n1, n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"969718c368b28ed1b2335ea2deb275c696cddb4f","date":1498803580,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[ReplicaPosition],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<ReplicaPosition, String> tryAPermutationOfRules(int[] rulePermutation, List<ReplicaPosition> replicaPositions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<ReplicaPosition, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (String n1, String n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (ReplicaPosition replicaPosition : replicaPositions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, replicaPosition.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(replicaPosition, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(replicaPosition.shard);\n        if (nodeNames == null) copyOfCurrentState.put(replicaPosition.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (replicaPositions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<ReplicaPosition, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (String n1, String n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d92226151c91fb4bebcca6d18782d1c84aee2cd","date":1498804792,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[ReplicaPosition],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<ReplicaPosition, String> tryAPermutationOfRules(int[] rulePermutation, List<ReplicaPosition> replicaPositions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<ReplicaPosition, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (String n1, String n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (ReplicaPosition replicaPosition : replicaPositions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, replicaPosition.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(replicaPosition, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(replicaPosition.shard);\n        if (nodeNames == null) copyOfCurrentState.put(replicaPosition.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (replicaPositions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<ReplicaPosition, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (String n1, String n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132":["c5db0d2513e9e40fad9ff93dd0b4777040e16b53"],"aac86f15785e5e3d9ad34bb348173b9ef1bfddca":["ec4fc24ecd353171e03bd016c1681cd97476015f","c5db0d2513e9e40fad9ff93dd0b4777040e16b53"],"0c0991cdd737429f93edd79c794430cfddd9bfc1":["2e9db5fcef0c59566ad373ff7844f8a985f0017c"],"ec4fc24ecd353171e03bd016c1681cd97476015f":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2e9db5fcef0c59566ad373ff7844f8a985f0017c":["3a0c04b71951333291abc7f317109a6a5957bd28"],"3a0c04b71951333291abc7f317109a6a5957bd28":["5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132"],"28288370235ed02234a64753cdbf0c6ec096304a":["2e9db5fcef0c59566ad373ff7844f8a985f0017c","0c0991cdd737429f93edd79c794430cfddd9bfc1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3a0c04b71951333291abc7f317109a6a5957bd28","2e9db5fcef0c59566ad373ff7844f8a985f0017c"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["2e9db5fcef0c59566ad373ff7844f8a985f0017c","0c0991cdd737429f93edd79c794430cfddd9bfc1"],"969718c368b28ed1b2335ea2deb275c696cddb4f":["28288370235ed02234a64753cdbf0c6ec096304a"],"0d92226151c91fb4bebcca6d18782d1c84aee2cd":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c5db0d2513e9e40fad9ff93dd0b4777040e16b53":["ec4fc24ecd353171e03bd016c1681cd97476015f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["969718c368b28ed1b2335ea2deb275c696cddb4f"]},"commit2Childs":{"5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132":["3a0c04b71951333291abc7f317109a6a5957bd28"],"aac86f15785e5e3d9ad34bb348173b9ef1bfddca":[],"0c0991cdd737429f93edd79c794430cfddd9bfc1":["28288370235ed02234a64753cdbf0c6ec096304a","e9017cf144952056066919f1ebc7897ff9bd71b1"],"ec4fc24ecd353171e03bd016c1681cd97476015f":["aac86f15785e5e3d9ad34bb348173b9ef1bfddca","c5db0d2513e9e40fad9ff93dd0b4777040e16b53"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["ec4fc24ecd353171e03bd016c1681cd97476015f"],"2e9db5fcef0c59566ad373ff7844f8a985f0017c":["0c0991cdd737429f93edd79c794430cfddd9bfc1","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9017cf144952056066919f1ebc7897ff9bd71b1"],"3a0c04b71951333291abc7f317109a6a5957bd28":["2e9db5fcef0c59566ad373ff7844f8a985f0017c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"28288370235ed02234a64753cdbf0c6ec096304a":["969718c368b28ed1b2335ea2deb275c696cddb4f"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"e9017cf144952056066919f1ebc7897ff9bd71b1":["0d92226151c91fb4bebcca6d18782d1c84aee2cd"],"969718c368b28ed1b2335ea2deb275c696cddb4f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0d92226151c91fb4bebcca6d18782d1c84aee2cd":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"c5db0d2513e9e40fad9ff93dd0b4777040e16b53":["5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132","aac86f15785e5e3d9ad34bb348173b9ef1bfddca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aac86f15785e5e3d9ad34bb348173b9ef1bfddca","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0d92226151c91fb4bebcca6d18782d1c84aee2cd","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}