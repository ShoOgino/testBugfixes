{"path":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","commits":[{"id":"83bbb041887bbef07b8a98d08a0e1713ce137039","date":1200330381,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","pathOld":"/dev/null","sourceNew":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || aborting;\n\n    try {\n\n      if (infoStream != null)\n        infoStream.println(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        bufferedDeleteTerms.clear();\n        bufferedDeleteDocIDs.clear();\n        numBufferedDeleteTerms = 0;\n\n        abortedFiles = files();\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null) {\n              n.out.reset();\n              n.reset();\n            }\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (IOException ioe) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (IOException ioe) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (IOException ioe) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (IOException ioe) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          ThreadState state = threadStates[i];\n          if (state.localFieldsWriter != null) {\n            state.localFieldsWriter.close();\n            state.localFieldsWriter = null;\n          }\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n        docStoreSegment = null;\n        files = null;\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["176324efd1eab6bd44a6d81c27c9b3a1a175ba3d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1fd1f3c5c06036aebe90bc6da756a37d03f63884","date":1200847858,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","sourceNew":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || aborting;\n\n    try {\n\n      if (infoStream != null)\n        infoStream.println(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        bufferedDeleteTerms.clear();\n        bufferedDeleteDocIDs.clear();\n        numBufferedDeleteTerms = 0;\n\n        abortedFiles = files();\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null) {\n              n.out.reset();\n              n.reset();\n            }\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (IOException ioe) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (IOException ioe) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (IOException ioe) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (IOException ioe) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          ThreadState state = threadStates[i];\n          if (state.localFieldsWriter != null) {\n            state.localFieldsWriter.close();\n            state.localFieldsWriter = null;\n          }\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || aborting;\n\n    try {\n\n      if (infoStream != null)\n        infoStream.println(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        bufferedDeleteTerms.clear();\n        bufferedDeleteDocIDs.clear();\n        numBufferedDeleteTerms = 0;\n\n        abortedFiles = files();\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null) {\n              n.out.reset();\n              n.reset();\n            }\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (IOException ioe) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (IOException ioe) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (IOException ioe) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (IOException ioe) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          ThreadState state = threadStates[i];\n          if (state.localFieldsWriter != null) {\n            state.localFieldsWriter.close();\n            state.localFieldsWriter = null;\n          }\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n        docStoreSegment = null;\n        files = null;\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":["176324efd1eab6bd44a6d81c27c9b3a1a175ba3d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"176324efd1eab6bd44a6d81c27c9b3a1a175ba3d","date":1202734547,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","sourceNew":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || abortCount>0;\n\n    try {\n\n      if (infoStream != null)\n        infoStream.println(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        bufferedDeleteTerms.clear();\n        bufferedDeleteDocIDs.clear();\n        numBufferedDeleteTerms = 0;\n\n        try {\n          abortedFiles = files();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          ThreadState state = threadStates[i];\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n          if (state.localFieldsWriter != null) {\n            try {\n              state.localFieldsWriter.close();\n            } catch (Throwable t) {\n            }\n            state.localFieldsWriter = null;\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (Throwable t) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (Throwable t) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (Throwable t) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (Throwable t) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null)\n              try {\n                n.reset();\n              } catch (Throwable t) {\n              }\n          }\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      abortCount--;\n      notifyAll();\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || aborting;\n\n    try {\n\n      if (infoStream != null)\n        infoStream.println(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        bufferedDeleteTerms.clear();\n        bufferedDeleteDocIDs.clear();\n        numBufferedDeleteTerms = 0;\n\n        abortedFiles = files();\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null) {\n              n.out.reset();\n              n.reset();\n            }\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (IOException ioe) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (IOException ioe) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (IOException ioe) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (IOException ioe) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          ThreadState state = threadStates[i];\n          if (state.localFieldsWriter != null) {\n            state.localFieldsWriter.close();\n            state.localFieldsWriter = null;\n          }\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n    }\n  }\n\n","bugFix":["83bbb041887bbef07b8a98d08a0e1713ce137039","1fd1f3c5c06036aebe90bc6da756a37d03f63884"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e82780afe6097066eb5befb86e9432f077667e3d","date":1202756169,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","sourceNew":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || abortCount>0;\n\n    try {\n\n      if (infoStream != null)\n        infoStream.println(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        bufferedDeleteTerms.clear();\n        bufferedDeleteDocIDs.clear();\n        numBufferedDeleteTerms = 0;\n\n        try {\n          abortedFiles = files();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          ThreadState state = threadStates[i];\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n          if (state.localFieldsWriter != null) {\n            try {\n              state.localFieldsWriter.close();\n            } catch (Throwable t) {\n            }\n            state.localFieldsWriter = null;\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (Throwable t) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (Throwable t) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (Throwable t) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (Throwable t) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null)\n              try {\n                n.reset();\n              } catch (Throwable t) {\n              }\n          }\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      if (ae != null)\n        abortCount--;\n      notifyAll();\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || abortCount>0;\n\n    try {\n\n      if (infoStream != null)\n        infoStream.println(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        bufferedDeleteTerms.clear();\n        bufferedDeleteDocIDs.clear();\n        numBufferedDeleteTerms = 0;\n\n        try {\n          abortedFiles = files();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          ThreadState state = threadStates[i];\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n          if (state.localFieldsWriter != null) {\n            try {\n              state.localFieldsWriter.close();\n            } catch (Throwable t) {\n            }\n            state.localFieldsWriter = null;\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (Throwable t) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (Throwable t) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (Throwable t) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (Throwable t) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null)\n              try {\n                n.reset();\n              } catch (Throwable t) {\n              }\n          }\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      abortCount--;\n      notifyAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be","date":1204801324,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","sourceNew":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || abortCount>0;\n\n    try {\n\n      if (infoStream != null)\n        infoStream.println(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        deletesInRAM.clear();\n\n        try {\n          abortedFiles = files();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          ThreadState state = threadStates[i];\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n          if (state.localFieldsWriter != null) {\n            try {\n              state.localFieldsWriter.close();\n            } catch (Throwable t) {\n            }\n            state.localFieldsWriter = null;\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (Throwable t) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (Throwable t) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (Throwable t) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (Throwable t) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null)\n              try {\n                n.reset();\n              } catch (Throwable t) {\n              }\n          }\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      if (ae != null)\n        abortCount--;\n      notifyAll();\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || abortCount>0;\n\n    try {\n\n      if (infoStream != null)\n        infoStream.println(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        bufferedDeleteTerms.clear();\n        bufferedDeleteDocIDs.clear();\n        numBufferedDeleteTerms = 0;\n\n        try {\n          abortedFiles = files();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          ThreadState state = threadStates[i];\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n          if (state.localFieldsWriter != null) {\n            try {\n              state.localFieldsWriter.close();\n            } catch (Throwable t) {\n            }\n            state.localFieldsWriter = null;\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (Throwable t) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (Throwable t) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (Throwable t) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (Throwable t) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null)\n              try {\n                n.reset();\n              } catch (Throwable t) {\n              }\n          }\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      if (ae != null)\n        abortCount--;\n      notifyAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a0af3a442be522899177e5e11384a45a6784a3f","date":1205348952,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","sourceNew":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || abortCount>0;\n\n    try {\n\n      if (infoStream != null)\n        infoStream.println(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        deletesInRAM.clear();\n\n        try {\n          abortedFiles = files();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          DocumentsWriterThreadState state = threadStates[i];\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n          if (state.localFieldsWriter != null) {\n            try {\n              state.localFieldsWriter.close();\n            } catch (Throwable t) {\n            }\n            state.localFieldsWriter = null;\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (Throwable t) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (Throwable t) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (Throwable t) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (Throwable t) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null)\n              try {\n                n.reset();\n              } catch (Throwable t) {\n              }\n          }\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      if (ae != null)\n        abortCount--;\n      notifyAll();\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || abortCount>0;\n\n    try {\n\n      if (infoStream != null)\n        infoStream.println(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        deletesInRAM.clear();\n\n        try {\n          abortedFiles = files();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          ThreadState state = threadStates[i];\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n          if (state.localFieldsWriter != null) {\n            try {\n              state.localFieldsWriter.close();\n            } catch (Throwable t) {\n            }\n            state.localFieldsWriter = null;\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (Throwable t) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (Throwable t) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (Throwable t) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (Throwable t) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null)\n              try {\n                n.reset();\n              } catch (Throwable t) {\n              }\n          }\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      if (ae != null)\n        abortCount--;\n      notifyAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84acdfa12c18361ff932244db20470fce117e52d","date":1206384355,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","sourceNew":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || abortCount>0;\n\n    try {\n\n      if (infoStream != null)\n        message(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        deletesInRAM.clear();\n\n        try {\n          abortedFiles = files();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          DocumentsWriterThreadState state = threadStates[i];\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n          if (state.localFieldsWriter != null) {\n            try {\n              state.localFieldsWriter.close();\n            } catch (Throwable t) {\n            }\n            state.localFieldsWriter = null;\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (Throwable t) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (Throwable t) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (Throwable t) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (Throwable t) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null)\n              try {\n                n.reset();\n              } catch (Throwable t) {\n              }\n          }\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      if (ae != null)\n        abortCount--;\n      notifyAll();\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || abortCount>0;\n\n    try {\n\n      if (infoStream != null)\n        infoStream.println(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        deletesInRAM.clear();\n\n        try {\n          abortedFiles = files();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          DocumentsWriterThreadState state = threadStates[i];\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n          if (state.localFieldsWriter != null) {\n            try {\n              state.localFieldsWriter.close();\n            } catch (Throwable t) {\n            }\n            state.localFieldsWriter = null;\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (Throwable t) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (Throwable t) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (Throwable t) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (Throwable t) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null)\n              try {\n                n.reset();\n              } catch (Throwable t) {\n              }\n          }\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      if (ae != null)\n        abortCount--;\n      notifyAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"455aeff4fef915340c5b19d71d5e147034e83093","date":1210099270,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush.  If ae is\n   *  non-null, it contains the root cause exception (which\n   *  we re-throw after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || abortCount>0;\n\n    try {\n\n      if (infoStream != null)\n        message(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        deletesInRAM.clear();\n\n        try {\n          abortedFiles = files();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          DocumentsWriterThreadState state = threadStates[i];\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n          if (state.localFieldsWriter != null) {\n            try {\n              state.localFieldsWriter.close();\n            } catch (Throwable t) {\n            }\n            state.localFieldsWriter = null;\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (Throwable t) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (Throwable t) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (Throwable t) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (Throwable t) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null)\n              try {\n                n.reset();\n              } catch (Throwable t) {\n              }\n          }\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      if (ae != null)\n        abortCount--;\n      notifyAll();\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception when adding docs,\n   *  flushing, etc.  This resets our state, discarding any\n   *  docs added since last flush.  If ae is non-null, it\n   *  contains the root cause exception (which we re-throw\n   *  after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || abortCount>0;\n\n    try {\n\n      if (infoStream != null)\n        message(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        deletesInRAM.clear();\n\n        try {\n          abortedFiles = files();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          DocumentsWriterThreadState state = threadStates[i];\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n          if (state.localFieldsWriter != null) {\n            try {\n              state.localFieldsWriter.close();\n            } catch (Throwable t) {\n            }\n            state.localFieldsWriter = null;\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (Throwable t) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (Throwable t) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (Throwable t) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (Throwable t) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null)\n              try {\n                n.reset();\n              } catch (Throwable t) {\n              }\n          }\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      if (ae != null)\n        abortCount--;\n      notifyAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5350389bf83287111f7760b9e3db3af8e3648474","date":1216372812,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#abort(AbortException).mjava","sourceNew":null,"sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush.  If ae is\n   *  non-null, it contains the root cause exception (which\n   *  we re-throw after we are done aborting). */\n  synchronized void abort(AbortException ae) throws IOException {\n\n    // Anywhere that throws an AbortException must first\n    // mark aborting to make sure while the exception is\n    // unwinding the un-synchronized stack, no thread grabs\n    // the corrupt ThreadState that hit the aborting\n    // exception:\n    assert ae == null || abortCount>0;\n\n    try {\n\n      if (infoStream != null)\n        message(\"docWriter: now abort\");\n\n      // Forcefully remove waiting ThreadStates from line\n      for(int i=0;i<numWaiting;i++)\n        waitingThreadStates[i].isIdle = true;\n      numWaiting = 0;\n\n      // Wait for all other threads to finish with DocumentsWriter:\n      pauseAllThreads();\n\n      assert 0 == numWaiting;\n\n      try {\n\n        deletesInRAM.clear();\n\n        try {\n          abortedFiles = files();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n        files = null;\n\n        // Clear vectors & fields from ThreadStates\n        for(int i=0;i<threadStates.length;i++) {\n          DocumentsWriterThreadState state = threadStates[i];\n          state.tvfLocal.reset();\n          state.fdtLocal.reset();\n          if (state.localFieldsWriter != null) {\n            try {\n              state.localFieldsWriter.close();\n            } catch (Throwable t) {\n            }\n            state.localFieldsWriter = null;\n          }\n        }\n\n        // Reset vectors writer\n        if (tvx != null) {\n          try {\n            tvx.close();\n          } catch (Throwable t) {\n          }\n          tvx = null;\n        }\n        if (tvd != null) {\n          try {\n            tvd.close();\n          } catch (Throwable t) {\n          }\n          tvd = null;\n        }\n        if (tvf != null) {\n          try {\n            tvf.close();\n          } catch (Throwable t) {\n          }\n          tvf = null;\n        }\n\n        // Reset fields writer\n        if (fieldsWriter != null) {\n          try {\n            fieldsWriter.close();\n          } catch (Throwable t) {\n          }\n          fieldsWriter = null;\n        }\n\n        // Discard pending norms:\n        final int numField = fieldInfos.size();\n        for (int i=0;i<numField;i++) {\n          FieldInfo fi = fieldInfos.fieldInfo(i);\n          if (fi.isIndexed && !fi.omitNorms) {\n            BufferedNorms n = norms[i];\n            if (n != null)\n              try {\n                n.reset();\n              } catch (Throwable t) {\n              }\n          }\n        }\n\n        // Reset all postings data\n        resetPostingsData();\n\n      } finally {\n        resumeAllThreads();\n      }\n\n      // If we have a root cause exception, re-throw it now:\n      if (ae != null) {\n        Throwable t = ae.getCause();\n        if (t instanceof IOException)\n          throw (IOException) t;\n        else if (t instanceof RuntimeException)\n          throw (RuntimeException) t;\n        else if (t instanceof Error)\n          throw (Error) t;\n        else\n          // Should not get here\n          assert false: \"unknown exception: \" + t;\n      }\n    } finally {\n      if (ae != null)\n        abortCount--;\n      notifyAll();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1fd1f3c5c06036aebe90bc6da756a37d03f63884":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"83bbb041887bbef07b8a98d08a0e1713ce137039":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"176324efd1eab6bd44a6d81c27c9b3a1a175ba3d":["1fd1f3c5c06036aebe90bc6da756a37d03f63884"],"455aeff4fef915340c5b19d71d5e147034e83093":["84acdfa12c18361ff932244db20470fce117e52d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["e82780afe6097066eb5befb86e9432f077667e3d"],"e82780afe6097066eb5befb86e9432f077667e3d":["176324efd1eab6bd44a6d81c27c9b3a1a175ba3d"],"5a0af3a442be522899177e5e11384a45a6784a3f":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"],"5350389bf83287111f7760b9e3db3af8e3648474":["455aeff4fef915340c5b19d71d5e147034e83093"],"84acdfa12c18361ff932244db20470fce117e52d":["5a0af3a442be522899177e5e11384a45a6784a3f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5350389bf83287111f7760b9e3db3af8e3648474"]},"commit2Childs":{"1fd1f3c5c06036aebe90bc6da756a37d03f63884":["176324efd1eab6bd44a6d81c27c9b3a1a175ba3d"],"83bbb041887bbef07b8a98d08a0e1713ce137039":["1fd1f3c5c06036aebe90bc6da756a37d03f63884"],"176324efd1eab6bd44a6d81c27c9b3a1a175ba3d":["e82780afe6097066eb5befb86e9432f077667e3d"],"455aeff4fef915340c5b19d71d5e147034e83093":["5350389bf83287111f7760b9e3db3af8e3648474"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["5a0af3a442be522899177e5e11384a45a6784a3f"],"e82780afe6097066eb5befb86e9432f077667e3d":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"],"5a0af3a442be522899177e5e11384a45a6784a3f":["84acdfa12c18361ff932244db20470fce117e52d"],"84acdfa12c18361ff932244db20470fce117e52d":["455aeff4fef915340c5b19d71d5e147034e83093"],"5350389bf83287111f7760b9e3db3af8e3648474":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}