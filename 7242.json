{"path":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","sourceOld":"  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"035bfd1088cdad8e71e315033daf330d0cd95923","date":1348092980,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","sourceOld":"  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91","date":1429620941,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return Explanation.match(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return new Explanation(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a259cdf9917ec38c8a812cc053f533b6e697a4a","date":1439487435,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf(docFreq=\" + df + \", docCount=\" + docCount + \")\");\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, searcher.maxDoc());\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#maxDoc()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#maxDoc()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#maxDoc()} is more efficient to compute\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long max = collectionStats.maxDoc();\n    final float idf = idf(df, max);\n    return Explanation.match(idf, \"idf(docFreq=\" + df + \", maxDocs=\" + max + \")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"665c23854e5ad5caf7ea153341d7d24e5dffbc4a","date":1478786509,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf, computed as log(1 + (docCount - docFreq + 0.5) / (docFreq + 0.5)) from:\",\n        Explanation.match(df, \"docFreq\"),\n        Explanation.match(docCount, \"docCount\"));\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf(docFreq=\" + df + \", docCount=\" + docCount + \")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf, computed as log(1 + (docCount - docFreq + 0.5) / (docFreq + 0.5)) from:\",\n        Explanation.match(df, \"docFreq\"),\n        Explanation.match(docCount, \"docCount\"));\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf(docFreq=\" + df + \", docCount=\" + docCount + \")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46","date":1508899684,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf, computed as log(1 + (N - n + 0.5) / (n + 0.5)) from:\",\n        Explanation.match(df, \"n, number of documents containing term\"),\n        Explanation.match(docCount, \"N, total number of documents with field\"));\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf, computed as log(1 + (docCount - docFreq + 0.5) / (docFreq + 0.5)) from:\",\n        Explanation.match(df, \"docFreq\"),\n        Explanation.match(docCount, \"docCount\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"086ffe31d8fba0110227db122974163709ecc1b4","date":1509678141,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf, computed as log(1 + (N - n + 0.5) / (n + 0.5)) from:\",\n        Explanation.match(df, \"n, number of documents containing term\"),\n        Explanation.match(docCount, \"N, total number of documents with field\"));\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf, computed as log(1 + (N - n + 0.5) / (n + 0.5)) from:\",\n        Explanation.match(df, \"n, number of documents containing term\"),\n        Explanation.match(docCount, \"N, total number of documents with field\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d523b8189b211dd1630166aa77b8c88bb48b3fcc","date":1510144168,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity#idfExplain(CollectionStatistics,TermStatistics).mjava","sourceNew":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf, computed as log(1 + (N - n + 0.5) / (n + 0.5)) from:\",\n        Explanation.match(df, \"n, number of documents containing term\"),\n        Explanation.match(docCount, \"N, total number of documents with field\"));\n  }\n\n","sourceOld":"  /**\n   * Computes a score factor for a simple term and returns an explanation\n   * for that score factor.\n   * \n   * <p>\n   * The default implementation uses:\n   * \n   * <pre class=\"prettyprint\">\n   * idf(docFreq, docCount);\n   * </pre>\n   * \n   * Note that {@link CollectionStatistics#docCount()} is used instead of\n   * {@link org.apache.lucene.index.IndexReader#numDocs() IndexReader#numDocs()} because also \n   * {@link TermStatistics#docFreq()} is used, and when the latter \n   * is inaccurate, so is {@link CollectionStatistics#docCount()}, and in the same direction.\n   * In addition, {@link CollectionStatistics#docCount()} does not skew when fields are sparse.\n   *   \n   * @param collectionStats collection-level statistics\n   * @param termStats term-level statistics for the term\n   * @return an Explain object that includes both an idf score factor \n             and an explanation for the term.\n   */\n  public Explanation idfExplain(CollectionStatistics collectionStats, TermStatistics termStats) {\n    final long df = termStats.docFreq();\n    final long docCount = collectionStats.docCount() == -1 ? collectionStats.maxDoc() : collectionStats.docCount();\n    final float idf = idf(df, docCount);\n    return Explanation.match(idf, \"idf, computed as log(1 + (N - n + 0.5) / (n + 0.5)) from:\",\n        Explanation.match(df, \"n, number of documents containing term\"),\n        Explanation.match(docCount, \"N, total number of documents with field\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46":["665c23854e5ad5caf7ea153341d7d24e5dffbc4a"],"086ffe31d8fba0110227db122974163709ecc1b4":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46"],"5a259cdf9917ec38c8a812cc053f533b6e697a4a":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46","086ffe31d8fba0110227db122974163709ecc1b4"],"035bfd1088cdad8e71e315033daf330d0cd95923":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"665c23854e5ad5caf7ea153341d7d24e5dffbc4a":["5a259cdf9917ec38c8a812cc053f533b6e697a4a"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["5a259cdf9917ec38c8a812cc053f533b6e697a4a","665c23854e5ad5caf7ea153341d7d24e5dffbc4a"],"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91":["035bfd1088cdad8e71e315033daf330d0cd95923"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"]},"commit2Childs":{"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46":["086ffe31d8fba0110227db122974163709ecc1b4","d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"086ffe31d8fba0110227db122974163709ecc1b4":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"5a259cdf9917ec38c8a812cc053f533b6e697a4a":["665c23854e5ad5caf7ea153341d7d24e5dffbc4a","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"035bfd1088cdad8e71e315033daf330d0cd95923":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["035bfd1088cdad8e71e315033daf330d0cd95923"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"665c23854e5ad5caf7ea153341d7d24e5dffbc4a":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91":["5a259cdf9917ec38c8a812cc053f533b6e697a4a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}