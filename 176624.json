{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","commits":[{"id":"30d3ec601cbd11cf056b7336f0e03f688ebcd9f7","date":1401116050,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,Long).mjava","sourceNew":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately\n   * close the writer. See <a href=\"#OOME\">above</a> for details.\n   * </p>\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateNumericDocValue(term, field, value)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"updateNumericDocValue\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. This method can be used to 'unset' a document's\n   * value by passing {@code null} as the new value. Also, you can only update\n   * fields that already exist in the index, not add new fields through this\n   * method.\n   * \n   * <p>\n   * <b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately\n   * close the writer. See <a href=\"#OOME\">above</a> for details.\n   * </p>\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateNumericDocValue(Term term, String field, Long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateNumericDocValue(term, field, value)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"updateNumericDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70285ef5917fa2c8feec026d4be4d9c20fa89162","date":1401366288,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","sourceNew":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately\n   * close the writer. See <a href=\"#OOME\">above</a> for details.\n   * </p>\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"updateNumericDocValue\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately\n   * close the writer. See <a href=\"#OOME\">above</a> for details.\n   * </p>\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateNumericDocValue(term, field, value)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"updateNumericDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"949847c0040cd70a68222d526cb0da7bf6cbb3c2","date":1410997182,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","sourceNew":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"updateNumericDocValue\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately\n   * close the writer. See <a href=\"#OOME\">above</a> for details.\n   * </p>\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"updateNumericDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["c48871ed951104729f5e17a8ee1091b43fa18980"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c48871ed951104729f5e17a8ee1091b43fa18980","date":1446564542,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","sourceNew":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"updateNumericDocValue\");\n    }\n  }\n\n","bugFix":["949847c0040cd70a68222d526cb0da7bf6cbb3c2","e072d0b1fc19e0533d8ce432eed245196bca6fde"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23a29a4862e38cc3b9bff14a888901c7c878885b","date":1464135767,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","sourceNew":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16ebfabc294f23b88b6a39722a02c9d39b353195","date":1464343867,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","sourceNew":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","sourceNew":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","sourceNew":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","sourceNew":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65233715955663909ad948e05aa3fed614f4a57b","date":1481324713,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","sourceNew":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    if (config.getIndexSortFields().contains(field)) {\n      throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + field + \", sort=\" + config.getIndexSort());\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","sourceNew":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    if (config.getIndexSortFields().contains(field)) {\n      throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + field + \", sort=\" + config.getIndexSort());\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","sourceNew":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    if (config.getIndexSortFields().contains(field)) {\n      throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + field + \", sort=\" + config.getIndexSort());\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n      throw tragedy;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    if (config.getIndexSortFields().contains(field)) {\n      throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + field + \", sort=\" + config.getIndexSort());\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a9b6ed5e493fd780f940f307e17673df92a4419","date":1583776063,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateNumericDocValue(Term,String,long).mjava","sourceNew":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    if (config.getIndexSortFields().contains(field)) {\n      throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + field + \", sort=\" + config.getIndexSort());\n    }\n    try {\n      return maybeProcessEvents(docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value)));\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n      throw tragedy;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link NumericDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link NumericDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateNumericDocValue(Term term, String field, long value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.NUMERIC)) {\n      throw new IllegalArgumentException(\"can only update existing numeric-docvalues fields!\");\n    }\n    if (config.getIndexSortFields().contains(field)) {\n      throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + field + \", sort=\" + config.getIndexSort());\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new NumericDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateNumericDocValue\");\n      throw tragedy;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"65233715955663909ad948e05aa3fed614f4a57b":["191128ac5b85671b1671e2c857437694283b6ebf"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["65233715955663909ad948e05aa3fed614f4a57b"],"0a9b6ed5e493fd780f940f307e17673df92a4419":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"23a29a4862e38cc3b9bff14a888901c7c878885b":["c48871ed951104729f5e17a8ee1091b43fa18980"],"6483e4260c08168709c02238ae083a51519a28dd":["c48871ed951104729f5e17a8ee1091b43fa18980","16ebfabc294f23b88b6a39722a02c9d39b353195"],"191128ac5b85671b1671e2c857437694283b6ebf":["c48871ed951104729f5e17a8ee1091b43fa18980","6483e4260c08168709c02238ae083a51519a28dd"],"70285ef5917fa2c8feec026d4be4d9c20fa89162":["30d3ec601cbd11cf056b7336f0e03f688ebcd9f7"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["23a29a4862e38cc3b9bff14a888901c7c878885b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c48871ed951104729f5e17a8ee1091b43fa18980","191128ac5b85671b1671e2c857437694283b6ebf"],"c48871ed951104729f5e17a8ee1091b43fa18980":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"30d3ec601cbd11cf056b7336f0e03f688ebcd9f7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9856095f7afb5a607bf5e65077615ed91273508c":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","65233715955663909ad948e05aa3fed614f4a57b"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["70285ef5917fa2c8feec026d4be4d9c20fa89162"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0a9b6ed5e493fd780f940f307e17673df92a4419"]},"commit2Childs":{"65233715955663909ad948e05aa3fed614f4a57b":["845b760a99e5f369fcd0a5d723a87b8def6a3f56","9856095f7afb5a607bf5e65077615ed91273508c"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["0a9b6ed5e493fd780f940f307e17673df92a4419"],"0a9b6ed5e493fd780f940f307e17673df92a4419":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"23a29a4862e38cc3b9bff14a888901c7c878885b":["16ebfabc294f23b88b6a39722a02c9d39b353195"],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["65233715955663909ad948e05aa3fed614f4a57b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["6483e4260c08168709c02238ae083a51519a28dd"],"70285ef5917fa2c8feec026d4be4d9c20fa89162":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9856095f7afb5a607bf5e65077615ed91273508c"],"c48871ed951104729f5e17a8ee1091b43fa18980":["23a29a4862e38cc3b9bff14a888901c7c878885b","6483e4260c08168709c02238ae083a51519a28dd","191128ac5b85671b1671e2c857437694283b6ebf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["30d3ec601cbd11cf056b7336f0e03f688ebcd9f7"],"30d3ec601cbd11cf056b7336f0e03f688ebcd9f7":["70285ef5917fa2c8feec026d4be4d9c20fa89162"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["c48871ed951104729f5e17a8ee1091b43fa18980"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}