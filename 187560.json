{"path":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long).mjava","commits":[{"id":"455aeff4fef915340c5b19d71d5e147034e83093","date":1210099270,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#commit(boolean,long).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.  Multiple\n        // threads can be doing this at once, if say a large\n        // merge and a small merge finish at the same time:\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        toSync = (SegmentInfos) segmentInfos.clone();\n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName);\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              message(\"wait for existing pendingCommit to finish...\");\n              try {\n                wait();\n              } catch (InterruptedException ie) {\n                Thread.currentThread().interrupt();\n              }\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success)\n                message(\"hit exception committing segments file\");\n            }\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos, minus flushes, and ask the Directory to\n   *  sync each file, if it wasn't already.  If that\n   *  succeeds, then we write a new segments_N file & sync\n   *  that. */\n  private void commit(boolean skipWait, long sizeInBytes) throws IOException {\n\n    assert testPoint(\"startCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"start commit() skipWait=\" + skipWait + \" sizeInBytes=\" + sizeInBytes);\n\n      if (!skipWait)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip commit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.  Multiple\n        // threads can be doing this at once, if say a large\n        // merge and a small merge finish at the same time:\n\n        toSync = (SegmentInfos) segmentInfos.clone();\n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n      }\n\n      if (infoStream != null)\n        message(\"commit index=\" + segString(toSync));\n\n      assert testPoint(\"midCommit\");\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName);\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midCommit2\");\n      \n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount) {\n          \n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n              toSync.commit(directory);\n              success = true;\n            } finally {\n              // Have our master segmentInfos record the\n              // generations we just sync'd\n              segmentInfos.updateGeneration(toSync);\n              if (!success)\n                message(\"hit exception committing segments file\");\n            }\n\n            message(\"commit complete\");\n\n            lastCommitChangeCount = myChangeCount;\n\n            deleter.checkpoint(toSync, true);\n            setRollbackSegmentInfos();\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        assert testPoint(\"midCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2586f96f60332eb97ecd2934b0763791462568b2","date":1220116589,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              message(\"wait for existing pendingCommit to finish...\");\n              doWait();\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success)\n                message(\"hit exception committing segments file\");\n            }\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.  Multiple\n        // threads can be doing this at once, if say a large\n        // merge and a small merge finish at the same time:\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        toSync = (SegmentInfos) segmentInfos.clone();\n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName);\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              message(\"wait for existing pendingCommit to finish...\");\n              try {\n                wait();\n              } catch (InterruptedException ie) {\n                Thread.currentThread().interrupt();\n              }\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success)\n                message(\"hit exception committing segments file\");\n            }\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":["0f44610301174bfb430443d89a88dc1c502feea1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"94991fb4ccf443dcb78fd2a03c07e2b25de2d04d","date":1221590956,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              message(\"wait for existing pendingCommit to finish...\");\n              doWait();\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success)\n                message(\"hit exception committing segments file\");\n            }\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              message(\"wait for existing pendingCommit to finish...\");\n              doWait();\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success)\n                message(\"hit exception committing segments file\");\n            }\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b1444275c93a8051a6fe6158639467a144ae0a4","date":1224502393,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              message(\"wait for existing pendingCommit to finish...\");\n              doWait();\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success)\n                message(\"hit exception committing segments file\");\n            }\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n          toSync = (SegmentInfos) segmentInfos.clone();\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount && (pendingCommit == null || myChangeCount > pendingCommitChangeCount)) {\n\n            // Wait now for any current pending commit to complete:\n            while(pendingCommit != null) {\n              message(\"wait for existing pendingCommit to finish...\");\n              doWait();\n            }\n\n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n\n              // Exception here means nothing is prepared\n              // (this method unwinds everything it did on\n              // an exception)\n              try {\n                toSync.prepareCommit(directory);\n              } finally {\n                // Have our master segmentInfos record the\n                // generations we just prepared.  We do this\n                // on error or success so we don't\n                // double-write a segments_N file.\n                segmentInfos.updateGeneration(toSync);\n              }\n\n              assert pendingCommit == null;\n              setPending = true;\n              pendingCommit = toSync;\n              pendingCommitChangeCount = myChangeCount;\n              success = true;\n            } finally {\n              if (!success)\n                message(\"hit exception committing segments file\");\n            }\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"4b1444275c93a8051a6fe6158639467a144ae0a4":["94991fb4ccf443dcb78fd2a03c07e2b25de2d04d"],"94991fb4ccf443dcb78fd2a03c07e2b25de2d04d":["2586f96f60332eb97ecd2934b0763791462568b2"],"455aeff4fef915340c5b19d71d5e147034e83093":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2586f96f60332eb97ecd2934b0763791462568b2":["455aeff4fef915340c5b19d71d5e147034e83093"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4b1444275c93a8051a6fe6158639467a144ae0a4"]},"commit2Childs":{"4b1444275c93a8051a6fe6158639467a144ae0a4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"94991fb4ccf443dcb78fd2a03c07e2b25de2d04d":["4b1444275c93a8051a6fe6158639467a144ae0a4"],"455aeff4fef915340c5b19d71d5e147034e83093":["2586f96f60332eb97ecd2934b0763791462568b2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["455aeff4fef915340c5b19d71d5e147034e83093"],"2586f96f60332eb97ecd2934b0763791462568b2":["94991fb4ccf443dcb78fd2a03c07e2b25de2d04d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}