{"path":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","commits":[{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext,Bits).mjava","sourceNew":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  // pkg-private for forcing use of BooleanScorer in tests\n  BooleanScorer booleanScorer(LeafReaderContext context) throws IOException {\n    List<BulkScorer> optional = new ArrayList<BulkScorer>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      BulkScorer subScorer = w.bulkScorer(context);\n      \n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        // TODO: there are some cases where BooleanScorer\n        // would handle conjunctions faster than\n        // BooleanScorer2...\n        return null;\n      } else if (c.isProhibited()) {\n        // TODO: there are some cases where BooleanScorer could do this faster\n        return null;\n      } else {\n        optional.add(subScorer);\n      }\n    }\n\n    if (optional.size() == 0) {\n      return null;\n    }\n\n    if (query.getMinimumNumberShouldMatch() > optional.size()) {\n      return null;\n    }\n\n    return new BooleanScorer(this, disableCoord, maxCoord, optional, Math.max(1, query.getMinimumNumberShouldMatch()), needsScores);\n  }\n\n","sourceOld":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  // pkg-private for forcing use of BooleanScorer in tests\n  BooleanScorer booleanScorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    List<BulkScorer> optional = new ArrayList<BulkScorer>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      BulkScorer subScorer = w.bulkScorer(context, acceptDocs);\n      \n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        // TODO: there are some cases where BooleanScorer\n        // would handle conjunctions faster than\n        // BooleanScorer2...\n        return null;\n      } else if (c.isProhibited()) {\n        // TODO: there are some cases where BooleanScorer could do this faster\n        return null;\n      } else {\n        optional.add(subScorer);\n      }\n    }\n\n    if (optional.size() == 0) {\n      return null;\n    }\n\n    if (query.getMinimumNumberShouldMatch() > optional.size()) {\n      return null;\n    }\n\n    return new BooleanScorer(this, disableCoord, maxCoord, optional, Math.max(1, query.getMinimumNumberShouldMatch()), needsScores);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c83732c32d5a6ea6a1ca930daa241ddec2f4c9c","date":1445865000,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","sourceNew":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  // pkg-private for forcing use of BooleanScorer in tests\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    List<BulkScorer> optional = new ArrayList<BulkScorer>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      BulkScorer subScorer = w.bulkScorer(context);\n      \n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        // TODO: there are some cases where BooleanScorer\n        // would handle conjunctions faster than\n        // BooleanScorer2...\n        return null;\n      } else if (c.isProhibited()) {\n        // TODO: there are some cases where BooleanScorer could do this faster\n        return null;\n      } else {\n        optional.add(subScorer);\n      }\n    }\n\n    if (optional.size() == 0) {\n      return null;\n    }\n\n    if (query.getMinimumNumberShouldMatch() > optional.size()) {\n      return null;\n    }\n\n    if (optional.size() == 1) {\n      BulkScorer opt = optional.get(0);\n      if (!disableCoord && maxCoord > 1) {\n        return new BooleanTopLevelScorers.BoostedBulkScorer(opt, coord(1, maxCoord));\n      } else {\n        return opt;\n      }\n    }\n\n    return new BooleanScorer(this, disableCoord, maxCoord, optional, Math.max(1, query.getMinimumNumberShouldMatch()), needsScores);\n  }\n\n","sourceOld":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  // pkg-private for forcing use of BooleanScorer in tests\n  BooleanScorer booleanScorer(LeafReaderContext context) throws IOException {\n    List<BulkScorer> optional = new ArrayList<BulkScorer>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      BulkScorer subScorer = w.bulkScorer(context);\n      \n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        // TODO: there are some cases where BooleanScorer\n        // would handle conjunctions faster than\n        // BooleanScorer2...\n        return null;\n      } else if (c.isProhibited()) {\n        // TODO: there are some cases where BooleanScorer could do this faster\n        return null;\n      } else {\n        optional.add(subScorer);\n      }\n    }\n\n    if (optional.size() == 0) {\n      return null;\n    }\n\n    if (query.getMinimumNumberShouldMatch() > optional.size()) {\n      return null;\n    }\n\n    return new BooleanScorer(this, disableCoord, maxCoord, optional, Math.max(1, query.getMinimumNumberShouldMatch()), needsScores);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0aa571364c08edee91e7ca61b5ff6ec29684afc4","date":1450717317,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","sourceNew":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  // pkg-private for forcing use of BooleanScorer in tests\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    if (query.getClauses(Occur.MUST).isEmpty() == false\n        || query.getClauses(Occur.FILTER).isEmpty() == false) {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    } else if (query.getClauses(Occur.MUST_NOT).isEmpty() == false) {\n      // TODO: there are some cases where BooleanScorer could do this faster\n      return null;\n    }\n\n    List<BulkScorer> optional = new ArrayList<BulkScorer>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.getOccur() != Occur.SHOULD) {\n        throw new AssertionError();\n      }\n      BulkScorer subScorer = w.bulkScorer(context);\n\n      if (subScorer != null) {\n        optional.add(subScorer);\n      }\n    }\n\n    if (optional.size() == 0) {\n      return null;\n    }\n\n    if (query.getMinimumNumberShouldMatch() > optional.size()) {\n      return null;\n    }\n\n    if (optional.size() == 1) {\n      BulkScorer opt = optional.get(0);\n      if (!disableCoord && maxCoord > 1) {\n        return new BooleanTopLevelScorers.BoostedBulkScorer(opt, coord(1, maxCoord));\n      } else {\n        return opt;\n      }\n    }\n\n    return new BooleanScorer(this, disableCoord, maxCoord, optional, Math.max(1, query.getMinimumNumberShouldMatch()), needsScores);\n  }\n\n","sourceOld":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  // pkg-private for forcing use of BooleanScorer in tests\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    List<BulkScorer> optional = new ArrayList<BulkScorer>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      BulkScorer subScorer = w.bulkScorer(context);\n      \n      if (subScorer == null) {\n        if (c.isRequired()) {\n          return null;\n        }\n      } else if (c.isRequired()) {\n        // TODO: there are some cases where BooleanScorer\n        // would handle conjunctions faster than\n        // BooleanScorer2...\n        return null;\n      } else if (c.isProhibited()) {\n        // TODO: there are some cases where BooleanScorer could do this faster\n        return null;\n      } else {\n        optional.add(subScorer);\n      }\n    }\n\n    if (optional.size() == 0) {\n      return null;\n    }\n\n    if (query.getMinimumNumberShouldMatch() > optional.size()) {\n      return null;\n    }\n\n    if (optional.size() == 1) {\n      BulkScorer opt = optional.get(0);\n      if (!disableCoord && maxCoord > 1) {\n        return new BooleanTopLevelScorers.BoostedBulkScorer(opt, coord(1, maxCoord));\n      } else {\n        return opt;\n      }\n    }\n\n    return new BooleanScorer(this, disableCoord, maxCoord, optional, Math.max(1, query.getMinimumNumberShouldMatch()), needsScores);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2262f0d8ead49d04485950fba849e166dbe28fb","date":1451569279,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","sourceNew":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    final int numOptionalClauses = query.getClauses(Occur.SHOULD).size();\n    final int numRequiredClauses = query.getClauses(Occur.MUST).size() + query.getClauses(Occur.FILTER).size();\n    \n    BulkScorer positiveScorer;\n    if (numRequiredClauses == 0) {\n      positiveScorer = optionalBulkScorer(context);\n      if (positiveScorer == null) {\n        return null;\n      }\n\n      // TODO: what is the right heuristic here?\n      final long costThreshold;\n      if (query.getMinimumNumberShouldMatch() <= 1) {\n        // when all clauses are optional, use BooleanScorer aggressively\n        // TODO: is there actually a threshold under which we should rather\n        // use the regular scorer?\n        costThreshold = -1;\n      } else {\n        // when a minimum number of clauses should match, BooleanScorer is\n        // going to score all windows that have at least minNrShouldMatch\n        // matches in the window. But there is no way to know if there is\n        // an intersection (all clauses might match a different doc ID and\n        // there will be no matches in the end) so we should only use\n        // BooleanScorer if matches are very dense\n        costThreshold = context.reader().maxDoc() / 3;\n      }\n\n      if (positiveScorer.cost() < costThreshold) {\n        return null;\n      }\n\n    } else if (numRequiredClauses == 1\n        && numOptionalClauses == 0\n        && query.getMinimumNumberShouldMatch() == 0) {\n      positiveScorer = requiredBulkScorer(context);\n    } else {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    }\n\n    if (positiveScorer == null) {\n      return null;\n    }\n\n    List<Scorer> prohibited = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.isProhibited()) {\n        Scorer scorer = w.scorer(context);\n        if (scorer != null) {\n          prohibited.add(scorer);\n        }\n      }\n    }\n\n    if (prohibited.isEmpty()) {\n      return positiveScorer;\n    } else {\n      Scorer prohibitedScorer = opt(prohibited, 1, true);\n      if (prohibitedScorer.twoPhaseIterator() != null) {\n        // ReqExclBulkScorer can't deal efficiently with two-phased prohibited clauses\n        return null;\n      }\n      return new ReqExclBulkScorer(positiveScorer, prohibitedScorer.iterator());\n    }\n  }\n\n","sourceOld":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  // pkg-private for forcing use of BooleanScorer in tests\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    if (query.getClauses(Occur.MUST).isEmpty() == false\n        || query.getClauses(Occur.FILTER).isEmpty() == false) {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    } else if (query.getClauses(Occur.MUST_NOT).isEmpty() == false) {\n      // TODO: there are some cases where BooleanScorer could do this faster\n      return null;\n    }\n\n    List<BulkScorer> optional = new ArrayList<BulkScorer>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.getOccur() != Occur.SHOULD) {\n        throw new AssertionError();\n      }\n      BulkScorer subScorer = w.bulkScorer(context);\n\n      if (subScorer != null) {\n        optional.add(subScorer);\n      }\n    }\n\n    if (optional.size() == 0) {\n      return null;\n    }\n\n    if (query.getMinimumNumberShouldMatch() > optional.size()) {\n      return null;\n    }\n\n    if (optional.size() == 1) {\n      BulkScorer opt = optional.get(0);\n      if (!disableCoord && maxCoord > 1) {\n        return new BooleanTopLevelScorers.BoostedBulkScorer(opt, coord(1, maxCoord));\n      } else {\n        return opt;\n      }\n    }\n\n    return new BooleanScorer(this, disableCoord, maxCoord, optional, Math.max(1, query.getMinimumNumberShouldMatch()), needsScores);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","sourceNew":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    final int numOptionalClauses = query.getClauses(Occur.SHOULD).size();\n    final int numRequiredClauses = query.getClauses(Occur.MUST).size() + query.getClauses(Occur.FILTER).size();\n    \n    BulkScorer positiveScorer;\n    if (numRequiredClauses == 0) {\n      positiveScorer = optionalBulkScorer(context);\n      if (positiveScorer == null) {\n        return null;\n      }\n\n      // TODO: what is the right heuristic here?\n      final long costThreshold;\n      if (query.getMinimumNumberShouldMatch() <= 1) {\n        // when all clauses are optional, use BooleanScorer aggressively\n        // TODO: is there actually a threshold under which we should rather\n        // use the regular scorer?\n        costThreshold = -1;\n      } else {\n        // when a minimum number of clauses should match, BooleanScorer is\n        // going to score all windows that have at least minNrShouldMatch\n        // matches in the window. But there is no way to know if there is\n        // an intersection (all clauses might match a different doc ID and\n        // there will be no matches in the end) so we should only use\n        // BooleanScorer if matches are very dense\n        costThreshold = context.reader().maxDoc() / 3;\n      }\n\n      if (positiveScorer.cost() < costThreshold) {\n        return null;\n      }\n\n    } else if (numRequiredClauses == 1\n        && numOptionalClauses == 0\n        && query.getMinimumNumberShouldMatch() == 0) {\n      positiveScorer = requiredBulkScorer(context);\n    } else {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    }\n\n    if (positiveScorer == null) {\n      return null;\n    }\n\n    List<Scorer> prohibited = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.isProhibited()) {\n        Scorer scorer = w.scorer(context);\n        if (scorer != null) {\n          prohibited.add(scorer);\n        }\n      }\n    }\n\n    if (prohibited.isEmpty()) {\n      return positiveScorer;\n    } else {\n      Scorer prohibitedScorer = opt(prohibited, 1);\n      if (prohibitedScorer.twoPhaseIterator() != null) {\n        // ReqExclBulkScorer can't deal efficiently with two-phased prohibited clauses\n        return null;\n      }\n      return new ReqExclBulkScorer(positiveScorer, prohibitedScorer.iterator());\n    }\n  }\n\n","sourceOld":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    final int numOptionalClauses = query.getClauses(Occur.SHOULD).size();\n    final int numRequiredClauses = query.getClauses(Occur.MUST).size() + query.getClauses(Occur.FILTER).size();\n    \n    BulkScorer positiveScorer;\n    if (numRequiredClauses == 0) {\n      positiveScorer = optionalBulkScorer(context);\n      if (positiveScorer == null) {\n        return null;\n      }\n\n      // TODO: what is the right heuristic here?\n      final long costThreshold;\n      if (query.getMinimumNumberShouldMatch() <= 1) {\n        // when all clauses are optional, use BooleanScorer aggressively\n        // TODO: is there actually a threshold under which we should rather\n        // use the regular scorer?\n        costThreshold = -1;\n      } else {\n        // when a minimum number of clauses should match, BooleanScorer is\n        // going to score all windows that have at least minNrShouldMatch\n        // matches in the window. But there is no way to know if there is\n        // an intersection (all clauses might match a different doc ID and\n        // there will be no matches in the end) so we should only use\n        // BooleanScorer if matches are very dense\n        costThreshold = context.reader().maxDoc() / 3;\n      }\n\n      if (positiveScorer.cost() < costThreshold) {\n        return null;\n      }\n\n    } else if (numRequiredClauses == 1\n        && numOptionalClauses == 0\n        && query.getMinimumNumberShouldMatch() == 0) {\n      positiveScorer = requiredBulkScorer(context);\n    } else {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    }\n\n    if (positiveScorer == null) {\n      return null;\n    }\n\n    List<Scorer> prohibited = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.isProhibited()) {\n        Scorer scorer = w.scorer(context);\n        if (scorer != null) {\n          prohibited.add(scorer);\n        }\n      }\n    }\n\n    if (prohibited.isEmpty()) {\n      return positiveScorer;\n    } else {\n      Scorer prohibitedScorer = opt(prohibited, 1, true);\n      if (prohibitedScorer.twoPhaseIterator() != null) {\n        // ReqExclBulkScorer can't deal efficiently with two-phased prohibited clauses\n        return null;\n      }\n      return new ReqExclBulkScorer(positiveScorer, prohibitedScorer.iterator());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","sourceNew":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    final int numOptionalClauses = query.getClauses(Occur.SHOULD).size();\n    final int numRequiredClauses = query.getClauses(Occur.MUST).size() + query.getClauses(Occur.FILTER).size();\n    \n    BulkScorer positiveScorer;\n    if (numRequiredClauses == 0) {\n      positiveScorer = optionalBulkScorer(context);\n      if (positiveScorer == null) {\n        return null;\n      }\n\n      // TODO: what is the right heuristic here?\n      final long costThreshold;\n      if (query.getMinimumNumberShouldMatch() <= 1) {\n        // when all clauses are optional, use BooleanScorer aggressively\n        // TODO: is there actually a threshold under which we should rather\n        // use the regular scorer?\n        costThreshold = -1;\n      } else {\n        // when a minimum number of clauses should match, BooleanScorer is\n        // going to score all windows that have at least minNrShouldMatch\n        // matches in the window. But there is no way to know if there is\n        // an intersection (all clauses might match a different doc ID and\n        // there will be no matches in the end) so we should only use\n        // BooleanScorer if matches are very dense\n        costThreshold = context.reader().maxDoc() / 3;\n      }\n\n      if (positiveScorer.cost() < costThreshold) {\n        return null;\n      }\n\n    } else if (numRequiredClauses == 1\n        && numOptionalClauses == 0\n        && query.getMinimumNumberShouldMatch() == 0) {\n      positiveScorer = requiredBulkScorer(context);\n    } else {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    }\n\n    if (positiveScorer == null) {\n      return null;\n    }\n\n    List<Scorer> prohibited = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.isProhibited()) {\n        Scorer scorer = w.scorer(context);\n        if (scorer != null) {\n          prohibited.add(scorer);\n        }\n      }\n    }\n\n    if (prohibited.isEmpty()) {\n      return positiveScorer;\n    } else {\n      Scorer prohibitedScorer = opt(prohibited, 1);\n      if (prohibitedScorer.twoPhaseIterator() != null) {\n        // ReqExclBulkScorer can't deal efficiently with two-phased prohibited clauses\n        return null;\n      }\n      return new ReqExclBulkScorer(positiveScorer, prohibitedScorer.iterator());\n    }\n  }\n\n","sourceOld":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    final int numOptionalClauses = query.getClauses(Occur.SHOULD).size();\n    final int numRequiredClauses = query.getClauses(Occur.MUST).size() + query.getClauses(Occur.FILTER).size();\n    \n    BulkScorer positiveScorer;\n    if (numRequiredClauses == 0) {\n      positiveScorer = optionalBulkScorer(context);\n      if (positiveScorer == null) {\n        return null;\n      }\n\n      // TODO: what is the right heuristic here?\n      final long costThreshold;\n      if (query.getMinimumNumberShouldMatch() <= 1) {\n        // when all clauses are optional, use BooleanScorer aggressively\n        // TODO: is there actually a threshold under which we should rather\n        // use the regular scorer?\n        costThreshold = -1;\n      } else {\n        // when a minimum number of clauses should match, BooleanScorer is\n        // going to score all windows that have at least minNrShouldMatch\n        // matches in the window. But there is no way to know if there is\n        // an intersection (all clauses might match a different doc ID and\n        // there will be no matches in the end) so we should only use\n        // BooleanScorer if matches are very dense\n        costThreshold = context.reader().maxDoc() / 3;\n      }\n\n      if (positiveScorer.cost() < costThreshold) {\n        return null;\n      }\n\n    } else if (numRequiredClauses == 1\n        && numOptionalClauses == 0\n        && query.getMinimumNumberShouldMatch() == 0) {\n      positiveScorer = requiredBulkScorer(context);\n    } else {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    }\n\n    if (positiveScorer == null) {\n      return null;\n    }\n\n    List<Scorer> prohibited = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.isProhibited()) {\n        Scorer scorer = w.scorer(context);\n        if (scorer != null) {\n          prohibited.add(scorer);\n        }\n      }\n    }\n\n    if (prohibited.isEmpty()) {\n      return positiveScorer;\n    } else {\n      Scorer prohibitedScorer = opt(prohibited, 1, true);\n      if (prohibitedScorer.twoPhaseIterator() != null) {\n        // ReqExclBulkScorer can't deal efficiently with two-phased prohibited clauses\n        return null;\n      }\n      return new ReqExclBulkScorer(positiveScorer, prohibitedScorer.iterator());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dca67e06c96e95a8d9ef07418b6299bfd981523b","date":1484639518,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","sourceNew":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    final int numOptionalClauses = query.getClauses(Occur.SHOULD).size();\n    final int numRequiredClauses = query.getClauses(Occur.MUST).size() + query.getClauses(Occur.FILTER).size();\n    \n    BulkScorer positiveScorer;\n    if (numRequiredClauses == 0) {\n      positiveScorer = optionalBulkScorer(context);\n      if (positiveScorer == null) {\n        return null;\n      }\n\n      // TODO: what is the right heuristic here?\n      final long costThreshold;\n      if (query.getMinimumNumberShouldMatch() <= 1) {\n        // when all clauses are optional, use BooleanScorer aggressively\n        // TODO: is there actually a threshold under which we should rather\n        // use the regular scorer?\n        costThreshold = -1;\n      } else {\n        // when a minimum number of clauses should match, BooleanScorer is\n        // going to score all windows that have at least minNrShouldMatch\n        // matches in the window. But there is no way to know if there is\n        // an intersection (all clauses might match a different doc ID and\n        // there will be no matches in the end) so we should only use\n        // BooleanScorer if matches are very dense\n        costThreshold = context.reader().maxDoc() / 3;\n      }\n\n      if (positiveScorer.cost() < costThreshold) {\n        return null;\n      }\n\n    } else if (numRequiredClauses == 1\n        && numOptionalClauses == 0\n        && query.getMinimumNumberShouldMatch() == 0) {\n      positiveScorer = requiredBulkScorer(context);\n    } else {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    }\n\n    if (positiveScorer == null) {\n      return null;\n    }\n\n    List<Scorer> prohibited = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.isProhibited()) {\n        Scorer scorer = w.scorer(context);\n        if (scorer != null) {\n          prohibited.add(scorer);\n        }\n      }\n    }\n\n    if (prohibited.isEmpty()) {\n      return positiveScorer;\n    } else {\n      Scorer prohibitedScorer = prohibited.size() == 1\n          ? prohibited.get(0)\n          : new DisjunctionSumScorer(this, prohibited, false);\n      if (prohibitedScorer.twoPhaseIterator() != null) {\n        // ReqExclBulkScorer can't deal efficiently with two-phased prohibited clauses\n        return null;\n      }\n      return new ReqExclBulkScorer(positiveScorer, prohibitedScorer.iterator());\n    }\n  }\n\n","sourceOld":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    final int numOptionalClauses = query.getClauses(Occur.SHOULD).size();\n    final int numRequiredClauses = query.getClauses(Occur.MUST).size() + query.getClauses(Occur.FILTER).size();\n    \n    BulkScorer positiveScorer;\n    if (numRequiredClauses == 0) {\n      positiveScorer = optionalBulkScorer(context);\n      if (positiveScorer == null) {\n        return null;\n      }\n\n      // TODO: what is the right heuristic here?\n      final long costThreshold;\n      if (query.getMinimumNumberShouldMatch() <= 1) {\n        // when all clauses are optional, use BooleanScorer aggressively\n        // TODO: is there actually a threshold under which we should rather\n        // use the regular scorer?\n        costThreshold = -1;\n      } else {\n        // when a minimum number of clauses should match, BooleanScorer is\n        // going to score all windows that have at least minNrShouldMatch\n        // matches in the window. But there is no way to know if there is\n        // an intersection (all clauses might match a different doc ID and\n        // there will be no matches in the end) so we should only use\n        // BooleanScorer if matches are very dense\n        costThreshold = context.reader().maxDoc() / 3;\n      }\n\n      if (positiveScorer.cost() < costThreshold) {\n        return null;\n      }\n\n    } else if (numRequiredClauses == 1\n        && numOptionalClauses == 0\n        && query.getMinimumNumberShouldMatch() == 0) {\n      positiveScorer = requiredBulkScorer(context);\n    } else {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    }\n\n    if (positiveScorer == null) {\n      return null;\n    }\n\n    List<Scorer> prohibited = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.isProhibited()) {\n        Scorer scorer = w.scorer(context);\n        if (scorer != null) {\n          prohibited.add(scorer);\n        }\n      }\n    }\n\n    if (prohibited.isEmpty()) {\n      return positiveScorer;\n    } else {\n      Scorer prohibitedScorer = opt(prohibited, 1);\n      if (prohibitedScorer.twoPhaseIterator() != null) {\n        // ReqExclBulkScorer can't deal efficiently with two-phased prohibited clauses\n        return null;\n      }\n      return new ReqExclBulkScorer(positiveScorer, prohibitedScorer.iterator());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"302d34f2c66e8d489ee13078305c330cbf67b226","date":1484754357,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","sourceNew":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    final int numOptionalClauses = query.getClauses(Occur.SHOULD).size();\n    final int numRequiredClauses = query.getClauses(Occur.MUST).size() + query.getClauses(Occur.FILTER).size();\n    \n    BulkScorer positiveScorer;\n    if (numRequiredClauses == 0) {\n      positiveScorer = optionalBulkScorer(context);\n      if (positiveScorer == null) {\n        return null;\n      }\n\n      // TODO: what is the right heuristic here?\n      final long costThreshold;\n      if (query.getMinimumNumberShouldMatch() <= 1) {\n        // when all clauses are optional, use BooleanScorer aggressively\n        // TODO: is there actually a threshold under which we should rather\n        // use the regular scorer?\n        costThreshold = -1;\n      } else {\n        // when a minimum number of clauses should match, BooleanScorer is\n        // going to score all windows that have at least minNrShouldMatch\n        // matches in the window. But there is no way to know if there is\n        // an intersection (all clauses might match a different doc ID and\n        // there will be no matches in the end) so we should only use\n        // BooleanScorer if matches are very dense\n        costThreshold = context.reader().maxDoc() / 3;\n      }\n\n      if (positiveScorer.cost() < costThreshold) {\n        return null;\n      }\n\n    } else if (numRequiredClauses == 1\n        && numOptionalClauses == 0\n        && query.getMinimumNumberShouldMatch() == 0) {\n      positiveScorer = requiredBulkScorer(context);\n    } else {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    }\n\n    if (positiveScorer == null) {\n      return null;\n    }\n\n    List<Scorer> prohibited = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.isProhibited()) {\n        Scorer scorer = w.scorer(context);\n        if (scorer != null) {\n          prohibited.add(scorer);\n        }\n      }\n    }\n\n    if (prohibited.isEmpty()) {\n      return positiveScorer;\n    } else {\n      Scorer prohibitedScorer = prohibited.size() == 1\n          ? prohibited.get(0)\n          : new DisjunctionSumScorer(this, prohibited, false);\n      if (prohibitedScorer.twoPhaseIterator() != null) {\n        // ReqExclBulkScorer can't deal efficiently with two-phased prohibited clauses\n        return null;\n      }\n      return new ReqExclBulkScorer(positiveScorer, prohibitedScorer.iterator());\n    }\n  }\n\n","sourceOld":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    final int numOptionalClauses = query.getClauses(Occur.SHOULD).size();\n    final int numRequiredClauses = query.getClauses(Occur.MUST).size() + query.getClauses(Occur.FILTER).size();\n    \n    BulkScorer positiveScorer;\n    if (numRequiredClauses == 0) {\n      positiveScorer = optionalBulkScorer(context);\n      if (positiveScorer == null) {\n        return null;\n      }\n\n      // TODO: what is the right heuristic here?\n      final long costThreshold;\n      if (query.getMinimumNumberShouldMatch() <= 1) {\n        // when all clauses are optional, use BooleanScorer aggressively\n        // TODO: is there actually a threshold under which we should rather\n        // use the regular scorer?\n        costThreshold = -1;\n      } else {\n        // when a minimum number of clauses should match, BooleanScorer is\n        // going to score all windows that have at least minNrShouldMatch\n        // matches in the window. But there is no way to know if there is\n        // an intersection (all clauses might match a different doc ID and\n        // there will be no matches in the end) so we should only use\n        // BooleanScorer if matches are very dense\n        costThreshold = context.reader().maxDoc() / 3;\n      }\n\n      if (positiveScorer.cost() < costThreshold) {\n        return null;\n      }\n\n    } else if (numRequiredClauses == 1\n        && numOptionalClauses == 0\n        && query.getMinimumNumberShouldMatch() == 0) {\n      positiveScorer = requiredBulkScorer(context);\n    } else {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    }\n\n    if (positiveScorer == null) {\n      return null;\n    }\n\n    List<Scorer> prohibited = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.isProhibited()) {\n        Scorer scorer = w.scorer(context);\n        if (scorer != null) {\n          prohibited.add(scorer);\n        }\n      }\n    }\n\n    if (prohibited.isEmpty()) {\n      return positiveScorer;\n    } else {\n      Scorer prohibitedScorer = opt(prohibited, 1);\n      if (prohibitedScorer.twoPhaseIterator() != null) {\n        // ReqExclBulkScorer can't deal efficiently with two-phased prohibited clauses\n        return null;\n      }\n      return new ReqExclBulkScorer(positiveScorer, prohibitedScorer.iterator());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b559eeae2a2a767f75666f9b692659cfe1bf631","date":1533724482,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","sourceNew":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    final int numOptionalClauses = query.getClauses(Occur.SHOULD).size();\n    final int numRequiredClauses = query.getClauses(Occur.MUST).size() + query.getClauses(Occur.FILTER).size();\n    \n    BulkScorer positiveScorer;\n    if (numRequiredClauses == 0) {\n      positiveScorer = optionalBulkScorer(context);\n      if (positiveScorer == null) {\n        return null;\n      }\n\n      // TODO: what is the right heuristic here?\n      final long costThreshold;\n      if (query.getMinimumNumberShouldMatch() <= 1) {\n        // when all clauses are optional, use BooleanScorer aggressively\n        // TODO: is there actually a threshold under which we should rather\n        // use the regular scorer?\n        costThreshold = -1;\n      } else {\n        // when a minimum number of clauses should match, BooleanScorer is\n        // going to score all windows that have at least minNrShouldMatch\n        // matches in the window. But there is no way to know if there is\n        // an intersection (all clauses might match a different doc ID and\n        // there will be no matches in the end) so we should only use\n        // BooleanScorer if matches are very dense\n        costThreshold = context.reader().maxDoc() / 3;\n      }\n\n      if (positiveScorer.cost() < costThreshold) {\n        return null;\n      }\n\n    } else if (numRequiredClauses == 1\n        && numOptionalClauses == 0\n        && query.getMinimumNumberShouldMatch() == 0) {\n      positiveScorer = requiredBulkScorer(context);\n    } else {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    }\n\n    if (positiveScorer == null) {\n      return null;\n    }\n\n    List<Scorer> prohibited = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.isProhibited()) {\n        Scorer scorer = w.scorer(context);\n        if (scorer != null) {\n          prohibited.add(scorer);\n        }\n      }\n    }\n\n    if (prohibited.isEmpty()) {\n      return positiveScorer;\n    } else {\n      Scorer prohibitedScorer = prohibited.size() == 1\n          ? prohibited.get(0)\n          : new DisjunctionSumScorer(this, prohibited, ScoreMode.COMPLETE_NO_SCORES);\n      if (prohibitedScorer.twoPhaseIterator() != null) {\n        // ReqExclBulkScorer can't deal efficiently with two-phased prohibited clauses\n        return null;\n      }\n      return new ReqExclBulkScorer(positiveScorer, prohibitedScorer.iterator());\n    }\n  }\n\n","sourceOld":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    final int numOptionalClauses = query.getClauses(Occur.SHOULD).size();\n    final int numRequiredClauses = query.getClauses(Occur.MUST).size() + query.getClauses(Occur.FILTER).size();\n    \n    BulkScorer positiveScorer;\n    if (numRequiredClauses == 0) {\n      positiveScorer = optionalBulkScorer(context);\n      if (positiveScorer == null) {\n        return null;\n      }\n\n      // TODO: what is the right heuristic here?\n      final long costThreshold;\n      if (query.getMinimumNumberShouldMatch() <= 1) {\n        // when all clauses are optional, use BooleanScorer aggressively\n        // TODO: is there actually a threshold under which we should rather\n        // use the regular scorer?\n        costThreshold = -1;\n      } else {\n        // when a minimum number of clauses should match, BooleanScorer is\n        // going to score all windows that have at least minNrShouldMatch\n        // matches in the window. But there is no way to know if there is\n        // an intersection (all clauses might match a different doc ID and\n        // there will be no matches in the end) so we should only use\n        // BooleanScorer if matches are very dense\n        costThreshold = context.reader().maxDoc() / 3;\n      }\n\n      if (positiveScorer.cost() < costThreshold) {\n        return null;\n      }\n\n    } else if (numRequiredClauses == 1\n        && numOptionalClauses == 0\n        && query.getMinimumNumberShouldMatch() == 0) {\n      positiveScorer = requiredBulkScorer(context);\n    } else {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    }\n\n    if (positiveScorer == null) {\n      return null;\n    }\n\n    List<Scorer> prohibited = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.isProhibited()) {\n        Scorer scorer = w.scorer(context);\n        if (scorer != null) {\n          prohibited.add(scorer);\n        }\n      }\n    }\n\n    if (prohibited.isEmpty()) {\n      return positiveScorer;\n    } else {\n      Scorer prohibitedScorer = prohibited.size() == 1\n          ? prohibited.get(0)\n          : new DisjunctionSumScorer(this, prohibited, false);\n      if (prohibitedScorer.twoPhaseIterator() != null) {\n        // ReqExclBulkScorer can't deal efficiently with two-phased prohibited clauses\n        return null;\n      }\n      return new ReqExclBulkScorer(positiveScorer, prohibitedScorer.iterator());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a13f208db1e7d2e6004f070428b8dc9f533a14c","date":1561708237,"type":3,"author":"Sven Amann","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanWeight#booleanScorer(LeafReaderContext).mjava","sourceNew":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    final int numOptionalClauses = query.getClauses(Occur.SHOULD).size();\n    final int numRequiredClauses = query.getClauses(Occur.MUST).size() + query.getClauses(Occur.FILTER).size();\n    \n    BulkScorer positiveScorer;\n    if (numRequiredClauses == 0) {\n      positiveScorer = optionalBulkScorer(context);\n      if (positiveScorer == null) {\n        return null;\n      }\n\n      // TODO: what is the right heuristic here?\n      final long costThreshold;\n      if (query.getMinimumNumberShouldMatch() <= 1) {\n        // when all clauses are optional, use BooleanScorer aggressively\n        // TODO: is there actually a threshold under which we should rather\n        // use the regular scorer?\n        costThreshold = -1;\n      } else {\n        // when a minimum number of clauses should match, BooleanScorer is\n        // going to score all windows that have at least minNrShouldMatch\n        // matches in the window. But there is no way to know if there is\n        // an intersection (all clauses might match a different doc ID and\n        // there will be no matches in the end) so we should only use\n        // BooleanScorer if matches are very dense\n        costThreshold = context.reader().maxDoc() / 3;\n      }\n\n      if (positiveScorer.cost() < costThreshold) {\n        return null;\n      }\n\n    } else if (numRequiredClauses == 1\n        && numOptionalClauses == 0\n        && query.getMinimumNumberShouldMatch() == 0) {\n      positiveScorer = requiredBulkScorer(context);\n    } else {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    }\n\n    if (positiveScorer == null) {\n      return null;\n    }\n\n    List<Scorer> prohibited = new ArrayList<>();\n    for (WeightedBooleanClause wc : weightedClauses) {\n      Weight w = wc.weight;\n      BooleanClause c = wc.clause;\n      if (c.isProhibited()) {\n        Scorer scorer = w.scorer(context);\n        if (scorer != null) {\n          prohibited.add(scorer);\n        }\n      }\n    }\n\n    if (prohibited.isEmpty()) {\n      return positiveScorer;\n    } else {\n      Scorer prohibitedScorer = prohibited.size() == 1\n          ? prohibited.get(0)\n          : new DisjunctionSumScorer(this, prohibited, ScoreMode.COMPLETE_NO_SCORES);\n      if (prohibitedScorer.twoPhaseIterator() != null) {\n        // ReqExclBulkScorer can't deal efficiently with two-phased prohibited clauses\n        return null;\n      }\n      return new ReqExclBulkScorer(positiveScorer, prohibitedScorer.iterator());\n    }\n  }\n\n","sourceOld":"  /** Try to build a boolean scorer for this weight. Returns null if {@link BooleanScorer}\n   *  cannot be used. */\n  BulkScorer booleanScorer(LeafReaderContext context) throws IOException {\n    final int numOptionalClauses = query.getClauses(Occur.SHOULD).size();\n    final int numRequiredClauses = query.getClauses(Occur.MUST).size() + query.getClauses(Occur.FILTER).size();\n    \n    BulkScorer positiveScorer;\n    if (numRequiredClauses == 0) {\n      positiveScorer = optionalBulkScorer(context);\n      if (positiveScorer == null) {\n        return null;\n      }\n\n      // TODO: what is the right heuristic here?\n      final long costThreshold;\n      if (query.getMinimumNumberShouldMatch() <= 1) {\n        // when all clauses are optional, use BooleanScorer aggressively\n        // TODO: is there actually a threshold under which we should rather\n        // use the regular scorer?\n        costThreshold = -1;\n      } else {\n        // when a minimum number of clauses should match, BooleanScorer is\n        // going to score all windows that have at least minNrShouldMatch\n        // matches in the window. But there is no way to know if there is\n        // an intersection (all clauses might match a different doc ID and\n        // there will be no matches in the end) so we should only use\n        // BooleanScorer if matches are very dense\n        costThreshold = context.reader().maxDoc() / 3;\n      }\n\n      if (positiveScorer.cost() < costThreshold) {\n        return null;\n      }\n\n    } else if (numRequiredClauses == 1\n        && numOptionalClauses == 0\n        && query.getMinimumNumberShouldMatch() == 0) {\n      positiveScorer = requiredBulkScorer(context);\n    } else {\n      // TODO: there are some cases where BooleanScorer\n      // would handle conjunctions faster than\n      // BooleanScorer2...\n      return null;\n    }\n\n    if (positiveScorer == null) {\n      return null;\n    }\n\n    List<Scorer> prohibited = new ArrayList<>();\n    Iterator<BooleanClause> cIter = query.iterator();\n    for (Weight w  : weights) {\n      BooleanClause c =  cIter.next();\n      if (c.isProhibited()) {\n        Scorer scorer = w.scorer(context);\n        if (scorer != null) {\n          prohibited.add(scorer);\n        }\n      }\n    }\n\n    if (prohibited.isEmpty()) {\n      return positiveScorer;\n    } else {\n      Scorer prohibitedScorer = prohibited.size() == 1\n          ? prohibited.get(0)\n          : new DisjunctionSumScorer(this, prohibited, ScoreMode.COMPLETE_NO_SCORES);\n      if (prohibitedScorer.twoPhaseIterator() != null) {\n        // ReqExclBulkScorer can't deal efficiently with two-phased prohibited clauses\n        return null;\n      }\n      return new ReqExclBulkScorer(positiveScorer, prohibitedScorer.iterator());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5b559eeae2a2a767f75666f9b692659cfe1bf631":["dca67e06c96e95a8d9ef07418b6299bfd981523b"],"0aa571364c08edee91e7ca61b5ff6ec29684afc4":["5c83732c32d5a6ea6a1ca930daa241ddec2f4c9c"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5c83732c32d5a6ea6a1ca930daa241ddec2f4c9c":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"dca67e06c96e95a8d9ef07418b6299bfd981523b":["c8a0e442f7b61f811680273b25da95994a724466"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c8a0e442f7b61f811680273b25da95994a724466":["b2262f0d8ead49d04485950fba849e166dbe28fb"],"3a13f208db1e7d2e6004f070428b8dc9f533a14c":["5b559eeae2a2a767f75666f9b692659cfe1bf631"],"b2262f0d8ead49d04485950fba849e166dbe28fb":["0aa571364c08edee91e7ca61b5ff6ec29684afc4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b2262f0d8ead49d04485950fba849e166dbe28fb","c8a0e442f7b61f811680273b25da95994a724466"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a13f208db1e7d2e6004f070428b8dc9f533a14c"],"302d34f2c66e8d489ee13078305c330cbf67b226":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","dca67e06c96e95a8d9ef07418b6299bfd981523b"]},"commit2Childs":{"5b559eeae2a2a767f75666f9b692659cfe1bf631":["3a13f208db1e7d2e6004f070428b8dc9f533a14c"],"0aa571364c08edee91e7ca61b5ff6ec29684afc4":["b2262f0d8ead49d04485950fba849e166dbe28fb"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["5c83732c32d5a6ea6a1ca930daa241ddec2f4c9c"],"5c83732c32d5a6ea6a1ca930daa241ddec2f4c9c":["0aa571364c08edee91e7ca61b5ff6ec29684afc4"],"dca67e06c96e95a8d9ef07418b6299bfd981523b":["5b559eeae2a2a767f75666f9b692659cfe1bf631","302d34f2c66e8d489ee13078305c330cbf67b226"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"c8a0e442f7b61f811680273b25da95994a724466":["dca67e06c96e95a8d9ef07418b6299bfd981523b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"3a13f208db1e7d2e6004f070428b8dc9f533a14c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b2262f0d8ead49d04485950fba849e166dbe28fb":["c8a0e442f7b61f811680273b25da95994a724466","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["302d34f2c66e8d489ee13078305c330cbf67b226"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"302d34f2c66e8d489ee13078305c330cbf67b226":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","302d34f2c66e8d489ee13078305c330cbf67b226"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}