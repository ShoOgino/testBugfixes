{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.ContainsVisitor#visit(Cell,Bits).mjava","commits":[{"id":"69da1c397a55d488a19e555c8da635417e2dfd47","date":1365020983,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.ContainsVisitor#visit(Cell,Bits).mjava","pathOld":"/dev/null","sourceNew":"    /** This is the primary algorithm; recursive.  Returns null if finds none. */\n    private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {\n\n      if (termsEnum == null)//signals all done\n        return null;\n\n      //Leaf docs match all query shape\n      SmallDocSet leafDocs = getLeafDocs(cell, acceptContains);\n\n      // Get the AND of all child results\n      SmallDocSet combinedSubResults = null;\n      Collection<Cell> subCells = cell.getSubCells(queryShape);\n      for (Cell subCell : subCells) {\n        if (!seekExact(subCell))\n          combinedSubResults = null;\n        else if (subCell.getLevel() == detailLevel)\n          combinedSubResults = getDocs(subCell, acceptContains);\n        else if (subCell.getShapeRel() == SpatialRelation.WITHIN)\n          combinedSubResults = getLeafDocs(subCell, acceptContains);\n        else\n          combinedSubResults = visit(subCell, acceptContains); //recursion\n\n        if (combinedSubResults == null)\n          break;\n        acceptContains = combinedSubResults;//has the 'AND' effect on next iteration\n      }\n\n      // Result: OR the leaf docs with AND of all child results\n      if (combinedSubResults != null) {\n        if (leafDocs == null)\n          return combinedSubResults;\n        return leafDocs.union(combinedSubResults);\n      }\n      return leafDocs;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0378a5fb14e1ef14d663bd48cdb3ba29a9053be9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0378a5fb14e1ef14d663bd48cdb3ba29a9053be9","date":1371743283,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.ContainsVisitor#visit(Cell,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.ContainsVisitor#visit(Cell,Bits).mjava","sourceNew":"    /** This is the primary algorithm; recursive.  Returns null if finds none. */\n    private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {\n\n      if (termsEnum == null)//signals all done\n        return null;\n\n      // Leaf docs match all query shape\n      SmallDocSet leafDocs = getLeafDocs(cell, acceptContains);\n\n      // Get the AND of all child results (into combinedSubResults)\n      SmallDocSet combinedSubResults = null;\n      //   Optimization: use null subCellsFilter when we know cell is within the query shape.\n      Shape subCellsFilter = queryShape;\n      if (cell.getLevel() != 0 && ((cell.getShapeRel() == null || cell.getShapeRel() == SpatialRelation.WITHIN))) {\n        subCellsFilter = null;\n        assert cell.getShape().relate(queryShape) == SpatialRelation.WITHIN;\n      }\n      Collection <Cell> subCells = cell.getSubCells(subCellsFilter);\n      for (Cell subCell : subCells) {\n        if (!seekExact(subCell))\n          combinedSubResults = null;\n        else if (subCell.getLevel() == detailLevel)\n          combinedSubResults = getDocs(subCell, acceptContains);\n        else if (!multiOverlappingIndexedShapes &&\n            subCell.getShapeRel() == SpatialRelation.WITHIN)\n          combinedSubResults = getLeafDocs(subCell, acceptContains);\n        else\n          combinedSubResults = visit(subCell, acceptContains); //recursion\n\n        if (combinedSubResults == null)\n          break;\n        acceptContains = combinedSubResults;//has the 'AND' effect on next iteration\n      }\n\n      // Result: OR the leaf docs with AND of all child results\n      if (combinedSubResults != null) {\n        if (leafDocs == null)\n          return combinedSubResults;\n        return leafDocs.union(combinedSubResults);//union is 'or'\n      }\n      return leafDocs;\n    }\n\n","sourceOld":"    /** This is the primary algorithm; recursive.  Returns null if finds none. */\n    private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {\n\n      if (termsEnum == null)//signals all done\n        return null;\n\n      //Leaf docs match all query shape\n      SmallDocSet leafDocs = getLeafDocs(cell, acceptContains);\n\n      // Get the AND of all child results\n      SmallDocSet combinedSubResults = null;\n      Collection<Cell> subCells = cell.getSubCells(queryShape);\n      for (Cell subCell : subCells) {\n        if (!seekExact(subCell))\n          combinedSubResults = null;\n        else if (subCell.getLevel() == detailLevel)\n          combinedSubResults = getDocs(subCell, acceptContains);\n        else if (subCell.getShapeRel() == SpatialRelation.WITHIN)\n          combinedSubResults = getLeafDocs(subCell, acceptContains);\n        else\n          combinedSubResults = visit(subCell, acceptContains); //recursion\n\n        if (combinedSubResults == null)\n          break;\n        acceptContains = combinedSubResults;//has the 'AND' effect on next iteration\n      }\n\n      // Result: OR the leaf docs with AND of all child results\n      if (combinedSubResults != null) {\n        if (leafDocs == null)\n          return combinedSubResults;\n        return leafDocs.union(combinedSubResults);\n      }\n      return leafDocs;\n    }\n\n","bugFix":["69da1c397a55d488a19e555c8da635417e2dfd47"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.ContainsVisitor#visit(Cell,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.ContainsVisitor#visit(Cell,Bits).mjava","sourceNew":"    /** This is the primary algorithm; recursive.  Returns null if finds none. */\n    private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {\n\n      if (termsEnum == null)//signals all done\n        return null;\n\n      // Leaf docs match all query shape\n      SmallDocSet leafDocs = getLeafDocs(cell, acceptContains);\n\n      // Get the AND of all child results (into combinedSubResults)\n      SmallDocSet combinedSubResults = null;\n      //   Optimization: use null subCellsFilter when we know cell is within the query shape.\n      Shape subCellsFilter = queryShape;\n      if (cell.getLevel() != 0 && ((cell.getShapeRel() == null || cell.getShapeRel() == SpatialRelation.WITHIN))) {\n        subCellsFilter = null;\n        assert cell.getShape().relate(queryShape) == SpatialRelation.WITHIN;\n      }\n      Collection <Cell> subCells = cell.getSubCells(subCellsFilter);\n      for (Cell subCell : subCells) {\n        if (!seekExact(subCell))\n          combinedSubResults = null;\n        else if (subCell.getLevel() == detailLevel)\n          combinedSubResults = getDocs(subCell, acceptContains);\n        else if (!multiOverlappingIndexedShapes &&\n            subCell.getShapeRel() == SpatialRelation.WITHIN)\n          combinedSubResults = getLeafDocs(subCell, acceptContains);\n        else\n          combinedSubResults = visit(subCell, acceptContains); //recursion\n\n        if (combinedSubResults == null)\n          break;\n        acceptContains = combinedSubResults;//has the 'AND' effect on next iteration\n      }\n\n      // Result: OR the leaf docs with AND of all child results\n      if (combinedSubResults != null) {\n        if (leafDocs == null)\n          return combinedSubResults;\n        return leafDocs.union(combinedSubResults);//union is 'or'\n      }\n      return leafDocs;\n    }\n\n","sourceOld":"    /** This is the primary algorithm; recursive.  Returns null if finds none. */\n    private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {\n\n      if (termsEnum == null)//signals all done\n        return null;\n\n      //Leaf docs match all query shape\n      SmallDocSet leafDocs = getLeafDocs(cell, acceptContains);\n\n      // Get the AND of all child results\n      SmallDocSet combinedSubResults = null;\n      Collection<Cell> subCells = cell.getSubCells(queryShape);\n      for (Cell subCell : subCells) {\n        if (!seekExact(subCell))\n          combinedSubResults = null;\n        else if (subCell.getLevel() == detailLevel)\n          combinedSubResults = getDocs(subCell, acceptContains);\n        else if (subCell.getShapeRel() == SpatialRelation.WITHIN)\n          combinedSubResults = getLeafDocs(subCell, acceptContains);\n        else\n          combinedSubResults = visit(subCell, acceptContains); //recursion\n\n        if (combinedSubResults == null)\n          break;\n        acceptContains = combinedSubResults;//has the 'AND' effect on next iteration\n      }\n\n      // Result: OR the leaf docs with AND of all child results\n      if (combinedSubResults != null) {\n        if (leafDocs == null)\n          return combinedSubResults;\n        return leafDocs.union(combinedSubResults);\n      }\n      return leafDocs;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6","date":1397789149,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.ContainsVisitor#visit(Cell,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.ContainsVisitor#visit(Cell,Bits).mjava","sourceNew":"    /** This is the primary algorithm; recursive.  Returns null if finds none. */\n    private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {\n\n      if (termsEnum == null)//signals all done\n        return null;\n\n      // Leaf docs match all query shape\n      SmallDocSet leafDocs = getLeafDocs(cell, acceptContains);\n\n      // Get the AND of all child results (into combinedSubResults)\n      SmallDocSet combinedSubResults = null;\n      //   Optimization: use null subCellsFilter when we know cell is within the query shape.\n      Shape subCellsFilter = queryShape;\n      if (cell.getLevel() != 0 && ((cell.getShapeRel() == null || cell.getShapeRel() == SpatialRelation.WITHIN))) {\n        subCellsFilter = null;\n        assert cell.getShape().relate(queryShape) == SpatialRelation.WITHIN;\n      }\n      CellIterator subCells = cell.getNextLevelCells(subCellsFilter);\n      while (subCells.hasNext()) {\n        Cell subCell = subCells.next();\n        if (!seekExact(subCell))\n          combinedSubResults = null;\n        else if (subCell.getLevel() == detailLevel)\n          combinedSubResults = getDocs(subCell, acceptContains);\n        else if (!multiOverlappingIndexedShapes &&\n            subCell.getShapeRel() == SpatialRelation.WITHIN)\n          combinedSubResults = getLeafDocs(subCell, acceptContains);\n        else\n          combinedSubResults = visit(subCell, acceptContains); //recursion\n\n        if (combinedSubResults == null)\n          break;\n        acceptContains = combinedSubResults;//has the 'AND' effect on next iteration\n      }\n\n      // Result: OR the leaf docs with AND of all child results\n      if (combinedSubResults != null) {\n        if (leafDocs == null)\n          return combinedSubResults;\n        return leafDocs.union(combinedSubResults);//union is 'or'\n      }\n      return leafDocs;\n    }\n\n","sourceOld":"    /** This is the primary algorithm; recursive.  Returns null if finds none. */\n    private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {\n\n      if (termsEnum == null)//signals all done\n        return null;\n\n      // Leaf docs match all query shape\n      SmallDocSet leafDocs = getLeafDocs(cell, acceptContains);\n\n      // Get the AND of all child results (into combinedSubResults)\n      SmallDocSet combinedSubResults = null;\n      //   Optimization: use null subCellsFilter when we know cell is within the query shape.\n      Shape subCellsFilter = queryShape;\n      if (cell.getLevel() != 0 && ((cell.getShapeRel() == null || cell.getShapeRel() == SpatialRelation.WITHIN))) {\n        subCellsFilter = null;\n        assert cell.getShape().relate(queryShape) == SpatialRelation.WITHIN;\n      }\n      Collection <Cell> subCells = cell.getSubCells(subCellsFilter);\n      for (Cell subCell : subCells) {\n        if (!seekExact(subCell))\n          combinedSubResults = null;\n        else if (subCell.getLevel() == detailLevel)\n          combinedSubResults = getDocs(subCell, acceptContains);\n        else if (!multiOverlappingIndexedShapes &&\n            subCell.getShapeRel() == SpatialRelation.WITHIN)\n          combinedSubResults = getLeafDocs(subCell, acceptContains);\n        else\n          combinedSubResults = visit(subCell, acceptContains); //recursion\n\n        if (combinedSubResults == null)\n          break;\n        acceptContains = combinedSubResults;//has the 'AND' effect on next iteration\n      }\n\n      // Result: OR the leaf docs with AND of all child results\n      if (combinedSubResults != null) {\n        if (leafDocs == null)\n          return combinedSubResults;\n        return leafDocs.union(combinedSubResults);//union is 'or'\n      }\n      return leafDocs;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0","date":1426015524,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.ContainsVisitor#visit(Cell,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.ContainsVisitor#visit(Cell,Bits).mjava","sourceNew":"    /** This is the primary algorithm; recursive.  Returns null if finds none. */\n    private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {\n\n      if (thisTerm == null)//signals all done\n        return null;\n\n      // Get the AND of all child results (into combinedSubResults)\n      SmallDocSet combinedSubResults = null;\n      //   Optimization: use null subCellsFilter when we know cell is within the query shape.\n      Shape subCellsFilter = queryShape;\n      if (cell.getLevel() != 0 && ((cell.getShapeRel() == null || cell.getShapeRel() == SpatialRelation.WITHIN))) {\n        subCellsFilter = null;\n        assert cell.getShape().relate(queryShape) == SpatialRelation.WITHIN;\n      }\n      CellIterator subCells = cell.getNextLevelCells(subCellsFilter);\n      while (subCells.hasNext()) {\n        Cell subCell = subCells.next();\n        if (!seek(subCell)) {\n          combinedSubResults = null;\n        } else if (subCell.getLevel() == detailLevel) {\n          combinedSubResults = getDocs(subCell, acceptContains);\n        } else if (!multiOverlappingIndexedShapes &&\n            subCell.getShapeRel() == SpatialRelation.WITHIN) {\n          combinedSubResults = getLeafDocs(subCell, acceptContains);\n        } else {\n          //OR the leaf docs with all child results\n          SmallDocSet leafDocs = getLeafDocs(subCell, acceptContains);\n          SmallDocSet subDocs = visit(subCell, acceptContains); //recursion\n          combinedSubResults = union(leafDocs, subDocs);\n        }\n\n        if (combinedSubResults == null)\n          break;\n        acceptContains = combinedSubResults;//has the 'AND' effect on next iteration\n      }\n\n      return combinedSubResults;\n    }\n\n","sourceOld":"    /** This is the primary algorithm; recursive.  Returns null if finds none. */\n    private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {\n\n      if (termsEnum == null)//signals all done\n        return null;\n\n      // Leaf docs match all query shape\n      SmallDocSet leafDocs = getLeafDocs(cell, acceptContains);\n\n      // Get the AND of all child results (into combinedSubResults)\n      SmallDocSet combinedSubResults = null;\n      //   Optimization: use null subCellsFilter when we know cell is within the query shape.\n      Shape subCellsFilter = queryShape;\n      if (cell.getLevel() != 0 && ((cell.getShapeRel() == null || cell.getShapeRel() == SpatialRelation.WITHIN))) {\n        subCellsFilter = null;\n        assert cell.getShape().relate(queryShape) == SpatialRelation.WITHIN;\n      }\n      CellIterator subCells = cell.getNextLevelCells(subCellsFilter);\n      while (subCells.hasNext()) {\n        Cell subCell = subCells.next();\n        if (!seekExact(subCell))\n          combinedSubResults = null;\n        else if (subCell.getLevel() == detailLevel)\n          combinedSubResults = getDocs(subCell, acceptContains);\n        else if (!multiOverlappingIndexedShapes &&\n            subCell.getShapeRel() == SpatialRelation.WITHIN)\n          combinedSubResults = getLeafDocs(subCell, acceptContains);\n        else\n          combinedSubResults = visit(subCell, acceptContains); //recursion\n\n        if (combinedSubResults == null)\n          break;\n        acceptContains = combinedSubResults;//has the 'AND' effect on next iteration\n      }\n\n      // Result: OR the leaf docs with AND of all child results\n      if (combinedSubResults != null) {\n        if (leafDocs == null)\n          return combinedSubResults;\n        return leafDocs.union(combinedSubResults);//union is 'or'\n      }\n      return leafDocs;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.ContainsVisitor#visit(Cell,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.ContainsVisitor#visit(Cell,Bits).mjava","sourceNew":"    /** This is the primary algorithm; recursive.  Returns null if finds none. */\n    private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {\n\n      if (thisTerm == null)//signals all done\n        return null;\n\n      // Get the AND of all child results (into combinedSubResults)\n      SmallDocSet combinedSubResults = null;\n      //   Optimization: use null subCellsFilter when we know cell is within the query shape.\n      Shape subCellsFilter = queryShape;\n      if (cell.getLevel() != 0 && ((cell.getShapeRel() == null || cell.getShapeRel() == SpatialRelation.WITHIN))) {\n        subCellsFilter = null;\n        assert cell.getShape().relate(queryShape) == SpatialRelation.WITHIN;\n      }\n      CellIterator subCells = cell.getNextLevelCells(subCellsFilter);\n      while (subCells.hasNext()) {\n        Cell subCell = subCells.next();\n        if (!seek(subCell)) {\n          combinedSubResults = null;\n        } else if (subCell.getLevel() == detailLevel) {\n          combinedSubResults = getDocs(subCell, acceptContains);\n        } else if (!multiOverlappingIndexedShapes &&\n            subCell.getShapeRel() == SpatialRelation.WITHIN) {\n          combinedSubResults = getLeafDocs(subCell, acceptContains);\n        } else {\n          //OR the leaf docs with all child results\n          SmallDocSet leafDocs = getLeafDocs(subCell, acceptContains);\n          SmallDocSet subDocs = visit(subCell, acceptContains); //recursion\n          combinedSubResults = union(leafDocs, subDocs);\n        }\n\n        if (combinedSubResults == null)\n          break;\n        acceptContains = combinedSubResults;//has the 'AND' effect on next iteration\n      }\n\n      return combinedSubResults;\n    }\n\n","sourceOld":"    /** This is the primary algorithm; recursive.  Returns null if finds none. */\n    private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {\n\n      if (termsEnum == null)//signals all done\n        return null;\n\n      // Leaf docs match all query shape\n      SmallDocSet leafDocs = getLeafDocs(cell, acceptContains);\n\n      // Get the AND of all child results (into combinedSubResults)\n      SmallDocSet combinedSubResults = null;\n      //   Optimization: use null subCellsFilter when we know cell is within the query shape.\n      Shape subCellsFilter = queryShape;\n      if (cell.getLevel() != 0 && ((cell.getShapeRel() == null || cell.getShapeRel() == SpatialRelation.WITHIN))) {\n        subCellsFilter = null;\n        assert cell.getShape().relate(queryShape) == SpatialRelation.WITHIN;\n      }\n      CellIterator subCells = cell.getNextLevelCells(subCellsFilter);\n      while (subCells.hasNext()) {\n        Cell subCell = subCells.next();\n        if (!seekExact(subCell))\n          combinedSubResults = null;\n        else if (subCell.getLevel() == detailLevel)\n          combinedSubResults = getDocs(subCell, acceptContains);\n        else if (!multiOverlappingIndexedShapes &&\n            subCell.getShapeRel() == SpatialRelation.WITHIN)\n          combinedSubResults = getLeafDocs(subCell, acceptContains);\n        else\n          combinedSubResults = visit(subCell, acceptContains); //recursion\n\n        if (combinedSubResults == null)\n          break;\n        acceptContains = combinedSubResults;//has the 'AND' effect on next iteration\n      }\n\n      // Result: OR the leaf docs with AND of all child results\n      if (combinedSubResults != null) {\n        if (leafDocs == null)\n          return combinedSubResults;\n        return leafDocs.union(combinedSubResults);//union is 'or'\n      }\n      return leafDocs;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"672b198fc3dce868916c727917cae58c2906763d","date":1443669960,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeQuery.ContainsVisitor#visit(Cell,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.ContainsVisitor#visit(Cell,Bits).mjava","sourceNew":"    /** This is the primary algorithm; recursive.  Returns null if finds none. */\n    private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {\n\n      if (thisTerm == null)//signals all done\n        return null;\n\n      // Get the AND of all child results (into combinedSubResults)\n      SmallDocSet combinedSubResults = null;\n      //   Optimization: use null subCellsFilter when we know cell is within the query shape.\n      Shape subCellsFilter = queryShape;\n      if (cell.getLevel() != 0 && ((cell.getShapeRel() == null || cell.getShapeRel() == SpatialRelation.WITHIN))) {\n        subCellsFilter = null;\n        assert cell.getShape().relate(queryShape) == SpatialRelation.WITHIN;\n      }\n      CellIterator subCells = cell.getNextLevelCells(subCellsFilter);\n      while (subCells.hasNext()) {\n        Cell subCell = subCells.next();\n        if (!seek(subCell)) {\n          combinedSubResults = null;\n        } else if (subCell.getLevel() == detailLevel) {\n          combinedSubResults = getDocs(subCell, acceptContains);\n        } else if (!multiOverlappingIndexedShapes &&\n            subCell.getShapeRel() == SpatialRelation.WITHIN) {\n          combinedSubResults = getLeafDocs(subCell, acceptContains);\n        } else {\n          //OR the leaf docs with all child results\n          SmallDocSet leafDocs = getLeafDocs(subCell, acceptContains);\n          SmallDocSet subDocs = visit(subCell, acceptContains); //recursion\n          combinedSubResults = union(leafDocs, subDocs);\n        }\n\n        if (combinedSubResults == null)\n          break;\n        acceptContains = combinedSubResults;//has the 'AND' effect on next iteration\n      }\n\n      return combinedSubResults;\n    }\n\n","sourceOld":"    /** This is the primary algorithm; recursive.  Returns null if finds none. */\n    private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {\n\n      if (thisTerm == null)//signals all done\n        return null;\n\n      // Get the AND of all child results (into combinedSubResults)\n      SmallDocSet combinedSubResults = null;\n      //   Optimization: use null subCellsFilter when we know cell is within the query shape.\n      Shape subCellsFilter = queryShape;\n      if (cell.getLevel() != 0 && ((cell.getShapeRel() == null || cell.getShapeRel() == SpatialRelation.WITHIN))) {\n        subCellsFilter = null;\n        assert cell.getShape().relate(queryShape) == SpatialRelation.WITHIN;\n      }\n      CellIterator subCells = cell.getNextLevelCells(subCellsFilter);\n      while (subCells.hasNext()) {\n        Cell subCell = subCells.next();\n        if (!seek(subCell)) {\n          combinedSubResults = null;\n        } else if (subCell.getLevel() == detailLevel) {\n          combinedSubResults = getDocs(subCell, acceptContains);\n        } else if (!multiOverlappingIndexedShapes &&\n            subCell.getShapeRel() == SpatialRelation.WITHIN) {\n          combinedSubResults = getLeafDocs(subCell, acceptContains);\n        } else {\n          //OR the leaf docs with all child results\n          SmallDocSet leafDocs = getLeafDocs(subCell, acceptContains);\n          SmallDocSet subDocs = visit(subCell, acceptContains); //recursion\n          combinedSubResults = union(leafDocs, subDocs);\n        }\n\n        if (combinedSubResults == null)\n          break;\n        acceptContains = combinedSubResults;//has the 'AND' effect on next iteration\n      }\n\n      return combinedSubResults;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6","11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["69da1c397a55d488a19e555c8da635417e2dfd47","0378a5fb14e1ef14d663bd48cdb3ba29a9053be9"],"672b198fc3dce868916c727917cae58c2906763d":["11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"69da1c397a55d488a19e555c8da635417e2dfd47":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["0378a5fb14e1ef14d663bd48cdb3ba29a9053be9"],"0378a5fb14e1ef14d663bd48cdb3ba29a9053be9":["69da1c397a55d488a19e555c8da635417e2dfd47"],"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0":["8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["672b198fc3dce868916c727917cae58c2906763d"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"69da1c397a55d488a19e555c8da635417e2dfd47":["37a0f60745e53927c4c876cfe5b5a58170f0646c","0378a5fb14e1ef14d663bd48cdb3ba29a9053be9"],"672b198fc3dce868916c727917cae58c2906763d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["69da1c397a55d488a19e555c8da635417e2dfd47"],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"0378a5fb14e1ef14d663bd48cdb3ba29a9053be9":["37a0f60745e53927c4c876cfe5b5a58170f0646c","8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","672b198fc3dce868916c727917cae58c2906763d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}