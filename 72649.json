{"path":"src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","commits":[{"id":"183ba46e9837e95333f35c590df5d02d0071c076","date":1164074105,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"/dev/null","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  public void testDateMath() {\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n    \n    assertU(adoc(\"id\", \"1\",  \"bday\", \"1976-07-04T12:08:56.235Z\"));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"487bcb36f5ba67741dd4dc6ebea3dc32420c4fb1","date":1185690521,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  public void testDateMath() {\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  public void testDateMath() {\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n    \n    assertU(adoc(\"id\", \"1\",  \"bday\", \"1976-07-04T12:08:56.235Z\"));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  public void testDateMath() {\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  public void testDateMath() {\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"487bcb36f5ba67741dd4dc6ebea3dc32420c4fb1":["183ba46e9837e95333f35c590df5d02d0071c076"],"183ba46e9837e95333f35c590df5d02d0071c076":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["487bcb36f5ba67741dd4dc6ebea3dc32420c4fb1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"487bcb36f5ba67741dd4dc6ebea3dc32420c4fb1":["ad94625fb8d088209f46650c8097196fec67f00c"],"183ba46e9837e95333f35c590df5d02d0071c076":["487bcb36f5ba67741dd4dc6ebea3dc32420c4fb1"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["183ba46e9837e95333f35c590df5d02d0071c076"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}