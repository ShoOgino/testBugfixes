{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(Builder[T],int,int,float).mjava","commits":[{"id":"1abb939fb41b2fe4f89fd518f3da288c0213341d","date":1435657417,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(Builder[T],int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(Builder<T> builder, int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    Arc<T> arc = new Arc<>();\n\n    final BytesReader r = getBytesReader();\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                                                             PackedInts.bitsRequired(builder.bytes.getPosition()), (int) (1 + builder.nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=builder.nodeCount;node++) {\n      newNodeAddress.set(node, 1 + builder.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<>(inputType, outputs, builder.bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int) builder.nodeCount;node>=1;node--) {\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<>();\n\n    final BytesReader r = getBytesReader();\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                       PackedInts.bitsRequired(this.bytes.getPosition()), (int) (1 + nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<>(inputType, outputs, bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int)nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6244579a467d5f2673ac98265d74bddbea1a8114","date":1478786509,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(Builder[T],int,int,float).mjava","sourceNew":null,"sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(Builder<T> builder, int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    Arc<T> arc = new Arc<>();\n\n    final BytesReader r = getBytesReader();\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                                                             PackedInts.bitsRequired(builder.bytes.getPosition()), (int) (1 + builder.nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=builder.nodeCount;node++) {\n      newNodeAddress.set(node, 1 + builder.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<>(inputType, outputs, builder.bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int) builder.nodeCount;node>=1;node--) {\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(Builder[T],int,int,float).mjava","sourceNew":null,"sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(Builder<T> builder, int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    Arc<T> arc = new Arc<>();\n\n    final BytesReader r = getBytesReader();\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                                                             PackedInts.bitsRequired(builder.bytes.getPosition()), (int) (1 + builder.nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=builder.nodeCount;node++) {\n      newNodeAddress.set(node, 1 + builder.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<>(inputType, outputs, builder.bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int) builder.nodeCount;node>=1;node--) {\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6244579a467d5f2673ac98265d74bddbea1a8114":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["1abb939fb41b2fe4f89fd518f3da288c0213341d","6244579a467d5f2673ac98265d74bddbea1a8114"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6244579a467d5f2673ac98265d74bddbea1a8114"]},"commit2Childs":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["6244579a467d5f2673ac98265d74bddbea1a8114","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"6244579a467d5f2673ac98265d74bddbea1a8114":["199dfa410f1fdbfd3294106b04096cce5ed34b21","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}