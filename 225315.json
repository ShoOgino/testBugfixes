{"path":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","commits":[{"id":"6066dbe072ec5334ff5824f474e9d3abd1620fb7","date":1278709584,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      int format = input.readInt();\n  \n      // check that it is a format we can understand\n      if (format < SegmentInfos.CURRENT_FORMAT)\n        throw new CorruptIndexException(\"Unknown (newer than us?) format version: \" + format);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        infos.add(new SegmentInfo(directory, format, input, codecs));\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0cd8367c3d48e4b63dee1895a261d4986c716bbb","date":1279637747,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      int format = input.readInt();\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        infos.add(new SegmentInfo(directory, format, input, codecs));\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      int format = input.readInt();\n  \n      // check that it is a format we can understand\n      if (format < SegmentInfos.CURRENT_FORMAT)\n        throw new CorruptIndexException(\"Unknown (newer than us?) format version: \" + format);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        infos.add(new SegmentInfo(directory, format, input, codecs));\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      int format = input.readInt();\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        infos.add(new SegmentInfo(directory, format, input, codecs));\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94cb8b3ec0439dfd8e179637ee4191cd9c6227e5","date":1292711882,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        infos.add(new SegmentInfo(directory, format, input, codecs));\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      int format = input.readInt();\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        infos.add(new SegmentInfo(directory, format, input, codecs));\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        infos.add(new SegmentInfo(directory, format, input, codecs));\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      int format = input.readInt();\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        infos.add(new SegmentInfo(directory, format, input, codecs));\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        infos.add(new SegmentInfo(directory, format, input, codecs));\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      int format = input.readInt();\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        infos.add(new SegmentInfo(directory, format, input, codecs));\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9dc373b96fc96e6300e2f5af947f6998e6aa6a6","date":1295759448,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        infos.add(new SegmentInfo(directory, format, input, codecs));\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9b72f7c3d7827c64dd4ec580ded81778da361d","date":1295897920,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        infos.add(new SegmentInfo(directory, format, input, codecs));\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        infos.add(new SegmentInfo(directory, format, input, codecs));\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1224a4027481acce15495b03bce9b48b93b42722","date":1300792329,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n  \n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos, IOContext context) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName, context);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0aab6e810b4b0d3743d6a048be0602801f4b3920","date":1308671625,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca791416b7d9cc876025db4aea7ec799e8167c0e","date":1308701127,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_FLEX) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4aa91b365d4819eed673110a366d7ce611fdab1b","date":1308730304,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_FLEX) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos, IOContext context) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName, context);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos, IOContext context) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName, context);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b9dc373b96fc96e6300e2f5af947f6998e6aa6a6":["94cb8b3ec0439dfd8e179637ee4191cd9c6227e5"],"0aab6e810b4b0d3743d6a048be0602801f4b3920":["1224a4027481acce15495b03bce9b48b93b42722"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["1224a4027481acce15495b03bce9b48b93b42722"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["0cd8367c3d48e4b63dee1895a261d4986c716bbb","94cb8b3ec0439dfd8e179637ee4191cd9c6227e5"],"0cd8367c3d48e4b63dee1895a261d4986c716bbb":["6066dbe072ec5334ff5824f474e9d3abd1620fb7"],"5f4e87790277826a2aea119328600dfb07761f32":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0cd8367c3d48e4b63dee1895a261d4986c716bbb"],"2553b00f699380c64959ccb27991289aae87be2e":["1224a4027481acce15495b03bce9b48b93b42722","4aa91b365d4819eed673110a366d7ce611fdab1b"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","94cb8b3ec0439dfd8e179637ee4191cd9c6227e5"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","b9dc373b96fc96e6300e2f5af947f6998e6aa6a6"],"6066dbe072ec5334ff5824f474e9d3abd1620fb7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","1224a4027481acce15495b03bce9b48b93b42722"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["29ef99d61cda9641b6250bf9567329a6e65f901d","1224a4027481acce15495b03bce9b48b93b42722"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","b9dc373b96fc96e6300e2f5af947f6998e6aa6a6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"94cb8b3ec0439dfd8e179637ee4191cd9c6227e5":["0cd8367c3d48e4b63dee1895a261d4986c716bbb"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["2553b00f699380c64959ccb27991289aae87be2e","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["4aa91b365d4819eed673110a366d7ce611fdab1b","639c36565ce03aed5b0fce7c9e4448e53a1f7efd"],"4aa91b365d4819eed673110a366d7ce611fdab1b":["ca791416b7d9cc876025db4aea7ec799e8167c0e"],"ca791416b7d9cc876025db4aea7ec799e8167c0e":["0aab6e810b4b0d3743d6a048be0602801f4b3920"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"1224a4027481acce15495b03bce9b48b93b42722":["b9dc373b96fc96e6300e2f5af947f6998e6aa6a6"]},"commit2Childs":{"b9dc373b96fc96e6300e2f5af947f6998e6aa6a6":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","29ef99d61cda9641b6250bf9567329a6e65f901d","1224a4027481acce15495b03bce9b48b93b42722"],"0aab6e810b4b0d3743d6a048be0602801f4b3920":["ca791416b7d9cc876025db4aea7ec799e8167c0e"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"0cd8367c3d48e4b63dee1895a261d4986c716bbb":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","5f4e87790277826a2aea119328600dfb07761f32","94cb8b3ec0439dfd8e179637ee4191cd9c6227e5"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"2553b00f699380c64959ccb27991289aae87be2e":["5d004d0e0b3f65bb40da76d476d659d7888270e8"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"6066dbe072ec5334ff5824f474e9d3abd1620fb7":["0cd8367c3d48e4b63dee1895a261d4986c716bbb"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"d619839baa8ce5503e496b94a9e42ad6f079293f":[],"29ef99d61cda9641b6250bf9567329a6e65f901d":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5f4e87790277826a2aea119328600dfb07761f32","6066dbe072ec5334ff5824f474e9d3abd1620fb7"],"94cb8b3ec0439dfd8e179637ee4191cd9c6227e5":["b9dc373b96fc96e6300e2f5af947f6998e6aa6a6","ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4aa91b365d4819eed673110a366d7ce611fdab1b":["2553b00f699380c64959ccb27991289aae87be2e","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ca791416b7d9cc876025db4aea7ec799e8167c0e":["4aa91b365d4819eed673110a366d7ce611fdab1b"],"1224a4027481acce15495b03bce9b48b93b42722":["0aab6e810b4b0d3743d6a048be0602801f4b3920","639c36565ce03aed5b0fce7c9e4448e53a1f7efd","2553b00f699380c64959ccb27991289aae87be2e","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f","5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}