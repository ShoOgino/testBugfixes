{"path":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#createCollection(int,DocRouter).mjava","commits":[{"id":"9724f10f3fa18adbeba8d1cbfda62676dae942a3","date":1354829537,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#createCollection(int,DocRouter).mjava","pathOld":"/dev/null","sourceNew":"  /***\n  public void testPrintHashCodes() throws Exception {\n   // from negative to positive, the upper bits of the hash ranges should be\n   // shard1: 11\n   // shard2: 10\n   // shard3: 00\n   // shard4: 01\n\n   String[] highBitsToShard = {\"shard3\",\"shard4\",\"shard1\",\"shard2\"};\n\n\n   for (int i = 0; i<26; i++) {\n      String id  = new String(Character.toChars('a'+i));\n      int hash = hash(id);\n      System.out.println(\"hash of \" + id + \" is \" + Integer.toHexString(hash) + \" high bits=\" + (hash>>>30)\n          + \" shard=\"+highBitsToShard[hash>>>30]);\n    }\n  }\n  ***/\n\n\n\n  DocCollection createCollection(int nSlices, DocRouter router) {\n    List<Range> ranges = router.partitionRange(nSlices, router.fullRange());\n\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i=0; i<ranges.size(); i++) {\n      Range range = ranges.get(i);\n      Slice slice = new Slice(\"shard\"+(i+1), null, map(\"range\",range));\n      slices.put(slice.getName(), slice);\n    }\n\n    DocCollection coll = new DocCollection(\"collection1\", slices, null, router);\n    return coll;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5fe03bc79bce6cdaa190cac905d8f82a01e8edcc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#createCollection(int,DocRouter).mjava","pathOld":"/dev/null","sourceNew":"  /***\n  public void testPrintHashCodes() throws Exception {\n   // from negative to positive, the upper bits of the hash ranges should be\n   // shard1: 11\n   // shard2: 10\n   // shard3: 00\n   // shard4: 01\n\n   String[] highBitsToShard = {\"shard3\",\"shard4\",\"shard1\",\"shard2\"};\n\n\n   for (int i = 0; i<26; i++) {\n      String id  = new String(Character.toChars('a'+i));\n      int hash = hash(id);\n      System.out.println(\"hash of \" + id + \" is \" + Integer.toHexString(hash) + \" high bits=\" + (hash>>>30)\n          + \" shard=\"+highBitsToShard[hash>>>30]);\n    }\n  }\n  ***/\n\n\n\n  DocCollection createCollection(int nSlices, DocRouter router) {\n    List<Range> ranges = router.partitionRange(nSlices, router.fullRange());\n\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i=0; i<ranges.size(); i++) {\n      Range range = ranges.get(i);\n      Slice slice = new Slice(\"shard\"+(i+1), null, map(\"range\",range));\n      slices.put(slice.getName(), slice);\n    }\n\n    DocCollection coll = new DocCollection(\"collection1\", slices, null, router);\n    return coll;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#createCollection(int,DocRouter).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#createCollection(int,DocRouter).mjava","sourceNew":"  /***\n  public void testPrintHashCodes() throws Exception {\n   // from negative to positive, the upper bits of the hash ranges should be\n   // shard1: 11\n   // shard2: 10\n   // shard3: 00\n   // shard4: 01\n\n   String[] highBitsToShard = {\"shard3\",\"shard4\",\"shard1\",\"shard2\"};\n\n\n   for (int i = 0; i<26; i++) {\n      String id  = new String(Character.toChars('a'+i));\n      int hash = hash(id);\n      System.out.println(\"hash of \" + id + \" is \" + Integer.toHexString(hash) + \" high bits=\" + (hash>>>30)\n          + \" shard=\"+highBitsToShard[hash>>>30]);\n    }\n  }\n  ***/\n\n\n\n  DocCollection createCollection(int nSlices, DocRouter router) {\n    List<Range> ranges = router.partitionRange(nSlices, router.fullRange());\n\n    Map<String,Slice> slices = new HashMap<>();\n    for (int i=0; i<ranges.size(); i++) {\n      Range range = ranges.get(i);\n      Slice slice = new Slice(\"shard\"+(i+1), null, map(\"range\",range));\n      slices.put(slice.getName(), slice);\n    }\n\n    DocCollection coll = new DocCollection(\"collection1\", slices, null, router);\n    return coll;\n  }\n\n","sourceOld":"  /***\n  public void testPrintHashCodes() throws Exception {\n   // from negative to positive, the upper bits of the hash ranges should be\n   // shard1: 11\n   // shard2: 10\n   // shard3: 00\n   // shard4: 01\n\n   String[] highBitsToShard = {\"shard3\",\"shard4\",\"shard1\",\"shard2\"};\n\n\n   for (int i = 0; i<26; i++) {\n      String id  = new String(Character.toChars('a'+i));\n      int hash = hash(id);\n      System.out.println(\"hash of \" + id + \" is \" + Integer.toHexString(hash) + \" high bits=\" + (hash>>>30)\n          + \" shard=\"+highBitsToShard[hash>>>30]);\n    }\n  }\n  ***/\n\n\n\n  DocCollection createCollection(int nSlices, DocRouter router) {\n    List<Range> ranges = router.partitionRange(nSlices, router.fullRange());\n\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i=0; i<ranges.size(); i++) {\n      Range range = ranges.get(i);\n      Slice slice = new Slice(\"shard\"+(i+1), null, map(\"range\",range));\n      slices.put(slice.getName(), slice);\n    }\n\n    DocCollection coll = new DocCollection(\"collection1\", slices, null, router);\n    return coll;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5fe03bc79bce6cdaa190cac905d8f82a01e8edcc","date":1405792133,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#createCollection(int,DocRouter).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#createCollection(int,DocRouter).mjava","sourceNew":"  /***\n    public void testPrintHashCodes() throws Exception {\n     // from negative to positive, the upper bits of the hash ranges should be\n     // shard1: 11\n     // shard2: 10\n     // shard3: 00\n     // shard4: 01\n  \n     String[] highBitsToShard = {\"shard3\",\"shard4\",\"shard1\",\"shard2\"};\n  \n  \n     for (int i = 0; i<26; i++) {\n        String id  = new String(Character.toChars('a'+i));\n        int hash = hash(id);\n        System.out.println(\"hash of \" + id + \" is \" + Integer.toHexString(hash) + \" high bits=\" + (hash>>>30)\n            + \" shard=\"+highBitsToShard[hash>>>30]);\n      }\n    }\n    ***/\n\n\n\n  DocCollection createCollection(int nSlices, DocRouter router) {\n    List<Range> ranges = router.partitionRange(nSlices, router.fullRange());\n\n    Map<String,Slice> slices = new HashMap<>();\n    for (int i=0; i<ranges.size(); i++) {\n      Range range = ranges.get(i);\n      Slice slice = new Slice(\"shard\"+(i+1), null, map(\"range\",range));\n      slices.put(slice.getName(), slice);\n    }\n\n    DocCollection coll = new DocCollection(\"collection1\", slices, null, router);\n    return coll;\n  }\n\n","sourceOld":"  /***\n  public void testPrintHashCodes() throws Exception {\n   // from negative to positive, the upper bits of the hash ranges should be\n   // shard1: 11\n   // shard2: 10\n   // shard3: 00\n   // shard4: 01\n\n   String[] highBitsToShard = {\"shard3\",\"shard4\",\"shard1\",\"shard2\"};\n\n\n   for (int i = 0; i<26; i++) {\n      String id  = new String(Character.toChars('a'+i));\n      int hash = hash(id);\n      System.out.println(\"hash of \" + id + \" is \" + Integer.toHexString(hash) + \" high bits=\" + (hash>>>30)\n          + \" shard=\"+highBitsToShard[hash>>>30]);\n    }\n  }\n  ***/\n\n\n\n  DocCollection createCollection(int nSlices, DocRouter router) {\n    List<Range> ranges = router.partitionRange(nSlices, router.fullRange());\n\n    Map<String,Slice> slices = new HashMap<>();\n    for (int i=0; i<ranges.size(); i++) {\n      Range range = ranges.get(i);\n      Slice slice = new Slice(\"shard\"+(i+1), null, map(\"range\",range));\n      slices.put(slice.getName(), slice);\n    }\n\n    DocCollection coll = new DocCollection(\"collection1\", slices, null, router);\n    return coll;\n  }\n\n","bugFix":["9724f10f3fa18adbeba8d1cbfda62676dae942a3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6681d02f2302c363be938426e68f8dfd090cc1bf","date":1575339019,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#createCollection(int,DocRouter).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#createCollection(int,DocRouter).mjava","sourceNew":"  /***\n    public void testPrintHashCodes() throws Exception {\n     // from negative to positive, the upper bits of the hash ranges should be\n     // shard1: 11\n     // shard2: 10\n     // shard3: 00\n     // shard4: 01\n  \n     String[] highBitsToShard = {\"shard3\",\"shard4\",\"shard1\",\"shard2\"};\n  \n  \n     for (int i = 0; i<26; i++) {\n        String id  = new String(Character.toChars('a'+i));\n        int hash = hash(id);\n        System.out.println(\"hash of \" + id + \" is \" + Integer.toHexString(hash) + \" high bits=\" + (hash>>>30)\n            + \" shard=\"+highBitsToShard[hash>>>30]);\n      }\n    }\n    ***/\n\n\n\n  DocCollection createCollection(int nSlices, DocRouter router) {\n    List<Range> ranges = router.partitionRange(nSlices, router.fullRange());\n\n    Map<String,Slice> slices = new HashMap<>();\n    for (int i=0; i<ranges.size(); i++) {\n      Range range = ranges.get(i);\n      Slice slice = new Slice(\"shard\"+(i+1), null, map(\"range\",range), \"collections1\");\n      slices.put(slice.getName(), slice);\n    }\n\n    DocCollection coll = new DocCollection(\"collection1\", slices, null, router);\n    return coll;\n  }\n\n","sourceOld":"  /***\n    public void testPrintHashCodes() throws Exception {\n     // from negative to positive, the upper bits of the hash ranges should be\n     // shard1: 11\n     // shard2: 10\n     // shard3: 00\n     // shard4: 01\n  \n     String[] highBitsToShard = {\"shard3\",\"shard4\",\"shard1\",\"shard2\"};\n  \n  \n     for (int i = 0; i<26; i++) {\n        String id  = new String(Character.toChars('a'+i));\n        int hash = hash(id);\n        System.out.println(\"hash of \" + id + \" is \" + Integer.toHexString(hash) + \" high bits=\" + (hash>>>30)\n            + \" shard=\"+highBitsToShard[hash>>>30]);\n      }\n    }\n    ***/\n\n\n\n  DocCollection createCollection(int nSlices, DocRouter router) {\n    List<Range> ranges = router.partitionRange(nSlices, router.fullRange());\n\n    Map<String,Slice> slices = new HashMap<>();\n    for (int i=0; i<ranges.size(); i++) {\n      Range range = ranges.get(i);\n      Slice slice = new Slice(\"shard\"+(i+1), null, map(\"range\",range));\n      slices.put(slice.getName(), slice);\n    }\n\n    DocCollection coll = new DocCollection(\"collection1\", slices, null, router);\n    return coll;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3aa683bba99315838c968fefedf3d74f44aa993","date":1575395112,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#createCollection(int,DocRouter).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#createCollection(int,DocRouter).mjava","sourceNew":"  /***\n    public void testPrintHashCodes() throws Exception {\n     // from negative to positive, the upper bits of the hash ranges should be\n     // shard1: 11\n     // shard2: 10\n     // shard3: 00\n     // shard4: 01\n  \n     String[] highBitsToShard = {\"shard3\",\"shard4\",\"shard1\",\"shard2\"};\n  \n  \n     for (int i = 0; i<26; i++) {\n        String id  = new String(Character.toChars('a'+i));\n        int hash = hash(id);\n        System.out.println(\"hash of \" + id + \" is \" + Integer.toHexString(hash) + \" high bits=\" + (hash>>>30)\n            + \" shard=\"+highBitsToShard[hash>>>30]);\n      }\n    }\n    ***/\n\n\n\n  DocCollection createCollection(int nSlices, DocRouter router) {\n    List<Range> ranges = router.partitionRange(nSlices, router.fullRange());\n\n    Map<String,Slice> slices = new HashMap<>();\n    for (int i=0; i<ranges.size(); i++) {\n      Range range = ranges.get(i);\n      Slice slice = new Slice(\"shard\"+(i+1), null, map(\"range\",range), \"collections1\");\n      slices.put(slice.getName(), slice);\n    }\n\n    DocCollection coll = new DocCollection(\"collection1\", slices, null, router);\n    return coll;\n  }\n\n","sourceOld":"  /***\n    public void testPrintHashCodes() throws Exception {\n     // from negative to positive, the upper bits of the hash ranges should be\n     // shard1: 11\n     // shard2: 10\n     // shard3: 00\n     // shard4: 01\n  \n     String[] highBitsToShard = {\"shard3\",\"shard4\",\"shard1\",\"shard2\"};\n  \n  \n     for (int i = 0; i<26; i++) {\n        String id  = new String(Character.toChars('a'+i));\n        int hash = hash(id);\n        System.out.println(\"hash of \" + id + \" is \" + Integer.toHexString(hash) + \" high bits=\" + (hash>>>30)\n            + \" shard=\"+highBitsToShard[hash>>>30]);\n      }\n    }\n    ***/\n\n\n\n  DocCollection createCollection(int nSlices, DocRouter router) {\n    List<Range> ranges = router.partitionRange(nSlices, router.fullRange());\n\n    Map<String,Slice> slices = new HashMap<>();\n    for (int i=0; i<ranges.size(); i++) {\n      Range range = ranges.get(i);\n      Slice slice = new Slice(\"shard\"+(i+1), null, map(\"range\",range));\n      slices.put(slice.getName(), slice);\n    }\n\n    DocCollection coll = new DocCollection(\"collection1\", slices, null, router);\n    return coll;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#createCollection(int,DocRouter).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#createCollection(int,DocRouter).mjava","sourceNew":"  /***\n    public void testPrintHashCodes() throws Exception {\n     // from negative to positive, the upper bits of the hash ranges should be\n     // shard1: 11\n     // shard2: 10\n     // shard3: 00\n     // shard4: 01\n  \n     String[] highBitsToShard = {\"shard3\",\"shard4\",\"shard1\",\"shard2\"};\n  \n  \n     for (int i = 0; i<26; i++) {\n        String id  = new String(Character.toChars('a'+i));\n        int hash = hash(id);\n        System.out.println(\"hash of \" + id + \" is \" + Integer.toHexString(hash) + \" high bits=\" + (hash>>>30)\n            + \" shard=\"+highBitsToShard[hash>>>30]);\n      }\n    }\n    ***/\n\n\n\n  @SuppressWarnings({\"unchecked\"})\n  DocCollection createCollection(int nSlices, DocRouter router) {\n    List<Range> ranges = router.partitionRange(nSlices, router.fullRange());\n\n    Map<String,Slice> slices = new HashMap<>();\n    for (int i=0; i<ranges.size(); i++) {\n      Range range = ranges.get(i);\n      Slice slice = new Slice(\"shard\"+(i+1), null, map(\"range\",range), \"collections1\");\n      slices.put(slice.getName(), slice);\n    }\n\n    DocCollection coll = new DocCollection(\"collection1\", slices, null, router);\n    return coll;\n  }\n\n","sourceOld":"  /***\n    public void testPrintHashCodes() throws Exception {\n     // from negative to positive, the upper bits of the hash ranges should be\n     // shard1: 11\n     // shard2: 10\n     // shard3: 00\n     // shard4: 01\n  \n     String[] highBitsToShard = {\"shard3\",\"shard4\",\"shard1\",\"shard2\"};\n  \n  \n     for (int i = 0; i<26; i++) {\n        String id  = new String(Character.toChars('a'+i));\n        int hash = hash(id);\n        System.out.println(\"hash of \" + id + \" is \" + Integer.toHexString(hash) + \" high bits=\" + (hash>>>30)\n            + \" shard=\"+highBitsToShard[hash>>>30]);\n      }\n    }\n    ***/\n\n\n\n  DocCollection createCollection(int nSlices, DocRouter router) {\n    List<Range> ranges = router.partitionRange(nSlices, router.fullRange());\n\n    Map<String,Slice> slices = new HashMap<>();\n    for (int i=0; i<ranges.size(); i++) {\n      Range range = ranges.get(i);\n      Slice slice = new Slice(\"shard\"+(i+1), null, map(\"range\",range), \"collections1\");\n      slices.put(slice.getName(), slice);\n    }\n\n    DocCollection coll = new DocCollection(\"collection1\", slices, null, router);\n    return coll;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3aa683bba99315838c968fefedf3d74f44aa993":["5fe03bc79bce6cdaa190cac905d8f82a01e8edcc","6681d02f2302c363be938426e68f8dfd090cc1bf"],"5fe03bc79bce6cdaa190cac905d8f82a01e8edcc":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["9724f10f3fa18adbeba8d1cbfda62676dae942a3"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["6681d02f2302c363be938426e68f8dfd090cc1bf"],"9724f10f3fa18adbeba8d1cbfda62676dae942a3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9724f10f3fa18adbeba8d1cbfda62676dae942a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["5fe03bc79bce6cdaa190cac905d8f82a01e8edcc"]},"commit2Childs":{"d3aa683bba99315838c968fefedf3d74f44aa993":[],"5fe03bc79bce6cdaa190cac905d8f82a01e8edcc":["d3aa683bba99315838c968fefedf3d74f44aa993","6681d02f2302c363be938426e68f8dfd090cc1bf"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5fe03bc79bce6cdaa190cac905d8f82a01e8edcc"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9724f10f3fa18adbeba8d1cbfda62676dae942a3":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","407687e67faf6e1f02a211ca078d8e3eed631027"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9724f10f3fa18adbeba8d1cbfda62676dae942a3","407687e67faf6e1f02a211ca078d8e3eed631027"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"6681d02f2302c363be938426e68f8dfd090cc1bf":["d3aa683bba99315838c968fefedf3d74f44aa993","aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3aa683bba99315838c968fefedf3d74f44aa993","407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}