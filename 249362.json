{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","commits":[{"id":"7a2106de37ce630e891f2b29595bc3bfcef1918d","date":1495624585,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2f4717538692c396242d8b00ae0001626caebdd","date":1495700710,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c32a8448145a74a8902798f2e63e322827757ff2","date":1496834422,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = container.getZkController().getZkClient().getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeNodeAddedMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"664ff2b928393480d9655010aa700656b0fcade0","date":1496842764,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = container.getZkController().getZkClient().getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeNodeAddedMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc5ed4ca39a59c23d13866a1e110e608d93cbcc1","date":1503489512,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = container.getZkController().getZkClient().getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = container.getZkController().getZkClient().getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeNodeAddedMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac","date":1503580177,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() {\n    super.init();\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = clusterDataProvider.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = container.getZkController().getZkClient().getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b869898f50ca80263bac2e3ae0949f7700e5c977","date":1503580229,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = container.getZkController().getZkClient().getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init() {\n    super.init();\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = clusterDataProvider.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3955a9511098c96b652734b2f2d4160d07cc2d63","date":1504780677,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() {\n    super.init();\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = container.getZkController().getZkClient().getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = container.getZkController().getZkClient().getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b71597cbe4c0f463a81f3f225fc0ff1355c8fee6","date":1505752009,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = container.getZkController().getZkClient().getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init() {\n    super.init();\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = container.getZkController().getZkClient().getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b8cffee0b9c10b78bd087c71485b482217fe84f","date":1505950827,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = zkClient.getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = container.getZkController().getZkClient().getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = zkClient.getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = zkClient.getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = zkClient.getChildren(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH, null, true);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (KeeperException.NoNodeException e) {\n      // ignore\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3f354f2175f861ee625bb3c9572d53b77cd8545","date":1508405819,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() {\n    super.init();\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init() {\n    List<Map<String, String>> o = (List<Map<String, String>>) properties.get(\"actions\");\n    if (o != null && !o.isEmpty()) {\n      for (int i = 0; i < o.size(); i++) {\n        Map<String, String> map = o.get(i);\n        actions.get(i).init(map);\n      }\n    }\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() {\n    super.init();\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init() {\n    super.init();\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, timeSource.getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4412883c12067d8a4e2a354aa8adc58c32be1d6","date":1521129281,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() {\n    super.init();\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init() {\n    super.init();\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTime());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d","date":1522763990,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void init() {\n    super.init();\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7f315cd0d0955ce9ca691cc8e2796af69c4b9b6","date":1536060944,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3650b9a37331aa4c5e0af6e7a8c2ac75734bb6f","date":1544472487,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n) && !nodeNameVsTimeAdded.containsKey(n)) {\n          // since {@code #restoreState(AutoScaling.Trigger)} is called first, the timeAdded for a node may also be restored\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n)) {\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7fb1186f5b61e0b74289e6786df8cbecfa471bc","date":1545308188,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n) && !nodeNameVsTimeAdded.containsKey(n)) {\n          // since {@code #restoreState(AutoScaling.Trigger)} is called first, the timeAdded for a node may also be restored\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n) && !nodeNameVsTimeAdded.containsKey(n)) {\n          // since {@code #restoreState(AutoScaling.Trigger)} is called first, the timeAdded for a node may also be restored\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n        removeMarker(n);\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d4af357762468d37df7424f81785cd89b49a7b","date":1570534862,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        String markerPath = ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH + \"/\" + n;\n        try {\n          Map<String, Object> markerData = Utils.getJson(stateManager, markerPath);\n          // skip inactive markers\n          if (markerData.getOrDefault(MARKER_STATE, MARKER_ACTIVE).equals(MARKER_INACTIVE)) {\n            return;\n          }\n        } catch (InterruptedException | IOException | KeeperException e) {\n          log.debug(\"-- ignoring marker \" + markerPath + \" state due to error\", e);\n        }\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n) && !nodeNameVsTimeAdded.containsKey(n)) {\n          // since {@code #restoreState(AutoScaling.Trigger)} is called first, the timeAdded for a node may also be restored\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n) && !nodeNameVsTimeAdded.containsKey(n)) {\n          // since {@code #restoreState(AutoScaling.Trigger)} is called first, the timeAdded for a node may also be restored\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        String markerPath = ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH + \"/\" + n;\n        try {\n          Map<String, Object> markerData = Utils.getJson(stateManager, markerPath);\n          // skip inactive markers\n          if (markerData.getOrDefault(MARKER_STATE, MARKER_ACTIVE).equals(MARKER_INACTIVE)) {\n            return;\n          }\n        } catch (InterruptedException | IOException | KeeperException e) {\n          log.debug(\"-- ignoring marker \" + markerPath + \" state due to error\", e);\n        }\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n) && !nodeNameVsTimeAdded.containsKey(n)) {\n          // since {@code #restoreState(AutoScaling.Trigger)} is called first, the timeAdded for a node may also be restored\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n) && !nodeNameVsTimeAdded.containsKey(n)) {\n          // since {@code #restoreState(AutoScaling.Trigger)} is called first, the timeAdded for a node may also be restored\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e35f2dde06b35aa9904949a3a93fabd090371077","date":1587906921,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        String markerPath = ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH + \"/\" + n;\n        try {\n          Map<String, Object> markerData = Utils.getJson(stateManager, markerPath);\n          // skip inactive markers\n          if (markerData.getOrDefault(MARKER_STATE, MARKER_ACTIVE).equals(MARKER_INACTIVE)) {\n            return;\n          }\n        } catch (InterruptedException | IOException | KeeperException e) {\n          log.debug(\"-- ignoring marker {} state due to error{}\", markerPath, e);\n        }\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n) && !nodeNameVsTimeAdded.containsKey(n)) {\n          // since {@code #restoreState(AutoScaling.Trigger)} is called first, the timeAdded for a node may also be restored\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        String markerPath = ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH + \"/\" + n;\n        try {\n          Map<String, Object> markerData = Utils.getJson(stateManager, markerPath);\n          // skip inactive markers\n          if (markerData.getOrDefault(MARKER_STATE, MARKER_ACTIVE).equals(MARKER_INACTIVE)) {\n            return;\n          }\n        } catch (InterruptedException | IOException | KeeperException e) {\n          log.debug(\"-- ignoring marker \" + markerPath + \" state due to error\", e);\n        }\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n) && !nodeNameVsTimeAdded.containsKey(n)) {\n          // since {@code #restoreState(AutoScaling.Trigger)} is called first, the timeAdded for a node may also be restored\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/NodeAddedTrigger#init().mjava","sourceNew":null,"sourceOld":"  @Override\n  public void init() throws Exception {\n    super.init();\n    lastLiveNodes = new HashSet<>(cloudManager.getClusterStateProvider().getLiveNodes());\n    log.debug(\"NodeAddedTrigger {} - Initial livenodes: {}\", name, lastLiveNodes);\n    log.debug(\"NodeAddedTrigger {} instantiated with properties: {}\", name, properties);\n    // pick up added nodes for which marker paths were created\n    try {\n      List<String> added = stateManager.listData(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      added.forEach(n -> {\n        String markerPath = ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH + \"/\" + n;\n        try {\n          Map<String, Object> markerData = Utils.getJson(stateManager, markerPath);\n          // skip inactive markers\n          if (markerData.getOrDefault(MARKER_STATE, MARKER_ACTIVE).equals(MARKER_INACTIVE)) {\n            return;\n          }\n        } catch (InterruptedException | IOException | KeeperException e) {\n          log.debug(\"-- ignoring marker {} state due to error{}\", markerPath, e);\n        }\n        // don't add nodes that have since gone away\n        if (lastLiveNodes.contains(n) && !nodeNameVsTimeAdded.containsKey(n)) {\n          // since {@code #restoreState(AutoScaling.Trigger)} is called first, the timeAdded for a node may also be restored\n          log.debug(\"Adding node from marker path: {}\", n);\n          nodeNameVsTimeAdded.put(n, cloudManager.getTimeSource().getTimeNs());\n        }\n      });\n    } catch (NoSuchElementException e) {\n      // ignore\n    } catch (Exception e) {\n      log.warn(\"Exception retrieving nodeLost markers\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5b8cffee0b9c10b78bd087c71485b482217fe84f"],"3955a9511098c96b652734b2f2d4160d07cc2d63":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"cc5ed4ca39a59c23d13866a1e110e608d93cbcc1":["664ff2b928393480d9655010aa700656b0fcade0"],"e2f4717538692c396242d8b00ae0001626caebdd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7a2106de37ce630e891f2b29595bc3bfcef1918d"],"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"f7fb1186f5b61e0b74289e6786df8cbecfa471bc":["a3650b9a37331aa4c5e0af6e7a8c2ac75734bb6f"],"7a2106de37ce630e891f2b29595bc3bfcef1918d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["c3f354f2175f861ee625bb3c9572d53b77cd8545"],"560c18d71dad43d675158783c3840f8c80d6d39c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"664ff2b928393480d9655010aa700656b0fcade0":["e2f4717538692c396242d8b00ae0001626caebdd","c32a8448145a74a8902798f2e63e322827757ff2"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["cc5ed4ca39a59c23d13866a1e110e608d93cbcc1"],"3f504512a03d978990cbff30db0522b354e846db":["e35f2dde06b35aa9904949a3a93fabd090371077"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["560c18d71dad43d675158783c3840f8c80d6d39c"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"a3650b9a37331aa4c5e0af6e7a8c2ac75734bb6f":["f7f315cd0d0955ce9ca691cc8e2796af69c4b9b6"],"c3f354f2175f861ee625bb3c9572d53b77cd8545":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"f7f315cd0d0955ce9ca691cc8e2796af69c4b9b6":["cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d"],"98d4af357762468d37df7424f81785cd89b49a7b":["f7fb1186f5b61e0b74289e6786df8cbecfa471bc"],"5b8cffee0b9c10b78bd087c71485b482217fe84f":["b71597cbe4c0f463a81f3f225fc0ff1355c8fee6"],"e35f2dde06b35aa9904949a3a93fabd090371077":["98d4af357762468d37df7424f81785cd89b49a7b"],"c32a8448145a74a8902798f2e63e322827757ff2":["e2f4717538692c396242d8b00ae0001626caebdd"],"b71597cbe4c0f463a81f3f225fc0ff1355c8fee6":["3955a9511098c96b652734b2f2d4160d07cc2d63"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"b0b597c65628ca9e73913a07e81691f8229bae35":["f7fb1186f5b61e0b74289e6786df8cbecfa471bc","98d4af357762468d37df7424f81785cd89b49a7b"]},"commit2Childs":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"3955a9511098c96b652734b2f2d4160d07cc2d63":["b71597cbe4c0f463a81f3f225fc0ff1355c8fee6"],"cc5ed4ca39a59c23d13866a1e110e608d93cbcc1":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"e2f4717538692c396242d8b00ae0001626caebdd":["664ff2b928393480d9655010aa700656b0fcade0","c32a8448145a74a8902798f2e63e322827757ff2"],"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d":["f7f315cd0d0955ce9ca691cc8e2796af69c4b9b6"],"7a2106de37ce630e891f2b29595bc3bfcef1918d":["e2f4717538692c396242d8b00ae0001626caebdd"],"f7fb1186f5b61e0b74289e6786df8cbecfa471bc":["98d4af357762468d37df7424f81785cd89b49a7b","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c304e97e7c1d472bc70e801b35ee78583916c6cd","e2f4717538692c396242d8b00ae0001626caebdd","7a2106de37ce630e891f2b29595bc3bfcef1918d","560c18d71dad43d675158783c3840f8c80d6d39c"],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"560c18d71dad43d675158783c3840f8c80d6d39c":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"664ff2b928393480d9655010aa700656b0fcade0":["cc5ed4ca39a59c23d13866a1e110e608d93cbcc1"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["c3f354f2175f861ee625bb3c9572d53b77cd8545"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["3955a9511098c96b652734b2f2d4160d07cc2d63"],"a3650b9a37331aa4c5e0af6e7a8c2ac75734bb6f":["f7fb1186f5b61e0b74289e6786df8cbecfa471bc"],"c3f354f2175f861ee625bb3c9572d53b77cd8545":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"f7f315cd0d0955ce9ca691cc8e2796af69c4b9b6":["a3650b9a37331aa4c5e0af6e7a8c2ac75734bb6f"],"98d4af357762468d37df7424f81785cd89b49a7b":["e35f2dde06b35aa9904949a3a93fabd090371077","b0b597c65628ca9e73913a07e81691f8229bae35"],"5b8cffee0b9c10b78bd087c71485b482217fe84f":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"c32a8448145a74a8902798f2e63e322827757ff2":["664ff2b928393480d9655010aa700656b0fcade0"],"e35f2dde06b35aa9904949a3a93fabd090371077":["3f504512a03d978990cbff30db0522b354e846db"],"b71597cbe4c0f463a81f3f225fc0ff1355c8fee6":["5b8cffee0b9c10b78bd087c71485b482217fe84f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}