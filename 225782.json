{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FSTCompiler#add(IntsRef,T).mjava","commits":[{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":1,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FSTCompiler#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FSTCompiler#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}