{"path":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","commits":[{"id":"fde68de507dbf344495d7b5e8052866fe5f254ab","date":1189434831,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"/dev/null","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the work\n      state.processDocument(analyzer);\n      // This call synchronized but fast\n      finishDocument(state);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        abort();\n      }\n    }\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c9a0deca56efc5191d6b3c41047fd538f3fae1d8","83bbb041887bbef07b8a98d08a0e1713ce137039","8560794cda5bcd510c60e38ed553e9c5a6204983"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"741a5cca05cabe1e7482410a29e563a08379251a","date":1196676550,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  int updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    boolean success = false;\n    int maxTermHit;\n    try {\n      // This call is not synchronized and does all the work\n      state.processDocument(analyzer);\n      // This call synchronized but fast\n      maxTermHit = state.maxTermHit;\n      finishDocument(state);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        abort();\n      }\n    }\n\n    int status = maxTermHit<<1;\n    if (state.doFlushAfter || timeToFlushDeletes())\n      status += 1;\n    return status;\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the work\n      state.processDocument(analyzer);\n      // This call synchronized but fast\n      finishDocument(state);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        abort();\n      }\n    }\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":null,"bugIntro":["5a251aa47d1808cbae42c0e172d698c377430e60","8560794cda5bcd510c60e38ed553e9c5a6204983"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8560794cda5bcd510c60e38ed553e9c5a6204983","date":1196807382,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  int updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    boolean success = false;\n    int maxTermHit;\n    try {\n      // This call is not synchronized and does all the work\n      try {\n        state.processDocument(analyzer);\n      } finally {\n        maxTermHit = state.maxTermHit;\n        // This call synchronized but fast\n        finishDocument(state);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n          state.isIdle = true;\n          if (state.abortOnExc)\n            abort();\n          notifyAll();\n        }\n      }\n    }\n\n    int status = maxTermHit<<1;\n    if (state.doFlushAfter || timeToFlushDeletes())\n      status += 1;\n    return status;\n  }\n\n","sourceOld":"  int updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    boolean success = false;\n    int maxTermHit;\n    try {\n      // This call is not synchronized and does all the work\n      state.processDocument(analyzer);\n      // This call synchronized but fast\n      maxTermHit = state.maxTermHit;\n      finishDocument(state);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        abort();\n      }\n    }\n\n    int status = maxTermHit<<1;\n    if (state.doFlushAfter || timeToFlushDeletes())\n      status += 1;\n    return status;\n  }\n\n","bugFix":["741a5cca05cabe1e7482410a29e563a08379251a","fde68de507dbf344495d7b5e8052866fe5f254ab"],"bugIntro":["c9a0deca56efc5191d6b3c41047fd538f3fae1d8","83bbb041887bbef07b8a98d08a0e1713ce137039","5a251aa47d1808cbae42c0e172d698c377430e60"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9a0deca56efc5191d6b3c41047fd538f3fae1d8","date":1198156049,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  int updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    boolean success = false;\n    int maxTermHit;\n    try {\n      try {\n        // This call is not synchronized and does all the work\n        state.processDocument(analyzer);\n      } finally {\n        maxTermHit = state.maxTermHit;\n        // This call is synchronized but fast\n        finishDocument(state);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n          state.isIdle = true;\n          if (state.abortOnExc)\n            abort();\n          notifyAll();\n        }\n      }\n    }\n\n    int status = maxTermHit<<1;\n    if (state.doFlushAfter || timeToFlushDeletes())\n      status += 1;\n    return status;\n  }\n\n","sourceOld":"  int updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    boolean success = false;\n    int maxTermHit;\n    try {\n      // This call is not synchronized and does all the work\n      try {\n        state.processDocument(analyzer);\n      } finally {\n        maxTermHit = state.maxTermHit;\n        // This call synchronized but fast\n        finishDocument(state);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n          state.isIdle = true;\n          if (state.abortOnExc)\n            abort();\n          notifyAll();\n        }\n      }\n    }\n\n    int status = maxTermHit<<1;\n    if (state.doFlushAfter || timeToFlushDeletes())\n      status += 1;\n    return status;\n  }\n\n","bugFix":["8560794cda5bcd510c60e38ed553e9c5a6204983","fde68de507dbf344495d7b5e8052866fe5f254ab"],"bugIntro":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a251aa47d1808cbae42c0e172d698c377430e60","date":1199375390,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    boolean success = false;\n    try {\n      try {\n        // This call is not synchronized and does all the work\n        state.processDocument(analyzer);\n      } finally {\n        // This call is synchronized but fast\n        finishDocument(state);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n          state.isIdle = true;\n          if (state.abortOnExc)\n            // Abort all buffered docs since last flush\n            abort();\n          else\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docID);\n          notifyAll();\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","sourceOld":"  int updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    boolean success = false;\n    int maxTermHit;\n    try {\n      try {\n        // This call is not synchronized and does all the work\n        state.processDocument(analyzer);\n      } finally {\n        maxTermHit = state.maxTermHit;\n        // This call is synchronized but fast\n        finishDocument(state);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n          state.isIdle = true;\n          if (state.abortOnExc)\n            abort();\n          notifyAll();\n        }\n      }\n    }\n\n    int status = maxTermHit<<1;\n    if (state.doFlushAfter || timeToFlushDeletes())\n      status += 1;\n    return status;\n  }\n\n","bugFix":["741a5cca05cabe1e7482410a29e563a08379251a","8560794cda5bcd510c60e38ed553e9c5a6204983"],"bugIntro":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83bbb041887bbef07b8a98d08a0e1713ce137039","date":1200330381,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    try {\n      boolean success = false;\n      try {\n        try {\n          // This call is not synchronized and does all the work\n          state.processDocument(analyzer);\n        } finally {\n          // This call is synchronized but fast\n          finishDocument(state);\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          synchronized(this) {\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docID);\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    boolean success = false;\n    try {\n      try {\n        // This call is not synchronized and does all the work\n        state.processDocument(analyzer);\n      } finally {\n        // This call is synchronized but fast\n        finishDocument(state);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n          state.isIdle = true;\n          if (state.abortOnExc)\n            // Abort all buffered docs since last flush\n            abort();\n          else\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docID);\n          notifyAll();\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":["5a251aa47d1808cbae42c0e172d698c377430e60","c9a0deca56efc5191d6b3c41047fd538f3fae1d8","8560794cda5bcd510c60e38ed553e9c5a6204983","fde68de507dbf344495d7b5e8052866fe5f254ab"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b76f497be58114d897182bb3ac8d503e7b3dcd1d","date":1204926435,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    try {\n      boolean success = false;\n      try {\n        try {\n          // This call is not synchronized and does all the work\n          state.processDocument(analyzer);\n        } finally {\n          // This call is synchronized but fast\n          finishDocument(state);\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          synchronized(this) {\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docID);\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    try {\n      boolean success = false;\n      try {\n        try {\n          // This call is not synchronized and does all the work\n          state.processDocument(analyzer);\n        } finally {\n          // This call is synchronized but fast\n          finishDocument(state);\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          synchronized(this) {\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docID);\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a0af3a442be522899177e5e11384a45a6784a3f","date":1205348952,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n    try {\n      boolean success = false;\n      try {\n        try {\n          // This call is not synchronized and does all the work\n          state.processDocument(analyzer);\n        } finally {\n          // This call is synchronized but fast\n          finishDocument(state);\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          synchronized(this) {\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docID);\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final ThreadState state = getThreadState(doc, delTerm);\n    try {\n      boolean success = false;\n      try {\n        try {\n          // This call is not synchronized and does all the work\n          state.processDocument(analyzer);\n        } finally {\n          // This call is synchronized but fast\n          finishDocument(state);\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          synchronized(this) {\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docID);\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4","date":1206538765,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n    try {\n      boolean success = false;\n      try {\n        try {\n          // This call is not synchronized and does all the work\n          state.processDocument(analyzer);\n        } finally {\n          // Note that we must call finishDocument even on\n          // exception, because for a non-aborting\n          // exception, a portion of the document has been\n          // indexed (and its ID is marked for deletion), so\n          // all index files must be updated to record this\n          // document.  This call is synchronized but fast.\n          finishDocument(state);\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          synchronized(this) {\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docID);\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n    try {\n      boolean success = false;\n      try {\n        try {\n          // This call is not synchronized and does all the work\n          state.processDocument(analyzer);\n        } finally {\n          // This call is synchronized but fast\n          finishDocument(state);\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          synchronized(this) {\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docID);\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5350389bf83287111f7760b9e3db3af8e3648474","date":1216372812,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc = state.consumer.processDocument();\n        \n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n    try {\n      boolean success = false;\n      try {\n        try {\n          // This call is not synchronized and does all the work\n          state.processDocument(analyzer);\n        } finally {\n          // Note that we must call finishDocument even on\n          // exception, because for a non-aborting\n          // exception, a portion of the document has been\n          // indexed (and its ID is marked for deletion), so\n          // all index files must be updated to record this\n          // document.  This call is synchronized but fast.\n          finishDocument(state);\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          synchronized(this) {\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docID);\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":null,"bugIntro":["24736f886f499d15345d6c4b717b9fe84a70dae2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Document,Analyzer,Term).mjava","sourceNew":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc = state.consumer.processDocument();\n        \n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","sourceOld":"  boolean updateDocument(Document doc, Analyzer analyzer, Term delTerm)\n    throws CorruptIndexException, IOException {\n\n    // This call is synchronized but fast\n    final DocumentsWriterThreadState state = getThreadState(doc, delTerm);\n\n    final DocState docState = state.docState;\n    docState.doc = doc;\n    docState.analyzer = analyzer;\n\n    boolean success = false;\n    try {\n      // This call is not synchronized and does all the\n      // work\n      final DocWriter perDoc = state.consumer.processDocument();\n        \n      // This call is synchronized but fast\n      finishDocument(state, perDoc);\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n\n          if (aborting) {\n            state.isIdle = true;\n            notifyAll();\n            abort();\n          } else {\n            skipDocWriter.docID = docState.docID;\n            boolean success2 = false;\n            try {\n              waitQueue.add(skipDocWriter);\n              success2 = true;\n            } finally {\n              if (!success2) {\n                state.isIdle = true;\n                notifyAll();\n                abort();\n                return false;\n              }\n            }\n\n            state.isIdle = true;\n            notifyAll();\n\n            // If this thread state had decided to flush, we\n            // must clear it so another thread can flush\n            if (state.doFlushAfter) {\n              state.doFlushAfter = false;\n              flushPending = false;\n              notifyAll();\n            }\n\n            // Immediately mark this document as deleted\n            // since likely it was partially added.  This\n            // keeps indexing as \"all or none\" (atomic) when\n            // adding a document:\n            addDeleteDocID(state.docState.docID);\n          }\n        }\n      }\n    }\n\n    return state.doFlushAfter || timeToFlushDeletes();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"83bbb041887bbef07b8a98d08a0e1713ce137039":["5a251aa47d1808cbae42c0e172d698c377430e60"],"fde68de507dbf344495d7b5e8052866fe5f254ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4":["5a0af3a442be522899177e5e11384a45a6784a3f"],"741a5cca05cabe1e7482410a29e563a08379251a":["fde68de507dbf344495d7b5e8052866fe5f254ab"],"c9a0deca56efc5191d6b3c41047fd538f3fae1d8":["8560794cda5bcd510c60e38ed553e9c5a6204983"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b76f497be58114d897182bb3ac8d503e7b3dcd1d":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"5a251aa47d1808cbae42c0e172d698c377430e60":["c9a0deca56efc5191d6b3c41047fd538f3fae1d8"],"8560794cda5bcd510c60e38ed553e9c5a6204983":["741a5cca05cabe1e7482410a29e563a08379251a"],"5a0af3a442be522899177e5e11384a45a6784a3f":["b76f497be58114d897182bb3ac8d503e7b3dcd1d"],"5350389bf83287111f7760b9e3db3af8e3648474":["dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["5350389bf83287111f7760b9e3db3af8e3648474"]},"commit2Childs":{"83bbb041887bbef07b8a98d08a0e1713ce137039":["b76f497be58114d897182bb3ac8d503e7b3dcd1d"],"fde68de507dbf344495d7b5e8052866fe5f254ab":["741a5cca05cabe1e7482410a29e563a08379251a"],"dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4":["5350389bf83287111f7760b9e3db3af8e3648474"],"741a5cca05cabe1e7482410a29e563a08379251a":["8560794cda5bcd510c60e38ed553e9c5a6204983"],"c9a0deca56efc5191d6b3c41047fd538f3fae1d8":["5a251aa47d1808cbae42c0e172d698c377430e60"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fde68de507dbf344495d7b5e8052866fe5f254ab"],"b76f497be58114d897182bb3ac8d503e7b3dcd1d":["5a0af3a442be522899177e5e11384a45a6784a3f"],"5a251aa47d1808cbae42c0e172d698c377430e60":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"8560794cda5bcd510c60e38ed553e9c5a6204983":["c9a0deca56efc5191d6b3c41047fd538f3fae1d8"],"5a0af3a442be522899177e5e11384a45a6784a3f":["dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4"],"5350389bf83287111f7760b9e3db3af8e3648474":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}