{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByHashDV#calcFacets().mjava","commits":[{"id":"602cca3f75af03832471d8324bbc5b977a02969c","date":1472676981,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByHashDV#calcFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByHashNumeric#calcFacets().mjava","sourceNew":"  private SimpleOrderedMap<Object> calcFacets() throws IOException {\n\n    if (sf.getType().getNumericType() != null) {\n      calc = FacetRangeProcessor.getNumericCalc(sf);\n    } else {\n      calc = new TermOrdCalc(); // kind of a hack\n    }\n\n    // TODO: Use the number of indexed terms, if present, as an estimate!\n    //    Even for NumericDocValues, we could check for a terms index for an estimate.\n    //    Our estimation should aim high to avoid expensive rehashes.\n\n    int possibleValues = fcontext.base.size();\n    // size smaller tables so that no resize will be necessary\n    int currHashSize = BitUtil.nextHighestPowerOfTwo((int) (possibleValues * (1 / LongCounts.LOAD_FACTOR) + 1));\n    currHashSize = Math.min(currHashSize, MAXIMUM_STARTING_TABLE_SIZE);\n    table = new LongCounts(currHashSize) {\n      @Override\n      protected void rehash() {\n        super.rehash();\n        doRehash(this);\n        oldToNewMapping = null; // allow for gc\n      }\n    };\n\n    // note: these methods/phases align with FacetFieldProcessorByArray's\n\n    createCollectAcc();\n\n    collectDocs();\n\n    return super.findTopSlots(table.numSlots(), table.cardinality(),\n        slotNum -> calc.bitsToValue(table.vals[slotNum]), // getBucketValFromSlotNum\n        val -> calc.formatValue(val)); // getFieldQueryVal\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> calcFacets() throws IOException {\n\n    if (sf.getType().getNumericType() != null) {\n      calc = FacetRangeProcessor.getNumericCalc(sf);\n    } else {\n      calc = new TermOrdCalc(); // kind of a hack\n    }\n\n    // TODO: Use the number of indexed terms, if present, as an estimate!\n    //    Even for NumericDocValues, we could check for a terms index for an estimate.\n    //    Our estimation should aim high to avoid expensive rehashes.\n\n    int possibleValues = fcontext.base.size();\n    // size smaller tables so that no resize will be necessary\n    int currHashSize = BitUtil.nextHighestPowerOfTwo((int) (possibleValues * (1 / LongCounts.LOAD_FACTOR) + 1));\n    currHashSize = Math.min(currHashSize, MAXIMUM_STARTING_TABLE_SIZE);\n    table = new LongCounts(currHashSize) {\n      @Override\n      protected void rehash() {\n        super.rehash();\n        doRehash(this);\n        oldToNewMapping = null; // allow for gc\n      }\n    };\n\n    // note: these methods/phases align with FacetFieldProcessorByArray's\n\n    createCollectAcc();\n\n    collectDocs();\n\n    return super.findTopSlots(table.numSlots(), table.cardinality(),\n        slotNum -> calc.bitsToValue(table.vals[slotNum]), // getBucketValFromSlotNum\n        val -> calc.formatValue(val)); // getFieldQueryVal\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByHashDV#calcFacets().mjava","pathOld":"/dev/null","sourceNew":"  private SimpleOrderedMap<Object> calcFacets() throws IOException {\n\n    if (sf.getType().getNumericType() != null) {\n      calc = FacetRangeProcessor.getNumericCalc(sf);\n    } else {\n      calc = new TermOrdCalc(); // kind of a hack\n    }\n\n    // TODO: Use the number of indexed terms, if present, as an estimate!\n    //    Even for NumericDocValues, we could check for a terms index for an estimate.\n    //    Our estimation should aim high to avoid expensive rehashes.\n\n    int possibleValues = fcontext.base.size();\n    // size smaller tables so that no resize will be necessary\n    int currHashSize = BitUtil.nextHighestPowerOfTwo((int) (possibleValues * (1 / LongCounts.LOAD_FACTOR) + 1));\n    currHashSize = Math.min(currHashSize, MAXIMUM_STARTING_TABLE_SIZE);\n    table = new LongCounts(currHashSize) {\n      @Override\n      protected void rehash() {\n        super.rehash();\n        doRehash(this);\n        oldToNewMapping = null; // allow for gc\n      }\n    };\n\n    // note: these methods/phases align with FacetFieldProcessorByArray's\n\n    createCollectAcc();\n\n    collectDocs();\n\n    return super.findTopSlots(table.numSlots(), table.cardinality(),\n        slotNum -> calc.bitsToValue(table.vals[slotNum]), // getBucketValFromSlotNum\n        val -> calc.formatValue(val)); // getFieldQueryVal\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByHashDV#calcFacets().mjava","pathOld":"/dev/null","sourceNew":"  private SimpleOrderedMap<Object> calcFacets() throws IOException {\n\n    if (sf.getType().getNumericType() != null) {\n      calc = FacetRangeProcessor.getNumericCalc(sf);\n    } else {\n      calc = new TermOrdCalc(); // kind of a hack\n    }\n\n    // TODO: Use the number of indexed terms, if present, as an estimate!\n    //    Even for NumericDocValues, we could check for a terms index for an estimate.\n    //    Our estimation should aim high to avoid expensive rehashes.\n\n    int possibleValues = fcontext.base.size();\n    // size smaller tables so that no resize will be necessary\n    int currHashSize = BitUtil.nextHighestPowerOfTwo((int) (possibleValues * (1 / LongCounts.LOAD_FACTOR) + 1));\n    currHashSize = Math.min(currHashSize, MAXIMUM_STARTING_TABLE_SIZE);\n    table = new LongCounts(currHashSize) {\n      @Override\n      protected void rehash() {\n        super.rehash();\n        doRehash(this);\n        oldToNewMapping = null; // allow for gc\n      }\n    };\n\n    // note: these methods/phases align with FacetFieldProcessorByArray's\n\n    createCollectAcc();\n\n    collectDocs();\n\n    return super.findTopSlots(table.numSlots(), table.cardinality(),\n        slotNum -> calc.bitsToValue(table.vals[slotNum]), // getBucketValFromSlotNum\n        val -> calc.formatValue(val)); // getFieldQueryVal\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByHashDV#calcFacets().mjava","pathOld":"/dev/null","sourceNew":"  private SimpleOrderedMap<Object> calcFacets() throws IOException {\n\n    if (sf.getType().getNumericType() != null) {\n      calc = FacetRangeProcessor.getNumericCalc(sf);\n    } else {\n      calc = new TermOrdCalc(); // kind of a hack\n    }\n\n    // TODO: Use the number of indexed terms, if present, as an estimate!\n    //    Even for NumericDocValues, we could check for a terms index for an estimate.\n    //    Our estimation should aim high to avoid expensive rehashes.\n\n    int possibleValues = fcontext.base.size();\n    // size smaller tables so that no resize will be necessary\n    int currHashSize = BitUtil.nextHighestPowerOfTwo((int) (possibleValues * (1 / LongCounts.LOAD_FACTOR) + 1));\n    currHashSize = Math.min(currHashSize, MAXIMUM_STARTING_TABLE_SIZE);\n    table = new LongCounts(currHashSize) {\n      @Override\n      protected void rehash() {\n        super.rehash();\n        doRehash(this);\n        oldToNewMapping = null; // allow for gc\n      }\n    };\n\n    // note: these methods/phases align with FacetFieldProcessorByArray's\n\n    createCollectAcc();\n\n    collectDocs();\n\n    return super.findTopSlots(table.numSlots(), table.cardinality(),\n        slotNum -> calc.bitsToValue(table.vals[slotNum]), // getBucketValFromSlotNum\n        val -> calc.formatValue(val)); // getFieldQueryVal\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d81baa64023bbb9b43f6d929ee168b105940d30","date":1486492702,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByHashDV#calcFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByHashDV#calcFacets().mjava","sourceNew":"  private SimpleOrderedMap<Object> calcFacets() throws IOException {\n\n    if (sf.getType().getNumberType() != null) {\n      calc = FacetRangeProcessor.getNumericCalc(sf);\n    } else {\n      calc = new TermOrdCalc(); // kind of a hack\n    }\n\n    // TODO: Use the number of indexed terms, if present, as an estimate!\n    //    Even for NumericDocValues, we could check for a terms index for an estimate.\n    //    Our estimation should aim high to avoid expensive rehashes.\n\n    int possibleValues = fcontext.base.size();\n    // size smaller tables so that no resize will be necessary\n    int currHashSize = BitUtil.nextHighestPowerOfTwo((int) (possibleValues * (1 / LongCounts.LOAD_FACTOR) + 1));\n    currHashSize = Math.min(currHashSize, MAXIMUM_STARTING_TABLE_SIZE);\n    table = new LongCounts(currHashSize) {\n      @Override\n      protected void rehash() {\n        super.rehash();\n        doRehash(this);\n        oldToNewMapping = null; // allow for gc\n      }\n    };\n\n    // note: these methods/phases align with FacetFieldProcessorByArray's\n\n    createCollectAcc();\n\n    collectDocs();\n\n    return super.findTopSlots(table.numSlots(), table.cardinality(),\n        slotNum -> calc.bitsToValue(table.vals[slotNum]), // getBucketValFromSlotNum\n        val -> calc.formatValue(val)); // getFieldQueryVal\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> calcFacets() throws IOException {\n\n    if (sf.getType().getNumericType() != null) {\n      calc = FacetRangeProcessor.getNumericCalc(sf);\n    } else {\n      calc = new TermOrdCalc(); // kind of a hack\n    }\n\n    // TODO: Use the number of indexed terms, if present, as an estimate!\n    //    Even for NumericDocValues, we could check for a terms index for an estimate.\n    //    Our estimation should aim high to avoid expensive rehashes.\n\n    int possibleValues = fcontext.base.size();\n    // size smaller tables so that no resize will be necessary\n    int currHashSize = BitUtil.nextHighestPowerOfTwo((int) (possibleValues * (1 / LongCounts.LOAD_FACTOR) + 1));\n    currHashSize = Math.min(currHashSize, MAXIMUM_STARTING_TABLE_SIZE);\n    table = new LongCounts(currHashSize) {\n      @Override\n      protected void rehash() {\n        super.rehash();\n        doRehash(this);\n        oldToNewMapping = null; // allow for gc\n      }\n    };\n\n    // note: these methods/phases align with FacetFieldProcessorByArray's\n\n    createCollectAcc();\n\n    collectDocs();\n\n    return super.findTopSlots(table.numSlots(), table.cardinality(),\n        slotNum -> calc.bitsToValue(table.vals[slotNum]), // getBucketValFromSlotNum\n        val -> calc.formatValue(val)); // getFieldQueryVal\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"602cca3f75af03832471d8324bbc5b977a02969c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","602cca3f75af03832471d8324bbc5b977a02969c"],"bc8f206328a706450934717bec7ccc22ad166fc0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","602cca3f75af03832471d8324bbc5b977a02969c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3d81baa64023bbb9b43f6d929ee168b105940d30"]},"commit2Childs":{"602cca3f75af03832471d8324bbc5b977a02969c":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","bc8f206328a706450934717bec7ccc22ad166fc0"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["602cca3f75af03832471d8324bbc5b977a02969c","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","bc8f206328a706450934717bec7ccc22ad166fc0","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["3d81baa64023bbb9b43f6d929ee168b105940d30","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"bc8f206328a706450934717bec7ccc22ad166fc0":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bc8f206328a706450934717bec7ccc22ad166fc0","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}