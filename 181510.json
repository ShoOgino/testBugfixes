{"path":"solr/core/src/java/org/apache/solr/schema/IndexSchema#loadFields(Document,XPath).mjava","commits":[{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#loadFields(Document,XPath).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Loads fields and dynamic fields.\n   * \n   * @return a map from field name to explicit required value  \n   */ \n  protected synchronized Map<String,Boolean> loadFields(Document document, XPath xpath) throws XPathExpressionException {\n    // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n    Map<String,Boolean> explicitRequiredProp = new HashMap<String,Boolean>();\n    \n    ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n\n    //                  /schema/fields/field | /schema/fields/dynamicField\n    String expression = stepsToPath(SCHEMA, FIELDS, FIELD)\n           + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n    NodeList nodes = (NodeList)xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n\n      NamedNodeMap attrs = node.getAttributes();\n\n      String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n      log.trace(\"reading field def \"+name);\n      String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n      FieldType ft = fieldTypes.get(type);\n      if (ft==null) {\n        throw new SolrException\n            (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n      }\n\n      Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n      if (null != args.get(REQUIRED)) {\n        explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n      }\n\n      SchemaField f = SchemaField.create(name,ft,args);\n\n      if (node.getNodeName().equals(FIELD)) {\n        SchemaField old = fields.put(f.getName(),f);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate field definition for '\"\n            + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n        }\n        log.debug(\"field defined: \" + f);\n        if( f.getDefaultValue() != null ) {\n          log.debug(name+\" contains default value: \" + f.getDefaultValue());\n          fieldsWithDefaultValue.add( f );\n        }\n        if (f.isRequired()) {\n          log.debug(name+\" is required in this schema\");\n          requiredFields.add(f);\n        }\n      } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n        if (isValidFieldGlob(name)) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          String msg = \"Dynamic field name '\" + name \n              + \"' should have either a leading or a trailing asterisk, and no others.\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {\n        // we should never get here\n        throw new RuntimeException(\"Unknown field type\");\n      }\n    }\n\n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(fieldsWithDefaultValue);\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    return explicitRequiredProp;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e75db149281884cd045eec3a62d6accddf3a2c3","date":1378839652,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#loadFields(Document,XPath).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#loadFields(Document,XPath).mjava","sourceNew":"  /** \n   * Loads fields and dynamic fields.\n   * \n   * @return a map from field name to explicit required value  \n   */ \n  protected synchronized Map<String,Boolean> loadFields(Document document, XPath xpath) throws XPathExpressionException {\n    // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n    Map<String,Boolean> explicitRequiredProp = new HashMap<String,Boolean>();\n    \n    ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n\n    //                  /schema/fields/field | /schema/fields/dynamicField\n    String expression = stepsToPath(SCHEMA, FIELDS, FIELD)\n           + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n    NodeList nodes = (NodeList)xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n\n      NamedNodeMap attrs = node.getAttributes();\n\n      String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n      log.trace(\"reading field def \"+name);\n      String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n      FieldType ft = fieldTypes.get(type);\n      if (ft==null) {\n        throw new SolrException\n            (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n      }\n\n      Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n      if (null != args.get(REQUIRED)) {\n        explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n      }\n\n      SchemaField f = SchemaField.create(name,ft,args);\n\n      if (node.getNodeName().equals(FIELD)) {\n        SchemaField old = fields.put(f.getName(),f);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate field definition for '\"\n            + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n        }\n        log.debug(\"field defined: \" + f);\n        if( f.getDefaultValue() != null ) {\n          log.debug(name+\" contains default value: \" + f.getDefaultValue());\n          fieldsWithDefaultValue.add( f );\n        }\n        if (f.isRequired()) {\n          log.debug(name+\" is required in this schema\");\n          requiredFields.add(f);\n        }\n      } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n        if( f.getDefaultValue() != null ) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n                                  DYNAMIC_FIELD + \" can not have a default value: \" + name);\n        }\n        if ( f.isRequired() ) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n                                  DYNAMIC_FIELD + \" can not be required: \" + name);\n        }\n        if (isValidFieldGlob(name)) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          String msg = \"Dynamic field name '\" + name \n              + \"' should have either a leading or a trailing asterisk, and no others.\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {\n        // we should never get here\n        throw new RuntimeException(\"Unknown field type\");\n      }\n    }\n\n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(fieldsWithDefaultValue);\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    return explicitRequiredProp;\n  }\n\n","sourceOld":"  /** \n   * Loads fields and dynamic fields.\n   * \n   * @return a map from field name to explicit required value  \n   */ \n  protected synchronized Map<String,Boolean> loadFields(Document document, XPath xpath) throws XPathExpressionException {\n    // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n    Map<String,Boolean> explicitRequiredProp = new HashMap<String,Boolean>();\n    \n    ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n\n    //                  /schema/fields/field | /schema/fields/dynamicField\n    String expression = stepsToPath(SCHEMA, FIELDS, FIELD)\n           + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n    NodeList nodes = (NodeList)xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n\n      NamedNodeMap attrs = node.getAttributes();\n\n      String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n      log.trace(\"reading field def \"+name);\n      String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n      FieldType ft = fieldTypes.get(type);\n      if (ft==null) {\n        throw new SolrException\n            (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n      }\n\n      Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n      if (null != args.get(REQUIRED)) {\n        explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n      }\n\n      SchemaField f = SchemaField.create(name,ft,args);\n\n      if (node.getNodeName().equals(FIELD)) {\n        SchemaField old = fields.put(f.getName(),f);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate field definition for '\"\n            + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n        }\n        log.debug(\"field defined: \" + f);\n        if( f.getDefaultValue() != null ) {\n          log.debug(name+\" contains default value: \" + f.getDefaultValue());\n          fieldsWithDefaultValue.add( f );\n        }\n        if (f.isRequired()) {\n          log.debug(name+\" is required in this schema\");\n          requiredFields.add(f);\n        }\n      } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n        if (isValidFieldGlob(name)) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          String msg = \"Dynamic field name '\" + name \n              + \"' should have either a leading or a trailing asterisk, and no others.\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {\n        // we should never get here\n        throw new RuntimeException(\"Unknown field type\");\n      }\n    }\n\n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(fieldsWithDefaultValue);\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    return explicitRequiredProp;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#loadFields(Document,XPath).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#loadFields(Document,XPath).mjava","sourceNew":"  /** \n   * Loads fields and dynamic fields.\n   * \n   * @return a map from field name to explicit required value  \n   */ \n  protected synchronized Map<String,Boolean> loadFields(Document document, XPath xpath) throws XPathExpressionException {\n    // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n    Map<String,Boolean> explicitRequiredProp = new HashMap<>();\n    \n    ArrayList<DynamicField> dFields = new ArrayList<>();\n\n    //                  /schema/fields/field | /schema/fields/dynamicField\n    String expression = stepsToPath(SCHEMA, FIELDS, FIELD)\n           + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n    NodeList nodes = (NodeList)xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n\n      NamedNodeMap attrs = node.getAttributes();\n\n      String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n      log.trace(\"reading field def \"+name);\n      String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n      FieldType ft = fieldTypes.get(type);\n      if (ft==null) {\n        throw new SolrException\n            (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n      }\n\n      Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n      if (null != args.get(REQUIRED)) {\n        explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n      }\n\n      SchemaField f = SchemaField.create(name,ft,args);\n\n      if (node.getNodeName().equals(FIELD)) {\n        SchemaField old = fields.put(f.getName(),f);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate field definition for '\"\n            + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n        }\n        log.debug(\"field defined: \" + f);\n        if( f.getDefaultValue() != null ) {\n          log.debug(name+\" contains default value: \" + f.getDefaultValue());\n          fieldsWithDefaultValue.add( f );\n        }\n        if (f.isRequired()) {\n          log.debug(name+\" is required in this schema\");\n          requiredFields.add(f);\n        }\n      } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n        if( f.getDefaultValue() != null ) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n                                  DYNAMIC_FIELD + \" can not have a default value: \" + name);\n        }\n        if ( f.isRequired() ) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n                                  DYNAMIC_FIELD + \" can not be required: \" + name);\n        }\n        if (isValidFieldGlob(name)) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          String msg = \"Dynamic field name '\" + name \n              + \"' should have either a leading or a trailing asterisk, and no others.\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {\n        // we should never get here\n        throw new RuntimeException(\"Unknown field type\");\n      }\n    }\n\n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(fieldsWithDefaultValue);\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    return explicitRequiredProp;\n  }\n\n","sourceOld":"  /** \n   * Loads fields and dynamic fields.\n   * \n   * @return a map from field name to explicit required value  \n   */ \n  protected synchronized Map<String,Boolean> loadFields(Document document, XPath xpath) throws XPathExpressionException {\n    // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n    Map<String,Boolean> explicitRequiredProp = new HashMap<String,Boolean>();\n    \n    ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n\n    //                  /schema/fields/field | /schema/fields/dynamicField\n    String expression = stepsToPath(SCHEMA, FIELDS, FIELD)\n           + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n    NodeList nodes = (NodeList)xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n\n      NamedNodeMap attrs = node.getAttributes();\n\n      String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n      log.trace(\"reading field def \"+name);\n      String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n      FieldType ft = fieldTypes.get(type);\n      if (ft==null) {\n        throw new SolrException\n            (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n      }\n\n      Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n      if (null != args.get(REQUIRED)) {\n        explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n      }\n\n      SchemaField f = SchemaField.create(name,ft,args);\n\n      if (node.getNodeName().equals(FIELD)) {\n        SchemaField old = fields.put(f.getName(),f);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate field definition for '\"\n            + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n        }\n        log.debug(\"field defined: \" + f);\n        if( f.getDefaultValue() != null ) {\n          log.debug(name+\" contains default value: \" + f.getDefaultValue());\n          fieldsWithDefaultValue.add( f );\n        }\n        if (f.isRequired()) {\n          log.debug(name+\" is required in this schema\");\n          requiredFields.add(f);\n        }\n      } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n        if( f.getDefaultValue() != null ) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n                                  DYNAMIC_FIELD + \" can not have a default value: \" + name);\n        }\n        if ( f.isRequired() ) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n                                  DYNAMIC_FIELD + \" can not be required: \" + name);\n        }\n        if (isValidFieldGlob(name)) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          String msg = \"Dynamic field name '\" + name \n              + \"' should have either a leading or a trailing asterisk, and no others.\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {\n        // we should never get here\n        throw new RuntimeException(\"Unknown field type\");\n      }\n    }\n\n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(fieldsWithDefaultValue);\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    return explicitRequiredProp;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e1bc9368a5cae1776f5b12df9dac1b0477f8f4","date":1395589252,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#loadFields(Document,XPath).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#loadFields(Document,XPath).mjava","sourceNew":"  /** \n   * Loads fields and dynamic fields.\n   * \n   * @return a map from field name to explicit required value  \n   */ \n  protected synchronized Map<String,Boolean> loadFields(Document document, XPath xpath) throws XPathExpressionException {\n    // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n    Map<String,Boolean> explicitRequiredProp = new HashMap<>();\n    \n    ArrayList<DynamicField> dFields = new ArrayList<>();\n\n    //                  /schema/field | /schema/dynamicField | /schema/fields/field | /schema/fields/dynamicField\n    String expression = stepsToPath(SCHEMA, FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, DYNAMIC_FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, FIELDS, FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n\n    NodeList nodes = (NodeList)xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n\n      NamedNodeMap attrs = node.getAttributes();\n\n      String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n      log.trace(\"reading field def \"+name);\n      String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n      FieldType ft = fieldTypes.get(type);\n      if (ft==null) {\n        throw new SolrException\n            (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n      }\n\n      Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n      if (null != args.get(REQUIRED)) {\n        explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n      }\n\n      SchemaField f = SchemaField.create(name,ft,args);\n\n      if (node.getNodeName().equals(FIELD)) {\n        SchemaField old = fields.put(f.getName(),f);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate field definition for '\"\n            + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n        }\n        log.debug(\"field defined: \" + f);\n        if( f.getDefaultValue() != null ) {\n          log.debug(name+\" contains default value: \" + f.getDefaultValue());\n          fieldsWithDefaultValue.add( f );\n        }\n        if (f.isRequired()) {\n          log.debug(name+\" is required in this schema\");\n          requiredFields.add(f);\n        }\n      } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n        if( f.getDefaultValue() != null ) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n                                  DYNAMIC_FIELD + \" can not have a default value: \" + name);\n        }\n        if ( f.isRequired() ) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n                                  DYNAMIC_FIELD + \" can not be required: \" + name);\n        }\n        if (isValidFieldGlob(name)) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          String msg = \"Dynamic field name '\" + name \n              + \"' should have either a leading or a trailing asterisk, and no others.\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {\n        // we should never get here\n        throw new RuntimeException(\"Unknown field type\");\n      }\n    }\n\n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(fieldsWithDefaultValue);\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    return explicitRequiredProp;\n  }\n\n","sourceOld":"  /** \n   * Loads fields and dynamic fields.\n   * \n   * @return a map from field name to explicit required value  \n   */ \n  protected synchronized Map<String,Boolean> loadFields(Document document, XPath xpath) throws XPathExpressionException {\n    // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n    Map<String,Boolean> explicitRequiredProp = new HashMap<>();\n    \n    ArrayList<DynamicField> dFields = new ArrayList<>();\n\n    //                  /schema/fields/field | /schema/fields/dynamicField\n    String expression = stepsToPath(SCHEMA, FIELDS, FIELD)\n           + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n    NodeList nodes = (NodeList)xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n\n      NamedNodeMap attrs = node.getAttributes();\n\n      String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n      log.trace(\"reading field def \"+name);\n      String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n      FieldType ft = fieldTypes.get(type);\n      if (ft==null) {\n        throw new SolrException\n            (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n      }\n\n      Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n      if (null != args.get(REQUIRED)) {\n        explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n      }\n\n      SchemaField f = SchemaField.create(name,ft,args);\n\n      if (node.getNodeName().equals(FIELD)) {\n        SchemaField old = fields.put(f.getName(),f);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate field definition for '\"\n            + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n        }\n        log.debug(\"field defined: \" + f);\n        if( f.getDefaultValue() != null ) {\n          log.debug(name+\" contains default value: \" + f.getDefaultValue());\n          fieldsWithDefaultValue.add( f );\n        }\n        if (f.isRequired()) {\n          log.debug(name+\" is required in this schema\");\n          requiredFields.add(f);\n        }\n      } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n        if( f.getDefaultValue() != null ) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n                                  DYNAMIC_FIELD + \" can not have a default value: \" + name);\n        }\n        if ( f.isRequired() ) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n                                  DYNAMIC_FIELD + \" can not be required: \" + name);\n        }\n        if (isValidFieldGlob(name)) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          String msg = \"Dynamic field name '\" + name \n              + \"' should have either a leading or a trailing asterisk, and no others.\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {\n        // we should never get here\n        throw new RuntimeException(\"Unknown field type\");\n      }\n    }\n\n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(fieldsWithDefaultValue);\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    return explicitRequiredProp;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37e5b631c49de2fb88f245c36ecf87650cfa4a24","date":1409693105,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#loadFields(Document,XPath).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#loadFields(Document,XPath).mjava","sourceNew":"  /** \n   * Loads fields and dynamic fields.\n   * \n   * @return a map from field name to explicit required value  \n   */ \n  protected synchronized Map<String,Boolean> loadFields(Document document, XPath xpath) throws XPathExpressionException {\n    // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n    Map<String,Boolean> explicitRequiredProp = new HashMap<>();\n    \n    ArrayList<DynamicField> dFields = new ArrayList<>();\n\n    //                  /schema/field | /schema/dynamicField | /schema/fields/field | /schema/fields/dynamicField\n    String expression = stepsToPath(SCHEMA, FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, DYNAMIC_FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, FIELDS, FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n\n    NodeList nodes = (NodeList)xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n\n      NamedNodeMap attrs = node.getAttributes();\n\n      String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n      log.trace(\"reading field def \"+name);\n      String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n      FieldType ft = fieldTypes.get(type);\n      if (ft==null) {\n        throw new SolrException\n            (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n      }\n\n      Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n      if (null != args.get(REQUIRED)) {\n        explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n      }\n\n      SchemaField f = SchemaField.create(name,ft,args);\n\n      if (node.getNodeName().equals(FIELD)) {\n        SchemaField old = fields.put(f.getName(),f);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate field definition for '\"\n            + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n        }\n        log.debug(\"field defined: \" + f);\n        if( f.getDefaultValue() != null ) {\n          log.debug(name+\" contains default value: \" + f.getDefaultValue());\n          fieldsWithDefaultValue.add( f );\n        }\n        if (f.isRequired()) {\n          log.debug(name+\" is required in this schema\");\n          requiredFields.add(f);\n        }\n      } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n        if (isValidDynamicField(dFields, f)) {\n          addDynamicFieldNoDupCheck(dFields, f);\n        }\n      } else {\n        // we should never get here\n        throw new RuntimeException(\"Unknown field type\");\n      }\n    }\n\n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(fieldsWithDefaultValue);\n\n    dynamicFields = dynamicFieldListToSortedArray(dFields);\n                                                                   \n    return explicitRequiredProp;\n  }\n\n","sourceOld":"  /** \n   * Loads fields and dynamic fields.\n   * \n   * @return a map from field name to explicit required value  \n   */ \n  protected synchronized Map<String,Boolean> loadFields(Document document, XPath xpath) throws XPathExpressionException {\n    // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n    Map<String,Boolean> explicitRequiredProp = new HashMap<>();\n    \n    ArrayList<DynamicField> dFields = new ArrayList<>();\n\n    //                  /schema/field | /schema/dynamicField | /schema/fields/field | /schema/fields/dynamicField\n    String expression = stepsToPath(SCHEMA, FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, DYNAMIC_FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, FIELDS, FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n\n    NodeList nodes = (NodeList)xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n\n      NamedNodeMap attrs = node.getAttributes();\n\n      String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n      log.trace(\"reading field def \"+name);\n      String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n      FieldType ft = fieldTypes.get(type);\n      if (ft==null) {\n        throw new SolrException\n            (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n      }\n\n      Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n      if (null != args.get(REQUIRED)) {\n        explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n      }\n\n      SchemaField f = SchemaField.create(name,ft,args);\n\n      if (node.getNodeName().equals(FIELD)) {\n        SchemaField old = fields.put(f.getName(),f);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate field definition for '\"\n            + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n        }\n        log.debug(\"field defined: \" + f);\n        if( f.getDefaultValue() != null ) {\n          log.debug(name+\" contains default value: \" + f.getDefaultValue());\n          fieldsWithDefaultValue.add( f );\n        }\n        if (f.isRequired()) {\n          log.debug(name+\" is required in this schema\");\n          requiredFields.add(f);\n        }\n      } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n        if( f.getDefaultValue() != null ) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n                                  DYNAMIC_FIELD + \" can not have a default value: \" + name);\n        }\n        if ( f.isRequired() ) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n                                  DYNAMIC_FIELD + \" can not be required: \" + name);\n        }\n        if (isValidFieldGlob(name)) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          String msg = \"Dynamic field name '\" + name \n              + \"' should have either a leading or a trailing asterisk, and no others.\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n        }\n      } else {\n        // we should never get here\n        throw new RuntimeException(\"Unknown field type\");\n      }\n    }\n\n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(fieldsWithDefaultValue);\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    return explicitRequiredProp;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9df8125ba9193a2e2e285ed92157810b1952a244","date":1587326330,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#loadFields(Document,XPath).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#loadFields(Document,XPath).mjava","sourceNew":"  /** \n   * Loads fields and dynamic fields.\n   * \n   * @return a map from field name to explicit required value  \n   */ \n  protected synchronized Map<String,Boolean> loadFields(Document document, XPath xpath) throws XPathExpressionException {\n    // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n    Map<String,Boolean> explicitRequiredProp = new HashMap<>();\n    \n    ArrayList<DynamicField> dFields = new ArrayList<>();\n\n    //                  /schema/field | /schema/dynamicField | /schema/fields/field | /schema/fields/dynamicField\n    String expression = stepsToPath(SCHEMA, FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, DYNAMIC_FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, FIELDS, FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n\n    NodeList nodes = (NodeList)xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n\n      NamedNodeMap attrs = node.getAttributes();\n\n      String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n      log.trace(\"reading field def {}\", name);\n      String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n      FieldType ft = fieldTypes.get(type);\n      if (ft==null) {\n        throw new SolrException\n            (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n      }\n\n      Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n      if (null != args.get(REQUIRED)) {\n        explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n      }\n\n      SchemaField f = SchemaField.create(name,ft,args);\n\n      if (node.getNodeName().equals(FIELD)) {\n        SchemaField old = fields.put(f.getName(),f);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate field definition for '\"\n            + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n        }\n        log.debug(\"field defined: {}\", f);\n        if( f.getDefaultValue() != null ) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"{} contains default value {}\", name, f.getDefaultValue());\n          }\n          fieldsWithDefaultValue.add( f );\n        }\n        if (f.isRequired()) {\n          log.debug(\"{} is required in this schema\", name);\n          requiredFields.add(f);\n        }\n      } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n        if (isValidDynamicField(dFields, f)) {\n          addDynamicFieldNoDupCheck(dFields, f);\n        }\n      } else {\n        // we should never get here\n        throw new RuntimeException(\"Unknown field type\");\n      }\n    }\n\n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(fieldsWithDefaultValue);\n\n    dynamicFields = dynamicFieldListToSortedArray(dFields);\n                                                                   \n    return explicitRequiredProp;\n  }\n\n","sourceOld":"  /** \n   * Loads fields and dynamic fields.\n   * \n   * @return a map from field name to explicit required value  \n   */ \n  protected synchronized Map<String,Boolean> loadFields(Document document, XPath xpath) throws XPathExpressionException {\n    // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n    Map<String,Boolean> explicitRequiredProp = new HashMap<>();\n    \n    ArrayList<DynamicField> dFields = new ArrayList<>();\n\n    //                  /schema/field | /schema/dynamicField | /schema/fields/field | /schema/fields/dynamicField\n    String expression = stepsToPath(SCHEMA, FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, DYNAMIC_FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, FIELDS, FIELD)\n        + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);\n\n    NodeList nodes = (NodeList)xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n    for (int i=0; i<nodes.getLength(); i++) {\n      Node node = nodes.item(i);\n\n      NamedNodeMap attrs = node.getAttributes();\n\n      String name = DOMUtil.getAttr(attrs, NAME, \"field definition\");\n      log.trace(\"reading field def \"+name);\n      String type = DOMUtil.getAttr(attrs, TYPE, \"field \" + name);\n\n      FieldType ft = fieldTypes.get(type);\n      if (ft==null) {\n        throw new SolrException\n            (ErrorCode.BAD_REQUEST, \"Unknown \" + FIELD_TYPE + \" '\" + type + \"' specified on field \" + name);\n      }\n\n      Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);\n      if (null != args.get(REQUIRED)) {\n        explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));\n      }\n\n      SchemaField f = SchemaField.create(name,ft,args);\n\n      if (node.getNodeName().equals(FIELD)) {\n        SchemaField old = fields.put(f.getName(),f);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate field definition for '\"\n            + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n          throw new SolrException(ErrorCode.SERVER_ERROR, msg );\n        }\n        log.debug(\"field defined: \" + f);\n        if( f.getDefaultValue() != null ) {\n          log.debug(name+\" contains default value: \" + f.getDefaultValue());\n          fieldsWithDefaultValue.add( f );\n        }\n        if (f.isRequired()) {\n          log.debug(name+\" is required in this schema\");\n          requiredFields.add(f);\n        }\n      } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {\n        if (isValidDynamicField(dFields, f)) {\n          addDynamicFieldNoDupCheck(dFields, f);\n        }\n      } else {\n        // we should never get here\n        throw new RuntimeException(\"Unknown field type\");\n      }\n    }\n\n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(fieldsWithDefaultValue);\n\n    dynamicFields = dynamicFieldListToSortedArray(dFields);\n                                                                   \n    return explicitRequiredProp;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["9e75db149281884cd045eec3a62d6accddf3a2c3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"37e5b631c49de2fb88f245c36ecf87650cfa4a24":["15e1bc9368a5cae1776f5b12df9dac1b0477f8f4"],"9e75db149281884cd045eec3a62d6accddf3a2c3":["08970e5b8411182a29412c177eff67ec1110095b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9df8125ba9193a2e2e285ed92157810b1952a244"],"9df8125ba9193a2e2e285ed92157810b1952a244":["37e5b631c49de2fb88f245c36ecf87650cfa4a24"],"15e1bc9368a5cae1776f5b12df9dac1b0477f8f4":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"08970e5b8411182a29412c177eff67ec1110095b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["15e1bc9368a5cae1776f5b12df9dac1b0477f8f4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["08970e5b8411182a29412c177eff67ec1110095b"],"37e5b631c49de2fb88f245c36ecf87650cfa4a24":["9df8125ba9193a2e2e285ed92157810b1952a244"],"9e75db149281884cd045eec3a62d6accddf3a2c3":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"15e1bc9368a5cae1776f5b12df9dac1b0477f8f4":["37e5b631c49de2fb88f245c36ecf87650cfa4a24"],"08970e5b8411182a29412c177eff67ec1110095b":["9e75db149281884cd045eec3a62d6accddf3a2c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9df8125ba9193a2e2e285ed92157810b1952a244":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}