{"path":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#updateMaxScoresIfNecessary(int).mjava","commits":[{"id":"523cc6563c99a55527ef7993efc5413c6648852d","date":1518704038,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#updateMaxScoresIfNecessary(int).mjava","pathOld":"/dev/null","sourceNew":"  private void updateMaxScoresIfNecessary(int target) throws IOException {\n    assert lead == null;\n\n    if (head.size() == 0) { // no matches in the current block\n      if (upTo != DocIdSetIterator.NO_MORE_DOCS) {\n        updateMaxScores(Math.max(target, upTo + 1));\n      }\n    } else if (head.top().doc > upTo) { // the next candidate is in a different block\n      assert head.top().doc >= target;\n      updateMaxScores(target);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0f25eddf3c27255ac101c0ce6044684cfe24c785"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f25eddf3c27255ac101c0ce6044684cfe24c785","date":1576772095,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#updateMaxScoresIfNecessary(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#updateMaxScoresIfNecessary(int).mjava","sourceNew":"  /**\n   * Update {@code upTo} and maximum scores of sub scorers so that {@code upTo}\n   * is greater than or equal to the next candidate after {@code target}, i.e.\n   * the top of `head`.\n   */\n  private void updateMaxScoresIfNecessary(int target) throws IOException {\n    assert lead == null;\n\n    while (upTo < DocIdSetIterator.NO_MORE_DOCS) {\n      if (head.size() == 0) {\n        // All clauses could fit in the tail, which means that the sum of the\n        // maximum scores of sub clauses is less than the minimum competitive score.\n        // Move to the next block until this condition becomes false.\n        target = Math.max(target, upTo + 1);\n        updateMaxScores(target);\n      } else if (head.top().doc > upTo) {\n        // We have a next candidate but it's not in the current block. We need to\n        // move to the next block in order to not miss any potential hits between\n        // `target` and `head.top().doc`.\n        assert head.top().doc >= target;\n        updateMaxScores(target);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    assert upTo == DocIdSetIterator.NO_MORE_DOCS || (head.size() > 0 && head.top().doc <= upTo);\n  }\n\n","sourceOld":"  private void updateMaxScoresIfNecessary(int target) throws IOException {\n    assert lead == null;\n\n    if (head.size() == 0) { // no matches in the current block\n      if (upTo != DocIdSetIterator.NO_MORE_DOCS) {\n        updateMaxScores(Math.max(target, upTo + 1));\n      }\n    } else if (head.top().doc > upTo) { // the next candidate is in a different block\n      assert head.top().doc >= target;\n      updateMaxScores(target);\n    }\n  }\n\n","bugFix":["523cc6563c99a55527ef7993efc5413c6648852d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c66470e527299cc148ad0b3441d08dfb7cb9e03","date":1576859740,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#updateMaxScoresIfNecessary(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#updateMaxScoresIfNecessary(int).mjava","sourceNew":"  /**\n   * Update {@code upTo} and maximum scores of sub scorers so that {@code upTo}\n   * is greater than or equal to the next candidate after {@code target}, i.e.\n   * the top of `head`.\n   */\n  private void updateMaxScoresIfNecessary(int target) throws IOException {\n    assert lead == null;\n\n    while (upTo < DocIdSetIterator.NO_MORE_DOCS) {\n      if (head.size() == 0) {\n        // All clauses could fit in the tail, which means that the sum of the\n        // maximum scores of sub clauses is less than the minimum competitive score.\n        // Move to the next block until this condition becomes false.\n        target = Math.max(target, upTo + 1);\n        updateMaxScores(target);\n      } else if (head.top().doc > upTo) {\n        // We have a next candidate but it's not in the current block. We need to\n        // move to the next block in order to not miss any potential hits between\n        // `target` and `head.top().doc`.\n        assert head.top().doc >= target;\n        updateMaxScores(target);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    assert upTo == DocIdSetIterator.NO_MORE_DOCS || (head.size() > 0 && head.top().doc <= upTo);\n  }\n\n","sourceOld":"  private void updateMaxScoresIfNecessary(int target) throws IOException {\n    assert lead == null;\n\n    if (head.size() == 0) { // no matches in the current block\n      if (upTo != DocIdSetIterator.NO_MORE_DOCS) {\n        updateMaxScores(Math.max(target, upTo + 1));\n      }\n    } else if (head.top().doc > upTo) { // the next candidate is in a different block\n      assert head.top().doc >= target;\n      updateMaxScores(target);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0f25eddf3c27255ac101c0ce6044684cfe24c785":["523cc6563c99a55527ef7993efc5413c6648852d"],"4c66470e527299cc148ad0b3441d08dfb7cb9e03":["523cc6563c99a55527ef7993efc5413c6648852d","0f25eddf3c27255ac101c0ce6044684cfe24c785"],"523cc6563c99a55527ef7993efc5413c6648852d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f25eddf3c27255ac101c0ce6044684cfe24c785"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["523cc6563c99a55527ef7993efc5413c6648852d"],"0f25eddf3c27255ac101c0ce6044684cfe24c785":["4c66470e527299cc148ad0b3441d08dfb7cb9e03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4c66470e527299cc148ad0b3441d08dfb7cb9e03":[],"523cc6563c99a55527ef7993efc5413c6648852d":["0f25eddf3c27255ac101c0ce6044684cfe24c785","4c66470e527299cc148ad0b3441d08dfb7cb9e03"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4c66470e527299cc148ad0b3441d08dfb7cb9e03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}