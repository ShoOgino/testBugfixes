{"path":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","commits":[{"id":"99a533edf1b9ea2c1b85e012d6e826545389e9c8","date":1329256696,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws KeeperException, InterruptedException {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 15) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(2000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a80994db3380cd78c6f65b84515e2e931b6b3da","date":1329530403,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 120) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws KeeperException, InterruptedException {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 15) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(2000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8","date":1329853856,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 120) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 120) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 120) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 120) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08bcaef9e931052e4ca24133a89cc6aefaf61829","date":1342469326,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 520) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 120) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 520) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 120) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc","date":1342989037,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection, ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    waitForRecoveriesToFinish(collection, zkStateReader, verbose, failOnTimeout, 120 * (TEST_NIGHTLY ? 2 : 1) * RANDOM_MULTIPLIER);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 520) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":["99a533edf1b9ea2c1b85e012d6e826545389e9c8","d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8","08bcaef9e931052e4ca24133a89cc6aefaf61829","3a80994db3380cd78c6f65b84515e2e931b6b3da"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection, ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    waitForRecoveriesToFinish(collection, zkStateReader, verbose, failOnTimeout, 120 * (TEST_NIGHTLY ? 2 : 1) * RANDOM_MULTIPLIER);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 520) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection, ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    waitForRecoveriesToFinish(collection, zkStateReader, verbose, failOnTimeout, 120 * (TEST_NIGHTLY ? 2 : 1) * RANDOM_MULTIPLIER);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == 120) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c30e4c1cee08b3b229a77991882594fe7250b66","date":1344448871,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection, ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    waitForRecoveriesToFinish(collection, zkStateReader, verbose, failOnTimeout, 120 * (TEST_NIGHTLY ? 2 : 1) * RANDOM_MULTIPLIER);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection, ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    waitForRecoveriesToFinish(collection, zkStateReader, verbose, failOnTimeout, 120 * (TEST_NIGHTLY ? 2 : 1) * RANDOM_MULTIPLIER);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":5,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection, ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    waitForRecoveriesToFinish(collection, zkStateReader, verbose, failOnTimeout, 120 * (TEST_NIGHTLY ? 2 : 1) * RANDOM_MULTIPLIER);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection, ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    waitForRecoveriesToFinish(collection, zkStateReader, verbose, failOnTimeout, 120 * (TEST_NIGHTLY ? 2 : 1) * RANDOM_MULTIPLIER);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection, ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    waitForRecoveriesToFinish(collection, zkStateReader, verbose, failOnTimeout, 120 * (TEST_NIGHTLY ? 2 : 1) * RANDOM_MULTIPLIER);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection, ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout)\n      throws Exception {\n    waitForRecoveriesToFinish(collection, zkStateReader, verbose, failOnTimeout, 120 * (TEST_NIGHTLY ? 2 : 1) * RANDOM_MULTIPLIER);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"99a533edf1b9ea2c1b85e012d6e826545389e9c8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a80994db3380cd78c6f65b84515e2e931b6b3da","d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8"],"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc":["08bcaef9e931052e4ca24133a89cc6aefaf61829"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","2c30e4c1cee08b3b229a77991882594fe7250b66"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8","933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","2c30e4c1cee08b3b229a77991882594fe7250b66"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["fe33227f6805edab2036cbb80645cc4e2d1fa424","933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"08bcaef9e931052e4ca24133a89cc6aefaf61829":["d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8"],"d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8":["3a80994db3380cd78c6f65b84515e2e931b6b3da"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["99a533edf1b9ea2c1b85e012d6e826545389e9c8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2c30e4c1cee08b3b229a77991882594fe7250b66"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"]},"commit2Childs":{"99a533edf1b9ea2c1b85e012d6e826545389e9c8":["3a80994db3380cd78c6f65b84515e2e931b6b3da"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","2c30e4c1cee08b3b229a77991882594fe7250b66"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["99a533edf1b9ea2c1b85e012d6e826545389e9c8"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"08bcaef9e931052e4ca24133a89cc6aefaf61829":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}