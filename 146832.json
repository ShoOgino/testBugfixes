{"path":"lucene/contrib/fast-vector-highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/fast-vector-highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery).mjava","pathOld":"contrib/fast-vector-highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery).mjava","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() ){\n      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() ){\n      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36f91bf9cfc9d0c3155edab43359e7670ea8a5af","date":1269580873,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery).mjava","pathOld":"lucene/contrib/fast-vector-highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery).mjava","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() ){\n      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() ){\n      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"36f91bf9cfc9d0c3155edab43359e7670ea8a5af":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["36f91bf9cfc9d0c3155edab43359e7670ea8a5af"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"36f91bf9cfc9d0c3155edab43359e7670ea8a5af":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["36f91bf9cfc9d0c3155edab43359e7670ea8a5af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}