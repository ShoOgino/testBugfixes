{"path":"lucene/sandbox/src/test/org/apache/lucene/search/TestCoveringQuery#testRandom().mjava","commits":[{"id":"7d5484fcfd752ec7a2ff2ed6a860c539fdf92da8","date":1503307834,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestCoveringQuery#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    int numDocs = atLeast(200);\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"field\", \"A\", Store.NO));\n      }\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"field\", \"B\", Store.NO));\n      }\n      if (random().nextDouble() > 0.9) {\n        doc.add(new StringField(\"field\", \"C\", Store.NO));\n      }\n      if (random().nextDouble() > 0.1) {\n        doc.add(new StringField(\"field\", \"D\", Store.NO));\n      }\n      doc.add(new NumericDocValuesField(\"min_match\", random().nextInt(6)));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = DirectoryReader.open(w);\n    IndexSearcher searcher = new IndexSearcher(r);\n    w.close();\n\n    int iters = atLeast(10);\n    for (int iter = 0; iter < iters; ++iter) {\n      List<Query> queries = new ArrayList<>();\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"A\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"B\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"C\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"D\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"E\")));\n      }\n\n      Query q = new CoveringQuery(queries, LongValuesSource.fromLongField(\"min_match\"));\n      QueryUtils.check(random(), q, searcher);\n\n      for (int i = 1; i < 4; ++i) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(i);\n        for (Query query : queries) {\n          builder.add(query, Occur.SHOULD);\n        }\n        Query q1 = builder.build();\n        Query q2 = new CoveringQuery(queries, LongValuesSource.constant(i));\n        assertEquals(\n            searcher.count(q1),\n            searcher.count(q2));\n      }\n\n      Query filtered = new BooleanQuery.Builder()\n          .add(q, Occur.MUST)\n          .add(new TermQuery(new Term(\"field\", \"A\")), Occur.MUST)\n          .build();\n      QueryUtils.check(random(), filtered, searcher);\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8e4fbf51a35a1292b838d83f793794c274932a1","date":1503371298,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestCoveringQuery#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    int numDocs = atLeast(200);\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"field\", \"A\", Store.NO));\n      }\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"field\", \"B\", Store.NO));\n      }\n      if (random().nextDouble() > 0.9) {\n        doc.add(new StringField(\"field\", \"C\", Store.NO));\n      }\n      if (random().nextDouble() > 0.1) {\n        doc.add(new StringField(\"field\", \"D\", Store.NO));\n      }\n      doc.add(new NumericDocValuesField(\"min_match\", random().nextInt(6)));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = DirectoryReader.open(w);\n    IndexSearcher searcher = new IndexSearcher(r);\n    w.close();\n\n    int iters = atLeast(10);\n    for (int iter = 0; iter < iters; ++iter) {\n      List<Query> queries = new ArrayList<>();\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"A\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"B\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"C\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"D\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"E\")));\n      }\n\n      Query q = new CoveringQuery(queries, LongValuesSource.fromLongField(\"min_match\"));\n      QueryUtils.check(random(), q, searcher);\n\n      for (int i = 1; i < 4; ++i) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(i);\n        for (Query query : queries) {\n          builder.add(query, Occur.SHOULD);\n        }\n        Query q1 = builder.build();\n        Query q2 = new CoveringQuery(queries, LongValuesSource.constant(i));\n        assertEquals(\n            searcher.count(q1),\n            searcher.count(q2));\n      }\n\n      Query filtered = new BooleanQuery.Builder()\n          .add(q, Occur.MUST)\n          .add(new TermQuery(new Term(\"field\", \"A\")), Occur.MUST)\n          .build();\n      QueryUtils.check(random(), filtered, searcher);\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestCoveringQuery#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    int numDocs = atLeast(200);\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"field\", \"A\", Store.NO));\n      }\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"field\", \"B\", Store.NO));\n      }\n      if (random().nextDouble() > 0.9) {\n        doc.add(new StringField(\"field\", \"C\", Store.NO));\n      }\n      if (random().nextDouble() > 0.1) {\n        doc.add(new StringField(\"field\", \"D\", Store.NO));\n      }\n      doc.add(new NumericDocValuesField(\"min_match\", random().nextInt(6)));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = DirectoryReader.open(w);\n    IndexSearcher searcher = new IndexSearcher(r);\n    w.close();\n\n    int iters = atLeast(10);\n    for (int iter = 0; iter < iters; ++iter) {\n      List<Query> queries = new ArrayList<>();\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"A\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"B\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"C\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"D\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"E\")));\n      }\n\n      Query q = new CoveringQuery(queries, LongValuesSource.fromLongField(\"min_match\"));\n      QueryUtils.check(random(), q, searcher);\n\n      for (int i = 1; i < 4; ++i) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(i);\n        for (Query query : queries) {\n          builder.add(query, Occur.SHOULD);\n        }\n        Query q1 = builder.build();\n        Query q2 = new CoveringQuery(queries, LongValuesSource.constant(i));\n        assertEquals(\n            searcher.count(q1),\n            searcher.count(q2));\n      }\n\n      Query filtered = new BooleanQuery.Builder()\n          .add(q, Occur.MUST)\n          .add(new TermQuery(new Term(\"field\", \"A\")), Occur.MUST)\n          .build();\n      QueryUtils.check(random(), filtered, searcher);\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","date":1579652839,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestCoveringQuery#testRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestCoveringQuery#testRandom().mjava","sourceNew":"  public void testRandom() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    int numDocs = atLeast(50);\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"field\", \"A\", Store.NO));\n      }\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"field\", \"B\", Store.NO));\n      }\n      if (random().nextDouble() > 0.9) {\n        doc.add(new StringField(\"field\", \"C\", Store.NO));\n      }\n      if (random().nextDouble() > 0.1) {\n        doc.add(new StringField(\"field\", \"D\", Store.NO));\n      }\n      doc.add(new NumericDocValuesField(\"min_match\", random().nextInt(6)));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = DirectoryReader.open(w);\n    IndexSearcher searcher = new IndexSearcher(r);\n    w.close();\n\n    int iters = atLeast(10);\n    for (int iter = 0; iter < iters; ++iter) {\n      List<Query> queries = new ArrayList<>();\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"A\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"B\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"C\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"D\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"E\")));\n      }\n\n      Query q = new CoveringQuery(queries, LongValuesSource.fromLongField(\"min_match\"));\n      QueryUtils.check(random(), q, searcher);\n\n      for (int i = 1; i < 4; ++i) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(i);\n        for (Query query : queries) {\n          builder.add(query, Occur.SHOULD);\n        }\n        Query q1 = builder.build();\n        Query q2 = new CoveringQuery(queries, LongValuesSource.constant(i));\n        assertEquals(\n            searcher.count(q1),\n            searcher.count(q2));\n      }\n\n      Query filtered = new BooleanQuery.Builder()\n          .add(q, Occur.MUST)\n          .add(new TermQuery(new Term(\"field\", \"A\")), Occur.MUST)\n          .build();\n      QueryUtils.check(random(), filtered, searcher);\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    int numDocs = atLeast(200);\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"field\", \"A\", Store.NO));\n      }\n      if (random().nextBoolean()) {\n        doc.add(new StringField(\"field\", \"B\", Store.NO));\n      }\n      if (random().nextDouble() > 0.9) {\n        doc.add(new StringField(\"field\", \"C\", Store.NO));\n      }\n      if (random().nextDouble() > 0.1) {\n        doc.add(new StringField(\"field\", \"D\", Store.NO));\n      }\n      doc.add(new NumericDocValuesField(\"min_match\", random().nextInt(6)));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = DirectoryReader.open(w);\n    IndexSearcher searcher = new IndexSearcher(r);\n    w.close();\n\n    int iters = atLeast(10);\n    for (int iter = 0; iter < iters; ++iter) {\n      List<Query> queries = new ArrayList<>();\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"A\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"B\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"C\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"D\")));\n      }\n      if (random().nextBoolean()) {\n        queries.add(new TermQuery(new Term(\"field\", \"E\")));\n      }\n\n      Query q = new CoveringQuery(queries, LongValuesSource.fromLongField(\"min_match\"));\n      QueryUtils.check(random(), q, searcher);\n\n      for (int i = 1; i < 4; ++i) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(i);\n        for (Query query : queries) {\n          builder.add(query, Occur.SHOULD);\n        }\n        Query q1 = builder.build();\n        Query q2 = new CoveringQuery(queries, LongValuesSource.constant(i));\n        assertEquals(\n            searcher.count(q1),\n            searcher.count(q2));\n      }\n\n      Query filtered = new BooleanQuery.Builder()\n          .add(q, Occur.MUST)\n          .add(new TermQuery(new Term(\"field\", \"A\")), Occur.MUST)\n          .build();\n      QueryUtils.check(random(), filtered, searcher);\n    }\n    \n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["a8e4fbf51a35a1292b838d83f793794c274932a1"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a8e4fbf51a35a1292b838d83f793794c274932a1"],"7d5484fcfd752ec7a2ff2ed6a860c539fdf92da8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"a8e4fbf51a35a1292b838d83f793794c274932a1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7d5484fcfd752ec7a2ff2ed6a860c539fdf92da8"]},"commit2Childs":{"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"7d5484fcfd752ec7a2ff2ed6a860c539fdf92da8":["a8e4fbf51a35a1292b838d83f793794c274932a1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","7d5484fcfd752ec7a2ff2ed6a860c539fdf92da8","a8e4fbf51a35a1292b838d83f793794c274932a1"],"a8e4fbf51a35a1292b838d83f793794c274932a1":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}