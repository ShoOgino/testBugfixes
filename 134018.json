{"path":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(CharSequence,int,int,int).mjava","commits":[{"id":"19024c62496b4703b181a585ccd7e7c9101f06a9","date":1343772512,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(CharSequence,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the MurmurHash3_x86_32 hash of the UTF-8 bytes of the String without actually encoding\n   * the string to a temporary buffer.  This is more than 2x faster than hashing the result\n   * of String.getBytes().\n   */\n  public static int murmurhash3_x86_32(CharSequence data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n\n    int pos = offset;\n    int end = offset + len;\n    int k1 = 0;\n    int k2 = 0;\n    int shift = 0;\n    int bits = 0;\n    int nBytes = 0;   // length in UTF8 bytes\n\n\n    while (pos < end) {\n      int code = data.charAt(pos++);\n      if (code < 0x80) {\n        k2 = code;\n        bits = 8;\n\n        /***\n         // optimized ascii implementation (currently slower!!! code size?)\n         if (shift == 24) {\n         k1 = k1 | (code << 24);\n\n         k1 *= c1;\n         k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n         k1 *= c2;\n\n         h1 ^= k1;\n         h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n         h1 = h1*5+0xe6546b64;\n\n         shift = 0;\n         nBytes += 4;\n         k1 = 0;\n         } else {\n         k1 |= code << shift;\n         shift += 8;\n         }\n         continue;\n         ***/\n\n      }\n      else if (code < 0x800) {\n        k2 = (0xC0 | (code >> 6))\n            | ((0x80 | (code & 0x3F)) << 8);\n        bits = 16;\n      }\n      else if (code < 0xD800 || code > 0xDFFF || pos>=end) {\n        // we check for pos>=end to encode an unpaired surrogate as 3 bytes.\n        k2 = (0xE0 | (code >> 12))\n            | ((0x80 | ((code >> 6) & 0x3F)) << 8)\n            | ((0x80 | (code & 0x3F)) << 16);\n        bits = 24;\n      } else {\n        // surrogate pair\n        // int utf32 = pos < end ? (int) data.charAt(pos++) : 0;\n        int utf32 = (int) data.charAt(pos++);\n        utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n        k2 = (0xff & (0xF0 | (utf32 >> 18)))\n            | ((0x80 | ((utf32 >> 12) & 0x3F))) << 8\n            | ((0x80 | ((utf32 >> 6) & 0x3F))) << 16\n            |  (0x80 | (utf32 & 0x3F)) << 24;\n        bits = 32;\n      }\n\n\n      k1 |= k2 << shift;\n\n      // int used_bits = 32 - shift;  // how many bits of k2 were used in k1.\n      // int unused_bits = bits - used_bits; //  (bits-(32-shift)) == bits+shift-32  == bits-newshift\n\n      shift += bits;\n      if (shift >= 32) {\n        // mix after we have a complete word\n\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n        h1 = h1*5+0xe6546b64;\n\n        shift -= 32;\n        // unfortunately, java won't let you shift 32 bits off, so we need to check for 0\n        if (shift != 0) {\n          k1 = k2 >>> (bits-shift);   // bits used == bits - newshift\n        } else {\n          k1 = 0;\n        }\n        nBytes += 4;\n      }\n\n    } // inner\n\n    // handle tail\n    if (shift > 0) {\n      nBytes += shift >> 3;\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n      h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= nBytes;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(CharSequence,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the MurmurHash3_x86_32 hash of the UTF-8 bytes of the String without actually encoding\n   * the string to a temporary buffer.  This is more than 2x faster than hashing the result\n   * of String.getBytes().\n   */\n  public static int murmurhash3_x86_32(CharSequence data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n\n    int pos = offset;\n    int end = offset + len;\n    int k1 = 0;\n    int k2 = 0;\n    int shift = 0;\n    int bits = 0;\n    int nBytes = 0;   // length in UTF8 bytes\n\n\n    while (pos < end) {\n      int code = data.charAt(pos++);\n      if (code < 0x80) {\n        k2 = code;\n        bits = 8;\n\n        /***\n         // optimized ascii implementation (currently slower!!! code size?)\n         if (shift == 24) {\n         k1 = k1 | (code << 24);\n\n         k1 *= c1;\n         k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n         k1 *= c2;\n\n         h1 ^= k1;\n         h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n         h1 = h1*5+0xe6546b64;\n\n         shift = 0;\n         nBytes += 4;\n         k1 = 0;\n         } else {\n         k1 |= code << shift;\n         shift += 8;\n         }\n         continue;\n         ***/\n\n      }\n      else if (code < 0x800) {\n        k2 = (0xC0 | (code >> 6))\n            | ((0x80 | (code & 0x3F)) << 8);\n        bits = 16;\n      }\n      else if (code < 0xD800 || code > 0xDFFF || pos>=end) {\n        // we check for pos>=end to encode an unpaired surrogate as 3 bytes.\n        k2 = (0xE0 | (code >> 12))\n            | ((0x80 | ((code >> 6) & 0x3F)) << 8)\n            | ((0x80 | (code & 0x3F)) << 16);\n        bits = 24;\n      } else {\n        // surrogate pair\n        // int utf32 = pos < end ? (int) data.charAt(pos++) : 0;\n        int utf32 = (int) data.charAt(pos++);\n        utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n        k2 = (0xff & (0xF0 | (utf32 >> 18)))\n            | ((0x80 | ((utf32 >> 12) & 0x3F))) << 8\n            | ((0x80 | ((utf32 >> 6) & 0x3F))) << 16\n            |  (0x80 | (utf32 & 0x3F)) << 24;\n        bits = 32;\n      }\n\n\n      k1 |= k2 << shift;\n\n      // int used_bits = 32 - shift;  // how many bits of k2 were used in k1.\n      // int unused_bits = bits - used_bits; //  (bits-(32-shift)) == bits+shift-32  == bits-newshift\n\n      shift += bits;\n      if (shift >= 32) {\n        // mix after we have a complete word\n\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n        h1 = h1*5+0xe6546b64;\n\n        shift -= 32;\n        // unfortunately, java won't let you shift 32 bits off, so we need to check for 0\n        if (shift != 0) {\n          k1 = k2 >>> (bits-shift);   // bits used == bits - newshift\n        } else {\n          k1 = 0;\n        }\n        nBytes += 4;\n      }\n\n    } // inner\n\n    // handle tail\n    if (shift > 0) {\n      nBytes += shift >> 3;\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n      h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= nBytes;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(CharSequence,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the MurmurHash3_x86_32 hash of the UTF-8 bytes of the String without actually encoding\n   * the string to a temporary buffer.  This is more than 2x faster than hashing the result\n   * of String.getBytes().\n   */\n  public static int murmurhash3_x86_32(CharSequence data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n\n    int pos = offset;\n    int end = offset + len;\n    int k1 = 0;\n    int k2 = 0;\n    int shift = 0;\n    int bits = 0;\n    int nBytes = 0;   // length in UTF8 bytes\n\n\n    while (pos < end) {\n      int code = data.charAt(pos++);\n      if (code < 0x80) {\n        k2 = code;\n        bits = 8;\n\n        /***\n         // optimized ascii implementation (currently slower!!! code size?)\n         if (shift == 24) {\n         k1 = k1 | (code << 24);\n\n         k1 *= c1;\n         k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n         k1 *= c2;\n\n         h1 ^= k1;\n         h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n         h1 = h1*5+0xe6546b64;\n\n         shift = 0;\n         nBytes += 4;\n         k1 = 0;\n         } else {\n         k1 |= code << shift;\n         shift += 8;\n         }\n         continue;\n         ***/\n\n      }\n      else if (code < 0x800) {\n        k2 = (0xC0 | (code >> 6))\n            | ((0x80 | (code & 0x3F)) << 8);\n        bits = 16;\n      }\n      else if (code < 0xD800 || code > 0xDFFF || pos>=end) {\n        // we check for pos>=end to encode an unpaired surrogate as 3 bytes.\n        k2 = (0xE0 | (code >> 12))\n            | ((0x80 | ((code >> 6) & 0x3F)) << 8)\n            | ((0x80 | (code & 0x3F)) << 16);\n        bits = 24;\n      } else {\n        // surrogate pair\n        // int utf32 = pos < end ? (int) data.charAt(pos++) : 0;\n        int utf32 = (int) data.charAt(pos++);\n        utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n        k2 = (0xff & (0xF0 | (utf32 >> 18)))\n            | ((0x80 | ((utf32 >> 12) & 0x3F))) << 8\n            | ((0x80 | ((utf32 >> 6) & 0x3F))) << 16\n            |  (0x80 | (utf32 & 0x3F)) << 24;\n        bits = 32;\n      }\n\n\n      k1 |= k2 << shift;\n\n      // int used_bits = 32 - shift;  // how many bits of k2 were used in k1.\n      // int unused_bits = bits - used_bits; //  (bits-(32-shift)) == bits+shift-32  == bits-newshift\n\n      shift += bits;\n      if (shift >= 32) {\n        // mix after we have a complete word\n\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n        h1 = h1*5+0xe6546b64;\n\n        shift -= 32;\n        // unfortunately, java won't let you shift 32 bits off, so we need to check for 0\n        if (shift != 0) {\n          k1 = k2 >>> (bits-shift);   // bits used == bits - newshift\n        } else {\n          k1 = 0;\n        }\n        nBytes += 4;\n      }\n\n    } // inner\n\n    // handle tail\n    if (shift > 0) {\n      nBytes += shift >> 3;\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n      h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= nBytes;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(CharSequence,int,int,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(CharSequence,int,int,int).mjava","sourceNew":"  /** Returns the MurmurHash3_x86_32 hash of the UTF-8 bytes of the String without actually encoding\n   * the string to a temporary buffer.  This is more than 2x faster than hashing the result\n   * of String.getBytes().\n   */\n  public static int murmurhash3_x86_32(CharSequence data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n\n    int pos = offset;\n    int end = offset + len;\n    int k1 = 0;\n    int k2 = 0;\n    int shift = 0;\n    int bits = 0;\n    int nBytes = 0;   // length in UTF8 bytes\n\n\n    while (pos < end) {\n      int code = data.charAt(pos++);\n      if (code < 0x80) {\n        k2 = code;\n        bits = 8;\n\n        /***\n         // optimized ascii implementation (currently slower!!! code size?)\n         if (shift == 24) {\n         k1 = k1 | (code << 24);\n\n         k1 *= c1;\n         k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n         k1 *= c2;\n\n         h1 ^= k1;\n         h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n         h1 = h1*5+0xe6546b64;\n\n         shift = 0;\n         nBytes += 4;\n         k1 = 0;\n         } else {\n         k1 |= code << shift;\n         shift += 8;\n         }\n         continue;\n         ***/\n\n      }\n      else if (code < 0x800) {\n        k2 = (0xC0 | (code >> 6))\n            | ((0x80 | (code & 0x3F)) << 8);\n        bits = 16;\n      }\n      else if (code < 0xD800 || code > 0xDFFF || pos>=end) {\n        // we check for pos>=end to encode an unpaired surrogate as 3 bytes.\n        k2 = (0xE0 | (code >> 12))\n            | ((0x80 | ((code >> 6) & 0x3F)) << 8)\n            | ((0x80 | (code & 0x3F)) << 16);\n        bits = 24;\n      } else {\n        // surrogate pair\n        // int utf32 = pos < end ? (int) data.charAt(pos++) : 0;\n        int utf32 = (int) data.charAt(pos++);\n        utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n        k2 = (0xff & (0xF0 | (utf32 >> 18)))\n            | ((0x80 | ((utf32 >> 12) & 0x3F))) << 8\n            | ((0x80 | ((utf32 >> 6) & 0x3F))) << 16\n            |  (0x80 | (utf32 & 0x3F)) << 24;\n        bits = 32;\n      }\n\n\n      k1 |= k2 << shift;\n\n      // int used_bits = 32 - shift;  // how many bits of k2 were used in k1.\n      // int unused_bits = bits - used_bits; //  (bits-(32-shift)) == bits+shift-32  == bits-newshift\n\n      shift += bits;\n      if (shift >= 32) {\n        // mix after we have a complete word\n\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n        h1 = h1*5+0xe6546b64;\n\n        shift -= 32;\n        // unfortunately, java won't let you shift 32 bits off, so we need to check for 0\n        if (shift != 0) {\n          k1 = k2 >>> (bits-shift);   // bits used == bits - newshift\n        } else {\n          k1 = 0;\n        }\n        nBytes += 4;\n      }\n\n    } // inner\n\n    // handle tail\n    if (shift > 0) {\n      nBytes += shift >> 3;\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n      h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= nBytes;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","sourceOld":"  /** Returns the MurmurHash3_x86_32 hash of the UTF-8 bytes of the String without actually encoding\n   * the string to a temporary buffer.  This is more than 2x faster than hashing the result\n   * of String.getBytes().\n   */\n  public static int murmurhash3_x86_32(CharSequence data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n\n    int pos = offset;\n    int end = offset + len;\n    int k1 = 0;\n    int k2 = 0;\n    int shift = 0;\n    int bits = 0;\n    int nBytes = 0;   // length in UTF8 bytes\n\n\n    while (pos < end) {\n      int code = data.charAt(pos++);\n      if (code < 0x80) {\n        k2 = code;\n        bits = 8;\n\n        /***\n         // optimized ascii implementation (currently slower!!! code size?)\n         if (shift == 24) {\n         k1 = k1 | (code << 24);\n\n         k1 *= c1;\n         k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n         k1 *= c2;\n\n         h1 ^= k1;\n         h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n         h1 = h1*5+0xe6546b64;\n\n         shift = 0;\n         nBytes += 4;\n         k1 = 0;\n         } else {\n         k1 |= code << shift;\n         shift += 8;\n         }\n         continue;\n         ***/\n\n      }\n      else if (code < 0x800) {\n        k2 = (0xC0 | (code >> 6))\n            | ((0x80 | (code & 0x3F)) << 8);\n        bits = 16;\n      }\n      else if (code < 0xD800 || code > 0xDFFF || pos>=end) {\n        // we check for pos>=end to encode an unpaired surrogate as 3 bytes.\n        k2 = (0xE0 | (code >> 12))\n            | ((0x80 | ((code >> 6) & 0x3F)) << 8)\n            | ((0x80 | (code & 0x3F)) << 16);\n        bits = 24;\n      } else {\n        // surrogate pair\n        // int utf32 = pos < end ? (int) data.charAt(pos++) : 0;\n        int utf32 = (int) data.charAt(pos++);\n        utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n        k2 = (0xff & (0xF0 | (utf32 >> 18)))\n            | ((0x80 | ((utf32 >> 12) & 0x3F))) << 8\n            | ((0x80 | ((utf32 >> 6) & 0x3F))) << 16\n            |  (0x80 | (utf32 & 0x3F)) << 24;\n        bits = 32;\n      }\n\n\n      k1 |= k2 << shift;\n\n      // int used_bits = 32 - shift;  // how many bits of k2 were used in k1.\n      // int unused_bits = bits - used_bits; //  (bits-(32-shift)) == bits+shift-32  == bits-newshift\n\n      shift += bits;\n      if (shift >= 32) {\n        // mix after we have a complete word\n\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n        h1 = h1*5+0xe6546b64;\n\n        shift -= 32;\n        // unfortunately, java won't let you shift 32 bits off, so we need to check for 0\n        if (shift != 0) {\n          k1 = k2 >>> (bits-shift);   // bits used == bits - newshift\n        } else {\n          k1 = 0;\n        }\n        nBytes += 4;\n      }\n\n    } // inner\n\n    // handle tail\n    if (shift > 0) {\n      nBytes += shift >> 3;\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n      h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= nBytes;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(CharSequence,int,int,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(CharSequence,int,int,int).mjava","sourceNew":"  /** Returns the MurmurHash3_x86_32 hash of the UTF-8 bytes of the String without actually encoding\n   * the string to a temporary buffer.  This is more than 2x faster than hashing the result\n   * of String.getBytes().\n   */\n  public static int murmurhash3_x86_32(CharSequence data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n\n    int pos = offset;\n    int end = offset + len;\n    int k1 = 0;\n    int k2 = 0;\n    int shift = 0;\n    int bits = 0;\n    int nBytes = 0;   // length in UTF8 bytes\n\n\n    while (pos < end) {\n      int code = data.charAt(pos++);\n      if (code < 0x80) {\n        k2 = code;\n        bits = 8;\n\n        /***\n         // optimized ascii implementation (currently slower!!! code size?)\n         if (shift == 24) {\n         k1 = k1 | (code << 24);\n\n         k1 *= c1;\n         k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n         k1 *= c2;\n\n         h1 ^= k1;\n         h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n         h1 = h1*5+0xe6546b64;\n\n         shift = 0;\n         nBytes += 4;\n         k1 = 0;\n         } else {\n         k1 |= code << shift;\n         shift += 8;\n         }\n         continue;\n         ***/\n\n      }\n      else if (code < 0x800) {\n        k2 = (0xC0 | (code >> 6))\n            | ((0x80 | (code & 0x3F)) << 8);\n        bits = 16;\n      }\n      else if (code < 0xD800 || code > 0xDFFF || pos>=end) {\n        // we check for pos>=end to encode an unpaired surrogate as 3 bytes.\n        k2 = (0xE0 | (code >> 12))\n            | ((0x80 | ((code >> 6) & 0x3F)) << 8)\n            | ((0x80 | (code & 0x3F)) << 16);\n        bits = 24;\n      } else {\n        // surrogate pair\n        // int utf32 = pos < end ? (int) data.charAt(pos++) : 0;\n        int utf32 = (int) data.charAt(pos++);\n        utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n        k2 = (0xff & (0xF0 | (utf32 >> 18)))\n            | ((0x80 | ((utf32 >> 12) & 0x3F))) << 8\n            | ((0x80 | ((utf32 >> 6) & 0x3F))) << 16\n            |  (0x80 | (utf32 & 0x3F)) << 24;\n        bits = 32;\n      }\n\n\n      k1 |= k2 << shift;\n\n      // int used_bits = 32 - shift;  // how many bits of k2 were used in k1.\n      // int unused_bits = bits - used_bits; //  (bits-(32-shift)) == bits+shift-32  == bits-newshift\n\n      shift += bits;\n      if (shift >= 32) {\n        // mix after we have a complete word\n\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n        h1 = h1*5+0xe6546b64;\n\n        shift -= 32;\n        // unfortunately, java won't let you shift 32 bits off, so we need to check for 0\n        if (shift != 0) {\n          k1 = k2 >>> (bits-shift);   // bits used == bits - newshift\n        } else {\n          k1 = 0;\n        }\n        nBytes += 4;\n      }\n\n    } // inner\n\n    // handle tail\n    if (shift > 0) {\n      nBytes += shift >> 3;\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n      h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= nBytes;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","sourceOld":"  /** Returns the MurmurHash3_x86_32 hash of the UTF-8 bytes of the String without actually encoding\n   * the string to a temporary buffer.  This is more than 2x faster than hashing the result\n   * of String.getBytes().\n   */\n  public static int murmurhash3_x86_32(CharSequence data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n\n    int pos = offset;\n    int end = offset + len;\n    int k1 = 0;\n    int k2 = 0;\n    int shift = 0;\n    int bits = 0;\n    int nBytes = 0;   // length in UTF8 bytes\n\n\n    while (pos < end) {\n      int code = data.charAt(pos++);\n      if (code < 0x80) {\n        k2 = code;\n        bits = 8;\n\n        /***\n         // optimized ascii implementation (currently slower!!! code size?)\n         if (shift == 24) {\n         k1 = k1 | (code << 24);\n\n         k1 *= c1;\n         k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n         k1 *= c2;\n\n         h1 ^= k1;\n         h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n         h1 = h1*5+0xe6546b64;\n\n         shift = 0;\n         nBytes += 4;\n         k1 = 0;\n         } else {\n         k1 |= code << shift;\n         shift += 8;\n         }\n         continue;\n         ***/\n\n      }\n      else if (code < 0x800) {\n        k2 = (0xC0 | (code >> 6))\n            | ((0x80 | (code & 0x3F)) << 8);\n        bits = 16;\n      }\n      else if (code < 0xD800 || code > 0xDFFF || pos>=end) {\n        // we check for pos>=end to encode an unpaired surrogate as 3 bytes.\n        k2 = (0xE0 | (code >> 12))\n            | ((0x80 | ((code >> 6) & 0x3F)) << 8)\n            | ((0x80 | (code & 0x3F)) << 16);\n        bits = 24;\n      } else {\n        // surrogate pair\n        // int utf32 = pos < end ? (int) data.charAt(pos++) : 0;\n        int utf32 = (int) data.charAt(pos++);\n        utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n        k2 = (0xff & (0xF0 | (utf32 >> 18)))\n            | ((0x80 | ((utf32 >> 12) & 0x3F))) << 8\n            | ((0x80 | ((utf32 >> 6) & 0x3F))) << 16\n            |  (0x80 | (utf32 & 0x3F)) << 24;\n        bits = 32;\n      }\n\n\n      k1 |= k2 << shift;\n\n      // int used_bits = 32 - shift;  // how many bits of k2 were used in k1.\n      // int unused_bits = bits - used_bits; //  (bits-(32-shift)) == bits+shift-32  == bits-newshift\n\n      shift += bits;\n      if (shift >= 32) {\n        // mix after we have a complete word\n\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n        h1 = h1*5+0xe6546b64;\n\n        shift -= 32;\n        // unfortunately, java won't let you shift 32 bits off, so we need to check for 0\n        if (shift != 0) {\n          k1 = k2 >>> (bits-shift);   // bits used == bits - newshift\n        } else {\n          k1 = 0;\n        }\n        nBytes += 4;\n      }\n\n    } // inner\n\n    // handle tail\n    if (shift > 0) {\n      nBytes += shift >> 3;\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n      h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= nBytes;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"19024c62496b4703b181a585ccd7e7c9101f06a9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["19024c62496b4703b181a585ccd7e7c9101f06a9","19275ba31e621f6da1b83bf13af75233876fd3d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","19024c62496b4703b181a585ccd7e7c9101f06a9"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["19024c62496b4703b181a585ccd7e7c9101f06a9"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","19024c62496b4703b181a585ccd7e7c9101f06a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["19275ba31e621f6da1b83bf13af75233876fd3d4"]},"commit2Childs":{"19024c62496b4703b181a585ccd7e7c9101f06a9":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","d6f074e73200c07d54f242d3880a8da5a35ff97b","19275ba31e621f6da1b83bf13af75233876fd3d4","8fd5be977c105554c6a7b68afcdbc511439723ab"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["19024c62496b4703b181a585ccd7e7c9101f06a9","d6f074e73200c07d54f242d3880a8da5a35ff97b","8fd5be977c105554c6a7b68afcdbc511439723ab"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"19275ba31e621f6da1b83bf13af75233876fd3d4":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","d6f074e73200c07d54f242d3880a8da5a35ff97b","8fd5be977c105554c6a7b68afcdbc511439723ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}