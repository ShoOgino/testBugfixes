{"path":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer,float).mjava","commits":[{"id":"b8b87263526557a451254f824e63e454e43e47ad","date":1453798964,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer,float).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @param boost a field boost\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer, float boost) {\n    if (field.fieldType().docValuesType() != DocValuesType.NONE)\n      throw new IllegalArgumentException(\"MemoryIndex does not support DocValues fields\");\n    if (field.fieldType().pointDimensionCount() != 0)\n      throw new IllegalArgumentException(\"MemoryIndex does not support Points\");\n    if (analyzer == null) {\n      addField(field.name(), field.tokenStream(null, null), boost);\n    }\n    else {\n      addField(field.name(), field.tokenStream(analyzer, null), boost,\n          analyzer.getPositionIncrementGap(field.name()), analyzer.getOffsetGap(field.name()));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275","89b68d01c34172936f1aa2a8b9abf0e1bc68415f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac88193d9fe80e165a43bb0555c43afa83da8330","date":1453823827,"type":0,"author":"jbernste","isMerge":true,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer,float).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @param boost a field boost\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer, float boost) {\n    if (field.fieldType().docValuesType() != DocValuesType.NONE)\n      throw new IllegalArgumentException(\"MemoryIndex does not support DocValues fields\");\n    if (field.fieldType().pointDimensionCount() != 0)\n      throw new IllegalArgumentException(\"MemoryIndex does not support Points\");\n    if (analyzer == null) {\n      addField(field.name(), field.tokenStream(null, null), boost);\n    }\n    else {\n      addField(field.name(), field.tokenStream(analyzer, null), boost,\n          analyzer.getPositionIncrementGap(field.name()), analyzer.getOffsetGap(field.name()));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer,float).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @param boost a field boost\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer, float boost) {\n    if (field.fieldType().docValuesType() != DocValuesType.NONE)\n      throw new IllegalArgumentException(\"MemoryIndex does not support DocValues fields\");\n    if (field.fieldType().pointDimensionCount() != 0)\n      throw new IllegalArgumentException(\"MemoryIndex does not support Points\");\n    if (analyzer == null) {\n      addField(field.name(), field.tokenStream(null, null), boost);\n    }\n    else {\n      addField(field.name(), field.tokenStream(analyzer, null), boost,\n          analyzer.getPositionIncrementGap(field.name()), analyzer.getOffsetGap(field.name()));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"253a79e1af11467dd01315b1919025d288aa0ccb","date":1458032260,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer,float).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer,float).mjava","sourceNew":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.\n   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.\n   *\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @param boost a field boost\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer, float boost) {\n    if (field.fieldType().pointDimensionCount() != 0) {\n      throw new IllegalArgumentException(\"MemoryIndex does not support Points\");\n    }\n\n    int offsetGap;\n    TokenStream tokenStream;\n    int positionIncrementGap;\n    if (analyzer != null) {\n      offsetGap = analyzer.getOffsetGap(field.name());\n      tokenStream = field.tokenStream(analyzer, null);\n      positionIncrementGap = analyzer.getPositionIncrementGap(field.name());\n    } else {\n      offsetGap = 1;\n      tokenStream = field.tokenStream(null, null);\n      positionIncrementGap = 0;\n    }\n\n    DocValuesType docValuesType = field.fieldType().docValuesType();\n    Object docValuesValue;\n    switch (docValuesType) {\n      case NONE:\n        docValuesValue = null;\n        break;\n      case BINARY:\n      case SORTED:\n      case SORTED_SET:\n        docValuesValue = field.binaryValue();\n        break;\n      case NUMERIC:\n      case SORTED_NUMERIC:\n        docValuesValue = field.numericValue();\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n    addField(field.name(), tokenStream, boost, positionIncrementGap, offsetGap, docValuesType, docValuesValue);\n  }\n\n","sourceOld":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @param boost a field boost\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer, float boost) {\n    if (field.fieldType().docValuesType() != DocValuesType.NONE)\n      throw new IllegalArgumentException(\"MemoryIndex does not support DocValues fields\");\n    if (field.fieldType().pointDimensionCount() != 0)\n      throw new IllegalArgumentException(\"MemoryIndex does not support Points\");\n    if (analyzer == null) {\n      addField(field.name(), field.tokenStream(null, null), boost);\n    }\n    else {\n      addField(field.name(), field.tokenStream(analyzer, null), boost,\n          analyzer.getPositionIncrementGap(field.name()), analyzer.getOffsetGap(field.name()));\n    }\n  }\n\n","bugFix":null,"bugIntro":["74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275","date":1458043999,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer,float).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer,float).mjava","sourceNew":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.\n   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.\n   *\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @param boost a field boost\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer, float boost) {\n    int offsetGap;\n    TokenStream tokenStream;\n    int positionIncrementGap;\n    if (analyzer != null) {\n      offsetGap = analyzer.getOffsetGap(field.name());\n      tokenStream = field.tokenStream(analyzer, null);\n      positionIncrementGap = analyzer.getPositionIncrementGap(field.name());\n    } else {\n      offsetGap = 1;\n      tokenStream = field.tokenStream(null, null);\n      positionIncrementGap = 0;\n    }\n\n    DocValuesType docValuesType = field.fieldType().docValuesType();\n    Object docValuesValue;\n    switch (docValuesType) {\n      case NONE:\n        docValuesValue = null;\n        break;\n      case BINARY:\n      case SORTED:\n      case SORTED_SET:\n        docValuesValue = field.binaryValue();\n        break;\n      case NUMERIC:\n      case SORTED_NUMERIC:\n        docValuesValue = field.numericValue();\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n    BytesRef pointValue = null;\n    if (field.fieldType().pointDimensionCount() > 0) {\n      pointValue = field.binaryValue();\n    }\n    addField(field.name(), tokenStream, boost, positionIncrementGap, offsetGap, docValuesType, docValuesValue,\n        field.fieldType().pointDimensionCount(), field.fieldType().pointNumBytes(), pointValue);\n  }\n\n","sourceOld":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.\n   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.\n   *\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @param boost a field boost\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer, float boost) {\n    if (field.fieldType().pointDimensionCount() != 0) {\n      throw new IllegalArgumentException(\"MemoryIndex does not support Points\");\n    }\n\n    int offsetGap;\n    TokenStream tokenStream;\n    int positionIncrementGap;\n    if (analyzer != null) {\n      offsetGap = analyzer.getOffsetGap(field.name());\n      tokenStream = field.tokenStream(analyzer, null);\n      positionIncrementGap = analyzer.getPositionIncrementGap(field.name());\n    } else {\n      offsetGap = 1;\n      tokenStream = field.tokenStream(null, null);\n      positionIncrementGap = 0;\n    }\n\n    DocValuesType docValuesType = field.fieldType().docValuesType();\n    Object docValuesValue;\n    switch (docValuesType) {\n      case NONE:\n        docValuesValue = null;\n        break;\n      case BINARY:\n      case SORTED:\n      case SORTED_SET:\n        docValuesValue = field.binaryValue();\n        break;\n      case NUMERIC:\n      case SORTED_NUMERIC:\n        docValuesValue = field.numericValue();\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n    addField(field.name(), tokenStream, boost, positionIncrementGap, offsetGap, docValuesType, docValuesValue);\n  }\n\n","bugFix":["b8b87263526557a451254f824e63e454e43e47ad","253a79e1af11467dd01315b1919025d288aa0ccb"],"bugIntro":["89b68d01c34172936f1aa2a8b9abf0e1bc68415f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89b68d01c34172936f1aa2a8b9abf0e1bc68415f","date":1486637198,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer,float).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer,float).mjava","sourceNew":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.\n   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.\n   *\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @param boost a field boost\n   */\n  public void addField(IndexableField field, Analyzer analyzer, float boost) {\n\n    Info info = getInfo(field.name(), field.fieldType());\n\n    int offsetGap;\n    TokenStream tokenStream;\n    int positionIncrementGap;\n    if (analyzer != null) {\n      offsetGap = analyzer.getOffsetGap(field.name());\n      tokenStream = field.tokenStream(analyzer, null);\n      positionIncrementGap = analyzer.getPositionIncrementGap(field.name());\n    } else {\n      offsetGap = 1;\n      tokenStream = field.tokenStream(null, null);\n      positionIncrementGap = 0;\n    }\n    if (tokenStream != null) {\n      storeTerms(info, tokenStream, boost, positionIncrementGap, offsetGap);\n    }\n\n    DocValuesType docValuesType = field.fieldType().docValuesType();\n    Object docValuesValue;\n    switch (docValuesType) {\n      case NONE:\n        docValuesValue = null;\n        break;\n      case BINARY:\n      case SORTED:\n      case SORTED_SET:\n        docValuesValue = field.binaryValue();\n        break;\n      case NUMERIC:\n      case SORTED_NUMERIC:\n        docValuesValue = field.numericValue();\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n    if (docValuesValue != null) {\n      storeDocValues(info, docValuesType, docValuesValue);\n    }\n\n    if (field.fieldType().pointDimensionCount() > 0) {\n      storePointValues(info, field.binaryValue());\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.\n   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.\n   *\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @param boost a field boost\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer, float boost) {\n    int offsetGap;\n    TokenStream tokenStream;\n    int positionIncrementGap;\n    if (analyzer != null) {\n      offsetGap = analyzer.getOffsetGap(field.name());\n      tokenStream = field.tokenStream(analyzer, null);\n      positionIncrementGap = analyzer.getPositionIncrementGap(field.name());\n    } else {\n      offsetGap = 1;\n      tokenStream = field.tokenStream(null, null);\n      positionIncrementGap = 0;\n    }\n\n    DocValuesType docValuesType = field.fieldType().docValuesType();\n    Object docValuesValue;\n    switch (docValuesType) {\n      case NONE:\n        docValuesValue = null;\n        break;\n      case BINARY:\n      case SORTED:\n      case SORTED_SET:\n        docValuesValue = field.binaryValue();\n        break;\n      case NUMERIC:\n      case SORTED_NUMERIC:\n        docValuesValue = field.numericValue();\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n    BytesRef pointValue = null;\n    if (field.fieldType().pointDimensionCount() > 0) {\n      pointValue = field.binaryValue();\n    }\n    addField(field.name(), tokenStream, boost, positionIncrementGap, offsetGap, docValuesType, docValuesValue,\n        field.fieldType().pointDimensionCount(), field.fieldType().pointNumBytes(), pointValue);\n  }\n\n","bugFix":["b8b87263526557a451254f824e63e454e43e47ad","74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acd9883560fd89e6448b2b447302fe543040cd4f","date":1488478696,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer,float).mjava","sourceNew":null,"sourceOld":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.\n   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.\n   *\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @param boost a field boost\n   */\n  public void addField(IndexableField field, Analyzer analyzer, float boost) {\n\n    Info info = getInfo(field.name(), field.fieldType());\n\n    int offsetGap;\n    TokenStream tokenStream;\n    int positionIncrementGap;\n    if (analyzer != null) {\n      offsetGap = analyzer.getOffsetGap(field.name());\n      tokenStream = field.tokenStream(analyzer, null);\n      positionIncrementGap = analyzer.getPositionIncrementGap(field.name());\n    } else {\n      offsetGap = 1;\n      tokenStream = field.tokenStream(null, null);\n      positionIncrementGap = 0;\n    }\n    if (tokenStream != null) {\n      storeTerms(info, tokenStream, boost, positionIncrementGap, offsetGap);\n    }\n\n    DocValuesType docValuesType = field.fieldType().docValuesType();\n    Object docValuesValue;\n    switch (docValuesType) {\n      case NONE:\n        docValuesValue = null;\n        break;\n      case BINARY:\n      case SORTED:\n      case SORTED_SET:\n        docValuesValue = field.binaryValue();\n        break;\n      case NUMERIC:\n      case SORTED_NUMERIC:\n        docValuesValue = field.numericValue();\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n    if (docValuesValue != null) {\n      storeDocValues(info, docValuesType, docValuesValue);\n    }\n\n    if (field.fieldType().pointDimensionCount() > 0) {\n      storePointValues(info, field.binaryValue());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275":["253a79e1af11467dd01315b1919025d288aa0ccb"],"ac88193d9fe80e165a43bb0555c43afa83da8330":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b8b87263526557a451254f824e63e454e43e47ad"],"b8b87263526557a451254f824e63e454e43e47ad":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"253a79e1af11467dd01315b1919025d288aa0ccb":["ac88193d9fe80e165a43bb0555c43afa83da8330"],"89b68d01c34172936f1aa2a8b9abf0e1bc68415f":["74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac88193d9fe80e165a43bb0555c43afa83da8330"],"acd9883560fd89e6448b2b447302fe543040cd4f":["89b68d01c34172936f1aa2a8b9abf0e1bc68415f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["acd9883560fd89e6448b2b447302fe543040cd4f"]},"commit2Childs":{"74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275":["89b68d01c34172936f1aa2a8b9abf0e1bc68415f"],"ac88193d9fe80e165a43bb0555c43afa83da8330":["253a79e1af11467dd01315b1919025d288aa0ccb","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"b8b87263526557a451254f824e63e454e43e47ad":["ac88193d9fe80e165a43bb0555c43afa83da8330"],"253a79e1af11467dd01315b1919025d288aa0ccb":["74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ac88193d9fe80e165a43bb0555c43afa83da8330","b8b87263526557a451254f824e63e454e43e47ad","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"89b68d01c34172936f1aa2a8b9abf0e1bc68415f":["acd9883560fd89e6448b2b447302fe543040cd4f"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"acd9883560fd89e6448b2b447302fe543040cd4f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}