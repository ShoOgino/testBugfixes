{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","commits":[{"id":"949847c0040cd70a68222d526cb0da7bf6cbb3c2","date":1410997182,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","pathOld":"/dev/null","sourceNew":"  private void tragicEvent(Throwable tragedy, String location) {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n    // its possible you could have a really bad day\n    if (this.tragedy == null) {\n      this.tragedy = tragedy;\n    }\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    synchronized(commitLock) {\n      if (closing == false) {\n        try {\n          rollback();\n        } catch (Throwable ignored) {\n          // it would be confusing to addSuppressed here, its unrelated to the disaster,\n          // and its possible our internal state is amiss anyway.\n        }\n      }\n    }\n    IOUtils.reThrowUnchecked(tragedy);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"25e07bf0d9fa18cd8f0185e309d09a873c45017c","date":1411478085,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","sourceNew":"  private void tragicEvent(Throwable tragedy, String location) {\n    // We cannot hold IW's lock here else it can lead to deadlock:\n    assert Thread.holdsLock(this) == false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n    synchronized (this) {\n      // its possible you could have a really bad day\n      if (this.tragedy == null) {\n        this.tragedy = tragedy;\n      }\n    }\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    synchronized(commitLock) {\n      if (closing == false) {\n        try {\n          rollback();\n        } catch (Throwable ignored) {\n          // it would be confusing to addSuppressed here, its unrelated to the disaster,\n          // and its possible our internal state is amiss anyway.\n        }\n      }\n    }\n    IOUtils.reThrowUnchecked(tragedy);\n  }\n\n","sourceOld":"  private void tragicEvent(Throwable tragedy, String location) {\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n    // its possible you could have a really bad day\n    if (this.tragedy == null) {\n      this.tragedy = tragedy;\n    }\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    synchronized(commitLock) {\n      if (closing == false) {\n        try {\n          rollback();\n        } catch (Throwable ignored) {\n          // it would be confusing to addSuppressed here, its unrelated to the disaster,\n          // and its possible our internal state is amiss anyway.\n        }\n      }\n    }\n    IOUtils.reThrowUnchecked(tragedy);\n  }\n\n","bugFix":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9299079153fd7895bf3cf6835cf7019af2ba89b3","date":1417813477,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","sourceNew":"  void tragicEvent(Throwable tragedy, String location) throws IOException {\n    // unbox our internal AbortingException\n    if (tragedy instanceof AbortingException) {\n      tragedy = tragedy.getCause();\n    }\n    // We cannot hold IW's lock here else it can lead to deadlock:\n    assert Thread.holdsLock(this) == false;\n\n    // How can it be a tragedy when nothing happened?\n    assert tragedy != null;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit tragic \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n\n    synchronized (this) {\n      // it's possible you could have a really bad day\n      if (this.tragedy == null) {\n        this.tragedy = tragedy;\n      }\n    }\n\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    synchronized(commitLock) {\n      if (closing == false) {\n        try {\n          rollback();\n        } catch (Throwable ignored) {\n          // it would be confusing to addSuppressed here, its unrelated to the disaster,\n          // and its possible our internal state is amiss anyway.\n        }\n      }\n    }\n\n    IOUtils.reThrow(tragedy);\n  }\n\n","sourceOld":"  private void tragicEvent(Throwable tragedy, String location) {\n    // We cannot hold IW's lock here else it can lead to deadlock:\n    assert Thread.holdsLock(this) == false;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n    synchronized (this) {\n      // its possible you could have a really bad day\n      if (this.tragedy == null) {\n        this.tragedy = tragedy;\n      }\n    }\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    synchronized(commitLock) {\n      if (closing == false) {\n        try {\n          rollback();\n        } catch (Throwable ignored) {\n          // it would be confusing to addSuppressed here, its unrelated to the disaster,\n          // and its possible our internal state is amiss anyway.\n        }\n      }\n    }\n    IOUtils.reThrowUnchecked(tragedy);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","sourceNew":"  void tragicEvent(Throwable tragedy, String location) throws IOException {\n    // unbox our internal AbortingException\n    if (tragedy instanceof AbortingException) {\n      tragedy = tragedy.getCause();\n    }\n    // We cannot hold IW's lock here else it can lead to deadlock:\n    assert Thread.holdsLock(this) == false;\n\n    // How can it be a tragedy when nothing happened?\n    assert tragedy != null;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit tragic \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n\n    synchronized (this) {\n      // it's possible you could have a really bad day\n      if (this.tragedy == null) {\n        this.tragedy = tragedy;\n      }\n    }\n\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    synchronized(commitLock) {\n      if (closing == false) {\n        try {\n          rollback();\n        } catch (Throwable ignored) {\n          // it would be confusing to addSuppressed here, it's unrelated to the disaster,\n          // and it's possible our internal state is amiss anyway.\n        }\n      }\n    }\n\n    IOUtils.reThrow(tragedy);\n  }\n\n","sourceOld":"  void tragicEvent(Throwable tragedy, String location) throws IOException {\n    // unbox our internal AbortingException\n    if (tragedy instanceof AbortingException) {\n      tragedy = tragedy.getCause();\n    }\n    // We cannot hold IW's lock here else it can lead to deadlock:\n    assert Thread.holdsLock(this) == false;\n\n    // How can it be a tragedy when nothing happened?\n    assert tragedy != null;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit tragic \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n\n    synchronized (this) {\n      // it's possible you could have a really bad day\n      if (this.tragedy == null) {\n        this.tragedy = tragedy;\n      }\n    }\n\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    synchronized(commitLock) {\n      if (closing == false) {\n        try {\n          rollback();\n        } catch (Throwable ignored) {\n          // it would be confusing to addSuppressed here, its unrelated to the disaster,\n          // and its possible our internal state is amiss anyway.\n        }\n      }\n    }\n\n    IOUtils.reThrow(tragedy);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9e22bdf0692bfa61e342b04a6ac7078670c1e16","date":1436866730,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","sourceNew":"  void tragicEvent(Throwable tragedy, String location) throws IOException {\n\n    // unbox our internal AbortingException\n    if (tragedy instanceof AbortingException) {\n      tragedy = tragedy.getCause();\n    }\n\n    // This is not supposed to be tragic: IW is supposed to catch this and\n    // ignore, because it means we asked the merge to abort:\n    assert tragedy instanceof MergePolicy.MergeAbortedException == false;\n\n    // We cannot hold IW's lock here else it can lead to deadlock:\n    assert Thread.holdsLock(this) == false;\n\n    // How can it be a tragedy when nothing happened?\n    assert tragedy != null;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit tragic \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n\n    synchronized (this) {\n      // It's possible you could have a really bad day\n      if (this.tragedy != null) {\n        // Another thread is already dealing / has dealt with the tragedy:\n        IOUtils.reThrow(tragedy);\n      }\n\n      this.tragedy = tragedy;\n    }\n\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    if (shouldClose(false)) {\n      rollbackInternal();\n    }\n\n    IOUtils.reThrow(tragedy);\n  }\n\n","sourceOld":"  void tragicEvent(Throwable tragedy, String location) throws IOException {\n    // unbox our internal AbortingException\n    if (tragedy instanceof AbortingException) {\n      tragedy = tragedy.getCause();\n    }\n    // We cannot hold IW's lock here else it can lead to deadlock:\n    assert Thread.holdsLock(this) == false;\n\n    // How can it be a tragedy when nothing happened?\n    assert tragedy != null;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit tragic \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n\n    synchronized (this) {\n      // it's possible you could have a really bad day\n      if (this.tragedy == null) {\n        this.tragedy = tragedy;\n      }\n    }\n\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    synchronized(commitLock) {\n      if (closing == false) {\n        try {\n          rollback();\n        } catch (Throwable ignored) {\n          // it would be confusing to addSuppressed here, it's unrelated to the disaster,\n          // and it's possible our internal state is amiss anyway.\n        }\n      }\n    }\n\n    IOUtils.reThrow(tragedy);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","date":1493374641,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","sourceNew":"  void tragicEvent(Throwable tragedy, String location) throws IOException {\n\n    // unbox our internal AbortingException\n    if (tragedy instanceof AbortingException) {\n      tragedy = tragedy.getCause();\n    }\n\n    // This is not supposed to be tragic: IW is supposed to catch this and\n    // ignore, because it means we asked the merge to abort:\n    assert tragedy instanceof MergePolicy.MergeAbortedException == false;\n\n    // We cannot hold IW's lock here else it can lead to deadlock:\n    assert Thread.holdsLock(this) == false;\n\n    // How can it be a tragedy when nothing happened?\n    assert tragedy != null;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit tragic \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n\n    synchronized (this) {\n      // It's possible you could have a really bad day\n      if (this.tragedy != null) {\n        // Another thread is already dealing / has dealt with the tragedy:\n        throw IOUtils.rethrowAlways(tragedy);\n      }\n\n      this.tragedy = tragedy;\n    }\n\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    if (shouldClose(false)) {\n      rollbackInternal();\n    }\n\n    throw IOUtils.rethrowAlways(tragedy);\n  }\n\n","sourceOld":"  void tragicEvent(Throwable tragedy, String location) throws IOException {\n\n    // unbox our internal AbortingException\n    if (tragedy instanceof AbortingException) {\n      tragedy = tragedy.getCause();\n    }\n\n    // This is not supposed to be tragic: IW is supposed to catch this and\n    // ignore, because it means we asked the merge to abort:\n    assert tragedy instanceof MergePolicy.MergeAbortedException == false;\n\n    // We cannot hold IW's lock here else it can lead to deadlock:\n    assert Thread.holdsLock(this) == false;\n\n    // How can it be a tragedy when nothing happened?\n    assert tragedy != null;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit tragic \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n\n    synchronized (this) {\n      // It's possible you could have a really bad day\n      if (this.tragedy != null) {\n        // Another thread is already dealing / has dealt with the tragedy:\n        IOUtils.reThrow(tragedy);\n      }\n\n      this.tragedy = tragedy;\n    }\n\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    if (shouldClose(false)) {\n      rollbackInternal();\n    }\n\n    IOUtils.reThrow(tragedy);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","sourceNew":"  void tragicEvent(Throwable tragedy, String location) throws IOException {\n\n    // unbox our internal AbortingException\n    if (tragedy instanceof AbortingException) {\n      tragedy = tragedy.getCause();\n    }\n\n    // This is not supposed to be tragic: IW is supposed to catch this and\n    // ignore, because it means we asked the merge to abort:\n    assert tragedy instanceof MergePolicy.MergeAbortedException == false;\n\n    // We cannot hold IW's lock here else it can lead to deadlock:\n    assert Thread.holdsLock(this) == false;\n\n    // How can it be a tragedy when nothing happened?\n    assert tragedy != null;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit tragic \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n\n    synchronized (this) {\n      // It's possible you could have a really bad day\n      if (this.tragedy != null) {\n        // Another thread is already dealing / has dealt with the tragedy:\n        throw IOUtils.rethrowAlways(tragedy);\n      }\n\n      this.tragedy = tragedy;\n    }\n\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    if (shouldClose(false)) {\n      rollbackInternal();\n    }\n\n    throw IOUtils.rethrowAlways(tragedy);\n  }\n\n","sourceOld":"  void tragicEvent(Throwable tragedy, String location) throws IOException {\n\n    // unbox our internal AbortingException\n    if (tragedy instanceof AbortingException) {\n      tragedy = tragedy.getCause();\n    }\n\n    // This is not supposed to be tragic: IW is supposed to catch this and\n    // ignore, because it means we asked the merge to abort:\n    assert tragedy instanceof MergePolicy.MergeAbortedException == false;\n\n    // We cannot hold IW's lock here else it can lead to deadlock:\n    assert Thread.holdsLock(this) == false;\n\n    // How can it be a tragedy when nothing happened?\n    assert tragedy != null;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit tragic \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n\n    synchronized (this) {\n      // It's possible you could have a really bad day\n      if (this.tragedy != null) {\n        // Another thread is already dealing / has dealt with the tragedy:\n        IOUtils.reThrow(tragedy);\n      }\n\n      this.tragedy = tragedy;\n    }\n\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    if (shouldClose(false)) {\n      rollbackInternal();\n    }\n\n    IOUtils.reThrow(tragedy);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tragicEvent(Throwable,String).mjava","sourceNew":"  /**\n   * This method set the tragic exception unless it's already set and closes the writer\n   * if necessary. Note this method will not rethrow the throwable passed to it.\n   */\n  private void tragicEvent(Throwable tragedy, String location) throws IOException {\n    try {\n      onTragicEvent(tragedy, location);\n    } finally {\n      maybeCloseOnTragicEvent();\n    }\n  }\n\n","sourceOld":"  void tragicEvent(Throwable tragedy, String location) throws IOException {\n\n    // unbox our internal AbortingException\n    if (tragedy instanceof AbortingException) {\n      tragedy = tragedy.getCause();\n    }\n\n    // This is not supposed to be tragic: IW is supposed to catch this and\n    // ignore, because it means we asked the merge to abort:\n    assert tragedy instanceof MergePolicy.MergeAbortedException == false;\n\n    // We cannot hold IW's lock here else it can lead to deadlock:\n    assert Thread.holdsLock(this) == false;\n\n    // How can it be a tragedy when nothing happened?\n    assert tragedy != null;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"hit tragic \" + tragedy.getClass().getSimpleName() + \" inside \" + location);\n    }\n\n    synchronized (this) {\n      // It's possible you could have a really bad day\n      if (this.tragedy != null) {\n        // Another thread is already dealing / has dealt with the tragedy:\n        throw IOUtils.rethrowAlways(tragedy);\n      }\n\n      this.tragedy = tragedy;\n    }\n\n    // if we are already closed (e.g. called by rollback), this will be a no-op.\n    if (shouldClose(false)) {\n      rollbackInternal();\n    }\n\n    throw IOUtils.rethrowAlways(tragedy);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16","97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"25e07bf0d9fa18cd8f0185e309d09a873c45017c":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["e9017cf144952056066919f1ebc7897ff9bd71b1","97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["e9017cf144952056066919f1ebc7897ff9bd71b1","845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"25e07bf0d9fa18cd8f0185e309d09a873c45017c":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}