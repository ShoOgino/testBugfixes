{"path":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","commits":[{"id":"ea469eab8fd0f3032f4fcde1c644a721e8309d3b","date":1320301582,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyWriter#LuceneTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n                              TaxonomyWriterCache cache)\n  throws CorruptIndexException, LockObtainFailedException,\n  IOException {\n\n    openIndexWriter(directory, openMode);\n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache==null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public LuceneTaxonomyWriter(Directory directory, OpenMode openMode,\n                              TaxonomyWriterCache cache)\n  throws CorruptIndexException, LockObtainFailedException,\n  IOException {\n\n    openLuceneIndex(directory, openMode);\n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache==null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ccebf8d83184ae6dc4876b9ac2a3bb68765e53f6","date":1320306100,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n                              TaxonomyWriterCache cache)\n  throws CorruptIndexException, LockObtainFailedException,\n  IOException {\n\n    indexWriter = openIndexWriter(directory, openMode);\n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache==null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n                              TaxonomyWriterCache cache)\n  throws CorruptIndexException, LockObtainFailedException,\n  IOException {\n\n    openIndexWriter(directory, openMode);\n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache==null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"233afcf63b8d53faa9a7993e911cc9873b0106d1","date":1321459183,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n                              TaxonomyWriterCache cache)\n  throws CorruptIndexException, LockObtainFailedException,\n  IOException {\n\n    if (!IndexReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      taxoIndexCreateTime = Long.toString(System.nanoTime());\n    }\n    \n    indexWriter = openIndexWriter(directory, openMode);\n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache==null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n                              TaxonomyWriterCache cache)\n  throws CorruptIndexException, LockObtainFailedException,\n  IOException {\n\n    indexWriter = openIndexWriter(directory, openMode);\n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache==null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":null,"bugIntro":["78e3613d9274c0d98ca67d976e415c82e9f9cf46","e26e3b5080bfb6fcabdc46d0072efe441de1a21b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9faeb5fb9565674fd02b39d8fc365311961f1938","date":1322463944,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n                              TaxonomyWriterCache cache)\n  throws CorruptIndexException, LockObtainFailedException,\n  IOException {\n\n    if (!IndexReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      taxoIndexCreateTime = Long.toString(System.nanoTime());\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache==null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n                              TaxonomyWriterCache cache)\n  throws CorruptIndexException, LockObtainFailedException,\n  IOException {\n\n    if (!IndexReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      taxoIndexCreateTime = Long.toString(System.nanoTime());\n    }\n    \n    indexWriter = openIndexWriter(directory, openMode);\n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache==null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":null,"bugIntro":["78e3613d9274c0d98ca67d976e415c82e9f9cf46"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"20b26030b0883b7f045e3350bb97bee7146f1efd","date":1327854897,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n                              TaxonomyWriterCache cache)\n  throws CorruptIndexException, LockObtainFailedException,\n  IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      taxoIndexCreateTime = Long.toString(System.nanoTime());\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache==null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n                              TaxonomyWriterCache cache)\n  throws CorruptIndexException, LockObtainFailedException,\n  IOException {\n\n    if (!IndexReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      taxoIndexCreateTime = Long.toString(System.nanoTime());\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache==null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":null,"bugIntro":["78e3613d9274c0d98ca67d976e415c82e9f9cf46"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n                              TaxonomyWriterCache cache)\n  throws CorruptIndexException, LockObtainFailedException,\n  IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      taxoIndexCreateTime = Long.toString(System.nanoTime());\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache==null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n                              TaxonomyWriterCache cache)\n  throws CorruptIndexException, LockObtainFailedException,\n  IOException {\n\n    if (!IndexReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      taxoIndexCreateTime = Long.toString(System.nanoTime());\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache==null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e26e3b5080bfb6fcabdc46d0072efe441de1a21b","date":1329396896,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n                              TaxonomyWriterCache cache)\n  throws CorruptIndexException, LockObtainFailedException,\n  IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      taxoIndexCreateTime = Long.toString(System.nanoTime());\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache==null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":["89f15687f60bd49cd3d9de427e85c17fd9397d61","233afcf63b8d53faa9a7993e911cc9873b0106d1"],"bugIntro":["78e3613d9274c0d98ca67d976e415c82e9f9cf46"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["e26e3b5080bfb6fcabdc46d0072efe441de1a21b"],"ea469eab8fd0f3032f4fcde1c644a721e8309d3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"20b26030b0883b7f045e3350bb97bee7146f1efd":["9faeb5fb9565674fd02b39d8fc365311961f1938"],"9faeb5fb9565674fd02b39d8fc365311961f1938":["233afcf63b8d53faa9a7993e911cc9873b0106d1"],"ccebf8d83184ae6dc4876b9ac2a3bb68765e53f6":["ea469eab8fd0f3032f4fcde1c644a721e8309d3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e26e3b5080bfb6fcabdc46d0072efe441de1a21b":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"233afcf63b8d53faa9a7993e911cc9873b0106d1":["ccebf8d83184ae6dc4876b9ac2a3bb68765e53f6"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["9faeb5fb9565674fd02b39d8fc365311961f1938","20b26030b0883b7f045e3350bb97bee7146f1efd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ea469eab8fd0f3032f4fcde1c644a721e8309d3b":["ccebf8d83184ae6dc4876b9ac2a3bb68765e53f6"],"20b26030b0883b7f045e3350bb97bee7146f1efd":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"9faeb5fb9565674fd02b39d8fc365311961f1938":["20b26030b0883b7f045e3350bb97bee7146f1efd","5cab9a86bd67202d20b6adc463008c8e982b070a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ea469eab8fd0f3032f4fcde1c644a721e8309d3b"],"ccebf8d83184ae6dc4876b9ac2a3bb68765e53f6":["233afcf63b8d53faa9a7993e911cc9873b0106d1"],"e26e3b5080bfb6fcabdc46d0072efe441de1a21b":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"233afcf63b8d53faa9a7993e911cc9873b0106d1":["9faeb5fb9565674fd02b39d8fc365311961f1938"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["e26e3b5080bfb6fcabdc46d0072efe441de1a21b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}