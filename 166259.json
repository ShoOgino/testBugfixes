{"path":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"/dev/null","sourceNew":"  public SolrCore(String index_path, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n       try {\n      if (index_path==null) {\n        index_path=SolrConfig.config.get(\"indexDir\",\"index\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + index_path);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.index_path = index_path;\n\n      parseListeners();\n\n      initIndex();\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n     } finally {\n\n       }\n\n\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"268776364d28ac43d2fac972c45f929978145470","date":1139281135,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","sourceNew":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n       try {\n      if (dataDir ==null) {\n        dataDir =SolrConfig.config.get(\"dataDir\",\"data\");\n      }\n\n      log.info(\"Opening new SolrCore with data directory at \" + dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      parseListeners();\n\n      initIndex();\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n     } finally {\n\n       }\n\n\n    }\n  }\n\n","sourceOld":"  public SolrCore(String index_path, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n       try {\n      if (index_path==null) {\n        index_path=SolrConfig.config.get(\"indexDir\",\"index\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + index_path);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.index_path = index_path;\n\n      parseListeners();\n\n      initIndex();\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n     } finally {\n\n       }\n\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0618894701fecbaef7c9b6dd8387835572b8268","date":1139861049,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","sourceNew":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir =SolrConfig.config.get(\"dataDir\",\"data\");\n      }\n\n      log.info(\"Opening new SolrCore with data directory at \" + dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      parseListeners();\n\n      initIndex();\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","sourceOld":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n       try {\n      if (dataDir ==null) {\n        dataDir =SolrConfig.config.get(\"dataDir\",\"data\");\n      }\n\n      log.info(\"Opening new SolrCore with data directory at \" + dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      parseListeners();\n\n      initIndex();\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n     } finally {\n\n       }\n\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04a954a68448c7f3d03c375dc4320f2c0b13cc60","date":1143819936,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","sourceNew":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir =SolrConfig.config.get(\"dataDir\",Config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + Config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      parseListeners();\n\n      initIndex();\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","sourceOld":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir =SolrConfig.config.get(\"dataDir\",\"data\");\n      }\n\n      log.info(\"Opening new SolrCore with data directory at \" + dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      parseListeners();\n\n      initIndex();\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5db1d0b312c5915094ef798a33d392623fd40bb3","date":1148622242,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","sourceNew":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir =SolrConfig.config.get(\"dataDir\",Config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + Config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      parseListeners();\n\n      initIndex();\n      \n      initWriters();\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","sourceOld":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir =SolrConfig.config.get(\"dataDir\",Config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + Config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      parseListeners();\n\n      initIndex();\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e99eba54d46b7d62e0202b1ab5da1725fb39fecd","date":1168639208,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","sourceNew":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir = SolrConfig.config.get(\"dataDir\",Config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + Config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      this.maxWarmingSearchers = SolrConfig.config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      parseListeners();\n\n      initIndex();\n      \n      initWriters();\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","sourceOld":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir =SolrConfig.config.get(\"dataDir\",Config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + Config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      parseListeners();\n\n      initIndex();\n      \n      initWriters();\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7ecad62a91d16f94e09186098207ad6865137c58","date":1174933286,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","sourceNew":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir = SolrConfig.config.get(\"dataDir\",Config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + Config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      this.maxWarmingSearchers = SolrConfig.config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      parseListeners();\n\n      initIndex();\n      \n      initWriters();\n      \n      reqHandlers.initHandlersFromConfig( SolrConfig.config );\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","sourceOld":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir = SolrConfig.config.get(\"dataDir\",Config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + Config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      this.maxWarmingSearchers = SolrConfig.config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      parseListeners();\n\n      initIndex();\n      \n      initWriters();\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4cc0532e82274748c1910318b92089c5604e48a","date":1183443010,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","sourceNew":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir = SolrConfig.config.get(\"dataDir\",Config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + Config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      this.maxWarmingSearchers = SolrConfig.config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      parseListeners();\n\n      initIndex();\n      \n      initWriters();\n      \n      reqHandlers.initHandlersFromConfig( SolrConfig.config );\n\n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( SolrConfig.config );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","sourceOld":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir = SolrConfig.config.get(\"dataDir\",Config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + Config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      this.maxWarmingSearchers = SolrConfig.config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      parseListeners();\n\n      initIndex();\n      \n      initWriters();\n      \n      reqHandlers.initHandlersFromConfig( SolrConfig.config );\n\n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6589002090bd74db749eef5befe2f447c0e3dd49","date":1184345280,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","sourceNew":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir = SolrConfig.config.get(\"dataDir\",Config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + Config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      this.maxWarmingSearchers = SolrConfig.config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      parseListeners();\n\n      initIndex();\n      \n      initWriters();\n      \n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      \n      reqHandlers.initHandlersFromConfig( SolrConfig.config );\n\n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( SolrConfig.config );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","sourceOld":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir = SolrConfig.config.get(\"dataDir\",Config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + Config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      this.maxWarmingSearchers = SolrConfig.config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      parseListeners();\n\n      initIndex();\n      \n      initWriters();\n      \n      reqHandlers.initHandlersFromConfig( SolrConfig.config );\n\n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( SolrConfig.config );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d6338c87060be5f66757a94945975f3bbd377a9","date":1189278234,"type":4,"author":"Ryan McKinley","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","sourceNew":null,"sourceOld":"  public SolrCore(String dataDir, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      core = this;   // set singleton\n\n      if (dataDir ==null) {\n        dataDir = SolrConfig.config.get(\"dataDir\",Config.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + Config.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(\"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n\n      this.maxWarmingSearchers = SolrConfig.config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      parseListeners();\n\n      initIndex();\n      \n      initWriters();\n      \n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      \n      reqHandlers.initHandlersFromConfig( SolrConfig.config );\n\n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( SolrConfig.config );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n                SolrConfig.config.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"048361614025800e582bfc7a7b0329dc6fd6a95e","date":1196999392,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"/dev/null","sourceNew":"  public SolrCore(String dataDir, IndexSchema schema) throws ParserConfigurationException, IOException, SAXException {\n    this( \"core\", dataDir, new SolrConfig(), schema );\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b46f0ccfb6b63c307ea901d48482630e3689042c","date":1198805331,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","sourceNew":"  public SolrCore(String dataDir, IndexSchema schema) throws ParserConfigurationException, IOException, SAXException {\n    this( null, dataDir, new SolrConfig(), schema );\n  }\n\n","sourceOld":"  public SolrCore(String dataDir, IndexSchema schema) throws ParserConfigurationException, IOException, SAXException {\n    this( \"core\", dataDir, new SolrConfig(), schema );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5151046764fb8d9662e02d6c5381b2adb69f96d","date":1216394962,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","sourceNew":"  /**\n   * \n   * @param dataDir\n   * @param schema\n   * @throws SAXException \n   * @throws IOException \n   * @throws ParserConfigurationException \n   * \n   * @since solr 1.0\n   */\n  public SolrCore(String dataDir, IndexSchema schema) throws ParserConfigurationException, IOException, SAXException {\n    this( null, dataDir, new SolrConfig(), schema, null );\n  }\n\n","sourceOld":"  public SolrCore(String dataDir, IndexSchema schema) throws ParserConfigurationException, IOException, SAXException {\n    this( null, dataDir, new SolrConfig(), schema );\n  }\n\n","bugFix":null,"bugIntro":["c28792ff7d1774c306e16afbd44ded91a417049b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c28792ff7d1774c306e16afbd44ded91a417049b","date":1219072108,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","sourceNew":"  /**\n   * \n   * @param dataDir\n   * @param schema\n   * @throws SAXException \n   * @throws IOException \n   * @throws ParserConfigurationException \n   * \n   * @since solr 1.0\n   */\n  public SolrCore(String dataDir, IndexSchema schema) throws ParserConfigurationException, IOException, SAXException {\n    this(null, dataDir, new SolrConfig(), schema, null );\n  }\n\n","sourceOld":"  /**\n   * \n   * @param dataDir\n   * @param schema\n   * @throws SAXException \n   * @throws IOException \n   * @throws ParserConfigurationException \n   * \n   * @since solr 1.0\n   */\n  public SolrCore(String dataDir, IndexSchema schema) throws ParserConfigurationException, IOException, SAXException {\n    this( null, dataDir, new SolrConfig(), schema, null );\n  }\n\n","bugFix":["d5151046764fb8d9662e02d6c5381b2adb69f96d"],"bugIntro":["e22ffe8cc51a892ae103df018822d7873e901c2a","e22ffe8cc51a892ae103df018822d7873e901c2a","e22ffe8cc51a892ae103df018822d7873e901c2a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,IndexSchema).mjava","sourceNew":"  /**\n   * \n   * @param dataDir\n   * @param schema\n   * @throws SAXException \n   * @throws IOException \n   * @throws ParserConfigurationException \n   * \n   * @since solr 1.0\n   */\n  public SolrCore(String dataDir, IndexSchema schema) throws ParserConfigurationException, IOException, SAXException {\n    this(null, dataDir, new SolrConfig(), schema, null );\n  }\n\n","sourceOld":"  /**\n   * \n   * @param dataDir\n   * @param schema\n   * @throws SAXException \n   * @throws IOException \n   * @throws ParserConfigurationException \n   * \n   * @since solr 1.0\n   */\n  public SolrCore(String dataDir, IndexSchema schema) throws ParserConfigurationException, IOException, SAXException {\n    this(null, dataDir, new SolrConfig(), schema, null );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"6d6338c87060be5f66757a94945975f3bbd377a9":["6589002090bd74db749eef5befe2f447c0e3dd49"],"d5151046764fb8d9662e02d6c5381b2adb69f96d":["b46f0ccfb6b63c307ea901d48482630e3689042c"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"c28792ff7d1774c306e16afbd44ded91a417049b":["d5151046764fb8d9662e02d6c5381b2adb69f96d"],"04a954a68448c7f3d03c375dc4320f2c0b13cc60":["c0618894701fecbaef7c9b6dd8387835572b8268"],"b46f0ccfb6b63c307ea901d48482630e3689042c":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"e99eba54d46b7d62e0202b1ab5da1725fb39fecd":["5db1d0b312c5915094ef798a33d392623fd40bb3"],"268776364d28ac43d2fac972c45f929978145470":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"a4cc0532e82274748c1910318b92089c5604e48a":["7ecad62a91d16f94e09186098207ad6865137c58"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"048361614025800e582bfc7a7b0329dc6fd6a95e":["6d6338c87060be5f66757a94945975f3bbd377a9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6589002090bd74db749eef5befe2f447c0e3dd49":["a4cc0532e82274748c1910318b92089c5604e48a"],"ad94625fb8d088209f46650c8097196fec67f00c":["c28792ff7d1774c306e16afbd44ded91a417049b"],"5db1d0b312c5915094ef798a33d392623fd40bb3":["04a954a68448c7f3d03c375dc4320f2c0b13cc60"],"7ecad62a91d16f94e09186098207ad6865137c58":["e99eba54d46b7d62e0202b1ab5da1725fb39fecd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c0618894701fecbaef7c9b6dd8387835572b8268":["268776364d28ac43d2fac972c45f929978145470"]},"commit2Childs":{"6d6338c87060be5f66757a94945975f3bbd377a9":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"d5151046764fb8d9662e02d6c5381b2adb69f96d":["c28792ff7d1774c306e16afbd44ded91a417049b"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"c28792ff7d1774c306e16afbd44ded91a417049b":["ad94625fb8d088209f46650c8097196fec67f00c"],"04a954a68448c7f3d03c375dc4320f2c0b13cc60":["5db1d0b312c5915094ef798a33d392623fd40bb3"],"b46f0ccfb6b63c307ea901d48482630e3689042c":["d5151046764fb8d9662e02d6c5381b2adb69f96d"],"e99eba54d46b7d62e0202b1ab5da1725fb39fecd":["7ecad62a91d16f94e09186098207ad6865137c58"],"268776364d28ac43d2fac972c45f929978145470":["c0618894701fecbaef7c9b6dd8387835572b8268"],"a4cc0532e82274748c1910318b92089c5604e48a":["6589002090bd74db749eef5befe2f447c0e3dd49"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["268776364d28ac43d2fac972c45f929978145470"],"048361614025800e582bfc7a7b0329dc6fd6a95e":["b46f0ccfb6b63c307ea901d48482630e3689042c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6589002090bd74db749eef5befe2f447c0e3dd49":["6d6338c87060be5f66757a94945975f3bbd377a9"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"5db1d0b312c5915094ef798a33d392623fd40bb3":["e99eba54d46b7d62e0202b1ab5da1725fb39fecd"],"7ecad62a91d16f94e09186098207ad6865137c58":["a4cc0532e82274748c1910318b92089c5604e48a"],"c0618894701fecbaef7c9b6dd8387835572b8268":["04a954a68448c7f3d03c375dc4320f2c0b13cc60"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}