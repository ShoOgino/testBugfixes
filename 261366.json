{"path":"src/java/org/apache/lucene/search/FieldSortedHitQueue#getCachedComparator(IndexReader,String,int,SortComparatorSource).mjava","commits":[{"id":"35c39157e8b6bc585e3a07e703d75db0f2ad56b2","date":1082672595,"type":1,"author":"Tim Jones","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#getCachedComparator(IndexReader,String,int,SortComparatorSource).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#getCachedComparator(IndexReader,String,int).mjava","sourceNew":"\t/**\n\t * Returns a comparator for the given field.  If there is already one in the cache, it is returned.\n\t * Otherwise one is created and put into the cache.  If <code>reader</code> is different than the\n\t * one used for the current cache, or has changed size, the cache is cleared first.\n\t * @param reader  Index to use.\n\t * @param field   Field to sort by.\n\t * @return  Comparator; never <code>null</code>.\n\t * @throws IOException  If an error occurs reading the index.\n\t * @see #determineComparator\n\t */\n\tstatic ScoreDocComparator getCachedComparator (final IndexReader reader, final String field, final int type, final SortComparatorSource factory)\n\tthrows IOException {\n\n\t\tif (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;\n\t\tif (type == SortField.SCORE) return ScoreDocComparator.RELEVANCE;\n\n\t\t// see if we have already generated a comparator for this field\n\t\tif (reader.hashCode() == lastReaderHash) {\n\t\t\tScoreDocLookupComparator comparer = (ScoreDocLookupComparator) fieldCache.get (field);\n\t\t\tif (comparer != null && comparer.sizeMatches(reader.maxDoc())) {\n\t\t\t\treturn comparer;\n\t\t\t}\n\t\t} else {\n\t\t\tlastReaderHash = reader.hashCode();\n\t\t\tfieldCache.clear();\n\t\t}\n\n\t\tScoreDocComparator comparer = null;\n\t\tswitch (type) {\n\t\t\tcase SortField.SCORE:  comparer = ScoreDocComparator.RELEVANCE; break;\n\t\t\tcase SortField.DOC:    comparer = ScoreDocComparator.INDEXORDER; break;\n\t\t\tcase SortField.AUTO:   comparer = determineComparator (reader, field); break;\n\t\t\tcase SortField.STRING: comparer = StringSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.INT:    comparer = IntegerSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.FLOAT:  comparer = FloatSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.CUSTOM: comparer = factory.newComparator (reader, field); break;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException (\"invalid sort field type: \"+type);\n\t\t}\n\n\t\t// store the comparator in the cache for reuse\n\t\tfieldCache.put (field, comparer);\n\n\t\treturn comparer;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns a comparator for the given field.  If there is already one in the cache, it is returned.\n\t * Otherwise one is created and put into the cache.  If <code>reader</code> is different than the\n\t * one used for the current cache, or has changed size, the cache is cleared first.\n\t * @param reader  Index to use.\n\t * @param field   Field to sort by.\n\t * @return  Comparator; never <code>null</code>.\n\t * @throws IOException  If an error occurs reading the index.\n\t * @see #determineComparator\n\t */\n\tstatic ScoreDocComparator getCachedComparator (final IndexReader reader, final String field, final int type)\n\tthrows IOException {\n\n\t\tif (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;\n\t\tif (type == SortField.SCORE) return ScoreDocComparator.RELEVANCE;\n\n\t\t// see if we have already generated a comparator for this field\n\t\tif (reader.hashCode() == lastReaderHash) {\n\t\t\tScoreDocLookupComparator comparer = (ScoreDocLookupComparator) fieldCache.get (field);\n\t\t\tif (comparer != null && comparer.sizeMatches(reader.maxDoc())) {\n\t\t\t\treturn comparer;\n\t\t\t}\n\t\t} else {\n\t\t\tlastReaderHash = reader.hashCode();\n\t\t\tfieldCache.clear();\n\t\t}\n\n\t\tScoreDocComparator comparer = null;\n\t\tswitch (type) {\n\t\t\tcase SortField.SCORE:  comparer = ScoreDocComparator.RELEVANCE; break;\n\t\t\tcase SortField.DOC:    comparer = ScoreDocComparator.INDEXORDER; break;\n\t\t\tcase SortField.INT:    comparer = IntegerSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.FLOAT:  comparer = FloatSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.STRING: comparer = StringSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.AUTO:   comparer = determineComparator (reader, field); break;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException (\"invalid sort field type: \"+type);\n\t\t}\n\n\t\t// store the comparator in the cache for reuse\n\t\tfieldCache.put (field, comparer);\n\n\t\treturn comparer;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78a881008cfecf8db714fc6813600b2ac8af4b07","date":1083943089,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#getCachedComparator(IndexReader,String,int,SortComparatorSource).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#getCachedComparator(IndexReader,String,int,SortComparatorSource).mjava","sourceNew":"\t/**\n\t * Returns a comparator for the given field.  If there is already one in the cache, it is returned.\n\t * Otherwise one is created and put into the cache.  If <code>reader</code> is different than the\n\t * one used for the current cache, or has changed size, the cache is cleared first.\n\t * @param reader  Index to use.\n\t * @param field   Field to sort by.\n\t * @return  Comparator; never <code>null</code>.\n\t * @throws IOException  If an error occurs reading the index.\n\t * @see #determineComparator\n\t */\n\tstatic ScoreDocComparator getCachedComparator (final IndexReader reader, final String field, final int type, final SortComparatorSource factory)\n\tthrows IOException {\n\n\t\tif (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;\n\t\tif (type == SortField.SCORE) return ScoreDocComparator.RELEVANCE;\n\n\t\t// see if we have already generated a comparator for this field\n\t\tif (reader.hashCode() == lastReaderHash) {\n\t\t\tScoreDocLookupComparator comparer = (ScoreDocLookupComparator) fieldCache.get (field);\n\t\t\tif (comparer != null && comparer.sizeMatches(reader.maxDoc())) {\n\t\t\t\treturn comparer;\n\t\t\t}\n\t\t} else {\n\t\t\tlastReaderHash = reader.hashCode();\n\t\t\tfieldCache.clear();\n\t\t}\n\n\t\tScoreDocComparator comparer = null;\n\t\tswitch (type) {\n\t\t\tcase SortField.AUTO:   comparer = determineComparator (reader, field); break;\n\t\t\tcase SortField.STRING: comparer = StringSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.INT:    comparer = IntegerSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.FLOAT:  comparer = FloatSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.CUSTOM: comparer = factory.newComparator (reader, field); break;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException (\"invalid sort field type: \"+type);\n\t\t}\n\n\t\t// store the comparator in the cache for reuse\n\t\tfieldCache.put (field, comparer);\n\n\t\treturn comparer;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns a comparator for the given field.  If there is already one in the cache, it is returned.\n\t * Otherwise one is created and put into the cache.  If <code>reader</code> is different than the\n\t * one used for the current cache, or has changed size, the cache is cleared first.\n\t * @param reader  Index to use.\n\t * @param field   Field to sort by.\n\t * @return  Comparator; never <code>null</code>.\n\t * @throws IOException  If an error occurs reading the index.\n\t * @see #determineComparator\n\t */\n\tstatic ScoreDocComparator getCachedComparator (final IndexReader reader, final String field, final int type, final SortComparatorSource factory)\n\tthrows IOException {\n\n\t\tif (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;\n\t\tif (type == SortField.SCORE) return ScoreDocComparator.RELEVANCE;\n\n\t\t// see if we have already generated a comparator for this field\n\t\tif (reader.hashCode() == lastReaderHash) {\n\t\t\tScoreDocLookupComparator comparer = (ScoreDocLookupComparator) fieldCache.get (field);\n\t\t\tif (comparer != null && comparer.sizeMatches(reader.maxDoc())) {\n\t\t\t\treturn comparer;\n\t\t\t}\n\t\t} else {\n\t\t\tlastReaderHash = reader.hashCode();\n\t\t\tfieldCache.clear();\n\t\t}\n\n\t\tScoreDocComparator comparer = null;\n\t\tswitch (type) {\n\t\t\tcase SortField.SCORE:  comparer = ScoreDocComparator.RELEVANCE; break;\n\t\t\tcase SortField.DOC:    comparer = ScoreDocComparator.INDEXORDER; break;\n\t\t\tcase SortField.AUTO:   comparer = determineComparator (reader, field); break;\n\t\t\tcase SortField.STRING: comparer = StringSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.INT:    comparer = IntegerSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.FLOAT:  comparer = FloatSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.CUSTOM: comparer = factory.newComparator (reader, field); break;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException (\"invalid sort field type: \"+type);\n\t\t}\n\n\t\t// store the comparator in the cache for reuse\n\t\tfieldCache.put (field, comparer);\n\n\t\treturn comparer;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99ee715b9c02dd47d9e69a18607a5192c1ebd82b","date":1085007927,"type":3,"author":"Tim Jones","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#getCachedComparator(IndexReader,String,int,SortComparatorSource).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#getCachedComparator(IndexReader,String,int,SortComparatorSource).mjava","sourceNew":"  static ScoreDocComparator getCachedComparator (IndexReader reader, String fieldname, int type, SortComparatorSource factory)\n  throws IOException {\n    if (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;\n    if (type == SortField.SCORE) return ScoreDocComparator.RELEVANCE;\n    ScoreDocComparator comparator = lookup (reader, fieldname, type, factory);\n    if (comparator == null) {\n      switch (type) {\n        case SortField.AUTO:\n          comparator = comparatorAuto (reader, fieldname);\n          break;\n        case SortField.INT:\n          comparator = comparatorInt (reader, fieldname);\n          break;\n        case SortField.FLOAT:\n          comparator = comparatorFloat (reader, fieldname);\n          break;\n        case SortField.STRING:\n          comparator = comparatorString (reader, fieldname);\n          break;\n        case SortField.CUSTOM:\n          comparator = factory.newComparator (reader, fieldname);\n          break;\n        default:\n          throw new RuntimeException (\"unknown field type: \"+type);\n      }\n      store (reader, fieldname, type, factory, comparator);\n    }\n    return comparator;\n  }\n\n","sourceOld":"\t/**\n\t * Returns a comparator for the given field.  If there is already one in the cache, it is returned.\n\t * Otherwise one is created and put into the cache.  If <code>reader</code> is different than the\n\t * one used for the current cache, or has changed size, the cache is cleared first.\n\t * @param reader  Index to use.\n\t * @param field   Field to sort by.\n\t * @return  Comparator; never <code>null</code>.\n\t * @throws IOException  If an error occurs reading the index.\n\t * @see #determineComparator\n\t */\n\tstatic ScoreDocComparator getCachedComparator (final IndexReader reader, final String field, final int type, final SortComparatorSource factory)\n\tthrows IOException {\n\n\t\tif (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;\n\t\tif (type == SortField.SCORE) return ScoreDocComparator.RELEVANCE;\n\n\t\t// see if we have already generated a comparator for this field\n\t\tif (reader.hashCode() == lastReaderHash) {\n\t\t\tScoreDocLookupComparator comparer = (ScoreDocLookupComparator) fieldCache.get (field);\n\t\t\tif (comparer != null && comparer.sizeMatches(reader.maxDoc())) {\n\t\t\t\treturn comparer;\n\t\t\t}\n\t\t} else {\n\t\t\tlastReaderHash = reader.hashCode();\n\t\t\tfieldCache.clear();\n\t\t}\n\n\t\tScoreDocComparator comparer = null;\n\t\tswitch (type) {\n\t\t\tcase SortField.AUTO:   comparer = determineComparator (reader, field); break;\n\t\t\tcase SortField.STRING: comparer = StringSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.INT:    comparer = IntegerSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.FLOAT:  comparer = FloatSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.CUSTOM: comparer = factory.newComparator (reader, field); break;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException (\"invalid sort field type: \"+type);\n\t\t}\n\n\t\t// store the comparator in the cache for reuse\n\t\tfieldCache.put (field, comparer);\n\n\t\treturn comparer;\n\t}\n\n","bugFix":null,"bugIntro":["2275c46fba03d235b53596f1b08c77ad11a24459"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba534479820dee396d07f520ba2a55400a1b6e7d","date":1085439102,"type":5,"author":"Tim Jones","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#getCachedComparator(IndexReader,String,int,Locale,SortComparatorSource).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#getCachedComparator(IndexReader,String,int,SortComparatorSource).mjava","sourceNew":"  static ScoreDocComparator getCachedComparator (IndexReader reader, String fieldname, int type, Locale locale, SortComparatorSource factory)\n  throws IOException {\n    if (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;\n    if (type == SortField.SCORE) return ScoreDocComparator.RELEVANCE;\n    ScoreDocComparator comparator = lookup (reader, fieldname, type, factory);\n    if (comparator == null) {\n      switch (type) {\n        case SortField.AUTO:\n          comparator = comparatorAuto (reader, fieldname);\n          break;\n        case SortField.INT:\n          comparator = comparatorInt (reader, fieldname);\n          break;\n        case SortField.FLOAT:\n          comparator = comparatorFloat (reader, fieldname);\n          break;\n        case SortField.STRING:\n          if (locale != null) comparator = comparatorStringLocale (reader, fieldname, locale);\n          else comparator = comparatorString (reader, fieldname);\n          break;\n        case SortField.CUSTOM:\n          comparator = factory.newComparator (reader, fieldname);\n          break;\n        default:\n          throw new RuntimeException (\"unknown field type: \"+type);\n      }\n      store (reader, fieldname, type, factory, comparator);\n    }\n    return comparator;\n  }\n\n","sourceOld":"  static ScoreDocComparator getCachedComparator (IndexReader reader, String fieldname, int type, SortComparatorSource factory)\n  throws IOException {\n    if (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;\n    if (type == SortField.SCORE) return ScoreDocComparator.RELEVANCE;\n    ScoreDocComparator comparator = lookup (reader, fieldname, type, factory);\n    if (comparator == null) {\n      switch (type) {\n        case SortField.AUTO:\n          comparator = comparatorAuto (reader, fieldname);\n          break;\n        case SortField.INT:\n          comparator = comparatorInt (reader, fieldname);\n          break;\n        case SortField.FLOAT:\n          comparator = comparatorFloat (reader, fieldname);\n          break;\n        case SortField.STRING:\n          comparator = comparatorString (reader, fieldname);\n          break;\n        case SortField.CUSTOM:\n          comparator = factory.newComparator (reader, fieldname);\n          break;\n        default:\n          throw new RuntimeException (\"unknown field type: \"+type);\n      }\n      store (reader, fieldname, type, factory, comparator);\n    }\n    return comparator;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"99ee715b9c02dd47d9e69a18607a5192c1ebd82b":["78a881008cfecf8db714fc6813600b2ac8af4b07"],"35c39157e8b6bc585e3a07e703d75db0f2ad56b2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78a881008cfecf8db714fc6813600b2ac8af4b07":["35c39157e8b6bc585e3a07e703d75db0f2ad56b2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ba534479820dee396d07f520ba2a55400a1b6e7d"],"ba534479820dee396d07f520ba2a55400a1b6e7d":["99ee715b9c02dd47d9e69a18607a5192c1ebd82b"]},"commit2Childs":{"99ee715b9c02dd47d9e69a18607a5192c1ebd82b":["ba534479820dee396d07f520ba2a55400a1b6e7d"],"35c39157e8b6bc585e3a07e703d75db0f2ad56b2":["78a881008cfecf8db714fc6813600b2ac8af4b07"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["35c39157e8b6bc585e3a07e703d75db0f2ad56b2"],"78a881008cfecf8db714fc6813600b2ac8af4b07":["99ee715b9c02dd47d9e69a18607a5192c1ebd82b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"ba534479820dee396d07f520ba2a55400a1b6e7d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}