{"path":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testLengthPrefixAcrossTwoBlocks().mjava","commits":[{"id":"9394c1716c0484f28e7ac42f9aaa5e5d9432fa7d","date":1331762974,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testLengthPrefixAcrossTwoBlocks().mjava","pathOld":"/dev/null","sourceNew":"  // LUCENE-3841: even though\n  // copyUsingLengthPrefix will never span two blocks, make\n  // sure if caller writes their own prefix followed by the\n  // bytes, it still works:\n  public void testLengthPrefixAcrossTwoBlocks() throws Exception {\n    final PagedBytes p = new PagedBytes(10);\n    final DataOutput out = p.getDataOutput();\n    final byte[] bytes1 = new byte[1000];\n    random.nextBytes(bytes1);\n    out.writeBytes(bytes1, 0, bytes1.length);\n    out.writeByte((byte) 40);\n    final byte[] bytes2 = new byte[40];\n    random.nextBytes(bytes2);\n    out.writeBytes(bytes2, 0, bytes2.length);\n\n    final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n    BytesRef answer = reader.fillSliceWithPrefix(new BytesRef(), 1000);\n    assertEquals(40, answer.length);\n    for(int i=0;i<40;i++) {\n      assertEquals(bytes2[i], answer.bytes[answer.offset + i]);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testLengthPrefixAcrossTwoBlocks().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testLengthPrefixAcrossTwoBlocks().mjava","sourceNew":"  // LUCENE-3841: even though\n  // copyUsingLengthPrefix will never span two blocks, make\n  // sure if caller writes their own prefix followed by the\n  // bytes, it still works:\n  public void testLengthPrefixAcrossTwoBlocks() throws Exception {\n    Random random = random();\n    final PagedBytes p = new PagedBytes(10);\n    final DataOutput out = p.getDataOutput();\n    final byte[] bytes1 = new byte[1000];\n    random.nextBytes(bytes1);\n    out.writeBytes(bytes1, 0, bytes1.length);\n    out.writeByte((byte) 40);\n    final byte[] bytes2 = new byte[40];\n    random.nextBytes(bytes2);\n    out.writeBytes(bytes2, 0, bytes2.length);\n\n    final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n    BytesRef answer = reader.fillSliceWithPrefix(new BytesRef(), 1000);\n    assertEquals(40, answer.length);\n    for(int i=0;i<40;i++) {\n      assertEquals(bytes2[i], answer.bytes[answer.offset + i]);\n    }\n  }\n\n","sourceOld":"  // LUCENE-3841: even though\n  // copyUsingLengthPrefix will never span two blocks, make\n  // sure if caller writes their own prefix followed by the\n  // bytes, it still works:\n  public void testLengthPrefixAcrossTwoBlocks() throws Exception {\n    final PagedBytes p = new PagedBytes(10);\n    final DataOutput out = p.getDataOutput();\n    final byte[] bytes1 = new byte[1000];\n    random.nextBytes(bytes1);\n    out.writeBytes(bytes1, 0, bytes1.length);\n    out.writeByte((byte) 40);\n    final byte[] bytes2 = new byte[40];\n    random.nextBytes(bytes2);\n    out.writeBytes(bytes2, 0, bytes2.length);\n\n    final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n    BytesRef answer = reader.fillSliceWithPrefix(new BytesRef(), 1000);\n    assertEquals(40, answer.length);\n    for(int i=0;i<40;i++) {\n      assertEquals(bytes2[i], answer.bytes[answer.offset + i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa968010b9c6598d02666b7b879c12e3cb0db4ee","date":1359063766,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testLengthPrefixAcrossTwoBlocks().mjava","sourceNew":null,"sourceOld":"  // LUCENE-3841: even though\n  // copyUsingLengthPrefix will never span two blocks, make\n  // sure if caller writes their own prefix followed by the\n  // bytes, it still works:\n  public void testLengthPrefixAcrossTwoBlocks() throws Exception {\n    Random random = random();\n    final PagedBytes p = new PagedBytes(10);\n    final DataOutput out = p.getDataOutput();\n    final byte[] bytes1 = new byte[1000];\n    random.nextBytes(bytes1);\n    out.writeBytes(bytes1, 0, bytes1.length);\n    out.writeByte((byte) 40);\n    final byte[] bytes2 = new byte[40];\n    random.nextBytes(bytes2);\n    out.writeBytes(bytes2, 0, bytes2.length);\n\n    final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n    BytesRef answer = reader.fillSliceWithPrefix(new BytesRef(), 1000);\n    assertEquals(40, answer.length);\n    for(int i=0;i<40;i++) {\n      assertEquals(bytes2[i], answer.bytes[answer.offset + i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testLengthPrefixAcrossTwoBlocks().mjava","sourceNew":null,"sourceOld":"  // LUCENE-3841: even though\n  // copyUsingLengthPrefix will never span two blocks, make\n  // sure if caller writes their own prefix followed by the\n  // bytes, it still works:\n  public void testLengthPrefixAcrossTwoBlocks() throws Exception {\n    Random random = random();\n    final PagedBytes p = new PagedBytes(10);\n    final DataOutput out = p.getDataOutput();\n    final byte[] bytes1 = new byte[1000];\n    random.nextBytes(bytes1);\n    out.writeBytes(bytes1, 0, bytes1.length);\n    out.writeByte((byte) 40);\n    final byte[] bytes2 = new byte[40];\n    random.nextBytes(bytes2);\n    out.writeBytes(bytes2, 0, bytes2.length);\n\n    final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n    BytesRef answer = reader.fillSliceWithPrefix(new BytesRef(), 1000);\n    assertEquals(40, answer.length);\n    for(int i=0;i<40;i++) {\n      assertEquals(bytes2[i], answer.bytes[answer.offset + i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fa968010b9c6598d02666b7b879c12e3cb0db4ee":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","fa968010b9c6598d02666b7b879c12e3cb0db4ee"],"9394c1716c0484f28e7ac42f9aaa5e5d9432fa7d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["9394c1716c0484f28e7ac42f9aaa5e5d9432fa7d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4d69c535930b5cce125cff868d40f6373dc27d4"]},"commit2Childs":{"fa968010b9c6598d02666b7b879c12e3cb0db4ee":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9394c1716c0484f28e7ac42f9aaa5e5d9432fa7d":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9394c1716c0484f28e7ac42f9aaa5e5d9432fa7d"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["fa968010b9c6598d02666b7b879c12e3cb0db4ee","d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}