{"path":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer).mjava","commits":[{"id":"b8b87263526557a451254f824e63e454e43e47ad","date":1453798964,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer) {\n    addField(field, analyzer, 1.0f);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac88193d9fe80e165a43bb0555c43afa83da8330","date":1453823827,"type":0,"author":"jbernste","isMerge":true,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer) {\n    addField(field, analyzer, 1.0f);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer) {\n    addField(field, analyzer, 1.0f);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"253a79e1af11467dd01315b1919025d288aa0ccb","date":1458032260,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer).mjava","sourceNew":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.\n   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.\n   *\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer) {\n    addField(field, analyzer, 1.0f);\n  }\n\n","sourceOld":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer) {\n    addField(field, analyzer, 1.0f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acd9883560fd89e6448b2b447302fe543040cd4f","date":1488478696,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer).mjava","sourceNew":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.\n   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.\n   *\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   */\n  public void addField(IndexableField field, Analyzer analyzer) {\n\n    Info info = getInfo(field.name(), field.fieldType());\n\n    int offsetGap;\n    TokenStream tokenStream;\n    int positionIncrementGap;\n    if (analyzer != null) {\n      offsetGap = analyzer.getOffsetGap(field.name());\n      tokenStream = field.tokenStream(analyzer, null);\n      positionIncrementGap = analyzer.getPositionIncrementGap(field.name());\n    } else {\n      offsetGap = 1;\n      tokenStream = field.tokenStream(null, null);\n      positionIncrementGap = 0;\n    }\n    if (tokenStream != null) {\n      storeTerms(info, tokenStream, positionIncrementGap, offsetGap);\n    }\n\n    DocValuesType docValuesType = field.fieldType().docValuesType();\n    Object docValuesValue;\n    switch (docValuesType) {\n      case NONE:\n        docValuesValue = null;\n        break;\n      case BINARY:\n      case SORTED:\n      case SORTED_SET:\n        docValuesValue = field.binaryValue();\n        break;\n      case NUMERIC:\n      case SORTED_NUMERIC:\n        docValuesValue = field.numericValue();\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n    if (docValuesValue != null) {\n      storeDocValues(info, docValuesType, docValuesValue);\n    }\n\n    if (field.fieldType().pointDimensionCount() > 0) {\n      storePointValues(info, field.binaryValue());\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.\n   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.\n   *\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these\n   *                                  structures are not supported by MemoryIndex\n   */\n  public void addField(IndexableField field, Analyzer analyzer) {\n    addField(field, analyzer, 1.0f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer).mjava","sourceNew":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.\n   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.\n   *\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   */\n  public void addField(IndexableField field, Analyzer analyzer) {\n\n    Info info = getInfo(field.name(), field.fieldType());\n\n    int offsetGap;\n    TokenStream tokenStream;\n    int positionIncrementGap;\n    if (analyzer != null) {\n      offsetGap = analyzer.getOffsetGap(field.name());\n      tokenStream = field.tokenStream(analyzer, null);\n      positionIncrementGap = analyzer.getPositionIncrementGap(field.name());\n    } else {\n      offsetGap = 1;\n      tokenStream = field.tokenStream(null, null);\n      positionIncrementGap = 0;\n    }\n    if (tokenStream != null) {\n      storeTerms(info, tokenStream, positionIncrementGap, offsetGap);\n    }\n\n    DocValuesType docValuesType = field.fieldType().docValuesType();\n    Object docValuesValue;\n    switch (docValuesType) {\n      case NONE:\n        docValuesValue = null;\n        break;\n      case BINARY:\n      case SORTED:\n      case SORTED_SET:\n        docValuesValue = field.binaryValue();\n        break;\n      case NUMERIC:\n      case SORTED_NUMERIC:\n        docValuesValue = field.numericValue();\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n    if (docValuesValue != null) {\n      storeDocValues(info, docValuesType, docValuesValue);\n    }\n\n    if (field.fieldType().pointDataDimensionCount() > 0) {\n      storePointValues(info, field.binaryValue());\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.\n   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.\n   *\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   */\n  public void addField(IndexableField field, Analyzer analyzer) {\n\n    Info info = getInfo(field.name(), field.fieldType());\n\n    int offsetGap;\n    TokenStream tokenStream;\n    int positionIncrementGap;\n    if (analyzer != null) {\n      offsetGap = analyzer.getOffsetGap(field.name());\n      tokenStream = field.tokenStream(analyzer, null);\n      positionIncrementGap = analyzer.getPositionIncrementGap(field.name());\n    } else {\n      offsetGap = 1;\n      tokenStream = field.tokenStream(null, null);\n      positionIncrementGap = 0;\n    }\n    if (tokenStream != null) {\n      storeTerms(info, tokenStream, positionIncrementGap, offsetGap);\n    }\n\n    DocValuesType docValuesType = field.fieldType().docValuesType();\n    Object docValuesValue;\n    switch (docValuesType) {\n      case NONE:\n        docValuesValue = null;\n        break;\n      case BINARY:\n      case SORTED:\n      case SORTED_SET:\n        docValuesValue = field.binaryValue();\n        break;\n      case NUMERIC:\n      case SORTED_NUMERIC:\n        docValuesValue = field.numericValue();\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n    if (docValuesValue != null) {\n      storeDocValues(info, docValuesType, docValuesValue);\n    }\n\n    if (field.fieldType().pointDimensionCount() > 0) {\n      storePointValues(info, field.binaryValue());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59ed8c026ba85e3c42fb89605b2032dc6f9cc241","date":1581113294,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#addField(IndexableField,Analyzer).mjava","sourceNew":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.\n   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.\n   *\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   */\n  public void addField(IndexableField field, Analyzer analyzer) {\n\n    Info info = getInfo(field.name(), field.fieldType());\n\n    int offsetGap;\n    TokenStream tokenStream;\n    int positionIncrementGap;\n    if (analyzer != null) {\n      offsetGap = analyzer.getOffsetGap(field.name());\n      tokenStream = field.tokenStream(analyzer, null);\n      positionIncrementGap = analyzer.getPositionIncrementGap(field.name());\n    } else {\n      offsetGap = 1;\n      tokenStream = field.tokenStream(null, null);\n      positionIncrementGap = 0;\n    }\n    if (tokenStream != null) {\n      storeTerms(info, tokenStream, positionIncrementGap, offsetGap);\n    }\n\n    DocValuesType docValuesType = field.fieldType().docValuesType();\n    Object docValuesValue;\n    switch (docValuesType) {\n      case NONE:\n        docValuesValue = null;\n        break;\n      case BINARY:\n      case SORTED:\n      case SORTED_SET:\n        docValuesValue = field.binaryValue();\n        break;\n      case NUMERIC:\n      case SORTED_NUMERIC:\n        docValuesValue = field.numericValue();\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n    if (docValuesValue != null) {\n      storeDocValues(info, docValuesType, docValuesValue);\n    }\n\n    if (field.fieldType().pointDimensionCount() > 0) {\n      storePointValues(info, field.binaryValue());\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.\n   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.\n   *\n   * @param field the field to add\n   * @param analyzer the analyzer to use for term analysis\n   */\n  public void addField(IndexableField field, Analyzer analyzer) {\n\n    Info info = getInfo(field.name(), field.fieldType());\n\n    int offsetGap;\n    TokenStream tokenStream;\n    int positionIncrementGap;\n    if (analyzer != null) {\n      offsetGap = analyzer.getOffsetGap(field.name());\n      tokenStream = field.tokenStream(analyzer, null);\n      positionIncrementGap = analyzer.getPositionIncrementGap(field.name());\n    } else {\n      offsetGap = 1;\n      tokenStream = field.tokenStream(null, null);\n      positionIncrementGap = 0;\n    }\n    if (tokenStream != null) {\n      storeTerms(info, tokenStream, positionIncrementGap, offsetGap);\n    }\n\n    DocValuesType docValuesType = field.fieldType().docValuesType();\n    Object docValuesValue;\n    switch (docValuesType) {\n      case NONE:\n        docValuesValue = null;\n        break;\n      case BINARY:\n      case SORTED:\n      case SORTED_SET:\n        docValuesValue = field.binaryValue();\n        break;\n      case NUMERIC:\n      case SORTED_NUMERIC:\n        docValuesValue = field.numericValue();\n        break;\n      default:\n        throw new UnsupportedOperationException(\"unknown doc values type [\" + docValuesType + \"]\");\n    }\n    if (docValuesValue != null) {\n      storeDocValues(info, docValuesType, docValuesValue);\n    }\n\n    if (field.fieldType().pointDataDimensionCount() > 0) {\n      storePointValues(info, field.binaryValue());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ac88193d9fe80e165a43bb0555c43afa83da8330":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b8b87263526557a451254f824e63e454e43e47ad"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["f6652c943595e92c187ee904c382863013eae28f"],"f6652c943595e92c187ee904c382863013eae28f":["acd9883560fd89e6448b2b447302fe543040cd4f"],"b8b87263526557a451254f824e63e454e43e47ad":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"253a79e1af11467dd01315b1919025d288aa0ccb":["ac88193d9fe80e165a43bb0555c43afa83da8330"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac88193d9fe80e165a43bb0555c43afa83da8330"],"acd9883560fd89e6448b2b447302fe543040cd4f":["253a79e1af11467dd01315b1919025d288aa0ccb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"]},"commit2Childs":{"ac88193d9fe80e165a43bb0555c43afa83da8330":["253a79e1af11467dd01315b1919025d288aa0ccb","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"b8b87263526557a451254f824e63e454e43e47ad":["ac88193d9fe80e165a43bb0555c43afa83da8330"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"253a79e1af11467dd01315b1919025d288aa0ccb":["acd9883560fd89e6448b2b447302fe543040cd4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ac88193d9fe80e165a43bb0555c43afa83da8330","b8b87263526557a451254f824e63e454e43e47ad","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"acd9883560fd89e6448b2b447302fe543040cd4f":["f6652c943595e92c187ee904c382863013eae28f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}