{"path":"src/java/org/apache/solr/util/SolrPluginUtils#getHighlights(DocList,String[],SolrIndexSearcher,Highlighter,int).mjava","commits":[{"id":"0452863ee588101738d341e6e97eb87eb010052a","date":1152814944,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/util/SolrPluginUtils#getHighlights(DocList,String[],SolrIndexSearcher,Highlighter,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Generates a list of Highlighted query fragments for each item in a list\n   * of documents\n   *\n   * @param docs query results\n   * @param fieldNames list of fields to summarize\n   * @param searcher the SolrIndexSearcher corresponding to a request\n   * @param numFragments maximum number of summary fragments to return for\n   *        a given field   \n   * @param highlighter a customized Highlighter instance\n   *\n   * @return NamedList containing a NamedList for each document, which in\n   * turns contains sets (field, summary) pairs.\n   */\n  public static NamedList getHighlights(DocList docs, \n                                        String[] fieldNames, \n                                        SolrIndexSearcher searcher,\n                                        Highlighter highlighter,\n                                        int numFragments\n                                        ) throws IOException {\n    NamedList fragments = new NamedList();\n    DocIterator iterator = docs.iterator();\n    for (int i=0; i<docs.size(); i++) {\n      int docId = iterator.nextDoc();\n      // use the Searcher's doc cache\n      Document doc = searcher.doc(docId);\n      NamedList docSummaries = new NamedList();\n      for(String fieldName : fieldNames) {\n        fieldName = fieldName.trim();\n        String[] docTexts = doc.getValues(fieldName);\n        if(docTexts == null) \n          continue;        \n        String[] summaries;\n        TextFragment[] frag;\n        if(docTexts.length == 1) {\n          // single-valued field\n          TokenStream tstream;\n          try {\n            // attempt term vectors\n            tstream = TokenSources.getTokenStream(\n              searcher.getReader(), docId, fieldName);\n          } catch (IllegalArgumentException e) {\n            // fall back to analyzer\n            tstream = searcher.getSchema().getAnalyzer().tokenStream(\n             fieldName, new StringReader(docTexts[0]));\n          }\n          frag = highlighter.getBestTextFragments(\n            tstream, docTexts[0], false, numFragments);\n\n        } else {\n          // multi-valued field\n          MultiValueTokenStream tstream;\n          tstream = new MultiValueTokenStream(fieldName,\n                                              docTexts,\n                                              searcher.getSchema().getAnalyzer());\n          frag = highlighter.getBestTextFragments(\n            tstream, tstream.asSingleValue(), false, numFragments);\n        }\n        // convert fragments back into text\n        // TODO: we can include score and position information in output as\n        // snippet attributes\n        if(frag.length > 0) {\n          ArrayList fragTexts = new ArrayList();\n          for (int j = 0; j < frag.length; j++) {\n              if ((frag[j] != null) && (frag[j].getScore() > 0)) {\n                  fragTexts.add(frag[j].toString());\n                }\n            }\n          summaries =  (String[]) fragTexts.toArray(new String[0]);\n          if(summaries.length > 0)\n            docSummaries.add(fieldName, summaries);\n        }\n      }      \n      String printId = searcher.getSchema().printableUniqueKey(doc);\n      fragments.add(printId == null ? null : printId, docSummaries);\n    }    \n    return fragments;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09b389e81c6f6d4cd07c05a8189081bc814b01ce","date":1152976365,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/util/SolrPluginUtils#getHighlights(DocList,String[],SolrIndexSearcher,Highlighter,int).mjava","pathOld":"src/java/org/apache/solr/util/SolrPluginUtils#getHighlights(DocList,String[],SolrIndexSearcher,Highlighter,int).mjava","sourceNew":"  /**\n   * Generates a list of Highlighted query fragments for each item in a list\n   * of documents\n   *\n   * @param docs query results\n   * @param fieldNames list of fields to summarize\n   * @param searcher the SolrIndexSearcher corresponding to a request\n   * @param numFragments maximum number of summary fragments to return for\n   *        a given field   \n   * @param highlighter a customized Highlighter instance\n   *\n   * @return NamedList containing a NamedList for each document, which in\n   * turns contains sets (field, summary) pairs.\n   */\n  public static NamedList getHighlights(DocList docs, \n                                        String[] fieldNames, \n                                        SolrIndexSearcher searcher,\n                                        Highlighter highlighter,\n                                        int numFragments\n                                        ) throws IOException {\n    NamedList fragments = new NamedList();\n    DocIterator iterator = docs.iterator();\n    for (int i=0; i<docs.size(); i++) {\n      int docId = iterator.nextDoc();\n      // use the Searcher's doc cache\n      Document doc = searcher.doc(docId);\n      NamedList docSummaries = new NamedList();\n      for(String fieldName : fieldNames) {\n        fieldName = fieldName.trim();\n        String[] docTexts = doc.getValues(fieldName);\n        if(docTexts == null) \n          continue;        \n        String[] summaries;\n        TextFragment[] frag;\n        if(docTexts.length == 1) {\n          // single-valued field\n          TokenStream tstream;\n          try {\n            // attempt term vectors\n            tstream = TokenSources.getTokenStream(\n              searcher.getReader(), docId, fieldName);\n          } catch (IllegalArgumentException e) {\n            // fall back to analyzer\n            tstream = new TokenOrderingFilter(\n                    searcher.getSchema().getAnalyzer().tokenStream(\n                      fieldName, new StringReader(docTexts[0])),\n                    10);\n          }\n          frag = highlighter.getBestTextFragments(\n            tstream, docTexts[0], false, numFragments);\n\n        } else {\n          // multi-valued field\n          MultiValueTokenStream tstream;\n          tstream = new MultiValueTokenStream(fieldName,\n                                              docTexts,\n                                              searcher.getSchema().getAnalyzer(), true);\n          frag = highlighter.getBestTextFragments(\n            tstream, tstream.asSingleValue(), false, numFragments);\n        }\n        // convert fragments back into text\n        // TODO: we can include score and position information in output as\n        // snippet attributes\n        if(frag.length > 0) {\n          ArrayList fragTexts = new ArrayList();\n          for (int j = 0; j < frag.length; j++) {\n              if ((frag[j] != null) && (frag[j].getScore() > 0)) {\n                  fragTexts.add(frag[j].toString());\n                }\n            }\n          summaries =  (String[]) fragTexts.toArray(new String[0]);\n          if(summaries.length > 0)\n            docSummaries.add(fieldName, summaries);\n        }\n      }      \n      String printId = searcher.getSchema().printableUniqueKey(doc);\n      fragments.add(printId == null ? null : printId, docSummaries);\n    }    \n    return fragments;\n  }\n\n","sourceOld":"  /**\n   * Generates a list of Highlighted query fragments for each item in a list\n   * of documents\n   *\n   * @param docs query results\n   * @param fieldNames list of fields to summarize\n   * @param searcher the SolrIndexSearcher corresponding to a request\n   * @param numFragments maximum number of summary fragments to return for\n   *        a given field   \n   * @param highlighter a customized Highlighter instance\n   *\n   * @return NamedList containing a NamedList for each document, which in\n   * turns contains sets (field, summary) pairs.\n   */\n  public static NamedList getHighlights(DocList docs, \n                                        String[] fieldNames, \n                                        SolrIndexSearcher searcher,\n                                        Highlighter highlighter,\n                                        int numFragments\n                                        ) throws IOException {\n    NamedList fragments = new NamedList();\n    DocIterator iterator = docs.iterator();\n    for (int i=0; i<docs.size(); i++) {\n      int docId = iterator.nextDoc();\n      // use the Searcher's doc cache\n      Document doc = searcher.doc(docId);\n      NamedList docSummaries = new NamedList();\n      for(String fieldName : fieldNames) {\n        fieldName = fieldName.trim();\n        String[] docTexts = doc.getValues(fieldName);\n        if(docTexts == null) \n          continue;        \n        String[] summaries;\n        TextFragment[] frag;\n        if(docTexts.length == 1) {\n          // single-valued field\n          TokenStream tstream;\n          try {\n            // attempt term vectors\n            tstream = TokenSources.getTokenStream(\n              searcher.getReader(), docId, fieldName);\n          } catch (IllegalArgumentException e) {\n            // fall back to analyzer\n            tstream = searcher.getSchema().getAnalyzer().tokenStream(\n             fieldName, new StringReader(docTexts[0]));\n          }\n          frag = highlighter.getBestTextFragments(\n            tstream, docTexts[0], false, numFragments);\n\n        } else {\n          // multi-valued field\n          MultiValueTokenStream tstream;\n          tstream = new MultiValueTokenStream(fieldName,\n                                              docTexts,\n                                              searcher.getSchema().getAnalyzer());\n          frag = highlighter.getBestTextFragments(\n            tstream, tstream.asSingleValue(), false, numFragments);\n        }\n        // convert fragments back into text\n        // TODO: we can include score and position information in output as\n        // snippet attributes\n        if(frag.length > 0) {\n          ArrayList fragTexts = new ArrayList();\n          for (int j = 0; j < frag.length; j++) {\n              if ((frag[j] != null) && (frag[j].getScore() > 0)) {\n                  fragTexts.add(frag[j].toString());\n                }\n            }\n          summaries =  (String[]) fragTexts.toArray(new String[0]);\n          if(summaries.length > 0)\n            docSummaries.add(fieldName, summaries);\n        }\n      }      \n      String printId = searcher.getSchema().printableUniqueKey(doc);\n      fragments.add(printId == null ? null : printId, docSummaries);\n    }    \n    return fragments;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af09a11446184597ca824554260a98704507f8a7","date":1157138567,"type":4,"author":"Mike Klaas","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/solr/util/SolrPluginUtils#getHighlights(DocList,String[],SolrIndexSearcher,Highlighter,int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Generates a list of Highlighted query fragments for each item in a list\n   * of documents\n   *\n   * @param docs query results\n   * @param fieldNames list of fields to summarize\n   * @param searcher the SolrIndexSearcher corresponding to a request\n   * @param numFragments maximum number of summary fragments to return for\n   *        a given field   \n   * @param highlighter a customized Highlighter instance\n   *\n   * @return NamedList containing a NamedList for each document, which in\n   * turns contains sets (field, summary) pairs.\n   */\n  public static NamedList getHighlights(DocList docs, \n                                        String[] fieldNames, \n                                        SolrIndexSearcher searcher,\n                                        Highlighter highlighter,\n                                        int numFragments\n                                        ) throws IOException {\n    NamedList fragments = new NamedList();\n    DocIterator iterator = docs.iterator();\n    for (int i=0; i<docs.size(); i++) {\n      int docId = iterator.nextDoc();\n      // use the Searcher's doc cache\n      Document doc = searcher.doc(docId);\n      NamedList docSummaries = new NamedList();\n      for(String fieldName : fieldNames) {\n        fieldName = fieldName.trim();\n        String[] docTexts = doc.getValues(fieldName);\n        if(docTexts == null) \n          continue;        \n        String[] summaries;\n        TextFragment[] frag;\n        if(docTexts.length == 1) {\n          // single-valued field\n          TokenStream tstream;\n          try {\n            // attempt term vectors\n            tstream = TokenSources.getTokenStream(\n              searcher.getReader(), docId, fieldName);\n          } catch (IllegalArgumentException e) {\n            // fall back to analyzer\n            tstream = new TokenOrderingFilter(\n                    searcher.getSchema().getAnalyzer().tokenStream(\n                      fieldName, new StringReader(docTexts[0])),\n                    10);\n          }\n          frag = highlighter.getBestTextFragments(\n            tstream, docTexts[0], false, numFragments);\n\n        } else {\n          // multi-valued field\n          MultiValueTokenStream tstream;\n          tstream = new MultiValueTokenStream(fieldName,\n                                              docTexts,\n                                              searcher.getSchema().getAnalyzer(), true);\n          frag = highlighter.getBestTextFragments(\n            tstream, tstream.asSingleValue(), false, numFragments);\n        }\n        // convert fragments back into text\n        // TODO: we can include score and position information in output as\n        // snippet attributes\n        if(frag.length > 0) {\n          ArrayList fragTexts = new ArrayList();\n          for (int j = 0; j < frag.length; j++) {\n              if ((frag[j] != null) && (frag[j].getScore() > 0)) {\n                  fragTexts.add(frag[j].toString());\n                }\n            }\n          summaries =  (String[]) fragTexts.toArray(new String[0]);\n          if(summaries.length > 0)\n            docSummaries.add(fieldName, summaries);\n        }\n      }      \n      String printId = searcher.getSchema().printableUniqueKey(doc);\n      fragments.add(printId == null ? null : printId, docSummaries);\n    }    \n    return fragments;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"09b389e81c6f6d4cd07c05a8189081bc814b01ce":["0452863ee588101738d341e6e97eb87eb010052a"],"0452863ee588101738d341e6e97eb87eb010052a":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"af09a11446184597ca824554260a98704507f8a7":["09b389e81c6f6d4cd07c05a8189081bc814b01ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"09b389e81c6f6d4cd07c05a8189081bc814b01ce":["af09a11446184597ca824554260a98704507f8a7"],"0452863ee588101738d341e6e97eb87eb010052a":["09b389e81c6f6d4cd07c05a8189081bc814b01ce"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0452863ee588101738d341e6e97eb87eb010052a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"af09a11446184597ca824554260a98704507f8a7":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["af09a11446184597ca824554260a98704507f8a7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}