{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","commits":[{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"/dev/null","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String,Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n        \n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n            \n            String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n            \n            String msgBaseUrl = getBaseUrl();\n            String msgCore = descriptor.getName();\n\n            if (baseUrl.equals(msgBaseUrl) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"/dev/null","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String,Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n        \n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n            \n            String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n            \n            String msgBaseUrl = getBaseUrl();\n            String msgCore = descriptor.getName();\n\n            if (baseUrl.equals(msgBaseUrl) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ceca2bff80f22f2c69257979e86498558a4c2691","date":1393261456,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String,Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n        \n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n            \n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n            \n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (nodeName.equals(msgNodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String,Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n        \n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n            \n            String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n            \n            String msgBaseUrl = getBaseUrl();\n            String msgCore = descriptor.getName();\n\n            if (baseUrl.equals(msgBaseUrl) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"840fc95f31a25d020cd825e880018bcfa0bacc71","date":1393483822,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String,Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n        \n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n            \n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n            \n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String,Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n        \n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n            \n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n            \n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (nodeName.equals(msgNodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","date":1393532551,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String,Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n        \n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n            \n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n            \n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String,Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n        \n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n            \n            String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n            \n            String msgBaseUrl = getBaseUrl();\n            String msgCore = descriptor.getName();\n\n            if (baseUrl.equals(msgBaseUrl) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbcfc050b9f253136eaa5950b57248b2109eac11","date":1427308993,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String,Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n        \n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n            \n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n            \n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String,Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n        \n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n            \n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n            \n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"20c56b78a24b25c89b1deb0a1331f7ee7af8ac7e","date":1464965423,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) throws InterruptedException {\n    log.info(\"Waiting for coreNodeName for core {} in collection {} to be assigned\",\n        descriptor.getName(), descriptor.getCollectionName());\n    final String thisNode = getNodeName();\n    try {\n      zkStateReader.waitForState(descriptor.getCollectionName(), 320, TimeUnit.SECONDS, (n, c) -> {\n        if (c == null)\n          return false;\n        for (Replica replica : c.getReplicasOnNode(thisNode)) {\n          if (descriptor.getName().equals(replica.getCoreName())) {\n            descriptor.getCloudDescriptor().setCoreNodeName(replica.getName());\n            return true;\n          }\n        }\n        return false;\n      });\n    } catch (TimeoutException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Timed out getting coreNodeName for \" + descriptor.getName());\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"650d17e953fb1d54e644f9928e3202e68b88eeb1","date":1465215234,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) throws InterruptedException {\n    log.info(\"Waiting for coreNodeName for core {} in collection {} to be assigned\",\n        descriptor.getName(), descriptor.getCollectionName());\n    final String thisNode = getNodeName();\n    try {\n      zkStateReader.waitForState(descriptor.getCollectionName(), 320, TimeUnit.SECONDS, (n, c) -> {\n        if (c == null)\n          return false;\n        for (Replica replica : c.getReplicasOnNode(thisNode)) {\n          if (descriptor.getName().equals(replica.getCoreName())) {\n            descriptor.getCloudDescriptor().setCoreNodeName(replica.getName());\n            return true;\n          }\n        }\n        return false;\n      });\n    } catch (TimeoutException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Timed out getting coreNodeName for \" + descriptor.getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":["344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) throws InterruptedException {\n    log.info(\"Waiting for coreNodeName for core {} in collection {} to be assigned\",\n        descriptor.getName(), descriptor.getCollectionName());\n    final String thisNode = getNodeName();\n    try {\n      zkStateReader.waitForState(descriptor.getCollectionName(), 320, TimeUnit.SECONDS, (n, c) -> {\n        if (c == null)\n          return false;\n        for (Replica replica : c.getReplicasOnNode(thisNode)) {\n          if (descriptor.getName().equals(replica.getCoreName())) {\n            descriptor.getCloudDescriptor().setCoreNodeName(replica.getName());\n            return true;\n          }\n        }\n        return false;\n      });\n    } catch (TimeoutException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Timed out getting coreNodeName for \" + descriptor.getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"962cd4f5e313777f35da8f521265323e84184929","date":1474533758,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.debug(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.debug(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.debug(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.info(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"717e5ceb2acae36d422ec75e5a4ce9fac40506e1","date":1501239603,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.debug(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              getCoreContainer().getCoresLocator().persist(getCoreContainer(), descriptor);\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.debug(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.debug(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      final DocCollection docCollection = zkStateReader.getClusterState()\n          .getCollectionOrNull(descriptor.getCloudDescriptor().getCollectionName());\n      if (docCollection != null && docCollection.getSlicesMap() != null) {\n        final Map<String, Slice> slicesMap = docCollection.getSlicesMap();\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.debug(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":["650d17e953fb1d54e644f9928e3202e68b88eeb1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.debug(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      final DocCollection docCollection = zkStateReader.getClusterState()\n          .getCollectionOrNull(descriptor.getCloudDescriptor().getCollectionName());\n      if (docCollection != null && docCollection.getSlicesMap() != null) {\n        final Map<String, Slice> slicesMap = docCollection.getSlicesMap();\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              getCoreContainer().getCoresLocator().persist(getCoreContainer(), descriptor);\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.debug(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      Map<String, Slice> slicesMap = zkStateReader.getClusterState()\n          .getSlicesMap(descriptor.getCloudDescriptor().getCollectionName());\n      if (slicesMap != null) {\n\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              getCoreContainer().getCoresLocator().persist(getCoreContainer(), descriptor);\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.debug(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      final DocCollection docCollection = zkStateReader.getClusterState()\n          .getCollectionOrNull(descriptor.getCloudDescriptor().getCollectionName());\n      if (docCollection != null && docCollection.getSlicesMap() != null) {\n        final Map<String, Slice> slicesMap = docCollection.getSlicesMap();\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              getCoreContainer().getCoresLocator().persist(getCoreContainer(), descriptor);\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.debug(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      final DocCollection docCollection = zkStateReader.getClusterState()\n          .getCollectionOrNull(descriptor.getCloudDescriptor().getCollectionName());\n      if (docCollection != null && docCollection.getSlicesMap() != null) {\n        final Map<String, Slice> slicesMap = docCollection.getSlicesMap();\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#waitForCoreNodeName(CoreDescriptor).mjava","sourceNew":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.debug(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      final DocCollection docCollection = zkStateReader.getClusterState()\n          .getCollectionOrNull(descriptor.getCloudDescriptor().getCollectionName());\n      if (docCollection != null && docCollection.getSlicesMap() != null) {\n        final Map<String, Slice> slicesMap = docCollection.getSlicesMap();\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              getCoreContainer().getCoresLocator().persist(getCoreContainer(), descriptor);\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForCoreNodeName(CoreDescriptor descriptor) {\n    int retryCount = 320;\n    log.debug(\"look for our core node name\");\n    while (retryCount-- > 0) {\n      final DocCollection docCollection = zkStateReader.getClusterState()\n          .getCollectionOrNull(descriptor.getCloudDescriptor().getCollectionName());\n      if (docCollection != null && docCollection.getSlicesMap() != null) {\n        final Map<String, Slice> slicesMap = docCollection.getSlicesMap();\n        for (Slice slice : slicesMap.values()) {\n          for (Replica replica : slice.getReplicas()) {\n            // TODO: for really large clusters, we could 'index' on this\n\n            String nodeName = replica.getStr(ZkStateReader.NODE_NAME_PROP);\n            String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n            String msgNodeName = getNodeName();\n            String msgCore = descriptor.getName();\n\n            if (msgNodeName.equals(nodeName) && core.equals(msgCore)) {\n              descriptor.getCloudDescriptor()\n                  .setCoreNodeName(replica.getName());\n              return;\n            }\n          }\n        }\n      }\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"20c56b78a24b25c89b1deb0a1331f7ee7af8ac7e":["fbcfc050b9f253136eaa5950b57248b2109eac11"],"962cd4f5e313777f35da8f521265323e84184929":["191128ac5b85671b1671e2c857437694283b6ebf"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["344b0840364d990b29b97467bfcc766ff8325d11","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"344b0840364d990b29b97467bfcc766ff8325d11":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"650d17e953fb1d54e644f9928e3202e68b88eeb1":["20c56b78a24b25c89b1deb0a1331f7ee7af8ac7e"],"191128ac5b85671b1671e2c857437694283b6ebf":["20c56b78a24b25c89b1deb0a1331f7ee7af8ac7e","650d17e953fb1d54e644f9928e3202e68b88eeb1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["fbcfc050b9f253136eaa5950b57248b2109eac11","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8":["849494cf2f3a96af5c8c84995108ddd8456fcd04","840fc95f31a25d020cd825e880018bcfa0bacc71"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["840fc95f31a25d020cd825e880018bcfa0bacc71","fbcfc050b9f253136eaa5950b57248b2109eac11"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["717e5ceb2acae36d422ec75e5a4ce9fac40506e1","344b0840364d990b29b97467bfcc766ff8325d11"],"840fc95f31a25d020cd825e880018bcfa0bacc71":["ceca2bff80f22f2c69257979e86498558a4c2691"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["191128ac5b85671b1671e2c857437694283b6ebf","962cd4f5e313777f35da8f521265323e84184929"],"ceca2bff80f22f2c69257979e86498558a4c2691":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"560c18d71dad43d675158783c3840f8c80d6d39c":["344b0840364d990b29b97467bfcc766ff8325d11","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["560c18d71dad43d675158783c3840f8c80d6d39c"],"fbcfc050b9f253136eaa5950b57248b2109eac11":["840fc95f31a25d020cd825e880018bcfa0bacc71"]},"commit2Childs":{"20c56b78a24b25c89b1deb0a1331f7ee7af8ac7e":["650d17e953fb1d54e644f9928e3202e68b88eeb1","191128ac5b85671b1671e2c857437694283b6ebf"],"962cd4f5e313777f35da8f521265323e84184929":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"344b0840364d990b29b97467bfcc766ff8325d11":["c304e97e7c1d472bc70e801b35ee78583916c6cd","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","560c18d71dad43d675158783c3840f8c80d6d39c"],"650d17e953fb1d54e644f9928e3202e68b88eeb1":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["962cd4f5e313777f35da8f521265323e84184929","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8":[],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","ceca2bff80f22f2c69257979e86498558a4c2691"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"840fc95f31a25d020cd825e880018bcfa0bacc71":["13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","fbcfc050b9f253136eaa5950b57248b2109eac11"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["717e5ceb2acae36d422ec75e5a4ce9fac40506e1","344b0840364d990b29b97467bfcc766ff8325d11","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"ceca2bff80f22f2c69257979e86498558a4c2691":["840fc95f31a25d020cd825e880018bcfa0bacc71"],"560c18d71dad43d675158783c3840f8c80d6d39c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fbcfc050b9f253136eaa5950b57248b2109eac11":["20c56b78a24b25c89b1deb0a1331f7ee7af8ac7e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}