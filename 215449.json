{"path":"solr/src/java/org/apache/solr/handler/component/PivotFacetComponent#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","commits":[{"id":"601c6168c1d70f05f7a6a2d8c7ad4ceb218f3541","date":1284416022,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/PivotFacetComponent#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\r\n   * Recursive function to do all the pivots\r\n   */\r\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\r\n  {\r\n    SolrIndexSearcher searcher = rb.req.getSearcher();\r\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\r\n    FieldType ftype = null;\r\n\r\n //   SimpleFacets sf = getFacetImplementation(rb.req, docs, rb.req.getParams());\r\n    String nextField = fnames.poll();\r\n\r\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\r\n    for (Map.Entry<String, Integer> kv : superFacets) {\r\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\r\n      if (kv.getValue() > minMatch ) {  \r\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\r\n        pivot.add( \"field\", field );\r\n        pivot.add( \"value\", kv.getKey() );\r\n        pivot.add( \"count\", kv.getValue() );\r\n        \r\n        if( subField == null ) {\r\n          values.add( pivot );\r\n        }\r\n        else {\r\n          String s = kv.getKey();\r\n          if( ftype == null ) {\r\n            ftype = searcher.getSchema().getField(field).getType();\r\n          }\r\n          \r\n          Query query = new TermQuery(new Term(field, ftype.toInternal(s)));\r\n          DocSet subset = searcher.getDocSet(query, docs);\r\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\r\n          \r\n          NamedList<Integer> nl = sf.getTermCounts(subField);\r\n          if (nl.size() > minMatch ) {\r\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\r\n            values.add( pivot ); // only add response if there are some counts\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // put the field back on the list\r\n    fnames.push( nextField );\r\n    return values;\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e904610f0db3fdf2ea10c5701f5f4f86c1e9ade","date":1286051536,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/PivotFacetComponent#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetComponent#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    FieldType ftype = null;\n\n //   SimpleFacets sf = getFacetImplementation(rb.req, docs, rb.req.getParams());\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {  \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", kv.getKey() );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          String s = kv.getKey();\n          if( ftype == null ) {\n            ftype = searcher.getSchema().getField(field).getType();\n          }\n          \n          Query query = new TermQuery(new Term(field, ftype.toInternal(s)));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\r\n   * Recursive function to do all the pivots\r\n   */\r\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\r\n  {\r\n    SolrIndexSearcher searcher = rb.req.getSearcher();\r\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\r\n    FieldType ftype = null;\r\n\r\n //   SimpleFacets sf = getFacetImplementation(rb.req, docs, rb.req.getParams());\r\n    String nextField = fnames.poll();\r\n\r\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\r\n    for (Map.Entry<String, Integer> kv : superFacets) {\r\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\r\n      if (kv.getValue() > minMatch ) {  \r\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\r\n        pivot.add( \"field\", field );\r\n        pivot.add( \"value\", kv.getKey() );\r\n        pivot.add( \"count\", kv.getValue() );\r\n        \r\n        if( subField == null ) {\r\n          values.add( pivot );\r\n        }\r\n        else {\r\n          String s = kv.getKey();\r\n          if( ftype == null ) {\r\n            ftype = searcher.getSchema().getField(field).getType();\r\n          }\r\n          \r\n          Query query = new TermQuery(new Term(field, ftype.toInternal(s)));\r\n          DocSet subset = searcher.getDocSet(query, docs);\r\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\r\n          \r\n          NamedList<Integer> nl = sf.getTermCounts(subField);\r\n          if (nl.size() > minMatch ) {\r\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\r\n            values.add( pivot ); // only add response if there are some counts\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // put the field back on the list\r\n    fnames.push( nextField );\r\n    return values;\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"251ec5b8ebb59d2b5458b97d6b8d7141b7ed8364","date":1287507822,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/PivotFacetComponent#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetComponent#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    FieldType ftype = searcher.getSchema().getField(field).getType();\n    \n    // Required to translate back to an object\n    Field f = new Field( field, \"X\", Store.YES, Index.ANALYZED );\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {\n        String internal = ftype.toInternal( kv.getKey() );\n        f.setValue( internal );\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject( f ) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, internal));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    FieldType ftype = null;\n\n //   SimpleFacets sf = getFacetImplementation(rb.req, docs, rb.req.getParams());\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {  \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", kv.getKey() );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          String s = kv.getKey();\n          if( ftype == null ) {\n            ftype = searcher.getSchema().getField(field).getType();\n          }\n          \n          Query query = new TermQuery(new Term(field, ftype.toInternal(s)));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03a198be002bb6786dce54cf550c3ca7bb7b88a9","date":1287519003,"type":4,"author":"Ryan McKinley","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetComponent#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    FieldType ftype = searcher.getSchema().getField(field).getType();\n    \n    // Required to translate back to an object\n    Field f = new Field( field, \"X\", Store.YES, Index.ANALYZED );\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {\n        String internal = ftype.toInternal( kv.getKey() );\n        f.setValue( internal );\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject( f ) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, internal));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetComponent#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    FieldType ftype = null;\n\n //   SimpleFacets sf = getFacetImplementation(rb.req, docs, rb.req.getParams());\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() > minMatch ) {  \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", kv.getKey() );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          String s = kv.getKey();\n          if( ftype == null ) {\n            ftype = searcher.getSchema().getField(field).getType();\n          }\n          \n          Query query = new TermQuery(new Term(field, ftype.toInternal(s)));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() > minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3e904610f0db3fdf2ea10c5701f5f4f86c1e9ade":["601c6168c1d70f05f7a6a2d8c7ad4ceb218f3541"],"601c6168c1d70f05f7a6a2d8c7ad4ceb218f3541":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"251ec5b8ebb59d2b5458b97d6b8d7141b7ed8364":["3e904610f0db3fdf2ea10c5701f5f4f86c1e9ade"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["3e904610f0db3fdf2ea10c5701f5f4f86c1e9ade","03a198be002bb6786dce54cf550c3ca7bb7b88a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["03a198be002bb6786dce54cf550c3ca7bb7b88a9"],"03a198be002bb6786dce54cf550c3ca7bb7b88a9":["251ec5b8ebb59d2b5458b97d6b8d7141b7ed8364"]},"commit2Childs":{"3e904610f0db3fdf2ea10c5701f5f4f86c1e9ade":["251ec5b8ebb59d2b5458b97d6b8d7141b7ed8364","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"601c6168c1d70f05f7a6a2d8c7ad4ceb218f3541":["3e904610f0db3fdf2ea10c5701f5f4f86c1e9ade"],"251ec5b8ebb59d2b5458b97d6b8d7141b7ed8364":["03a198be002bb6786dce54cf550c3ca7bb7b88a9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["601c6168c1d70f05f7a6a2d8c7ad4ceb218f3541"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":[],"03a198be002bb6786dce54cf550c3ca7bb7b88a9":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}