{"path":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","commits":[{"id":"9cf81bc8c6e4078e236f0e38b3a2d0271854f207","date":1364832963,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Persist the managed schema to ZooKeeper and rename the non-managed schema \n   * by appending {@link #UPGRADED_SCHEMA_EXTENSION}.\n   *\n   * Failure to rename the non-managed schema will be logged as a warning,\n   * and no exception will be thrown.\n   */\n  private void zkUgradeToManagedSchema() {\n    ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)config.getResourceLoader();\n    ZkCmdExecutor zkCmdExecutor = new ZkCmdExecutor(30);\n    ZkController zkController = zkLoader.getZkController();\n    final String managedSchemaPath = zkLoader.getCollectionZkPath() + \"/\" + managedSchemaResourceName;\n    try {\n      // Create the managed schema znode\n      zkCmdExecutor.ensureExists(managedSchemaPath, zkController.getZkClient());\n      // Persist the managed schema\n      StringWriter writer = new StringWriter();\n      schema.persist(writer);\n      zkController.getZkClient().setData(managedSchemaPath, writer.toString().getBytes(\"UTF-8\"), true);\n      log.info(\"Upgraded to managed schema at \" + managedSchemaPath + \"\");\n    } catch (Exception e) {\n      if (e instanceof InterruptedException) {\n        Thread.currentThread().interrupt(); // Restore the interrupted status\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } else {\n        final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n        log.error(msg, e);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n      }\n    }\n\n    // After successfully persisting the managed schema, rename the non-managed\n    // schema znode by appending UPGRADED_SCHEMA_EXTENSION to its name.\n\n    if (resourceName.equals(managedSchemaResourceName)) {\n      log.info(\"On upgrading to managed schema, did not rename non-managed schema \"\n          + resourceName + \" because it's the same as the managed schema's name.\");\n    } else {\n      // Rename the non-managed schema znode in ZooKeeper\n      final String nonManagedSchemaPath = zkLoader.getCollectionZkPath() + \"/\" + resourceName;\n      try {\n        if (zkController.pathExists(nonManagedSchemaPath)) {\n          // First, copy the non-managed schema znode content to the upgraded schema znode\n          byte[] bytes = zkController.getZkClient().getData(nonManagedSchemaPath, null, null, true);\n          final String upgradedSchemaPath = nonManagedSchemaPath + UPGRADED_SCHEMA_EXTENSION;\n          zkCmdExecutor.ensureExists(upgradedSchemaPath, zkController.getZkClient());\n          zkController.getZkClient().setData(upgradedSchemaPath, bytes, true);\n          // Then delete the non-managed schema znode\n          zkController.getZkClient().delete(nonManagedSchemaPath, -1, true);\n\n          // Set the resource name to the managed schema so that the CoreAdminHandler returns a findable filename \n          schema.setResourceName(managedSchemaResourceName);\n\n          log.info(\"After upgrading to managed schema in ZooKeeper, renamed the non-managed schema \"\n              + nonManagedSchemaPath + \" to \" + upgradedSchemaPath);\n        } else {\n          log.info(\"After upgrading to managed schema in ZooKeeper, the non-managed schema \"\n              + nonManagedSchemaPath + \" no longer exists.\");\n        }\n      } catch (Exception e) {\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt(); // Restore the interrupted status\n          log.warn(\"\", e); // Log as warning and suppress the exception \n        } else {\n          final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n          log.warn(msg, e); // Log as warning and suppress the exception\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","sourceNew":"  /**\n   * Persist the managed schema to ZooKeeper and rename the non-managed schema \n   * by appending {@link #UPGRADED_SCHEMA_EXTENSION}.\n   *\n   * Failure to rename the non-managed schema will be logged as a warning,\n   * and no exception will be thrown.\n   */\n  private void zkUgradeToManagedSchema() {\n    schema.persistManagedSchemaToZooKeeper(true); // Only create, don't update it if it already exists\n\n    // After successfully persisting the managed schema, rename the non-managed\n    // schema znode by appending UPGRADED_SCHEMA_EXTENSION to its name.\n\n    if (resourceName.equals(managedSchemaResourceName)) {\n      log.info(\"On upgrading to managed schema, did not rename non-managed schema \"\n          + resourceName + \" because it's the same as the managed schema's name.\");\n    } else {\n      // Rename the non-managed schema znode in ZooKeeper\n      ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final String nonManagedSchemaPath = zkLoader.getCollectionZkPath() + \"/\" + resourceName;\n      try {\n        ZkController zkController = zkLoader.getZkController();\n        ZkCmdExecutor zkCmdExecutor = new ZkCmdExecutor(zkController.getClientTimeout());\n        if (zkController.pathExists(nonManagedSchemaPath)) {\n          // First, copy the non-managed schema znode content to the upgraded schema znode\n          byte[] bytes = zkController.getZkClient().getData(nonManagedSchemaPath, null, null, true);\n          final String upgradedSchemaPath = nonManagedSchemaPath + UPGRADED_SCHEMA_EXTENSION;\n          zkCmdExecutor.ensureExists(upgradedSchemaPath, zkController.getZkClient());\n          zkController.getZkClient().setData(upgradedSchemaPath, bytes, true);\n          // Then delete the non-managed schema znode\n          zkController.getZkClient().delete(nonManagedSchemaPath, -1, true);\n\n          // Set the resource name to the managed schema so that the CoreAdminHandler returns a findable filename \n          schema.setResourceName(managedSchemaResourceName);\n\n          log.info(\"After upgrading to managed schema in ZooKeeper, renamed the non-managed schema \"\n                  + nonManagedSchemaPath + \" to \" + upgradedSchemaPath);\n        } else {\n          log.info(\"After upgrading to managed schema in ZooKeeper, the non-managed schema \"\n                  + nonManagedSchemaPath + \" no longer exists.\");\n        }\n      } catch (Exception e) {\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt(); // Restore the interrupted status\n        }\n        final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n        log.warn(msg, e); // Log as warning and suppress the exception\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Persist the managed schema to ZooKeeper and rename the non-managed schema \n   * by appending {@link #UPGRADED_SCHEMA_EXTENSION}.\n   *\n   * Failure to rename the non-managed schema will be logged as a warning,\n   * and no exception will be thrown.\n   */\n  private void zkUgradeToManagedSchema() {\n    ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)config.getResourceLoader();\n    ZkCmdExecutor zkCmdExecutor = new ZkCmdExecutor(30);\n    ZkController zkController = zkLoader.getZkController();\n    final String managedSchemaPath = zkLoader.getCollectionZkPath() + \"/\" + managedSchemaResourceName;\n    try {\n      // Create the managed schema znode\n      zkCmdExecutor.ensureExists(managedSchemaPath, zkController.getZkClient());\n      // Persist the managed schema\n      StringWriter writer = new StringWriter();\n      schema.persist(writer);\n      zkController.getZkClient().setData(managedSchemaPath, writer.toString().getBytes(\"UTF-8\"), true);\n      log.info(\"Upgraded to managed schema at \" + managedSchemaPath + \"\");\n    } catch (Exception e) {\n      if (e instanceof InterruptedException) {\n        Thread.currentThread().interrupt(); // Restore the interrupted status\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } else {\n        final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n        log.error(msg, e);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n      }\n    }\n\n    // After successfully persisting the managed schema, rename the non-managed\n    // schema znode by appending UPGRADED_SCHEMA_EXTENSION to its name.\n\n    if (resourceName.equals(managedSchemaResourceName)) {\n      log.info(\"On upgrading to managed schema, did not rename non-managed schema \"\n          + resourceName + \" because it's the same as the managed schema's name.\");\n    } else {\n      // Rename the non-managed schema znode in ZooKeeper\n      final String nonManagedSchemaPath = zkLoader.getCollectionZkPath() + \"/\" + resourceName;\n      try {\n        if (zkController.pathExists(nonManagedSchemaPath)) {\n          // First, copy the non-managed schema znode content to the upgraded schema znode\n          byte[] bytes = zkController.getZkClient().getData(nonManagedSchemaPath, null, null, true);\n          final String upgradedSchemaPath = nonManagedSchemaPath + UPGRADED_SCHEMA_EXTENSION;\n          zkCmdExecutor.ensureExists(upgradedSchemaPath, zkController.getZkClient());\n          zkController.getZkClient().setData(upgradedSchemaPath, bytes, true);\n          // Then delete the non-managed schema znode\n          zkController.getZkClient().delete(nonManagedSchemaPath, -1, true);\n\n          // Set the resource name to the managed schema so that the CoreAdminHandler returns a findable filename \n          schema.setResourceName(managedSchemaResourceName);\n\n          log.info(\"After upgrading to managed schema in ZooKeeper, renamed the non-managed schema \"\n              + nonManagedSchemaPath + \" to \" + upgradedSchemaPath);\n        } else {\n          log.info(\"After upgrading to managed schema in ZooKeeper, the non-managed schema \"\n              + nonManagedSchemaPath + \" no longer exists.\");\n        }\n      } catch (Exception e) {\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt(); // Restore the interrupted status\n          log.warn(\"\", e); // Log as warning and suppress the exception \n        } else {\n          final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n          log.warn(msg, e); // Log as warning and suppress the exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17778d9c1f3a8a67383edebf24754bf30a5120f8","date":1415342366,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","sourceNew":"  /**\n   * Persist the managed schema to ZooKeeper and rename the non-managed schema \n   * by appending {@link #UPGRADED_SCHEMA_EXTENSION}.\n   *\n   * Failure to rename the non-managed schema will be logged as a warning,\n   * and no exception will be thrown.\n   */\n  private void zkUgradeToManagedSchema() {\n    schema.persistManagedSchemaToZooKeeper(true); // Only create, don't update it if it already exists\n\n    // After successfully persisting the managed schema, rename the non-managed\n    // schema znode by appending UPGRADED_SCHEMA_EXTENSION to its name.\n\n    if (resourceName.equals(managedSchemaResourceName)) {\n      log.info(\"On upgrading to managed schema, did not rename non-managed schema \"\n          + resourceName + \" because it's the same as the managed schema's name.\");\n    } else {\n      // Rename the non-managed schema znode in ZooKeeper\n      ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final String nonManagedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + resourceName;\n      try {\n        ZkController zkController = zkLoader.getZkController();\n        ZkCmdExecutor zkCmdExecutor = new ZkCmdExecutor(zkController.getClientTimeout());\n        if (zkController.pathExists(nonManagedSchemaPath)) {\n          // First, copy the non-managed schema znode content to the upgraded schema znode\n          byte[] bytes = zkController.getZkClient().getData(nonManagedSchemaPath, null, null, true);\n          final String upgradedSchemaPath = nonManagedSchemaPath + UPGRADED_SCHEMA_EXTENSION;\n          zkCmdExecutor.ensureExists(upgradedSchemaPath, zkController.getZkClient());\n          zkController.getZkClient().setData(upgradedSchemaPath, bytes, true);\n          // Then delete the non-managed schema znode\n          zkController.getZkClient().delete(nonManagedSchemaPath, -1, true);\n\n          // Set the resource name to the managed schema so that the CoreAdminHandler returns a findable filename \n          schema.setResourceName(managedSchemaResourceName);\n\n          log.info(\"After upgrading to managed schema in ZooKeeper, renamed the non-managed schema \"\n                  + nonManagedSchemaPath + \" to \" + upgradedSchemaPath);\n        } else {\n          log.info(\"After upgrading to managed schema in ZooKeeper, the non-managed schema \"\n                  + nonManagedSchemaPath + \" no longer exists.\");\n        }\n      } catch (Exception e) {\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt(); // Restore the interrupted status\n        }\n        final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n        log.warn(msg, e); // Log as warning and suppress the exception\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Persist the managed schema to ZooKeeper and rename the non-managed schema \n   * by appending {@link #UPGRADED_SCHEMA_EXTENSION}.\n   *\n   * Failure to rename the non-managed schema will be logged as a warning,\n   * and no exception will be thrown.\n   */\n  private void zkUgradeToManagedSchema() {\n    schema.persistManagedSchemaToZooKeeper(true); // Only create, don't update it if it already exists\n\n    // After successfully persisting the managed schema, rename the non-managed\n    // schema znode by appending UPGRADED_SCHEMA_EXTENSION to its name.\n\n    if (resourceName.equals(managedSchemaResourceName)) {\n      log.info(\"On upgrading to managed schema, did not rename non-managed schema \"\n          + resourceName + \" because it's the same as the managed schema's name.\");\n    } else {\n      // Rename the non-managed schema znode in ZooKeeper\n      ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final String nonManagedSchemaPath = zkLoader.getCollectionZkPath() + \"/\" + resourceName;\n      try {\n        ZkController zkController = zkLoader.getZkController();\n        ZkCmdExecutor zkCmdExecutor = new ZkCmdExecutor(zkController.getClientTimeout());\n        if (zkController.pathExists(nonManagedSchemaPath)) {\n          // First, copy the non-managed schema znode content to the upgraded schema znode\n          byte[] bytes = zkController.getZkClient().getData(nonManagedSchemaPath, null, null, true);\n          final String upgradedSchemaPath = nonManagedSchemaPath + UPGRADED_SCHEMA_EXTENSION;\n          zkCmdExecutor.ensureExists(upgradedSchemaPath, zkController.getZkClient());\n          zkController.getZkClient().setData(upgradedSchemaPath, bytes, true);\n          // Then delete the non-managed schema znode\n          zkController.getZkClient().delete(nonManagedSchemaPath, -1, true);\n\n          // Set the resource name to the managed schema so that the CoreAdminHandler returns a findable filename \n          schema.setResourceName(managedSchemaResourceName);\n\n          log.info(\"After upgrading to managed schema in ZooKeeper, renamed the non-managed schema \"\n                  + nonManagedSchemaPath + \" to \" + upgradedSchemaPath);\n        } else {\n          log.info(\"After upgrading to managed schema in ZooKeeper, the non-managed schema \"\n                  + nonManagedSchemaPath + \" no longer exists.\");\n        }\n      } catch (Exception e) {\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt(); // Restore the interrupted status\n        }\n        final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n        log.warn(msg, e); // Log as warning and suppress the exception\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dad6a48950aafc9c2f5dc54740f8c6ab81304203","date":1552999379,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","sourceNew":"  /**\n   * Persist the managed schema to ZooKeeper and rename the non-managed schema \n   * by appending {@link #UPGRADED_SCHEMA_EXTENSION}.\n   *\n   * Failure to rename the non-managed schema will be logged as a warning,\n   * and no exception will be thrown.\n   */\n  private void zkUgradeToManagedSchema() {\n    schema.persistManagedSchemaToZooKeeper(true); // Only create, don't update it if it already exists\n\n    // After successfully persisting the managed schema, rename the non-managed\n    // schema znode by appending UPGRADED_SCHEMA_EXTENSION to its name.\n\n    if (resourceName.equals(managedSchemaResourceName)) {\n      log.info(\"On upgrading to managed schema, did not rename non-managed schema \"\n          + resourceName + \" because it's the same as the managed schema's name.\");\n    } else {\n      // Rename the non-managed schema znode in ZooKeeper\n      ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final String nonManagedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + resourceName;\n      try {\n        ZkController zkController = zkLoader.getZkController();\n        ZkCmdExecutor zkCmdExecutor = new ZkCmdExecutor(zkController.getClientTimeout());\n        if (zkController.pathExists(nonManagedSchemaPath)) {\n          // First, copy the non-managed schema znode content to the upgraded schema znode\n          byte[] bytes = zkController.getZkClient().getData(nonManagedSchemaPath, null, null, true);\n          final String upgradedSchemaPath = nonManagedSchemaPath + UPGRADED_SCHEMA_EXTENSION;\n          zkCmdExecutor.ensureExists(upgradedSchemaPath, zkController.getZkClient());\n          zkController.getZkClient().setData(upgradedSchemaPath, bytes, true);\n          // Then delete the non-managed schema znode\n          if (zkController.getZkClient().exists(nonManagedSchemaPath, true)) {\n            try {\n              zkController.getZkClient().delete(nonManagedSchemaPath, -1, true);\n            } catch (KeeperException.NoNodeException ex) {\n              // ignore - someone beat us to it\n            }\n          }\n\n          // Set the resource name to the managed schema so that the CoreAdminHandler returns a findable filename \n          schema.setResourceName(managedSchemaResourceName);\n\n          log.info(\"After upgrading to managed schema in ZooKeeper, renamed the non-managed schema \"\n                  + nonManagedSchemaPath + \" to \" + upgradedSchemaPath);\n        } else {\n          log.info(\"After upgrading to managed schema in ZooKeeper, the non-managed schema \"\n                  + nonManagedSchemaPath + \" no longer exists.\");\n        }\n      } catch (Exception e) {\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt(); // Restore the interrupted status\n        }\n        final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n        log.warn(msg, e); // Log as warning and suppress the exception\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Persist the managed schema to ZooKeeper and rename the non-managed schema \n   * by appending {@link #UPGRADED_SCHEMA_EXTENSION}.\n   *\n   * Failure to rename the non-managed schema will be logged as a warning,\n   * and no exception will be thrown.\n   */\n  private void zkUgradeToManagedSchema() {\n    schema.persistManagedSchemaToZooKeeper(true); // Only create, don't update it if it already exists\n\n    // After successfully persisting the managed schema, rename the non-managed\n    // schema znode by appending UPGRADED_SCHEMA_EXTENSION to its name.\n\n    if (resourceName.equals(managedSchemaResourceName)) {\n      log.info(\"On upgrading to managed schema, did not rename non-managed schema \"\n          + resourceName + \" because it's the same as the managed schema's name.\");\n    } else {\n      // Rename the non-managed schema znode in ZooKeeper\n      ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final String nonManagedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + resourceName;\n      try {\n        ZkController zkController = zkLoader.getZkController();\n        ZkCmdExecutor zkCmdExecutor = new ZkCmdExecutor(zkController.getClientTimeout());\n        if (zkController.pathExists(nonManagedSchemaPath)) {\n          // First, copy the non-managed schema znode content to the upgraded schema znode\n          byte[] bytes = zkController.getZkClient().getData(nonManagedSchemaPath, null, null, true);\n          final String upgradedSchemaPath = nonManagedSchemaPath + UPGRADED_SCHEMA_EXTENSION;\n          zkCmdExecutor.ensureExists(upgradedSchemaPath, zkController.getZkClient());\n          zkController.getZkClient().setData(upgradedSchemaPath, bytes, true);\n          // Then delete the non-managed schema znode\n          zkController.getZkClient().delete(nonManagedSchemaPath, -1, true);\n\n          // Set the resource name to the managed schema so that the CoreAdminHandler returns a findable filename \n          schema.setResourceName(managedSchemaResourceName);\n\n          log.info(\"After upgrading to managed schema in ZooKeeper, renamed the non-managed schema \"\n                  + nonManagedSchemaPath + \" to \" + upgradedSchemaPath);\n        } else {\n          log.info(\"After upgrading to managed schema in ZooKeeper, the non-managed schema \"\n                  + nonManagedSchemaPath + \" no longer exists.\");\n        }\n      } catch (Exception e) {\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt(); // Restore the interrupted status\n        }\n        final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n        log.warn(msg, e); // Log as warning and suppress the exception\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b2329af9080ec86a454c9439598b88e169fc28a","date":1579536707,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","sourceNew":"  /**\n   * Persist the managed schema to ZooKeeper and rename the non-managed schema \n   * by appending {@link #UPGRADED_SCHEMA_EXTENSION}.\n   *\n   * Failure to rename the non-managed schema will be logged as a warning,\n   * and no exception will be thrown.\n   */\n  private void zkUgradeToManagedSchema() {\n    schema.persistManagedSchemaToZooKeeper(true); // Only create, don't update it if it already exists\n\n    // After successfully persisting the managed schema, rename the non-managed\n    // schema znode by appending UPGRADED_SCHEMA_EXTENSION to its name.\n\n    if (resourceName.equals(managedSchemaResourceName)) {\n      log.info(\"On upgrading to managed schema, did not rename non-managed schema \"\n          + resourceName + \" because it's the same as the managed schema's name.\");\n    } else {\n      // Rename the non-managed schema znode in ZooKeeper\n      ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      ZkController zkController = zkLoader.getZkController();\n      SolrZkClient zkClient = zkController.getZkClient();\n      final String nonManagedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + resourceName;\n      final String lockPath = nonManagedSchemaPath + \".lock\";\n      boolean locked = false;\n      try {\n        try {\n          zkClient.makePath(lockPath, null, CreateMode.EPHEMERAL, null, true, true);\n          locked = true;\n        } catch (Exception e) {\n          // some other node already started the upgrade, or an error occurred - bail out\n          return;\n        }\n        ZkCmdExecutor zkCmdExecutor = new ZkCmdExecutor(zkController.getClientTimeout());\n        if (zkController.pathExists(nonManagedSchemaPath)) {\n          // First, copy the non-managed schema znode content to the upgraded schema znode\n          byte[] bytes = zkController.getZkClient().getData(nonManagedSchemaPath, null, null, true);\n          final String upgradedSchemaPath = nonManagedSchemaPath + UPGRADED_SCHEMA_EXTENSION;\n          zkCmdExecutor.ensureExists(upgradedSchemaPath, zkController.getZkClient());\n          zkController.getZkClient().setData(upgradedSchemaPath, bytes, true);\n          // Then delete the non-managed schema znode\n          if (zkController.getZkClient().exists(nonManagedSchemaPath, true)) {\n            try {\n              zkController.getZkClient().delete(nonManagedSchemaPath, -1, true);\n            } catch (KeeperException.NoNodeException ex) {\n              // ignore - someone beat us to it\n            }\n          }\n\n          // Set the resource name to the managed schema so that the CoreAdminHandler returns a findable filename \n          schema.setResourceName(managedSchemaResourceName);\n\n          log.info(\"After upgrading to managed schema in ZooKeeper, renamed the non-managed schema \"\n                  + nonManagedSchemaPath + \" to \" + upgradedSchemaPath);\n        } else {\n          log.info(\"After upgrading to managed schema in ZooKeeper, the non-managed schema \"\n                  + nonManagedSchemaPath + \" no longer exists.\");\n        }\n      } catch (Exception e) {\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt(); // Restore the interrupted status\n        }\n        final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n        log.warn(msg, e); // Log as warning and suppress the exception\n      } finally {\n        if (locked) {\n          // unlock\n          try {\n            zkClient.delete(lockPath, -1, true);\n          } catch (KeeperException.NoNodeException nne) {\n            // ignore - someone else deleted it\n          } catch (Exception e) {\n            log.warn(\"Unable to delete schema upgrade lock file \" + lockPath, e);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Persist the managed schema to ZooKeeper and rename the non-managed schema \n   * by appending {@link #UPGRADED_SCHEMA_EXTENSION}.\n   *\n   * Failure to rename the non-managed schema will be logged as a warning,\n   * and no exception will be thrown.\n   */\n  private void zkUgradeToManagedSchema() {\n    schema.persistManagedSchemaToZooKeeper(true); // Only create, don't update it if it already exists\n\n    // After successfully persisting the managed schema, rename the non-managed\n    // schema znode by appending UPGRADED_SCHEMA_EXTENSION to its name.\n\n    if (resourceName.equals(managedSchemaResourceName)) {\n      log.info(\"On upgrading to managed schema, did not rename non-managed schema \"\n          + resourceName + \" because it's the same as the managed schema's name.\");\n    } else {\n      // Rename the non-managed schema znode in ZooKeeper\n      ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      final String nonManagedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + resourceName;\n      try {\n        ZkController zkController = zkLoader.getZkController();\n        ZkCmdExecutor zkCmdExecutor = new ZkCmdExecutor(zkController.getClientTimeout());\n        if (zkController.pathExists(nonManagedSchemaPath)) {\n          // First, copy the non-managed schema znode content to the upgraded schema znode\n          byte[] bytes = zkController.getZkClient().getData(nonManagedSchemaPath, null, null, true);\n          final String upgradedSchemaPath = nonManagedSchemaPath + UPGRADED_SCHEMA_EXTENSION;\n          zkCmdExecutor.ensureExists(upgradedSchemaPath, zkController.getZkClient());\n          zkController.getZkClient().setData(upgradedSchemaPath, bytes, true);\n          // Then delete the non-managed schema znode\n          if (zkController.getZkClient().exists(nonManagedSchemaPath, true)) {\n            try {\n              zkController.getZkClient().delete(nonManagedSchemaPath, -1, true);\n            } catch (KeeperException.NoNodeException ex) {\n              // ignore - someone beat us to it\n            }\n          }\n\n          // Set the resource name to the managed schema so that the CoreAdminHandler returns a findable filename \n          schema.setResourceName(managedSchemaResourceName);\n\n          log.info(\"After upgrading to managed schema in ZooKeeper, renamed the non-managed schema \"\n                  + nonManagedSchemaPath + \" to \" + upgradedSchemaPath);\n        } else {\n          log.info(\"After upgrading to managed schema in ZooKeeper, the non-managed schema \"\n                  + nonManagedSchemaPath + \" no longer exists.\");\n        }\n      } catch (Exception e) {\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt(); // Restore the interrupted status\n        }\n        final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n        log.warn(msg, e); // Log as warning and suppress the exception\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3873cff5fd3b100cbfe1bfb542cebfe6d1dcfb29","date":1585171178,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","sourceNew":"  /**\n   * Persist the managed schema to ZooKeeper and rename the non-managed schema \n   * by appending {@link #UPGRADED_SCHEMA_EXTENSION}.\n   *\n   * Failure to rename the non-managed schema will be logged as a warning,\n   * and no exception will be thrown.\n   */\n  private void zkUgradeToManagedSchema() {\n    if (resourceName.equals(managedSchemaResourceName)) {\n      log.info(\"On upgrading to managed schema, did not rename non-managed schema \"\n          + resourceName + \" because it's the same as the managed schema's name.\");\n      return;\n    }\n    final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n    final ZkController zkController = zkLoader.getZkController();\n    final SolrZkClient zkClient = zkController.getZkClient();\n    final String lockPath = zkLoader.getConfigSetZkPath() + \"/schemaUpgrade.lock\";\n    boolean locked = false;\n    try {\n      try {\n        zkClient.makePath(lockPath, null, CreateMode.EPHEMERAL, null, true, true);\n        locked = true;\n      } catch (Exception e) {\n        // some other node already started the upgrade, or an error occurred - bail out\n        return;\n      }\n      schema.persistManagedSchemaToZooKeeper(true); // Only create, don't update it if it already exists\n\n      // After successfully persisting the managed schema, rename the non-managed\n      // schema znode by appending UPGRADED_SCHEMA_EXTENSION to its name.\n\n      // Rename the non-managed schema znode in ZooKeeper\n      final String nonManagedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + resourceName;\n      try {\n        ZkCmdExecutor zkCmdExecutor = new ZkCmdExecutor(zkController.getClientTimeout());\n        if (zkController.pathExists(nonManagedSchemaPath)) {\n          // First, copy the non-managed schema znode content to the upgraded schema znode\n          byte[] bytes = zkController.getZkClient().getData(nonManagedSchemaPath, null, null, true);\n          final String upgradedSchemaPath = nonManagedSchemaPath + UPGRADED_SCHEMA_EXTENSION;\n          zkCmdExecutor.ensureExists(upgradedSchemaPath, zkController.getZkClient());\n          zkController.getZkClient().setData(upgradedSchemaPath, bytes, true);\n          // Then delete the non-managed schema znode\n          if (zkController.getZkClient().exists(nonManagedSchemaPath, true)) {\n            try {\n              zkController.getZkClient().delete(nonManagedSchemaPath, -1, true);\n            } catch (KeeperException.NoNodeException ex) {\n              // ignore - someone beat us to it\n            }\n          }\n\n          // Set the resource name to the managed schema so that the CoreAdminHandler returns a findable filename\n          schema.setResourceName(managedSchemaResourceName);\n\n          log.info(\"After upgrading to managed schema in ZooKeeper, renamed the non-managed schema \"\n              + nonManagedSchemaPath + \" to \" + upgradedSchemaPath);\n        } else {\n          log.info(\"After upgrading to managed schema in ZooKeeper, the non-managed schema \"\n              + nonManagedSchemaPath + \" no longer exists.\");\n        }\n      } catch (Exception e) {\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt(); // Restore the interrupted status\n        }\n        final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n        log.warn(msg, e); // Log as warning and suppress the exception\n      }\n    } finally {\n      if (locked) {\n        // unlock\n        try {\n          zkClient.delete(lockPath, -1, true);\n        } catch (KeeperException.NoNodeException nne) {\n          // ignore - someone else deleted it\n        } catch (Exception e) {\n          log.warn(\"Unable to delete schema upgrade lock file \" + lockPath, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Persist the managed schema to ZooKeeper and rename the non-managed schema \n   * by appending {@link #UPGRADED_SCHEMA_EXTENSION}.\n   *\n   * Failure to rename the non-managed schema will be logged as a warning,\n   * and no exception will be thrown.\n   */\n  private void zkUgradeToManagedSchema() {\n    schema.persistManagedSchemaToZooKeeper(true); // Only create, don't update it if it already exists\n\n    // After successfully persisting the managed schema, rename the non-managed\n    // schema znode by appending UPGRADED_SCHEMA_EXTENSION to its name.\n\n    if (resourceName.equals(managedSchemaResourceName)) {\n      log.info(\"On upgrading to managed schema, did not rename non-managed schema \"\n          + resourceName + \" because it's the same as the managed schema's name.\");\n    } else {\n      // Rename the non-managed schema znode in ZooKeeper\n      ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n      ZkController zkController = zkLoader.getZkController();\n      SolrZkClient zkClient = zkController.getZkClient();\n      final String nonManagedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + resourceName;\n      final String lockPath = nonManagedSchemaPath + \".lock\";\n      boolean locked = false;\n      try {\n        try {\n          zkClient.makePath(lockPath, null, CreateMode.EPHEMERAL, null, true, true);\n          locked = true;\n        } catch (Exception e) {\n          // some other node already started the upgrade, or an error occurred - bail out\n          return;\n        }\n        ZkCmdExecutor zkCmdExecutor = new ZkCmdExecutor(zkController.getClientTimeout());\n        if (zkController.pathExists(nonManagedSchemaPath)) {\n          // First, copy the non-managed schema znode content to the upgraded schema znode\n          byte[] bytes = zkController.getZkClient().getData(nonManagedSchemaPath, null, null, true);\n          final String upgradedSchemaPath = nonManagedSchemaPath + UPGRADED_SCHEMA_EXTENSION;\n          zkCmdExecutor.ensureExists(upgradedSchemaPath, zkController.getZkClient());\n          zkController.getZkClient().setData(upgradedSchemaPath, bytes, true);\n          // Then delete the non-managed schema znode\n          if (zkController.getZkClient().exists(nonManagedSchemaPath, true)) {\n            try {\n              zkController.getZkClient().delete(nonManagedSchemaPath, -1, true);\n            } catch (KeeperException.NoNodeException ex) {\n              // ignore - someone beat us to it\n            }\n          }\n\n          // Set the resource name to the managed schema so that the CoreAdminHandler returns a findable filename \n          schema.setResourceName(managedSchemaResourceName);\n\n          log.info(\"After upgrading to managed schema in ZooKeeper, renamed the non-managed schema \"\n                  + nonManagedSchemaPath + \" to \" + upgradedSchemaPath);\n        } else {\n          log.info(\"After upgrading to managed schema in ZooKeeper, the non-managed schema \"\n                  + nonManagedSchemaPath + \" no longer exists.\");\n        }\n      } catch (Exception e) {\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt(); // Restore the interrupted status\n        }\n        final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n        log.warn(msg, e); // Log as warning and suppress the exception\n      } finally {\n        if (locked) {\n          // unlock\n          try {\n            zkClient.delete(lockPath, -1, true);\n          } catch (KeeperException.NoNodeException nne) {\n            // ignore - someone else deleted it\n          } catch (Exception e) {\n            log.warn(\"Unable to delete schema upgrade lock file \" + lockPath, e);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9df8125ba9193a2e2e285ed92157810b1952a244","date":1587326330,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchemaFactory#zkUgradeToManagedSchema().mjava","sourceNew":"  /**\n   * Persist the managed schema to ZooKeeper and rename the non-managed schema \n   * by appending {@link #UPGRADED_SCHEMA_EXTENSION}.\n   *\n   * Failure to rename the non-managed schema will be logged as a warning,\n   * and no exception will be thrown.\n   */\n  private void zkUgradeToManagedSchema() {\n    if (resourceName.equals(managedSchemaResourceName)) {\n      log.info(\"On upgrading to managed schema, did not rename non-managed schema {} because it's the same as the managed schema's name.\"\n          , resourceName);\n      return;\n    }\n    final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n    final ZkController zkController = zkLoader.getZkController();\n    final SolrZkClient zkClient = zkController.getZkClient();\n    final String lockPath = zkLoader.getConfigSetZkPath() + \"/schemaUpgrade.lock\";\n    boolean locked = false;\n    try {\n      try {\n        zkClient.makePath(lockPath, null, CreateMode.EPHEMERAL, null, true, true);\n        locked = true;\n      } catch (Exception e) {\n        // some other node already started the upgrade, or an error occurred - bail out\n        return;\n      }\n      schema.persistManagedSchemaToZooKeeper(true); // Only create, don't update it if it already exists\n\n      // After successfully persisting the managed schema, rename the non-managed\n      // schema znode by appending UPGRADED_SCHEMA_EXTENSION to its name.\n\n      // Rename the non-managed schema znode in ZooKeeper\n      final String nonManagedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + resourceName;\n      try {\n        ZkCmdExecutor zkCmdExecutor = new ZkCmdExecutor(zkController.getClientTimeout());\n        if (zkController.pathExists(nonManagedSchemaPath)) {\n          // First, copy the non-managed schema znode content to the upgraded schema znode\n          byte[] bytes = zkController.getZkClient().getData(nonManagedSchemaPath, null, null, true);\n          final String upgradedSchemaPath = nonManagedSchemaPath + UPGRADED_SCHEMA_EXTENSION;\n          zkCmdExecutor.ensureExists(upgradedSchemaPath, zkController.getZkClient());\n          zkController.getZkClient().setData(upgradedSchemaPath, bytes, true);\n          // Then delete the non-managed schema znode\n          if (zkController.getZkClient().exists(nonManagedSchemaPath, true)) {\n            try {\n              zkController.getZkClient().delete(nonManagedSchemaPath, -1, true);\n            } catch (KeeperException.NoNodeException ex) {\n              // ignore - someone beat us to it\n            }\n          }\n\n          // Set the resource name to the managed schema so that the CoreAdminHandler returns a findable filename\n          schema.setResourceName(managedSchemaResourceName);\n\n          log.info(\"After upgrading to managed schema in ZooKeeper, renamed the non-managed schema {} to {}\"\n              , nonManagedSchemaPath, upgradedSchemaPath);\n        } else {\n          log.info(\"After upgrading to managed schema in ZooKeeper, the non-managed schema {} no longer exists.\"\n              , nonManagedSchemaPath);\n        }\n      } catch (Exception e) {\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt(); // Restore the interrupted status\n        }\n        final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n        log.warn(msg, e); // Log as warning and suppress the exception\n      }\n    } finally {\n      if (locked) {\n        // unlock\n        try {\n          zkClient.delete(lockPath, -1, true);\n        } catch (KeeperException.NoNodeException nne) {\n          // ignore - someone else deleted it\n        } catch (Exception e) {\n          log.warn(\"Unable to delete schema upgrade lock file {}\", lockPath, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Persist the managed schema to ZooKeeper and rename the non-managed schema \n   * by appending {@link #UPGRADED_SCHEMA_EXTENSION}.\n   *\n   * Failure to rename the non-managed schema will be logged as a warning,\n   * and no exception will be thrown.\n   */\n  private void zkUgradeToManagedSchema() {\n    if (resourceName.equals(managedSchemaResourceName)) {\n      log.info(\"On upgrading to managed schema, did not rename non-managed schema \"\n          + resourceName + \" because it's the same as the managed schema's name.\");\n      return;\n    }\n    final ZkSolrResourceLoader zkLoader = (ZkSolrResourceLoader)loader;\n    final ZkController zkController = zkLoader.getZkController();\n    final SolrZkClient zkClient = zkController.getZkClient();\n    final String lockPath = zkLoader.getConfigSetZkPath() + \"/schemaUpgrade.lock\";\n    boolean locked = false;\n    try {\n      try {\n        zkClient.makePath(lockPath, null, CreateMode.EPHEMERAL, null, true, true);\n        locked = true;\n      } catch (Exception e) {\n        // some other node already started the upgrade, or an error occurred - bail out\n        return;\n      }\n      schema.persistManagedSchemaToZooKeeper(true); // Only create, don't update it if it already exists\n\n      // After successfully persisting the managed schema, rename the non-managed\n      // schema znode by appending UPGRADED_SCHEMA_EXTENSION to its name.\n\n      // Rename the non-managed schema znode in ZooKeeper\n      final String nonManagedSchemaPath = zkLoader.getConfigSetZkPath() + \"/\" + resourceName;\n      try {\n        ZkCmdExecutor zkCmdExecutor = new ZkCmdExecutor(zkController.getClientTimeout());\n        if (zkController.pathExists(nonManagedSchemaPath)) {\n          // First, copy the non-managed schema znode content to the upgraded schema znode\n          byte[] bytes = zkController.getZkClient().getData(nonManagedSchemaPath, null, null, true);\n          final String upgradedSchemaPath = nonManagedSchemaPath + UPGRADED_SCHEMA_EXTENSION;\n          zkCmdExecutor.ensureExists(upgradedSchemaPath, zkController.getZkClient());\n          zkController.getZkClient().setData(upgradedSchemaPath, bytes, true);\n          // Then delete the non-managed schema znode\n          if (zkController.getZkClient().exists(nonManagedSchemaPath, true)) {\n            try {\n              zkController.getZkClient().delete(nonManagedSchemaPath, -1, true);\n            } catch (KeeperException.NoNodeException ex) {\n              // ignore - someone beat us to it\n            }\n          }\n\n          // Set the resource name to the managed schema so that the CoreAdminHandler returns a findable filename\n          schema.setResourceName(managedSchemaResourceName);\n\n          log.info(\"After upgrading to managed schema in ZooKeeper, renamed the non-managed schema \"\n              + nonManagedSchemaPath + \" to \" + upgradedSchemaPath);\n        } else {\n          log.info(\"After upgrading to managed schema in ZooKeeper, the non-managed schema \"\n              + nonManagedSchemaPath + \" no longer exists.\");\n        }\n      } catch (Exception e) {\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt(); // Restore the interrupted status\n        }\n        final String msg = \"Error persisting managed schema resource \" + managedSchemaResourceName;\n        log.warn(msg, e); // Log as warning and suppress the exception\n      }\n    } finally {\n      if (locked) {\n        // unlock\n        try {\n          zkClient.delete(lockPath, -1, true);\n        } catch (KeeperException.NoNodeException nne) {\n          // ignore - someone else deleted it\n        } catch (Exception e) {\n          log.warn(\"Unable to delete schema upgrade lock file \" + lockPath, e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3873cff5fd3b100cbfe1bfb542cebfe6d1dcfb29":["8b2329af9080ec86a454c9439598b88e169fc28a"],"9cf81bc8c6e4078e236f0e38b3a2d0271854f207":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["17778d9c1f3a8a67383edebf24754bf30a5120f8"],"17778d9c1f3a8a67383edebf24754bf30a5120f8":["08970e5b8411182a29412c177eff67ec1110095b"],"8b2329af9080ec86a454c9439598b88e169fc28a":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9df8125ba9193a2e2e285ed92157810b1952a244"],"9df8125ba9193a2e2e285ed92157810b1952a244":["3873cff5fd3b100cbfe1bfb542cebfe6d1dcfb29"],"08970e5b8411182a29412c177eff67ec1110095b":["9cf81bc8c6e4078e236f0e38b3a2d0271854f207"]},"commit2Childs":{"3873cff5fd3b100cbfe1bfb542cebfe6d1dcfb29":["9df8125ba9193a2e2e285ed92157810b1952a244"],"9cf81bc8c6e4078e236f0e38b3a2d0271854f207":["08970e5b8411182a29412c177eff67ec1110095b"],"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["8b2329af9080ec86a454c9439598b88e169fc28a"],"17778d9c1f3a8a67383edebf24754bf30a5120f8":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"8b2329af9080ec86a454c9439598b88e169fc28a":["3873cff5fd3b100cbfe1bfb542cebfe6d1dcfb29"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9cf81bc8c6e4078e236f0e38b3a2d0271854f207"],"08970e5b8411182a29412c177eff67ec1110095b":["17778d9c1f3a8a67383edebf24754bf30a5120f8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9df8125ba9193a2e2e285ed92157810b1952a244":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}