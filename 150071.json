{"path":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","commits":[{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    int count = 0;\n    while(it.hasNext()) {\n      String name = it.next();\n      if (count % 3 == 0) {\n        deleteFile(name, true);\n      } else if (count % 3 == 1) {\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (count % 3 == 2) {\n        // Truncate the file:\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(fileLength(name)/2);\n        out.close();\n      }\n      count++;\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    int count = 0;\n    while(it.hasNext()) {\n      String name = it.next();\n      if (count % 3 == 0) {\n        deleteFile(name, true);\n      } else if (count % 3 == 1) {\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (count % 3 == 2) {\n        // Truncate the file:\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(fileLength(name)/2);\n        out.close();\n      }\n      count++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a408894969be9ea9d3672a323abc7641291d229","date":1322482995,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(4);\n      if (damage == 0) {\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        // Partially Truncate the file:\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(fileLength(name)/2);\n        out.close();\n      } else {\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    int count = 0;\n    while(it.hasNext()) {\n      String name = it.next();\n      if (count % 3 == 0) {\n        deleteFile(name, true);\n      } else if (count % 3 == 1) {\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (count % 3 == 2) {\n        // Truncate the file:\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(fileLength(name)/2);\n        out.close();\n      }\n      count++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6a3fe8668125a7bb217ab4b515c348a6d21ddf9","date":1322493662,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(fileLength(name)/2);\n        out.close();\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(4);\n      if (damage == 0) {\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        // Partially Truncate the file:\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(fileLength(name)/2);\n        out.close();\n      } else {\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f592e183306e8e4efabf3e7e08d3e709c9b97dbb","date":1324403520,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput in = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(in, in.length()/2);\n        tempOut.close();\n        in.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        in = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(in, in.length());\n        out.close();\n        in.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(fileLength(name)/2);\n        out.close();\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":["71122e5efb3fd9ad29e81a7682dc45a8852bd53c","b6f9be74ca7baaef11857ad002cad40419979516"],"bugIntro":["d19974432be9aed28ee7dca73bdf01d139e763a9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#crash().mjava","sourceNew":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput in = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(in, in.length()/2);\n        tempOut.close();\n        in.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        in = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(in, in.length());\n        out.close();\n        in.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  /** Simulates a crash of OS or machine by overwriting\n   *  unsynced files. */\n  public synchronized void crash() throws IOException {\n    crashed = true;\n    openFiles = new HashMap<String,Integer>();\n    openFilesForWrite = new HashSet<String>();\n    openFilesDeleted = new HashSet<String>();\n    Iterator<String> it = unSyncedFiles.iterator();\n    unSyncedFiles = new HashSet<String>();\n    // first force-close all files, so we can corrupt on windows etc.\n    // clone the file map, as these guys want to remove themselves on close.\n    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);\n    for (Closeable f : m.keySet())\n      try {\n        f.close();\n      } catch (Exception ignored) {}\n    \n    while(it.hasNext()) {\n      String name = it.next();\n      int damage = randomState.nextInt(5);\n      String action = null;\n      if (damage == 0) {\n        action = \"deleted\";\n        deleteFile(name, true);\n      } else if (damage == 1) {\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length = fileLength(name);\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        while(upto < length) {\n          final int limit = (int) Math.min(length-upto, zeroes.length);\n          out.writeBytes(zeroes, 0, limit);\n          upto += limit;\n        }\n        out.close();\n      } else if (damage == 2) {\n        action = \"partially truncated\";\n        // Partially Truncate the file:\n\n        // First, make temp file and copy only half this\n        // file over:\n        String tempFileName;\n        while (true) {\n          tempFileName = \"\"+randomState.nextInt();\n          if (!delegate.fileExists(tempFileName)) {\n            break;\n          }\n        }\n        final IndexOutput tempOut = delegate.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        IndexInput in = delegate.openInput(name, LuceneTestCase.newIOContext(randomState));\n        tempOut.copyBytes(in, in.length()/2);\n        tempOut.close();\n        in.close();\n\n        // Delete original and copy bytes back:\n        deleteFile(name, true);\n        \n        final IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        in = delegate.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));\n        out.copyBytes(in, in.length());\n        out.close();\n        in.close();\n        deleteFile(tempFileName, true);\n      } else if (damage == 3) {\n        // The file survived intact:\n        action = \"didn't change\";\n      } else {\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name, true);\n        IndexOutput out = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState));\n        out.setLength(0);\n        out.close();\n      }\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"f592e183306e8e4efabf3e7e08d3e709c9b97dbb":["a6a3fe8668125a7bb217ab4b515c348a6d21ddf9"],"7b91922b55d15444d554721b352861d028eb8278":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a6a3fe8668125a7bb217ab4b515c348a6d21ddf9":["8a408894969be9ea9d3672a323abc7641291d229"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["f592e183306e8e4efabf3e7e08d3e709c9b97dbb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8a408894969be9ea9d3672a323abc7641291d229":["7b91922b55d15444d554721b352861d028eb8278"]},"commit2Childs":{"f592e183306e8e4efabf3e7e08d3e709c9b97dbb":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7b91922b55d15444d554721b352861d028eb8278":["8a408894969be9ea9d3672a323abc7641291d229"],"a6a3fe8668125a7bb217ab4b515c348a6d21ddf9":["f592e183306e8e4efabf3e7e08d3e709c9b97dbb"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7b91922b55d15444d554721b352861d028eb8278"],"8a408894969be9ea9d3672a323abc7641291d229":["a6a3fe8668125a7bb217ab4b515c348a6d21ddf9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}