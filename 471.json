{"path":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","commits":[{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrClient client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrClient client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrClient client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c94d2661bc1c14426980ec7882e951fdcff08d0","date":1427167177,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":["6b834dd353486678973f4157b3ba402ac3a7ca88","19389fe47925b510b2811e2b385a75f7ad19dcca"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98287baa2c8d136e801f366a73e27a23285b7b98","date":1427241813,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a26cd9f6579b26eac9a2baee73a4ac85a74ad5ab","date":1444337884,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e16ac84f9e5d560008fe1554462ff8b853b3d3c","date":1520142134,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11d6f92dfa9251d9da6d80ec5963a9cbecc90180","date":1530559969,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","sourceNew":"  @Test\n  // 29-June-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","sourceNew":"  @Test\n  // 29-June-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","sourceNew":"  @Test\n  // 29-June-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run(false);\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Test\n  // 29-June-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":["11d6f92dfa9251d9da6d80ec5963a9cbecc90180","270612d8e1a51cded91704d7af12f8979de0f584"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add1e7dd742ea533ff4318cea83ca0a1f669f662","date":1585262285,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(3, TimeUnit.MINUTES);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(3, TimeUnit.MINUTES);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run(false);\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run(false);\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(3, TimeUnit.MINUTES);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(3, TimeUnit.MINUTES);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run(false);\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StoppableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    int batchSize = 1;\n    if (random().nextBoolean()) {\n      batchSize = random().nextInt(98) + 2;\n    }\n    \n    boolean pauseBetweenUpdates = TEST_NIGHTLY ? random().nextBoolean() : true;\n    int maxUpdates = -1;\n    if (!pauseBetweenUpdates) {\n      maxUpdates = 1000 + random().nextInt(1000);\n    } else {\n      maxUpdates = 15000;\n    }\n    \n    for (int i = 0; i < threadCount; i++) {\n      StoppableIndexingThread indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, maxUpdates, batchSize, pauseBetweenUpdates); // random().nextInt(999) + 1\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StoppableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StoppableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(3, TimeUnit.MINUTES);\n    \n    // even if things were leveled out, a jetty may have just been stopped or something\n    // we wait again and wait to level out again to make sure the system is not still in flux\n    \n    Thread.sleep(3000);\n\n    waitForThingsToLevelOut(3, TimeUnit.MINUTES);\n\n    checkShardConsistency(batchSize == 1, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run(false);\n    }\n\n    try (CloudSolrClient client = createCloudClient(\"collection1\")) {\n        createCollection(null, \"testcollection\", 1, 1, 1, client, null, \"conf1\");\n\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e16ac84f9e5d560008fe1554462ff8b853b3d3c":["a26cd9f6579b26eac9a2baee73a4ac85a74ad5ab"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["11d6f92dfa9251d9da6d80ec5963a9cbecc90180"],"abb23fcc2461782ab204e61213240feb77d355aa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"98287baa2c8d136e801f366a73e27a23285b7b98":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"a26cd9f6579b26eac9a2baee73a4ac85a74ad5ab":["98287baa2c8d136e801f366a73e27a23285b7b98"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["add1e7dd742ea533ff4318cea83ca0a1f669f662"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["cc3b13b430571c2e169f98fe38e1e7666f88522d","98287baa2c8d136e801f366a73e27a23285b7b98"],"11d6f92dfa9251d9da6d80ec5963a9cbecc90180":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c","11d6f92dfa9251d9da6d80ec5963a9cbecc90180"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["abb23fcc2461782ab204e61213240feb77d355aa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c","11d6f92dfa9251d9da6d80ec5963a9cbecc90180"]},"commit2Childs":{"7e16ac84f9e5d560008fe1554462ff8b853b3d3c":["11d6f92dfa9251d9da6d80ec5963a9cbecc90180","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["add1e7dd742ea533ff4318cea83ca0a1f669f662"],"abb23fcc2461782ab204e61213240feb77d355aa":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["98287baa2c8d136e801f366a73e27a23285b7b98"],"98287baa2c8d136e801f366a73e27a23285b7b98":["a26cd9f6579b26eac9a2baee73a4ac85a74ad5ab","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"a26cd9f6579b26eac9a2baee73a4ac85a74ad5ab":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"11d6f92dfa9251d9da6d80ec5963a9cbecc90180":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["abb23fcc2461782ab204e61213240feb77d355aa"],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["6c94d2661bc1c14426980ec7882e951fdcff08d0","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}