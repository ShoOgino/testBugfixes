{"path":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","commits":[{"id":"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd","date":1361836936,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      throw new IllegalArgumentException(\"there must be at least one drill-down\");\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    for(FacetRequest fr :  fsp.facetRequests) {\n      if (fr.categoryPath.length == 0) {\n        throw new IllegalArgumentException(\"all FacetRequests must have CategoryPath with length > 0\");\n      }\n    }\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    Term[][] drillDownTerms = new Term[clauses.length-startClause][];\n    for(int i=startClause;i<clauses.length;i++) {\n      Query q = clauses[i].getQuery();\n      assert q instanceof ConstantScoreQuery;\n      q = ((ConstantScoreQuery) q).getQuery();\n      assert q instanceof TermQuery || q instanceof BooleanQuery;\n      if (q instanceof TermQuery) {\n        drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n      } else {\n        BooleanQuery q2 = (BooleanQuery) q;\n        BooleanClause[] clauses2 = q2.getClauses();\n        drillDownTerms[i-startClause] = new Term[clauses2.length];\n        for(int j=0;j<clauses2.length;j++) {\n          assert clauses2[j].getQuery() instanceof TermQuery;\n          drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n        }\n      }\n    }\n\n    FacetsCollector drillDownCollector = FacetsCollector.create(getDrillDownAccumulator(fsp));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      FacetRequest drillSidewaysRequest = null;\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          if (drillSidewaysRequest != null) {\n            throw new IllegalArgumentException(\"multiple FacetRequests for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n          }\n          drillSidewaysRequest = fr;\n        }\n      }\n      if (drillSidewaysRequest == null) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, drillSidewaysRequest)));\n    }\n\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n\n    searcher.search(dsq, hitCollector);\n\n    List<FacetResult> drillDownResults = drillDownCollector.getFacetResults();\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        mergedResults.add(drillDownResults.get(i));\n      } else {\n        // Drill sideways dim:\n        List<FacetResult> sidewaysResult = drillSidewaysCollectors[dimIndex.intValue()].getFacetResults();\n\n        assert sidewaysResult.size() == 1: \"size=\" + sidewaysResult.size();\n        mergedResults.add(sidewaysResult.get(0));\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["416910ae9ffe752ba5b6334f75d6c36e019626cc","e70df4d80cde893a6897f8e6543c2d7666b73d7a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba3abc2c7b1d377e50611d0c03245d1526c73863","date":1362673381,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      throw new IllegalArgumentException(\"there must be at least one drill-down\");\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    for(FacetRequest fr :  fsp.facetRequests) {\n      if (fr.categoryPath.length == 0) {\n        throw new IllegalArgumentException(\"all FacetRequests must have CategoryPath with length > 0\");\n      }\n    }\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    Term[][] drillDownTerms = new Term[clauses.length-startClause][];\n    for(int i=startClause;i<clauses.length;i++) {\n      Query q = clauses[i].getQuery();\n      assert q instanceof ConstantScoreQuery;\n      q = ((ConstantScoreQuery) q).getQuery();\n      assert q instanceof TermQuery || q instanceof BooleanQuery;\n      if (q instanceof TermQuery) {\n        drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n      } else {\n        BooleanQuery q2 = (BooleanQuery) q;\n        BooleanClause[] clauses2 = q2.getClauses();\n        drillDownTerms[i-startClause] = new Term[clauses2.length];\n        for(int j=0;j<clauses2.length;j++) {\n          assert clauses2[j].getQuery() instanceof TermQuery;\n          drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n        }\n      }\n    }\n\n    FacetsCollector drillDownCollector = FacetsCollector.create(getDrillDownAccumulator(fsp));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      if (requests.isEmpty()) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n\n    searcher.search(dsq, hitCollector);\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = (List<FacetResult>[]) new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n        }\n        mergedResults.add(drillDownResults.get(i));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      throw new IllegalArgumentException(\"there must be at least one drill-down\");\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    for(FacetRequest fr :  fsp.facetRequests) {\n      if (fr.categoryPath.length == 0) {\n        throw new IllegalArgumentException(\"all FacetRequests must have CategoryPath with length > 0\");\n      }\n    }\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    Term[][] drillDownTerms = new Term[clauses.length-startClause][];\n    for(int i=startClause;i<clauses.length;i++) {\n      Query q = clauses[i].getQuery();\n      assert q instanceof ConstantScoreQuery;\n      q = ((ConstantScoreQuery) q).getQuery();\n      assert q instanceof TermQuery || q instanceof BooleanQuery;\n      if (q instanceof TermQuery) {\n        drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n      } else {\n        BooleanQuery q2 = (BooleanQuery) q;\n        BooleanClause[] clauses2 = q2.getClauses();\n        drillDownTerms[i-startClause] = new Term[clauses2.length];\n        for(int j=0;j<clauses2.length;j++) {\n          assert clauses2[j].getQuery() instanceof TermQuery;\n          drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n        }\n      }\n    }\n\n    FacetsCollector drillDownCollector = FacetsCollector.create(getDrillDownAccumulator(fsp));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      FacetRequest drillSidewaysRequest = null;\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          if (drillSidewaysRequest != null) {\n            throw new IllegalArgumentException(\"multiple FacetRequests for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n          }\n          drillSidewaysRequest = fr;\n        }\n      }\n      if (drillSidewaysRequest == null) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, drillSidewaysRequest)));\n    }\n\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n\n    searcher.search(dsq, hitCollector);\n\n    List<FacetResult> drillDownResults = drillDownCollector.getFacetResults();\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        mergedResults.add(drillDownResults.get(i));\n      } else {\n        // Drill sideways dim:\n        List<FacetResult> sidewaysResult = drillSidewaysCollectors[dimIndex.intValue()].getFacetResults();\n\n        assert sidewaysResult.size() == 1: \"size=\" + sidewaysResult.size();\n        mergedResults.add(sidewaysResult.get(0));\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2ae7e371df56ccde467b71db7e82066f05a5972","date":1363620258,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      throw new IllegalArgumentException(\"there must be at least one drill-down\");\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    for(FacetRequest fr :  fsp.facetRequests) {\n      if (fr.categoryPath.length == 0) {\n        throw new IllegalArgumentException(\"all FacetRequests must have CategoryPath with length > 0\");\n      }\n    }\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    Term[][] drillDownTerms = new Term[clauses.length-startClause][];\n    for(int i=startClause;i<clauses.length;i++) {\n      Query q = clauses[i].getQuery();\n      assert q instanceof ConstantScoreQuery;\n      q = ((ConstantScoreQuery) q).getQuery();\n      assert q instanceof TermQuery || q instanceof BooleanQuery;\n      if (q instanceof TermQuery) {\n        drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n      } else {\n        BooleanQuery q2 = (BooleanQuery) q;\n        BooleanClause[] clauses2 = q2.getClauses();\n        drillDownTerms[i-startClause] = new Term[clauses2.length];\n        for(int j=0;j<clauses2.length;j++) {\n          assert clauses2[j].getQuery() instanceof TermQuery;\n          drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n        }\n      }\n    }\n\n    FacetsCollector drillDownCollector = FacetsCollector.create(getDrillDownAccumulator(fsp));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      if (requests.isEmpty()) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n\n    searcher.search(dsq, hitCollector);\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n        }\n        mergedResults.add(drillDownResults.get(i));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      throw new IllegalArgumentException(\"there must be at least one drill-down\");\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    for(FacetRequest fr :  fsp.facetRequests) {\n      if (fr.categoryPath.length == 0) {\n        throw new IllegalArgumentException(\"all FacetRequests must have CategoryPath with length > 0\");\n      }\n    }\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    Term[][] drillDownTerms = new Term[clauses.length-startClause][];\n    for(int i=startClause;i<clauses.length;i++) {\n      Query q = clauses[i].getQuery();\n      assert q instanceof ConstantScoreQuery;\n      q = ((ConstantScoreQuery) q).getQuery();\n      assert q instanceof TermQuery || q instanceof BooleanQuery;\n      if (q instanceof TermQuery) {\n        drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n      } else {\n        BooleanQuery q2 = (BooleanQuery) q;\n        BooleanClause[] clauses2 = q2.getClauses();\n        drillDownTerms[i-startClause] = new Term[clauses2.length];\n        for(int j=0;j<clauses2.length;j++) {\n          assert clauses2[j].getQuery() instanceof TermQuery;\n          drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n        }\n      }\n    }\n\n    FacetsCollector drillDownCollector = FacetsCollector.create(getDrillDownAccumulator(fsp));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      if (requests.isEmpty()) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n\n    searcher.search(dsq, hitCollector);\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = (List<FacetResult>[]) new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n        }\n        mergedResults.add(drillDownResults.get(i));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e70df4d80cde893a6897f8e6543c2d7666b73d7a","date":1365615272,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);      \n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    Term[][] drillDownTerms = new Term[clauses.length-startClause][];\n    for(int i=startClause;i<clauses.length;i++) {\n      Query q = clauses[i].getQuery();\n      assert q instanceof ConstantScoreQuery;\n      q = ((ConstantScoreQuery) q).getQuery();\n      assert q instanceof TermQuery || q instanceof BooleanQuery;\n      if (q instanceof TermQuery) {\n        drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n      } else {\n        BooleanQuery q2 = (BooleanQuery) q;\n        BooleanClause[] clauses2 = q2.getClauses();\n        drillDownTerms[i-startClause] = new Term[clauses2.length];\n        for(int j=0;j<clauses2.length;j++) {\n          assert clauses2[j].getQuery() instanceof TermQuery;\n          drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n        }\n      }\n    }\n\n    FacetsCollector drillDownCollector = FacetsCollector.create(getDrillDownAccumulator(fsp));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      if (requests.isEmpty()) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n\n    searcher.search(dsq, hitCollector);\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n        }\n        mergedResults.add(drillDownResults.get(i));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      throw new IllegalArgumentException(\"there must be at least one drill-down\");\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    for(FacetRequest fr :  fsp.facetRequests) {\n      if (fr.categoryPath.length == 0) {\n        throw new IllegalArgumentException(\"all FacetRequests must have CategoryPath with length > 0\");\n      }\n    }\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    Term[][] drillDownTerms = new Term[clauses.length-startClause][];\n    for(int i=startClause;i<clauses.length;i++) {\n      Query q = clauses[i].getQuery();\n      assert q instanceof ConstantScoreQuery;\n      q = ((ConstantScoreQuery) q).getQuery();\n      assert q instanceof TermQuery || q instanceof BooleanQuery;\n      if (q instanceof TermQuery) {\n        drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n      } else {\n        BooleanQuery q2 = (BooleanQuery) q;\n        BooleanClause[] clauses2 = q2.getClauses();\n        drillDownTerms[i-startClause] = new Term[clauses2.length];\n        for(int j=0;j<clauses2.length;j++) {\n          assert clauses2[j].getQuery() instanceof TermQuery;\n          drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n        }\n      }\n    }\n\n    FacetsCollector drillDownCollector = FacetsCollector.create(getDrillDownAccumulator(fsp));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      if (requests.isEmpty()) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n\n    searcher.search(dsq, hitCollector);\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n        }\n        mergedResults.add(drillDownResults.get(i));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","bugFix":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e2f479a58780f0a2a9c1c6f7202207a75d094cd9","date":1366841689,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);      \n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    Term[][] drillDownTerms = new Term[clauses.length-startClause][];\n    for(int i=startClause;i<clauses.length;i++) {\n      Query q = clauses[i].getQuery();\n      assert q instanceof ConstantScoreQuery;\n      q = ((ConstantScoreQuery) q).getQuery();\n      assert q instanceof TermQuery || q instanceof BooleanQuery;\n      if (q instanceof TermQuery) {\n        drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n      } else {\n        BooleanQuery q2 = (BooleanQuery) q;\n        BooleanClause[] clauses2 = q2.getClauses();\n        drillDownTerms[i-startClause] = new Term[clauses2.length];\n        for(int j=0;j<clauses2.length;j++) {\n          assert clauses2[j].getQuery() instanceof TermQuery;\n          drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n        }\n      }\n    }\n\n    FacetsCollector drillDownCollector = FacetsCollector.create(getDrillDownAccumulator(fsp));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      if (requests.isEmpty()) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms, scoreSubDocsAtOnce());\n\n    searcher.search(dsq, hitCollector);\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n        }\n        mergedResults.add(drillDownResults.get(i));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);      \n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    Term[][] drillDownTerms = new Term[clauses.length-startClause][];\n    for(int i=startClause;i<clauses.length;i++) {\n      Query q = clauses[i].getQuery();\n      assert q instanceof ConstantScoreQuery;\n      q = ((ConstantScoreQuery) q).getQuery();\n      assert q instanceof TermQuery || q instanceof BooleanQuery;\n      if (q instanceof TermQuery) {\n        drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n      } else {\n        BooleanQuery q2 = (BooleanQuery) q;\n        BooleanClause[] clauses2 = q2.getClauses();\n        drillDownTerms[i-startClause] = new Term[clauses2.length];\n        for(int j=0;j<clauses2.length;j++) {\n          assert clauses2[j].getQuery() instanceof TermQuery;\n          drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n        }\n      }\n    }\n\n    FacetsCollector drillDownCollector = FacetsCollector.create(getDrillDownAccumulator(fsp));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      if (requests.isEmpty()) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n\n    searcher.search(dsq, hitCollector);\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n        }\n        mergedResults.add(drillDownResults.get(i));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"378fbd2626d3f584f8146e25acf62ee817361580","date":1367266329,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search when there are no drill-downs:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);      \n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector drillDownCollector = FacetsCollector.create(getDrillDownAccumulator(fsp));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      if (requests.isEmpty()) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n          //System.out.println(\"get DD results\");\n        }\n        //System.out.println(\"add dd results \" + i);\n        mergedResults.add(drillDownResults.get(i));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);      \n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    Term[][] drillDownTerms = new Term[clauses.length-startClause][];\n    for(int i=startClause;i<clauses.length;i++) {\n      Query q = clauses[i].getQuery();\n      assert q instanceof ConstantScoreQuery;\n      q = ((ConstantScoreQuery) q).getQuery();\n      assert q instanceof TermQuery || q instanceof BooleanQuery;\n      if (q instanceof TermQuery) {\n        drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n      } else {\n        BooleanQuery q2 = (BooleanQuery) q;\n        BooleanClause[] clauses2 = q2.getClauses();\n        drillDownTerms[i-startClause] = new Term[clauses2.length];\n        for(int j=0;j<clauses2.length;j++) {\n          assert clauses2[j].getQuery() instanceof TermQuery;\n          drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n        }\n      }\n    }\n\n    FacetsCollector drillDownCollector = FacetsCollector.create(getDrillDownAccumulator(fsp));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      if (requests.isEmpty()) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms, scoreSubDocsAtOnce());\n\n    searcher.search(dsq, hitCollector);\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n        }\n        mergedResults.add(drillDownResults.get(i));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"416910ae9ffe752ba5b6334f75d6c36e019626cc","date":1367953778,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search when there are no drill-downs:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);      \n    }\n\n    List<FacetRequest> ddRequests = new ArrayList<FacetRequest>();\n    for(FacetRequest fr : fsp.facetRequests) {\n      assert fr.categoryPath.length > 0;\n      if (!drillDownDims.containsKey(fr.categoryPath.components[0])) {\n        ddRequests.add(fr);\n      }\n    }\n    FacetSearchParams fsp2;\n    if (!ddRequests.isEmpty()) {\n      fsp2 = new FacetSearchParams(fsp.indexingParams, ddRequests);\n    } else {\n      fsp2 = null;\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector drillDownCollector = fsp2 == null ? null : FacetsCollector.create(getDrillDownAccumulator(fsp2));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      if (requests.isEmpty()) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    int ddUpto = 0;\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n          //System.out.println(\"get DD results\");\n        }\n        //System.out.println(\"add dd results \" + i);\n        mergedResults.add(drillDownResults.get(ddUpto++));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search when there are no drill-downs:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);      \n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector drillDownCollector = FacetsCollector.create(getDrillDownAccumulator(fsp));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      if (requests.isEmpty()) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n          //System.out.println(\"get DD results\");\n        }\n        //System.out.println(\"add dd results \" + i);\n        mergedResults.add(drillDownResults.get(i));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","bugFix":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f9543b93c856b40e808833973fa6ac9773b88e3","date":1372256868,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search when there are no drill-downs:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);      \n    }\n\n    List<FacetRequest> ddRequests = new ArrayList<FacetRequest>();\n    for(FacetRequest fr : fsp.facetRequests) {\n      assert fr.categoryPath.length > 0;\n      if (!drillDownDims.containsKey(fr.categoryPath.components[0])) {\n        ddRequests.add(fr);\n      }\n    }\n    FacetSearchParams fsp2;\n    if (!ddRequests.isEmpty()) {\n      fsp2 = new FacetSearchParams(fsp.indexingParams, ddRequests);\n    } else {\n      fsp2 = null;\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector drillDownCollector = fsp2 == null ? null : FacetsCollector.create(getDrillDownAccumulator(fsp2));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      // We already moved all drill-downs that didn't have a\n      // FacetRequest, in moveDrillDownOnlyClauses above:\n      assert !requests.isEmpty();\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    int ddUpto = 0;\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n          //System.out.println(\"get DD results\");\n        }\n        //System.out.println(\"add dd results \" + i);\n        mergedResults.add(drillDownResults.get(ddUpto++));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search when there are no drill-downs:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);      \n    }\n\n    List<FacetRequest> ddRequests = new ArrayList<FacetRequest>();\n    for(FacetRequest fr : fsp.facetRequests) {\n      assert fr.categoryPath.length > 0;\n      if (!drillDownDims.containsKey(fr.categoryPath.components[0])) {\n        ddRequests.add(fr);\n      }\n    }\n    FacetSearchParams fsp2;\n    if (!ddRequests.isEmpty()) {\n      fsp2 = new FacetSearchParams(fsp.indexingParams, ddRequests);\n    } else {\n      fsp2 = null;\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector drillDownCollector = fsp2 == null ? null : FacetsCollector.create(getDrillDownAccumulator(fsp2));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      if (requests.isEmpty()) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    int ddUpto = 0;\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n          //System.out.println(\"get DD results\");\n        }\n        //System.out.println(\"add dd results \" + i);\n        mergedResults.add(drillDownResults.get(ddUpto++));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search when there are no drill-downs:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);      \n    }\n\n    List<FacetRequest> ddRequests = new ArrayList<FacetRequest>();\n    for(FacetRequest fr : fsp.facetRequests) {\n      assert fr.categoryPath.length > 0;\n      if (!drillDownDims.containsKey(fr.categoryPath.components[0])) {\n        ddRequests.add(fr);\n      }\n    }\n    FacetSearchParams fsp2;\n    if (!ddRequests.isEmpty()) {\n      fsp2 = new FacetSearchParams(fsp.indexingParams, ddRequests);\n    } else {\n      fsp2 = null;\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector drillDownCollector = fsp2 == null ? null : FacetsCollector.create(getDrillDownAccumulator(fsp2));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      // We already moved all drill-downs that didn't have a\n      // FacetRequest, in moveDrillDownOnlyClauses above:\n      assert !requests.isEmpty();\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    int ddUpto = 0;\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n          //System.out.println(\"get DD results\");\n        }\n        //System.out.println(\"add dd results \" + i);\n        mergedResults.add(drillDownResults.get(ddUpto++));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search when there are no drill-downs:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);      \n    }\n\n    List<FacetRequest> ddRequests = new ArrayList<FacetRequest>();\n    for(FacetRequest fr : fsp.facetRequests) {\n      assert fr.categoryPath.length > 0;\n      if (!drillDownDims.containsKey(fr.categoryPath.components[0])) {\n        ddRequests.add(fr);\n      }\n    }\n    FacetSearchParams fsp2;\n    if (!ddRequests.isEmpty()) {\n      fsp2 = new FacetSearchParams(fsp.indexingParams, ddRequests);\n    } else {\n      fsp2 = null;\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector drillDownCollector = fsp2 == null ? null : FacetsCollector.create(getDrillDownAccumulator(fsp2));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      if (requests.isEmpty()) {\n        throw new IllegalArgumentException(\"could not find FacetRequest for drill-sideways dimension \\\"\" + dim + \"\\\"\");\n      }\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    int ddUpto = 0;\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n          //System.out.println(\"get DD results\");\n        }\n        //System.out.println(\"add dd results \" + i);\n        mergedResults.add(drillDownResults.get(ddUpto++));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28ac5cee8abf30398e12bc016a5ce9d441831a63","date":1384691298,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search when there are no drill-downs:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);\n    }\n\n    List<FacetRequest> ddRequests = new ArrayList<FacetRequest>();\n    for(FacetRequest fr : fsp.facetRequests) {\n      assert fr.categoryPath.length > 0;\n      if (!drillDownDims.containsKey(fr.categoryPath.components[0])) {\n        ddRequests.add(fr);\n      }\n    }\n    FacetSearchParams fsp2;\n    if (!ddRequests.isEmpty()) {\n      fsp2 = new FacetSearchParams(fsp.indexingParams, ddRequests);\n    } else {\n      fsp2 = null;\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector drillDownCollector = fsp2 == null ? null : FacetsCollector.create(getDrillDownAccumulator(fsp2));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      // We already moved all drill-downs that didn't have a\n      // FacetRequest, in moveDrillDownOnlyClauses above:\n      assert !requests.isEmpty();\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    int ddUpto = 0;\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n          //System.out.println(\"get DD results\");\n        }\n        //System.out.println(\"add dd results \" + i);\n        mergedResults.add(drillDownResults.get(ddUpto++));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search when there are no drill-downs:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);      \n    }\n\n    List<FacetRequest> ddRequests = new ArrayList<FacetRequest>();\n    for(FacetRequest fr : fsp.facetRequests) {\n      assert fr.categoryPath.length > 0;\n      if (!drillDownDims.containsKey(fr.categoryPath.components[0])) {\n        ddRequests.add(fr);\n      }\n    }\n    FacetSearchParams fsp2;\n    if (!ddRequests.isEmpty()) {\n      fsp2 = new FacetSearchParams(fsp.indexingParams, ddRequests);\n    } else {\n      fsp2 = null;\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector drillDownCollector = fsp2 == null ? null : FacetsCollector.create(getDrillDownAccumulator(fsp2));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      // We already moved all drill-downs that didn't have a\n      // FacetRequest, in moveDrillDownOnlyClauses above:\n      assert !requests.isEmpty();\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    int ddUpto = 0;\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n          //System.out.println(\"get DD results\");\n        }\n        //System.out.println(\"add dd results \" + i);\n        mergedResults.add(drillDownResults.get(ddUpto++));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e8428426152984b387a961487efefbe9cf62acf","date":1385332540,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","sourceNew":null,"sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search when there are no drill-downs:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);\n    }\n\n    List<FacetRequest> ddRequests = new ArrayList<FacetRequest>();\n    for(FacetRequest fr : fsp.facetRequests) {\n      assert fr.categoryPath.length > 0;\n      if (!drillDownDims.containsKey(fr.categoryPath.components[0])) {\n        ddRequests.add(fr);\n      }\n    }\n    FacetSearchParams fsp2;\n    if (!ddRequests.isEmpty()) {\n      fsp2 = new FacetSearchParams(fsp.indexingParams, ddRequests);\n    } else {\n      fsp2 = null;\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector drillDownCollector = fsp2 == null ? null : FacetsCollector.create(getDrillDownAccumulator(fsp2));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      // We already moved all drill-downs that didn't have a\n      // FacetRequest, in moveDrillDownOnlyClauses above:\n      assert !requests.isEmpty();\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    int ddUpto = 0;\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n          //System.out.println(\"get DD results\");\n        }\n        //System.out.println(\"add dd results \" + i);\n        mergedResults.add(drillDownResults.get(ddUpto++));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSideways#search(DrillDownQuery,Collector,FacetSearchParams).mjava","sourceNew":null,"sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query,\n                                    Collector hitCollector, FacetSearchParams fsp) throws IOException {\n\n    if (query.fip != fsp.indexingParams) {\n      throw new IllegalArgumentException(\"DrillDownQuery's FacetIndexingParams should match FacetSearchParams'\");\n    }\n\n    query = moveDrillDownOnlyClauses(query, fsp);\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    if (drillDownDims.isEmpty()) {\n      // Just do ordinary search when there are no drill-downs:\n      FacetsCollector c = FacetsCollector.create(getDrillDownAccumulator(fsp));\n      searcher.search(query, MultiCollector.wrap(hitCollector, c));\n      return new DrillSidewaysResult(c.getFacetResults(), null);      \n    }\n\n    List<FacetRequest> ddRequests = new ArrayList<FacetRequest>();\n    for(FacetRequest fr : fsp.facetRequests) {\n      assert fr.categoryPath.length > 0;\n      if (!drillDownDims.containsKey(fr.categoryPath.components[0])) {\n        ddRequests.add(fr);\n      }\n    }\n    FacetSearchParams fsp2;\n    if (!ddRequests.isEmpty()) {\n      fsp2 = new FacetSearchParams(fsp.indexingParams, ddRequests);\n    } else {\n      fsp2 = null;\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector drillDownCollector = fsp2 == null ? null : FacetsCollector.create(getDrillDownAccumulator(fsp2));\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(FacetRequest fr : fsp.facetRequests) {\n        assert fr.categoryPath.length > 0;\n        if (fr.categoryPath.components[0].equals(dim)) {\n          requests.add(fr);\n        }\n      }\n      // We already moved all drill-downs that didn't have a\n      // FacetRequest, in moveDrillDownOnlyClauses above:\n      assert !requests.isEmpty();\n      drillSidewaysCollectors[idx++] = FacetsCollector.create(getDrillSidewaysAccumulator(dim, new FacetSearchParams(fsp.indexingParams, requests)));\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    int numDims = drillDownDims.size();\n    List<FacetResult>[] drillSidewaysResults = new List[numDims];\n    List<FacetResult> drillDownResults = null;\n\n    List<FacetResult> mergedResults = new ArrayList<FacetResult>();\n    int[] requestUpto = new int[drillDownDims.size()];\n    int ddUpto = 0;\n    for(int i=0;i<fsp.facetRequests.size();i++) {\n      FacetRequest fr = fsp.facetRequests.get(i);\n      assert fr.categoryPath.length > 0;\n      Integer dimIndex = drillDownDims.get(fr.categoryPath.components[0]);\n      if (dimIndex == null) {\n        // Pure drill down dim (the current query didn't\n        // drill down on this dim):\n        if (drillDownResults == null) {\n          // Lazy init, in case all requests were against\n          // drill-sideways dims:\n          drillDownResults = drillDownCollector.getFacetResults();\n          //System.out.println(\"get DD results\");\n        }\n        //System.out.println(\"add dd results \" + i);\n        mergedResults.add(drillDownResults.get(ddUpto++));\n      } else {\n        // Drill sideways dim:\n        int dim = dimIndex.intValue();\n        List<FacetResult> sidewaysResult = drillSidewaysResults[dim];\n        if (sidewaysResult == null) {\n          // Lazy init, in case no facet request is against\n          // a given drill down dim:\n          sidewaysResult = drillSidewaysCollectors[dim].getFacetResults();\n          drillSidewaysResults[dim] = sidewaysResult;\n        }\n        mergedResults.add(sidewaysResult.get(requestUpto[dim]));\n        requestUpto[dim]++;\n      }\n    }\n\n    return new DrillSidewaysResult(mergedResults, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f2ae7e371df56ccde467b71db7e82066f05a5972":["ba3abc2c7b1d377e50611d0c03245d1526c73863"],"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"28ac5cee8abf30398e12bc016a5ce9d441831a63":["4f9543b93c856b40e808833973fa6ac9773b88e3"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["416910ae9ffe752ba5b6334f75d6c36e019626cc","4f9543b93c856b40e808833973fa6ac9773b88e3"],"ba3abc2c7b1d377e50611d0c03245d1526c73863":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"2e8428426152984b387a961487efefbe9cf62acf":["28ac5cee8abf30398e12bc016a5ce9d441831a63"],"4f9543b93c856b40e808833973fa6ac9773b88e3":["416910ae9ffe752ba5b6334f75d6c36e019626cc"],"416910ae9ffe752ba5b6334f75d6c36e019626cc":["378fbd2626d3f584f8146e25acf62ee817361580"],"378fbd2626d3f584f8146e25acf62ee817361580":["e2f479a58780f0a2a9c1c6f7202207a75d094cd9"],"e70df4d80cde893a6897f8e6543c2d7666b73d7a":["f2ae7e371df56ccde467b71db7e82066f05a5972"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2f479a58780f0a2a9c1c6f7202207a75d094cd9":["e70df4d80cde893a6897f8e6543c2d7666b73d7a"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["4f9543b93c856b40e808833973fa6ac9773b88e3","2e8428426152984b387a961487efefbe9cf62acf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"]},"commit2Childs":{"f2ae7e371df56ccde467b71db7e82066f05a5972":["e70df4d80cde893a6897f8e6543c2d7666b73d7a"],"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd":["ba3abc2c7b1d377e50611d0c03245d1526c73863"],"28ac5cee8abf30398e12bc016a5ce9d441831a63":["2e8428426152984b387a961487efefbe9cf62acf"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"ba3abc2c7b1d377e50611d0c03245d1526c73863":["f2ae7e371df56ccde467b71db7e82066f05a5972"],"2e8428426152984b387a961487efefbe9cf62acf":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"4f9543b93c856b40e808833973fa6ac9773b88e3":["28ac5cee8abf30398e12bc016a5ce9d441831a63","37a0f60745e53927c4c876cfe5b5a58170f0646c","3cc728b07df73b197e6d940d27f9b08b63918f13"],"416910ae9ffe752ba5b6334f75d6c36e019626cc":["37a0f60745e53927c4c876cfe5b5a58170f0646c","4f9543b93c856b40e808833973fa6ac9773b88e3"],"378fbd2626d3f584f8146e25acf62ee817361580":["416910ae9ffe752ba5b6334f75d6c36e019626cc"],"e70df4d80cde893a6897f8e6543c2d7666b73d7a":["e2f479a58780f0a2a9c1c6f7202207a75d094cd9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"e2f479a58780f0a2a9c1c6f7202207a75d094cd9":["378fbd2626d3f584f8146e25acf62ee817361580"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}