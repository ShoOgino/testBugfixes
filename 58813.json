{"path":"solr/core/src/test/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice#validateIntegrityAndSetLength(File,long).mjava","commits":[{"id":"44ca189138a5b6e1989d12ab992fab60e235ddc7","date":1549051496,"type":0,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice#validateIntegrityAndSetLength(File,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Find out the number of bytes in the block that match its crc.\n   *\n   * This algorithm assumes that data corruption caused by unexpected\n   * datanode shutdown occurs only in the last crc chunk. So it checks\n   * only the last chunk.\n   *\n   * @param blockFile the block file\n   * @param genStamp generation stamp of the block\n   * @return the number of valid bytes\n   */\n  private long validateIntegrityAndSetLength(File blockFile, long genStamp) {\n    try {\n      final File metaFile = FsDatasetUtil.getMetaFile(blockFile, genStamp);\n      long blockFileLen = blockFile.length();\n      long metaFileLen = metaFile.length();\n      int crcHeaderLen = DataChecksum.getChecksumHeaderSize();\n      if (!blockFile.exists() || blockFileLen == 0 ||\n          !metaFile.exists() || metaFileLen < crcHeaderLen) {\n        return 0;\n      }\n      try (DataInputStream checksumIn = new DataInputStream(\n          new BufferedInputStream(\n              fileIoProvider.getFileInputStream(volume, metaFile),\n              ioFileBufferSize))) {\n        // read and handle the common header here. For now just a version\n        final DataChecksum checksum = BlockMetadataHeader.readDataChecksum(\n            checksumIn, metaFile);\n        int bytesPerChecksum = checksum.getBytesPerChecksum();\n        int checksumSize = checksum.getChecksumSize();\n        long numChunks = Math.min(\n            (blockFileLen + bytesPerChecksum - 1) / bytesPerChecksum,\n            (metaFileLen - crcHeaderLen) / checksumSize);\n        if (numChunks == 0) {\n          return 0;\n        }\n        try (InputStream blockIn = fileIoProvider.getFileInputStream(\n            volume, blockFile);\n             ReplicaInputStreams ris = new ReplicaInputStreams(blockIn,\n                 checksumIn, volume.obtainReference(), fileIoProvider)) {\n          ris.skipChecksumFully((numChunks - 1) * checksumSize);\n          long lastChunkStartPos = (numChunks - 1) * bytesPerChecksum;\n          ris.skipDataFully(lastChunkStartPos);\n          int lastChunkSize = (int) Math.min(\n              bytesPerChecksum, blockFileLen - lastChunkStartPos);\n          byte[] buf = new byte[lastChunkSize + checksumSize];\n          ris.readChecksumFully(buf, lastChunkSize, checksumSize);\n          ris.readDataFully(buf, 0, lastChunkSize);\n          checksum.update(buf, 0, lastChunkSize);\n          long validFileLength;\n          if (checksum.compare(buf, lastChunkSize)) { // last chunk matches crc\n            validFileLength = lastChunkStartPos + lastChunkSize;\n          } else { // last chunk is corrupt\n            validFileLength = lastChunkStartPos;\n          }\n          // truncate if extra bytes are present without CRC\n          if (blockFile.length() > validFileLength) {\n            try (RandomAccessFile blockRAF =\n                     fileIoProvider.getRandomAccessFile(\n                         volume, blockFile, \"rw\")) {\n              // truncate blockFile\n              blockRAF.setLength(validFileLength);\n            }\n          }\n          return validFileLength;\n        }\n      }\n    } catch (IOException e) {\n      FsDatasetImpl.LOG.warn(\"Getting exception while validating integrity \" +\n          \"and setting length for blockFile\", e);\n      return 0;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"44ca189138a5b6e1989d12ab992fab60e235ddc7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["44ca189138a5b6e1989d12ab992fab60e235ddc7"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["44ca189138a5b6e1989d12ab992fab60e235ddc7"],"44ca189138a5b6e1989d12ab992fab60e235ddc7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}