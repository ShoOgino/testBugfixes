{"path":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.TermsWriter#writeBlocks(IntsRef,int,int).mjava","commits":[{"id":"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","date":1400786907,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.TermsWriter#writeBlocks(IntsRef,int,int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.TermsWriter#writeBlocks(IntsRef,int,int).mjava","sourceNew":"    void writeBlocks(IntsRef prevTerm, int prefixLength, int count) throws IOException {\n      if (count <= maxItemsInBlock) {\n        // Easy case: not floor block.  Eg, prefix is \"foo\",\n        // and we found 30 terms/sub-blocks starting w/ that\n        // prefix, and minItemsInBlock <= 30 <=\n        // maxItemsInBlock.\n        final PendingBlock nonFloorBlock = writeBlock(prevTerm, prefixLength, prefixLength, count, count, 0, false, -1, true);\n        nonFloorBlock.compileIndex(null, scratchBytes);\n        pending.add(nonFloorBlock);\n      } else {\n        // Floor block case.  Eg, prefix is \"foo\" but we\n        // have 100 terms/sub-blocks starting w/ that\n        // prefix.  We segment the entries into a primary\n        // block and following floor blocks using the first\n        // label in the suffix to assign to floor blocks.\n\n        // TODO: we could store min & max suffix start byte\n        // in each block, to make floor blocks authoritative\n\n        /*\n        if (DEBUG) {\n          final BytesRef prefix = new BytesRef(prefixLength);\n          for(int m=0;m<prefixLength;m++) {\n            prefix.bytes[m] = (byte) prevTerm.ints[m];\n          }\n          prefix.length = prefixLength;\n          //System.out.println(\"\\nWBS count=\" + count + \" prefix=\" + prefix.utf8ToString() + \" \" + prefix);\n          System.out.println(\"writeBlocks: prefix=\" + toString(prefix) + \" \" + prefix + \" count=\" + count + \" pending.size()=\" + pending.size());\n        }\n        */\n        //System.out.println(\"\\nwbs count=\" + count);\n\n        final int savLabel = prevTerm.ints[prevTerm.offset + prefixLength];\n\n        // Count up how many items fall under\n        // each unique label after the prefix.\n        \n        // TODO: this is wasteful since the builder had\n        // already done this (partitioned these sub-terms\n        // according to their leading prefix byte)\n        \n        final List<PendingEntry> slice = pending.subList(pending.size()-count, pending.size());\n        int lastSuffixLeadLabel = -1;\n        int termCount = 0;\n        int subCount = 0;\n        int numSubs = 0;\n\n        for(PendingEntry ent : slice) {\n\n          // First byte in the suffix of this term\n          final int suffixLeadLabel;\n          if (ent.isTerm) {\n            PendingTerm term = (PendingTerm) ent;\n            if (term.term.length == prefixLength) {\n              // Suffix is 0, ie prefix 'foo' and term is\n              // 'foo' so the term has empty string suffix\n              // in this block\n              assert lastSuffixLeadLabel == -1;\n              assert numSubs == 0;\n              suffixLeadLabel = -1;\n            } else {\n              suffixLeadLabel = term.term.bytes[term.term.offset + prefixLength] & 0xff;\n            }\n          } else {\n            PendingBlock block = (PendingBlock) ent;\n            assert block.prefix.length > prefixLength;\n            suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n          }\n\n          if (suffixLeadLabel != lastSuffixLeadLabel && (termCount + subCount) != 0) {\n            if (subBytes.length == numSubs) {\n              subBytes = ArrayUtil.grow(subBytes);\n              subTermCounts = ArrayUtil.grow(subTermCounts);\n              subSubCounts = ArrayUtil.grow(subSubCounts);\n            }\n            subBytes[numSubs] = lastSuffixLeadLabel;\n            lastSuffixLeadLabel = suffixLeadLabel;\n            subTermCounts[numSubs] = termCount;\n            subSubCounts[numSubs] = subCount;\n            /*\n            if (suffixLeadLabel == -1) {\n              System.out.println(\"  sub \" + -1 + \" termCount=\" + termCount + \" subCount=\" + subCount);\n            } else {\n              System.out.println(\"  sub \" + Integer.toHexString(suffixLeadLabel) + \" termCount=\" + termCount + \" subCount=\" + subCount);\n            }\n            */\n            termCount = subCount = 0;\n            numSubs++;\n          }\n\n          if (ent.isTerm) {\n            termCount++;\n          } else {\n            subCount++;\n          }\n        }\n\n        if (subBytes.length == numSubs) {\n          subBytes = ArrayUtil.grow(subBytes);\n          subTermCounts = ArrayUtil.grow(subTermCounts);\n          subSubCounts = ArrayUtil.grow(subSubCounts);\n        }\n\n        subBytes[numSubs] = lastSuffixLeadLabel;\n        subTermCounts[numSubs] = termCount;\n        subSubCounts[numSubs] = subCount;\n        numSubs++;\n        /*\n        if (lastSuffixLeadLabel == -1) {\n          System.out.println(\"  sub \" + -1 + \" termCount=\" + termCount + \" subCount=\" + subCount);\n        } else {\n          System.out.println(\"  sub \" + Integer.toHexString(lastSuffixLeadLabel) + \" termCount=\" + termCount + \" subCount=\" + subCount);\n        }\n        */\n\n        if (subTermCountSums.length < numSubs) {\n          subTermCountSums = ArrayUtil.grow(subTermCountSums, numSubs);\n        }\n\n        // Roll up (backwards) the termCounts; postings impl\n        // needs this to know where to pull the term slice\n        // from its pending terms stack:\n        int sum = 0;\n        for(int idx=numSubs-1;idx>=0;idx--) {\n          sum += subTermCounts[idx];\n          subTermCountSums[idx] = sum;\n        }\n\n        // TODO: make a better segmenter?  It'd have to\n        // absorb the too-small end blocks backwards into\n        // the previous blocks\n\n        // Naive greedy segmentation; this is not always\n        // best (it can produce a too-small block as the\n        // last block):\n        int pendingCount = 0;\n        int startLabel = subBytes[0];\n        int curStart = count;\n        subCount = 0;\n\n        final List<PendingBlock> floorBlocks = new ArrayList<>();\n        PendingBlock firstBlock = null;\n\n        for(int sub=0;sub<numSubs;sub++) {\n          pendingCount += subTermCounts[sub] + subSubCounts[sub];\n          //System.out.println(\"  \" + (subTermCounts[sub] + subSubCounts[sub]));\n          subCount++;\n\n          // Greedily make a floor block as soon as we've\n          // crossed the min count\n          if (pendingCount >= minItemsInBlock) {\n            final int curPrefixLength;\n            if (startLabel == -1) {\n              curPrefixLength = prefixLength;\n            } else {\n              curPrefixLength = 1+prefixLength;\n              // floor term:\n              prevTerm.ints[prevTerm.offset + prefixLength] = startLabel;\n            }\n            //System.out.println(\"  \" + subCount + \" subs\");\n            final PendingBlock floorBlock = writeBlock(prevTerm, prefixLength, curPrefixLength, curStart, pendingCount, subTermCountSums[1+sub], true, startLabel, curStart == pendingCount);\n            if (firstBlock == null) {\n              firstBlock = floorBlock;\n            } else {\n              floorBlocks.add(floorBlock);\n            }\n            curStart -= pendingCount;\n            //System.out.println(\"    = \" + pendingCount);\n            pendingCount = 0;\n\n            assert minItemsInBlock == 1 || subCount > 1: \"minItemsInBlock=\" + minItemsInBlock + \" subCount=\" + subCount + \" sub=\" + sub + \" of \" + numSubs + \" subTermCount=\" + subTermCountSums[sub] + \" subSubCount=\" + subSubCounts[sub] + \" depth=\" + prefixLength;\n            subCount = 0;\n            startLabel = subBytes[sub+1];\n\n            if (curStart == 0) {\n              break;\n            }\n\n            if (curStart <= maxItemsInBlock) {\n              // remainder is small enough to fit into a\n              // block.  NOTE that this may be too small (<\n              // minItemsInBlock); need a true segmenter\n              // here\n              assert startLabel != -1;\n              assert firstBlock != null;\n              prevTerm.ints[prevTerm.offset + prefixLength] = startLabel;\n              //System.out.println(\"  final \" + (numSubs-sub-1) + \" subs\");\n              /*\n              for(sub++;sub < numSubs;sub++) {\n                System.out.println(\"  \" + (subTermCounts[sub] + subSubCounts[sub]));\n              }\n              System.out.println(\"    = \" + curStart);\n              if (curStart < minItemsInBlock) {\n                System.out.println(\"      **\");\n              }\n              */\n              floorBlocks.add(writeBlock(prevTerm, prefixLength, prefixLength+1, curStart, curStart, 0, true, startLabel, true));\n              break;\n            }\n          }\n        }\n\n        prevTerm.ints[prevTerm.offset + prefixLength] = savLabel;\n\n        assert firstBlock != null;\n        firstBlock.compileIndex(floorBlocks, scratchBytes);\n\n        pending.add(firstBlock);\n        //if (DEBUG) System.out.println(\"  done pending.size()=\" + pending.size());\n      }\n      lastBlockIndex = pending.size()-1;\n    }\n\n","sourceOld":"    void writeBlocks(IntsRef prevTerm, int prefixLength, int count) throws IOException {\n      if (count <= maxItemsInBlock) {\n        // Easy case: not floor block.  Eg, prefix is \"foo\",\n        // and we found 30 terms/sub-blocks starting w/ that\n        // prefix, and minItemsInBlock <= 30 <=\n        // maxItemsInBlock.\n        final PendingBlock nonFloorBlock = writeBlock(prevTerm, prefixLength, prefixLength, count, count, 0, false, -1, true);\n        nonFloorBlock.compileIndex(null, scratchBytes);\n        pending.add(nonFloorBlock);\n      } else {\n        // Floor block case.  Eg, prefix is \"foo\" but we\n        // have 100 terms/sub-blocks starting w/ that\n        // prefix.  We segment the entries into a primary\n        // block and following floor blocks using the first\n        // label in the suffix to assign to floor blocks.\n\n        // TODO: we could store min & max suffix start byte\n        // in each block, to make floor blocks authoritative\n\n        /*\n        if (DEBUG) {\n          final BytesRef prefix = new BytesRef(prefixLength);\n          for(int m=0;m<prefixLength;m++) {\n            prefix.bytes[m] = (byte) prevTerm.ints[m];\n          }\n          prefix.length = prefixLength;\n          //System.out.println(\"\\nWBS count=\" + count + \" prefix=\" + prefix.utf8ToString() + \" \" + prefix);\n          System.out.println(\"writeBlocks: prefix=\" + toString(prefix) + \" \" + prefix + \" count=\" + count + \" pending.size()=\" + pending.size());\n        }\n        */\n        //System.out.println(\"\\nwbs count=\" + count);\n\n        final int savLabel = prevTerm.ints[prevTerm.offset + prefixLength];\n\n        // Count up how many items fall under\n        // each unique label after the prefix.\n        \n        // TODO: this is wasteful since the builder had\n        // already done this (partitioned these sub-terms\n        // according to their leading prefix byte)\n        \n        final List<PendingEntry> slice = pending.subList(pending.size()-count, pending.size());\n        int lastSuffixLeadLabel = -1;\n        int termCount = 0;\n        int subCount = 0;\n        int numSubs = 0;\n\n        for(PendingEntry ent : slice) {\n\n          // First byte in the suffix of this term\n          final int suffixLeadLabel;\n          if (ent.isTerm) {\n            PendingTerm term = (PendingTerm) ent;\n            if (term.term.length == prefixLength) {\n              // Suffix is 0, ie prefix 'foo' and term is\n              // 'foo' so the term has empty string suffix\n              // in this block\n              assert lastSuffixLeadLabel == -1;\n              assert numSubs == 0;\n              suffixLeadLabel = -1;\n            } else {\n              suffixLeadLabel = term.term.bytes[term.term.offset + prefixLength] & 0xff;\n            }\n          } else {\n            PendingBlock block = (PendingBlock) ent;\n            assert block.prefix.length > prefixLength;\n            suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n          }\n\n          if (suffixLeadLabel != lastSuffixLeadLabel && (termCount + subCount) != 0) {\n            if (subBytes.length == numSubs) {\n              subBytes = ArrayUtil.grow(subBytes);\n              subTermCounts = ArrayUtil.grow(subTermCounts);\n              subSubCounts = ArrayUtil.grow(subSubCounts);\n            }\n            subBytes[numSubs] = lastSuffixLeadLabel;\n            lastSuffixLeadLabel = suffixLeadLabel;\n            subTermCounts[numSubs] = termCount;\n            subSubCounts[numSubs] = subCount;\n            /*\n            if (suffixLeadLabel == -1) {\n              System.out.println(\"  sub \" + -1 + \" termCount=\" + termCount + \" subCount=\" + subCount);\n            } else {\n              System.out.println(\"  sub \" + Integer.toHexString(suffixLeadLabel) + \" termCount=\" + termCount + \" subCount=\" + subCount);\n            }\n            */\n            termCount = subCount = 0;\n            numSubs++;\n          }\n\n          if (ent.isTerm) {\n            termCount++;\n          } else {\n            subCount++;\n          }\n        }\n\n        if (subBytes.length == numSubs) {\n          subBytes = ArrayUtil.grow(subBytes);\n          subTermCounts = ArrayUtil.grow(subTermCounts);\n          subSubCounts = ArrayUtil.grow(subSubCounts);\n        }\n\n        subBytes[numSubs] = lastSuffixLeadLabel;\n        subTermCounts[numSubs] = termCount;\n        subSubCounts[numSubs] = subCount;\n        numSubs++;\n        /*\n        if (lastSuffixLeadLabel == -1) {\n          System.out.println(\"  sub \" + -1 + \" termCount=\" + termCount + \" subCount=\" + subCount);\n        } else {\n          System.out.println(\"  sub \" + Integer.toHexString(lastSuffixLeadLabel) + \" termCount=\" + termCount + \" subCount=\" + subCount);\n        }\n        */\n\n        if (subTermCountSums.length < numSubs) {\n          subTermCountSums = ArrayUtil.grow(subTermCountSums, numSubs);\n        }\n\n        // Roll up (backwards) the termCounts; postings impl\n        // needs this to know where to pull the term slice\n        // from its pending terms stack:\n        int sum = 0;\n        for(int idx=numSubs-1;idx>=0;idx--) {\n          sum += subTermCounts[idx];\n          subTermCountSums[idx] = sum;\n        }\n\n        // TODO: make a better segmenter?  It'd have to\n        // absorb the too-small end blocks backwards into\n        // the previous blocks\n\n        // Naive greedy segmentation; this is not always\n        // best (it can produce a too-small block as the\n        // last block):\n        int pendingCount = 0;\n        int startLabel = subBytes[0];\n        int curStart = count;\n        subCount = 0;\n\n        final List<PendingBlock> floorBlocks = new ArrayList<>();\n        PendingBlock firstBlock = null;\n\n        for(int sub=0;sub<numSubs;sub++) {\n          pendingCount += subTermCounts[sub] + subSubCounts[sub];\n          //System.out.println(\"  \" + (subTermCounts[sub] + subSubCounts[sub]));\n          subCount++;\n\n          // Greedily make a floor block as soon as we've\n          // crossed the min count\n          if (pendingCount >= minItemsInBlock) {\n            final int curPrefixLength;\n            if (startLabel == -1) {\n              curPrefixLength = prefixLength;\n            } else {\n              curPrefixLength = 1+prefixLength;\n              // floor term:\n              prevTerm.ints[prevTerm.offset + prefixLength] = startLabel;\n            }\n            //System.out.println(\"  \" + subCount + \" subs\");\n            final PendingBlock floorBlock = writeBlock(prevTerm, prefixLength, curPrefixLength, curStart, pendingCount, subTermCountSums[1+sub], true, startLabel, curStart == pendingCount);\n            if (firstBlock == null) {\n              firstBlock = floorBlock;\n            } else {\n              floorBlocks.add(floorBlock);\n            }\n            curStart -= pendingCount;\n            //System.out.println(\"    = \" + pendingCount);\n            pendingCount = 0;\n\n            assert minItemsInBlock == 1 || subCount > 1: \"minItemsInBlock=\" + minItemsInBlock + \" subCount=\" + subCount + \" sub=\" + sub + \" of \" + numSubs + \" subTermCount=\" + subTermCountSums[sub] + \" subSubCount=\" + subSubCounts[sub] + \" depth=\" + prefixLength;\n            subCount = 0;\n            startLabel = subBytes[sub+1];\n\n            if (curStart == 0) {\n              break;\n            }\n\n            if (curStart <= maxItemsInBlock) {\n              // remainder is small enough to fit into a\n              // block.  NOTE that this may be too small (<\n              // minItemsInBlock); need a true segmenter\n              // here\n              assert startLabel != -1;\n              assert firstBlock != null;\n              prevTerm.ints[prevTerm.offset + prefixLength] = startLabel;\n              //System.out.println(\"  final \" + (numSubs-sub-1) + \" subs\");\n              /*\n              for(sub++;sub < numSubs;sub++) {\n                System.out.println(\"  \" + (subTermCounts[sub] + subSubCounts[sub]));\n              }\n              System.out.println(\"    = \" + curStart);\n              if (curStart < minItemsInBlock) {\n                System.out.println(\"      **\");\n              }\n              */\n              floorBlocks.add(writeBlock(prevTerm, prefixLength, prefixLength+1, curStart, curStart, 0, true, startLabel, true));\n              break;\n            }\n          }\n        }\n\n        prevTerm.ints[prevTerm.offset + prefixLength] = savLabel;\n\n        assert firstBlock != null;\n        firstBlock.compileIndex(floorBlocks, scratchBytes);\n\n        pending.add(firstBlock);\n        //if (DEBUG) System.out.println(\"  done pending.size()=\" + pending.size());\n      }\n      lastBlockIndex = pending.size()-1;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d637064d608752565d4f9f41b2497dfdfdde50e","date":1400798123,"type":2,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.TermsWriter#writeBlocks(IntsRef,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsWriter.TermsWriter#writeBlocks(IntsRef,int,int).mjava","sourceNew":"    void writeBlocks(IntsRef prevTerm, int prefixLength, int count) throws IOException {\n      if (count <= maxItemsInBlock) {\n        // Easy case: not floor block.  Eg, prefix is \"foo\",\n        // and we found 30 terms/sub-blocks starting w/ that\n        // prefix, and minItemsInBlock <= 30 <=\n        // maxItemsInBlock.\n        final PendingBlock nonFloorBlock = writeBlock(prevTerm, prefixLength, prefixLength, count, count, 0, false, -1, true);\n        nonFloorBlock.compileIndex(null, scratchBytes);\n        pending.add(nonFloorBlock);\n      } else {\n        // Floor block case.  Eg, prefix is \"foo\" but we\n        // have 100 terms/sub-blocks starting w/ that\n        // prefix.  We segment the entries into a primary\n        // block and following floor blocks using the first\n        // label in the suffix to assign to floor blocks.\n\n        // TODO: we could store min & max suffix start byte\n        // in each block, to make floor blocks authoritative\n\n        /*\n        if (DEBUG) {\n          final BytesRef prefix = new BytesRef(prefixLength);\n          for(int m=0;m<prefixLength;m++) {\n            prefix.bytes[m] = (byte) prevTerm.ints[m];\n          }\n          prefix.length = prefixLength;\n          //System.out.println(\"\\nWBS count=\" + count + \" prefix=\" + prefix.utf8ToString() + \" \" + prefix);\n          System.out.println(\"writeBlocks: prefix=\" + toString(prefix) + \" \" + prefix + \" count=\" + count + \" pending.size()=\" + pending.size());\n        }\n        */\n        //System.out.println(\"\\nwbs count=\" + count);\n\n        final int savLabel = prevTerm.ints[prevTerm.offset + prefixLength];\n\n        // Count up how many items fall under\n        // each unique label after the prefix.\n        \n        // TODO: this is wasteful since the builder had\n        // already done this (partitioned these sub-terms\n        // according to their leading prefix byte)\n        \n        final List<PendingEntry> slice = pending.subList(pending.size()-count, pending.size());\n        int lastSuffixLeadLabel = -1;\n        int termCount = 0;\n        int subCount = 0;\n        int numSubs = 0;\n\n        for(PendingEntry ent : slice) {\n\n          // First byte in the suffix of this term\n          final int suffixLeadLabel;\n          if (ent.isTerm) {\n            PendingTerm term = (PendingTerm) ent;\n            if (term.term.length == prefixLength) {\n              // Suffix is 0, ie prefix 'foo' and term is\n              // 'foo' so the term has empty string suffix\n              // in this block\n              assert lastSuffixLeadLabel == -1;\n              assert numSubs == 0;\n              suffixLeadLabel = -1;\n            } else {\n              suffixLeadLabel = term.term.bytes[term.term.offset + prefixLength] & 0xff;\n            }\n          } else {\n            PendingBlock block = (PendingBlock) ent;\n            assert block.prefix.length > prefixLength;\n            suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n          }\n\n          if (suffixLeadLabel != lastSuffixLeadLabel && (termCount + subCount) != 0) {\n            if (subBytes.length == numSubs) {\n              subBytes = ArrayUtil.grow(subBytes);\n              subTermCounts = ArrayUtil.grow(subTermCounts);\n              subSubCounts = ArrayUtil.grow(subSubCounts);\n            }\n            subBytes[numSubs] = lastSuffixLeadLabel;\n            lastSuffixLeadLabel = suffixLeadLabel;\n            subTermCounts[numSubs] = termCount;\n            subSubCounts[numSubs] = subCount;\n            /*\n            if (suffixLeadLabel == -1) {\n              System.out.println(\"  sub \" + -1 + \" termCount=\" + termCount + \" subCount=\" + subCount);\n            } else {\n              System.out.println(\"  sub \" + Integer.toHexString(suffixLeadLabel) + \" termCount=\" + termCount + \" subCount=\" + subCount);\n            }\n            */\n            termCount = subCount = 0;\n            numSubs++;\n          }\n\n          if (ent.isTerm) {\n            termCount++;\n          } else {\n            subCount++;\n          }\n        }\n\n        if (subBytes.length == numSubs) {\n          subBytes = ArrayUtil.grow(subBytes);\n          subTermCounts = ArrayUtil.grow(subTermCounts);\n          subSubCounts = ArrayUtil.grow(subSubCounts);\n        }\n\n        subBytes[numSubs] = lastSuffixLeadLabel;\n        subTermCounts[numSubs] = termCount;\n        subSubCounts[numSubs] = subCount;\n        numSubs++;\n        /*\n        if (lastSuffixLeadLabel == -1) {\n          System.out.println(\"  sub \" + -1 + \" termCount=\" + termCount + \" subCount=\" + subCount);\n        } else {\n          System.out.println(\"  sub \" + Integer.toHexString(lastSuffixLeadLabel) + \" termCount=\" + termCount + \" subCount=\" + subCount);\n        }\n        */\n\n        if (subTermCountSums.length < numSubs) {\n          subTermCountSums = ArrayUtil.grow(subTermCountSums, numSubs);\n        }\n\n        // Roll up (backwards) the termCounts; postings impl\n        // needs this to know where to pull the term slice\n        // from its pending terms stack:\n        int sum = 0;\n        for(int idx=numSubs-1;idx>=0;idx--) {\n          sum += subTermCounts[idx];\n          subTermCountSums[idx] = sum;\n        }\n\n        // TODO: make a better segmenter?  It'd have to\n        // absorb the too-small end blocks backwards into\n        // the previous blocks\n\n        // Naive greedy segmentation; this is not always\n        // best (it can produce a too-small block as the\n        // last block):\n        int pendingCount = 0;\n        int startLabel = subBytes[0];\n        int curStart = count;\n        subCount = 0;\n\n        final List<PendingBlock> floorBlocks = new ArrayList<>();\n        PendingBlock firstBlock = null;\n\n        for(int sub=0;sub<numSubs;sub++) {\n          pendingCount += subTermCounts[sub] + subSubCounts[sub];\n          //System.out.println(\"  \" + (subTermCounts[sub] + subSubCounts[sub]));\n          subCount++;\n\n          // Greedily make a floor block as soon as we've\n          // crossed the min count\n          if (pendingCount >= minItemsInBlock) {\n            final int curPrefixLength;\n            if (startLabel == -1) {\n              curPrefixLength = prefixLength;\n            } else {\n              curPrefixLength = 1+prefixLength;\n              // floor term:\n              prevTerm.ints[prevTerm.offset + prefixLength] = startLabel;\n            }\n            //System.out.println(\"  \" + subCount + \" subs\");\n            final PendingBlock floorBlock = writeBlock(prevTerm, prefixLength, curPrefixLength, curStart, pendingCount, subTermCountSums[1+sub], true, startLabel, curStart == pendingCount);\n            if (firstBlock == null) {\n              firstBlock = floorBlock;\n            } else {\n              floorBlocks.add(floorBlock);\n            }\n            curStart -= pendingCount;\n            //System.out.println(\"    = \" + pendingCount);\n            pendingCount = 0;\n\n            assert minItemsInBlock == 1 || subCount > 1: \"minItemsInBlock=\" + minItemsInBlock + \" subCount=\" + subCount + \" sub=\" + sub + \" of \" + numSubs + \" subTermCount=\" + subTermCountSums[sub] + \" subSubCount=\" + subSubCounts[sub] + \" depth=\" + prefixLength;\n            subCount = 0;\n            startLabel = subBytes[sub+1];\n\n            if (curStart == 0) {\n              break;\n            }\n\n            if (curStart <= maxItemsInBlock) {\n              // remainder is small enough to fit into a\n              // block.  NOTE that this may be too small (<\n              // minItemsInBlock); need a true segmenter\n              // here\n              assert startLabel != -1;\n              assert firstBlock != null;\n              prevTerm.ints[prevTerm.offset + prefixLength] = startLabel;\n              //System.out.println(\"  final \" + (numSubs-sub-1) + \" subs\");\n              /*\n              for(sub++;sub < numSubs;sub++) {\n                System.out.println(\"  \" + (subTermCounts[sub] + subSubCounts[sub]));\n              }\n              System.out.println(\"    = \" + curStart);\n              if (curStart < minItemsInBlock) {\n                System.out.println(\"      **\");\n              }\n              */\n              floorBlocks.add(writeBlock(prevTerm, prefixLength, prefixLength+1, curStart, curStart, 0, true, startLabel, true));\n              break;\n            }\n          }\n        }\n\n        prevTerm.ints[prevTerm.offset + prefixLength] = savLabel;\n\n        assert firstBlock != null;\n        firstBlock.compileIndex(floorBlocks, scratchBytes);\n\n        pending.add(firstBlock);\n        //if (DEBUG) System.out.println(\"  done pending.size()=\" + pending.size());\n      }\n      lastBlockIndex = pending.size()-1;\n    }\n\n","sourceOld":"    void writeBlocks(IntsRef prevTerm, int prefixLength, int count) throws IOException {\n      if (prefixLength == 0 || count <= maxItemsInBlock) {\n        // Easy case: not floor block.  Eg, prefix is \"foo\",\n        // and we found 30 terms/sub-blocks starting w/ that\n        // prefix, and minItemsInBlock <= 30 <=\n        // maxItemsInBlock.\n        final PendingBlock nonFloorBlock = writeBlock(prevTerm, prefixLength, prefixLength, count, count, 0, false, -1, true);\n        nonFloorBlock.compileIndex(null, scratchBytes);\n        pending.add(nonFloorBlock);\n      } else {\n        // Floor block case.  Eg, prefix is \"foo\" but we\n        // have 100 terms/sub-blocks starting w/ that\n        // prefix.  We segment the entries into a primary\n        // block and following floor blocks using the first\n        // label in the suffix to assign to floor blocks.\n\n        // TODO: we could store min & max suffix start byte\n        // in each block, to make floor blocks authoritative\n\n        //if (DEBUG) {\n        //  final BytesRef prefix = new BytesRef(prefixLength);\n        //  for(int m=0;m<prefixLength;m++) {\n        //    prefix.bytes[m] = (byte) prevTerm.ints[m];\n        //  }\n        //  prefix.length = prefixLength;\n        //  //System.out.println(\"\\nWBS count=\" + count + \" prefix=\" + prefix.utf8ToString() + \" \" + prefix);\n        //  System.out.println(\"writeBlocks: prefix=\" + prefix + \" \" + prefix + \" count=\" + count + \" pending.size()=\" + pending.size());\n        //}\n        //System.out.println(\"\\nwbs count=\" + count);\n\n        final int savLabel = prevTerm.ints[prevTerm.offset + prefixLength];\n\n        // Count up how many items fall under\n        // each unique label after the prefix.\n        \n        // TODO: this is wasteful since the builder had\n        // already done this (partitioned these sub-terms\n        // according to their leading prefix byte)\n        \n        final List<PendingEntry> slice = pending.subList(pending.size()-count, pending.size());\n        int lastSuffixLeadLabel = -1;\n        int termCount = 0;\n        int subCount = 0;\n        int numSubs = 0;\n\n        for(PendingEntry ent : slice) {\n\n          // First byte in the suffix of this term\n          final int suffixLeadLabel;\n          if (ent.isTerm) {\n            PendingTerm term = (PendingTerm) ent;\n            if (term.term.length == prefixLength) {\n              // Suffix is 0, ie prefix 'foo' and term is\n              // 'foo' so the term has empty string suffix\n              // in this block\n              assert lastSuffixLeadLabel == -1;\n              assert numSubs == 0;\n              suffixLeadLabel = -1;\n            } else {\n              suffixLeadLabel = term.term.bytes[term.term.offset + prefixLength] & 0xff;\n            }\n          } else {\n            PendingBlock block = (PendingBlock) ent;\n            assert block.prefix.length > prefixLength;\n            suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n          }\n\n          if (suffixLeadLabel != lastSuffixLeadLabel && (termCount + subCount) != 0) {\n            if (subBytes.length == numSubs) {\n              subBytes = ArrayUtil.grow(subBytes);\n              subTermCounts = ArrayUtil.grow(subTermCounts);\n              subSubCounts = ArrayUtil.grow(subSubCounts);\n            }\n            subBytes[numSubs] = lastSuffixLeadLabel;\n            lastSuffixLeadLabel = suffixLeadLabel;\n            subTermCounts[numSubs] = termCount;\n            subSubCounts[numSubs] = subCount;\n            /*\n            if (suffixLeadLabel == -1) {\n              System.out.println(\"  sub \" + -1 + \" termCount=\" + termCount + \" subCount=\" + subCount);\n            } else {\n              System.out.println(\"  sub \" + Integer.toHexString(suffixLeadLabel) + \" termCount=\" + termCount + \" subCount=\" + subCount);\n            }\n            */\n            termCount = subCount = 0;\n            numSubs++;\n          }\n\n          if (ent.isTerm) {\n            termCount++;\n          } else {\n            subCount++;\n          }\n        }\n\n        if (subBytes.length == numSubs) {\n          subBytes = ArrayUtil.grow(subBytes);\n          subTermCounts = ArrayUtil.grow(subTermCounts);\n          subSubCounts = ArrayUtil.grow(subSubCounts);\n        }\n\n        subBytes[numSubs] = lastSuffixLeadLabel;\n        subTermCounts[numSubs] = termCount;\n        subSubCounts[numSubs] = subCount;\n        numSubs++;\n        /*\n        if (lastSuffixLeadLabel == -1) {\n          System.out.println(\"  sub \" + -1 + \" termCount=\" + termCount + \" subCount=\" + subCount);\n        } else {\n          System.out.println(\"  sub \" + Integer.toHexString(lastSuffixLeadLabel) + \" termCount=\" + termCount + \" subCount=\" + subCount);\n        }\n        */\n\n        if (subTermCountSums.length < numSubs) {\n          subTermCountSums = ArrayUtil.grow(subTermCountSums, numSubs);\n        }\n\n        // Roll up (backwards) the termCounts; postings impl\n        // needs this to know where to pull the term slice\n        // from its pending terms stack:\n        int sum = 0;\n        for(int idx=numSubs-1;idx>=0;idx--) {\n          sum += subTermCounts[idx];\n          subTermCountSums[idx] = sum;\n        }\n\n        // TODO: make a better segmenter?  It'd have to\n        // absorb the too-small end blocks backwards into\n        // the previous blocks\n\n        // Naive greedy segmentation; this is not always\n        // best (it can produce a too-small block as the\n        // last block):\n        int pendingCount = 0;\n        int startLabel = subBytes[0];\n        int curStart = count;\n        subCount = 0;\n\n        final List<PendingBlock> floorBlocks = new ArrayList<>();\n        PendingBlock firstBlock = null;\n\n        for(int sub=0;sub<numSubs;sub++) {\n          pendingCount += subTermCounts[sub] + subSubCounts[sub];\n          //System.out.println(\"  \" + (subTermCounts[sub] + subSubCounts[sub]));\n          subCount++;\n\n          // Greedily make a floor block as soon as we've\n          // crossed the min count\n          if (pendingCount >= minItemsInBlock) {\n            final int curPrefixLength;\n            if (startLabel == -1) {\n              curPrefixLength = prefixLength;\n            } else {\n              curPrefixLength = 1+prefixLength;\n              // floor term:\n              prevTerm.ints[prevTerm.offset + prefixLength] = startLabel;\n            }\n            //System.out.println(\"  \" + subCount + \" subs\");\n            final PendingBlock floorBlock = writeBlock(prevTerm, prefixLength, curPrefixLength, curStart, pendingCount, subTermCountSums[1+sub], true, startLabel, curStart == pendingCount);\n            if (firstBlock == null) {\n              firstBlock = floorBlock;\n            } else {\n              floorBlocks.add(floorBlock);\n            }\n            curStart -= pendingCount;\n            //System.out.println(\"    = \" + pendingCount);\n            pendingCount = 0;\n\n            assert minItemsInBlock == 1 || subCount > 1: \"minItemsInBlock=\" + minItemsInBlock + \" subCount=\" + subCount + \" sub=\" + sub + \" of \" + numSubs + \" subTermCount=\" + subTermCountSums[sub] + \" subSubCount=\" + subSubCounts[sub] + \" depth=\" + prefixLength;\n            subCount = 0;\n            startLabel = subBytes[sub+1];\n\n            if (curStart == 0) {\n              break;\n            }\n\n            if (curStart <= maxItemsInBlock) {\n              // remainder is small enough to fit into a\n              // block.  NOTE that this may be too small (<\n              // minItemsInBlock); need a true segmenter\n              // here\n              assert startLabel != -1;\n              assert firstBlock != null;\n              prevTerm.ints[prevTerm.offset + prefixLength] = startLabel;\n              //System.out.println(\"  final \" + (numSubs-sub-1) + \" subs\");\n              /*\n              for(sub++;sub < numSubs;sub++) {\n                System.out.println(\"  \" + (subTermCounts[sub] + subSubCounts[sub]));\n              }\n              System.out.println(\"    = \" + curStart);\n              if (curStart < minItemsInBlock) {\n                System.out.println(\"      **\");\n              }\n              */\n              floorBlocks.add(writeBlock(prevTerm, prefixLength, prefixLength+1, curStart, curStart, 0, true, startLabel, true));\n              break;\n            }\n          }\n        }\n\n        prevTerm.ints[prevTerm.offset + prefixLength] = savLabel;\n\n        assert firstBlock != null;\n        firstBlock.compileIndex(floorBlocks, scratchBytes);\n\n        pending.add(firstBlock);\n        //if (DEBUG) System.out.println(\"  done pending.size()=\" + pending.size());\n      }\n      lastBlockIndex = pending.size()-1;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f838187609fee3a1afa5f162f93c796046242c84","date":1406216791,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.TermsWriter#writeBlocks(IntsRef,int,int).mjava","sourceNew":null,"sourceOld":"    void writeBlocks(IntsRef prevTerm, int prefixLength, int count) throws IOException {\n      if (count <= maxItemsInBlock) {\n        // Easy case: not floor block.  Eg, prefix is \"foo\",\n        // and we found 30 terms/sub-blocks starting w/ that\n        // prefix, and minItemsInBlock <= 30 <=\n        // maxItemsInBlock.\n        final PendingBlock nonFloorBlock = writeBlock(prevTerm, prefixLength, prefixLength, count, count, 0, false, -1, true);\n        nonFloorBlock.compileIndex(null, scratchBytes);\n        pending.add(nonFloorBlock);\n      } else {\n        // Floor block case.  Eg, prefix is \"foo\" but we\n        // have 100 terms/sub-blocks starting w/ that\n        // prefix.  We segment the entries into a primary\n        // block and following floor blocks using the first\n        // label in the suffix to assign to floor blocks.\n\n        // TODO: we could store min & max suffix start byte\n        // in each block, to make floor blocks authoritative\n\n        /*\n        if (DEBUG) {\n          final BytesRef prefix = new BytesRef(prefixLength);\n          for(int m=0;m<prefixLength;m++) {\n            prefix.bytes[m] = (byte) prevTerm.ints[m];\n          }\n          prefix.length = prefixLength;\n          //System.out.println(\"\\nWBS count=\" + count + \" prefix=\" + prefix.utf8ToString() + \" \" + prefix);\n          System.out.println(\"writeBlocks: prefix=\" + toString(prefix) + \" \" + prefix + \" count=\" + count + \" pending.size()=\" + pending.size());\n        }\n        */\n        //System.out.println(\"\\nwbs count=\" + count);\n\n        final int savLabel = prevTerm.ints[prevTerm.offset + prefixLength];\n\n        // Count up how many items fall under\n        // each unique label after the prefix.\n        \n        // TODO: this is wasteful since the builder had\n        // already done this (partitioned these sub-terms\n        // according to their leading prefix byte)\n        \n        final List<PendingEntry> slice = pending.subList(pending.size()-count, pending.size());\n        int lastSuffixLeadLabel = -1;\n        int termCount = 0;\n        int subCount = 0;\n        int numSubs = 0;\n\n        for(PendingEntry ent : slice) {\n\n          // First byte in the suffix of this term\n          final int suffixLeadLabel;\n          if (ent.isTerm) {\n            PendingTerm term = (PendingTerm) ent;\n            if (term.term.length == prefixLength) {\n              // Suffix is 0, ie prefix 'foo' and term is\n              // 'foo' so the term has empty string suffix\n              // in this block\n              assert lastSuffixLeadLabel == -1;\n              assert numSubs == 0;\n              suffixLeadLabel = -1;\n            } else {\n              suffixLeadLabel = term.term.bytes[term.term.offset + prefixLength] & 0xff;\n            }\n          } else {\n            PendingBlock block = (PendingBlock) ent;\n            assert block.prefix.length > prefixLength;\n            suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n          }\n\n          if (suffixLeadLabel != lastSuffixLeadLabel && (termCount + subCount) != 0) {\n            if (subBytes.length == numSubs) {\n              subBytes = ArrayUtil.grow(subBytes);\n              subTermCounts = ArrayUtil.grow(subTermCounts);\n              subSubCounts = ArrayUtil.grow(subSubCounts);\n            }\n            subBytes[numSubs] = lastSuffixLeadLabel;\n            lastSuffixLeadLabel = suffixLeadLabel;\n            subTermCounts[numSubs] = termCount;\n            subSubCounts[numSubs] = subCount;\n            /*\n            if (suffixLeadLabel == -1) {\n              System.out.println(\"  sub \" + -1 + \" termCount=\" + termCount + \" subCount=\" + subCount);\n            } else {\n              System.out.println(\"  sub \" + Integer.toHexString(suffixLeadLabel) + \" termCount=\" + termCount + \" subCount=\" + subCount);\n            }\n            */\n            termCount = subCount = 0;\n            numSubs++;\n          }\n\n          if (ent.isTerm) {\n            termCount++;\n          } else {\n            subCount++;\n          }\n        }\n\n        if (subBytes.length == numSubs) {\n          subBytes = ArrayUtil.grow(subBytes);\n          subTermCounts = ArrayUtil.grow(subTermCounts);\n          subSubCounts = ArrayUtil.grow(subSubCounts);\n        }\n\n        subBytes[numSubs] = lastSuffixLeadLabel;\n        subTermCounts[numSubs] = termCount;\n        subSubCounts[numSubs] = subCount;\n        numSubs++;\n        /*\n        if (lastSuffixLeadLabel == -1) {\n          System.out.println(\"  sub \" + -1 + \" termCount=\" + termCount + \" subCount=\" + subCount);\n        } else {\n          System.out.println(\"  sub \" + Integer.toHexString(lastSuffixLeadLabel) + \" termCount=\" + termCount + \" subCount=\" + subCount);\n        }\n        */\n\n        if (subTermCountSums.length < numSubs) {\n          subTermCountSums = ArrayUtil.grow(subTermCountSums, numSubs);\n        }\n\n        // Roll up (backwards) the termCounts; postings impl\n        // needs this to know where to pull the term slice\n        // from its pending terms stack:\n        int sum = 0;\n        for(int idx=numSubs-1;idx>=0;idx--) {\n          sum += subTermCounts[idx];\n          subTermCountSums[idx] = sum;\n        }\n\n        // TODO: make a better segmenter?  It'd have to\n        // absorb the too-small end blocks backwards into\n        // the previous blocks\n\n        // Naive greedy segmentation; this is not always\n        // best (it can produce a too-small block as the\n        // last block):\n        int pendingCount = 0;\n        int startLabel = subBytes[0];\n        int curStart = count;\n        subCount = 0;\n\n        final List<PendingBlock> floorBlocks = new ArrayList<>();\n        PendingBlock firstBlock = null;\n\n        for(int sub=0;sub<numSubs;sub++) {\n          pendingCount += subTermCounts[sub] + subSubCounts[sub];\n          //System.out.println(\"  \" + (subTermCounts[sub] + subSubCounts[sub]));\n          subCount++;\n\n          // Greedily make a floor block as soon as we've\n          // crossed the min count\n          if (pendingCount >= minItemsInBlock) {\n            final int curPrefixLength;\n            if (startLabel == -1) {\n              curPrefixLength = prefixLength;\n            } else {\n              curPrefixLength = 1+prefixLength;\n              // floor term:\n              prevTerm.ints[prevTerm.offset + prefixLength] = startLabel;\n            }\n            //System.out.println(\"  \" + subCount + \" subs\");\n            final PendingBlock floorBlock = writeBlock(prevTerm, prefixLength, curPrefixLength, curStart, pendingCount, subTermCountSums[1+sub], true, startLabel, curStart == pendingCount);\n            if (firstBlock == null) {\n              firstBlock = floorBlock;\n            } else {\n              floorBlocks.add(floorBlock);\n            }\n            curStart -= pendingCount;\n            //System.out.println(\"    = \" + pendingCount);\n            pendingCount = 0;\n\n            assert minItemsInBlock == 1 || subCount > 1: \"minItemsInBlock=\" + minItemsInBlock + \" subCount=\" + subCount + \" sub=\" + sub + \" of \" + numSubs + \" subTermCount=\" + subTermCountSums[sub] + \" subSubCount=\" + subSubCounts[sub] + \" depth=\" + prefixLength;\n            subCount = 0;\n            startLabel = subBytes[sub+1];\n\n            if (curStart == 0) {\n              break;\n            }\n\n            if (curStart <= maxItemsInBlock) {\n              // remainder is small enough to fit into a\n              // block.  NOTE that this may be too small (<\n              // minItemsInBlock); need a true segmenter\n              // here\n              assert startLabel != -1;\n              assert firstBlock != null;\n              prevTerm.ints[prevTerm.offset + prefixLength] = startLabel;\n              //System.out.println(\"  final \" + (numSubs-sub-1) + \" subs\");\n              /*\n              for(sub++;sub < numSubs;sub++) {\n                System.out.println(\"  \" + (subTermCounts[sub] + subSubCounts[sub]));\n              }\n              System.out.println(\"    = \" + curStart);\n              if (curStart < minItemsInBlock) {\n                System.out.println(\"      **\");\n              }\n              */\n              floorBlocks.add(writeBlock(prevTerm, prefixLength, prefixLength+1, curStart, curStart, 0, true, startLabel, true));\n              break;\n            }\n          }\n        }\n\n        prevTerm.ints[prevTerm.offset + prefixLength] = savLabel;\n\n        assert firstBlock != null;\n        firstBlock.compileIndex(floorBlocks, scratchBytes);\n\n        pending.add(firstBlock);\n        //if (DEBUG) System.out.println(\"  done pending.size()=\" + pending.size());\n      }\n      lastBlockIndex = pending.size()-1;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f838187609fee3a1afa5f162f93c796046242c84":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f838187609fee3a1afa5f162f93c796046242c84"]},"commit2Childs":{"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["f838187609fee3a1afa5f162f93c796046242c84"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","4d637064d608752565d4f9f41b2497dfdfdde50e"],"f838187609fee3a1afa5f162f93c796046242c84":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}