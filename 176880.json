{"path":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","sourceNew":"  private void add(Dictionary dict, Position fromPosData, int endPos, int wordID, Type type, boolean addPenalty) throws IOException {\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost:\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) + \" leftID=\" + leftID);\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    if ((addPenalty || (!outputCompounds && searchMode)) && type != Type.USER) {\n      final int penalty = computePenalty(fromPosData.pos, endPos - fromPosData.pos);\n      if (VERBOSE) {\n        if (penalty > 0) {\n          System.out.println(\"        + penalty=\" + penalty + \" cost=\" + (leastCost+penalty));\n        }\n      }\n      leastCost += penalty;\n    }\n\n    //positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type);\n    assert leftID == dict.getRightId(wordID);\n    positions.get(endPos).add(leastCost, leftID, fromPosData.pos, leastIDX, wordID, type);\n  }\n\n","sourceOld":"  private void add(Dictionary dict, Position fromPosData, int endPos, int wordID, Type type, boolean addPenalty) throws IOException {\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost:\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) + \" leftID=\" + leftID);\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    if ((addPenalty || (!outputCompounds && searchMode)) && type != Type.USER) {\n      final int penalty = computePenalty(fromPosData.pos, endPos - fromPosData.pos);\n      if (VERBOSE) {\n        if (penalty > 0) {\n          System.out.println(\"        + penalty=\" + penalty + \" cost=\" + (leastCost+penalty));\n        }\n      }\n      leastCost += penalty;\n    }\n\n    //positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type);\n    assert leftID == dict.getRightId(wordID);\n    positions.get(endPos).add(leastCost, leftID, fromPosData.pos, leastIDX, wordID, type);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60380b37ed701033fb7211062affa5d9105428e1","date":1463046862,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","pathOld":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","sourceNew":"  private void add(Dictionary dict, Position fromPosData, int endPos, int wordID, Type type, boolean addPenalty) throws IOException {\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost:\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) + \" leftID=\" + leftID + \")\");\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    if ((addPenalty || (!outputCompounds && searchMode)) && type != Type.USER) {\n      final int penalty = computePenalty(fromPosData.pos, endPos - fromPosData.pos);\n      if (VERBOSE) {\n        if (penalty > 0) {\n          System.out.println(\"        + penalty=\" + penalty + \" cost=\" + (leastCost+penalty));\n        }\n      }\n      leastCost += penalty;\n    }\n\n    //positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type);\n    assert leftID == dict.getRightId(wordID);\n    positions.get(endPos).add(leastCost, leftID, fromPosData.pos, leastIDX, wordID, type);\n  }\n\n","sourceOld":"  private void add(Dictionary dict, Position fromPosData, int endPos, int wordID, Type type, boolean addPenalty) throws IOException {\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost:\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) + \" leftID=\" + leftID);\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    if ((addPenalty || (!outputCompounds && searchMode)) && type != Type.USER) {\n      final int penalty = computePenalty(fromPosData.pos, endPos - fromPosData.pos);\n      if (VERBOSE) {\n        if (penalty > 0) {\n          System.out.println(\"        + penalty=\" + penalty + \" cost=\" + (leastCost+penalty));\n        }\n      }\n      leastCost += penalty;\n    }\n\n    //positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type);\n    assert leftID == dict.getRightId(wordID);\n    positions.get(endPos).add(leastCost, leftID, fromPosData.pos, leastIDX, wordID, type);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","pathOld":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","sourceNew":"  private void add(Dictionary dict, Position fromPosData, int endPos, int wordID, Type type, boolean addPenalty) throws IOException {\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost:\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) + \" leftID=\" + leftID + \")\");\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    if ((addPenalty || (!outputCompounds && searchMode)) && type != Type.USER) {\n      final int penalty = computePenalty(fromPosData.pos, endPos - fromPosData.pos);\n      if (VERBOSE) {\n        if (penalty > 0) {\n          System.out.println(\"        + penalty=\" + penalty + \" cost=\" + (leastCost+penalty));\n        }\n      }\n      leastCost += penalty;\n    }\n\n    //positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type);\n    assert leftID == dict.getRightId(wordID);\n    positions.get(endPos).add(leastCost, leftID, fromPosData.pos, leastIDX, wordID, type);\n  }\n\n","sourceOld":"  private void add(Dictionary dict, Position fromPosData, int endPos, int wordID, Type type, boolean addPenalty) throws IOException {\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost:\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) + \" leftID=\" + leftID);\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    if ((addPenalty || (!outputCompounds && searchMode)) && type != Type.USER) {\n      final int penalty = computePenalty(fromPosData.pos, endPos - fromPosData.pos);\n      if (VERBOSE) {\n        if (penalty > 0) {\n          System.out.println(\"        + penalty=\" + penalty + \" cost=\" + (leastCost+penalty));\n        }\n      }\n      leastCost += penalty;\n    }\n\n    //positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type);\n    assert leftID == dict.getRightId(wordID);\n    positions.get(endPos).add(leastCost, leftID, fromPosData.pos, leastIDX, wordID, type);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","pathOld":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","sourceNew":"  private void add(Dictionary dict, Position fromPosData, int endPos, int wordID, Type type, boolean addPenalty) throws IOException {\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost:\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) + \" leftID=\" + leftID + \")\");\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    if ((addPenalty || (!outputCompounds && searchMode)) && type != Type.USER) {\n      final int penalty = computePenalty(fromPosData.pos, endPos - fromPosData.pos);\n      if (VERBOSE) {\n        if (penalty > 0) {\n          System.out.println(\"        + penalty=\" + penalty + \" cost=\" + (leastCost+penalty));\n        }\n      }\n      leastCost += penalty;\n    }\n\n    //positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type);\n    assert leftID == dict.getRightId(wordID);\n    positions.get(endPos).add(leastCost, leftID, fromPosData.pos, leastIDX, wordID, type);\n  }\n\n","sourceOld":"  private void add(Dictionary dict, Position fromPosData, int endPos, int wordID, Type type, boolean addPenalty) throws IOException {\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost:\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) + \" leftID=\" + leftID);\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    if ((addPenalty || (!outputCompounds && searchMode)) && type != Type.USER) {\n      final int penalty = computePenalty(fromPosData.pos, endPos - fromPosData.pos);\n      if (VERBOSE) {\n        if (penalty > 0) {\n          System.out.println(\"        + penalty=\" + penalty + \" cost=\" + (leastCost+penalty));\n        }\n      }\n      leastCost += penalty;\n    }\n\n    //positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type);\n    assert leftID == dict.getRightId(wordID);\n    positions.get(endPos).add(leastCost, leftID, fromPosData.pos, leastIDX, wordID, type);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"60380b37ed701033fb7211062affa5d9105428e1":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b89678825b68eccaf09e6ab71675fc0b0af1e099","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["b89678825b68eccaf09e6ab71675fc0b0af1e099","60380b37ed701033fb7211062affa5d9105428e1"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["60380b37ed701033fb7211062affa5d9105428e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89"],"60380b37ed701033fb7211062affa5d9105428e1":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}