{"path":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            T output1 = cmo.output;\n            if (output1.equals(outputs.getNoOutput())) {\n              output1 = outputs.getNoOutput();\n            }\n            T output2 = pair.output;\n            if (output2.equals(outputs.getNoOutput())) {\n              output2 = outputs.getNoOutput();\n            }\n            cmo.output = outputs.common(output1, output2);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            T output1 = cmo.output;\n            if (output1.equals(outputs.getNoOutput())) {\n              output1 = outputs.getNoOutput();\n            }\n            T output2 = pair.output;\n            if (output2.equals(outputs.getNoOutput())) {\n              output2 = outputs.getNoOutput();\n            }\n            cmo.output = outputs.common(output1, output2);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            T output1 = cmo.output;\n            if (output1.equals(outputs.getNoOutput())) {\n              output1 = outputs.getNoOutput();\n            }\n            T output2 = pair.output;\n            if (output2.equals(outputs.getNoOutput())) {\n              output2 = outputs.getNoOutput();\n            }\n            cmo.output = outputs.common(output1, output2);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput<T> cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            T output1 = cmo.output;\n            if (output1.equals(outputs.getNoOutput())) {\n              output1 = outputs.getNoOutput();\n            }\n            T output2 = pair.output;\n            if (output2.equals(outputs.getNoOutput())) {\n              output2 = outputs.getNoOutput();\n            }\n            cmo.output = outputs.common(output1, output2);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            T output1 = cmo.output;\n            if (output1.equals(outputs.getNoOutput())) {\n              output1 = outputs.getNoOutput();\n            }\n            T output2 = pair.output;\n            if (output2.equals(outputs.getNoOutput())) {\n              output2 = outputs.getNoOutput();\n            }\n            cmo.output = outputs.common(output1, output2);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput<T> cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            T output1 = cmo.output;\n            if (output1.equals(outputs.getNoOutput())) {\n              output1 = outputs.getNoOutput();\n            }\n            T output2 = pair.output;\n            if (output2.equals(outputs.getNoOutput())) {\n              output2 = outputs.getNoOutput();\n            }\n            cmo.output = outputs.common(output1, output2);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ebe14aae60589c9bb6423f3cce02d5f599e1540","date":1348361556,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":null,"sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            T output1 = cmo.output;\n            if (output1.equals(outputs.getNoOutput())) {\n              output1 = outputs.getNoOutput();\n            }\n            T output2 = pair.output;\n            if (output2.equals(outputs.getNoOutput())) {\n              output2 = outputs.getNoOutput();\n            }\n            cmo.output = outputs.common(output1, output2);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput<T> cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"]},"commit2Childs":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}