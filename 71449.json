{"path":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testGeo3DRelations().mjava","commits":[{"id":"f64b7098768253180859cd8faeae6b1a185b06ed","date":1441223971,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testGeo3DRelations().mjava","pathOld":"/dev/null","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    PlanetModel planetModel;\n    if (random().nextBoolean()) {\n      planetModel = PlanetModel.WGS84;\n    } else {\n      planetModel = PlanetModel.SPHERE;\n    }\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = new GeoPoint(planetModel, toRadians(randomLat()), toRadians(randomLon()));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    double planetMax = planetModel.getMaximumMagnitude();\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape(planetModel);\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(planetMax, bounds.getMinimumX()),\n                           encodeValueLenient(planetMax, bounds.getMaximumX()),\n                           encodeValueLenient(planetMax, bounds.getMinimumY()),\n                           encodeValueLenient(planetMax, bounds.getMaximumY()),\n                           encodeValueLenient(planetMax, bounds.getMinimumZ()),\n                           encodeValueLenient(planetMax, bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(planetMax, point)) {\n              if (shape.isWithin(quantize(planetMax, point))) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(planetModel,\n                                                        decodeValueMin(planetMax, cell.xMinEnc), decodeValueMax(planetMax, cell.xMaxEnc),\n                                                        decodeValueMin(planetMax, cell.yMinEnc), decodeValueMax(planetMax, cell.yMaxEnc),\n                                                        decodeValueMin(planetMax, cell.zMinEnc), decodeValueMax(planetMax, cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+decodeValueMin(planetMax, cell.xMinEnc)+\" maxx=\"+decodeValueMax(planetMax, cell.xMaxEnc)+\n              \" miny=\"+decodeValueMin(planetMax, cell.yMinEnc)+\" maxy=\"+decodeValueMax(planetMax, cell.yMaxEnc)+\n              \" minz=\"+decodeValueMin(planetMax, cell.zMinEnc)+\" maxz=\"+decodeValueMax(planetMax, cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(planetMax, docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            break;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(planetMax, docs[docID])) {\n                  if (VERBOSE) {\n                    log.println(\"    skip doc=\" + docID);\n                  }\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint quantized = quantize(planetMax, point);\n        boolean expected = shape.isWithin(quantized);\n\n        if (expected != shape.isWithin(point)) {\n          // Quantization changed the result; skip testing this doc:\n          continue;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not\");\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          log.println(\"  quantized=\" + quantize(planetMax, docs[docID]));\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        if (VERBOSE) {\n          System.out.print(sw.toString());\n        }\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d8f71af177fad4bbfdf462d318247e573faac27f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8f71af177fad4bbfdf462d318247e573faac27f","date":1441729530,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    PlanetModel planetModel = getPlanetModel();\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = new GeoPoint(planetModel, toRadians(randomLat()), toRadians(randomLon()));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    double planetMax = planetModel.getMaximumMagnitude();\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape(planetModel);\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(planetMax, bounds.getMinimumX()),\n                           encodeValueLenient(planetMax, bounds.getMaximumX()),\n                           encodeValueLenient(planetMax, bounds.getMinimumY()),\n                           encodeValueLenient(planetMax, bounds.getMaximumY()),\n                           encodeValueLenient(planetMax, bounds.getMinimumZ()),\n                           encodeValueLenient(planetMax, bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(planetMax, point)) {\n              if (shape.isWithin(quantize(planetMax, point))) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(planetModel,\n                                                        decodeValueMin(planetMax, cell.xMinEnc), decodeValueMax(planetMax, cell.xMaxEnc),\n                                                        decodeValueMin(planetMax, cell.yMinEnc), decodeValueMax(planetMax, cell.yMaxEnc),\n                                                        decodeValueMin(planetMax, cell.zMinEnc), decodeValueMax(planetMax, cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+decodeValueMin(planetMax, cell.xMinEnc)+\" maxx=\"+decodeValueMax(planetMax, cell.xMaxEnc)+\n              \" miny=\"+decodeValueMin(planetMax, cell.yMinEnc)+\" maxy=\"+decodeValueMax(planetMax, cell.yMaxEnc)+\n              \" minz=\"+decodeValueMin(planetMax, cell.zMinEnc)+\" maxz=\"+decodeValueMax(planetMax, cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(planetMax, docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            break;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(planetMax, docs[docID])) {\n                  if (VERBOSE) {\n                    log.println(\"    skip doc=\" + docID);\n                  }\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint quantized = quantize(planetMax, point);\n        boolean expected = shape.isWithin(quantized);\n\n        if (expected != shape.isWithin(point)) {\n          // Quantization changed the result; skip testing this doc:\n          continue;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not\");\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          log.println(\"  quantized=\" + quantize(planetMax, docs[docID]));\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    PlanetModel planetModel;\n    if (random().nextBoolean()) {\n      planetModel = PlanetModel.WGS84;\n    } else {\n      planetModel = PlanetModel.SPHERE;\n    }\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = new GeoPoint(planetModel, toRadians(randomLat()), toRadians(randomLon()));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    double planetMax = planetModel.getMaximumMagnitude();\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape(planetModel);\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(planetMax, bounds.getMinimumX()),\n                           encodeValueLenient(planetMax, bounds.getMaximumX()),\n                           encodeValueLenient(planetMax, bounds.getMinimumY()),\n                           encodeValueLenient(planetMax, bounds.getMaximumY()),\n                           encodeValueLenient(planetMax, bounds.getMinimumZ()),\n                           encodeValueLenient(planetMax, bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(planetMax, point)) {\n              if (shape.isWithin(quantize(planetMax, point))) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(planetModel,\n                                                        decodeValueMin(planetMax, cell.xMinEnc), decodeValueMax(planetMax, cell.xMaxEnc),\n                                                        decodeValueMin(planetMax, cell.yMinEnc), decodeValueMax(planetMax, cell.yMaxEnc),\n                                                        decodeValueMin(planetMax, cell.zMinEnc), decodeValueMax(planetMax, cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+decodeValueMin(planetMax, cell.xMinEnc)+\" maxx=\"+decodeValueMax(planetMax, cell.xMaxEnc)+\n              \" miny=\"+decodeValueMin(planetMax, cell.yMinEnc)+\" maxy=\"+decodeValueMax(planetMax, cell.yMaxEnc)+\n              \" minz=\"+decodeValueMin(planetMax, cell.zMinEnc)+\" maxz=\"+decodeValueMax(planetMax, cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(planetMax, docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            break;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(planetMax, docs[docID])) {\n                  if (VERBOSE) {\n                    log.println(\"    skip doc=\" + docID);\n                  }\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint quantized = quantize(planetMax, point);\n        boolean expected = shape.isWithin(quantized);\n\n        if (expected != shape.isWithin(point)) {\n          // Quantization changed the result; skip testing this doc:\n          continue;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not\");\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          log.println(\"  quantized=\" + quantize(planetMax, docs[docID]));\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        if (VERBOSE) {\n          System.out.print(sw.toString());\n        }\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":["f64b7098768253180859cd8faeae6b1a185b06ed"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"88ac68451dbfc2bd5d5f81f95e7d6ee30ed41100","date":1442480912,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    PlanetModel planetModel = getPlanetModel();\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = new GeoPoint(planetModel, toRadians(randomLat()), toRadians(randomLon()));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    double planetMax = planetModel.getMaximumMagnitude();\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape(planetModel);\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(planetMax, bounds.getMinimumX()),\n                           encodeValueLenient(planetMax, bounds.getMaximumX()),\n                           encodeValueLenient(planetMax, bounds.getMinimumY()),\n                           encodeValueLenient(planetMax, bounds.getMaximumY()),\n                           encodeValueLenient(planetMax, bounds.getMinimumZ()),\n                           encodeValueLenient(planetMax, bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(planetMax, point)) {\n              if (shape.isWithin(quantize(planetMax, point))) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(planetModel,\n                                                        decodeValueMin(planetMax, cell.xMinEnc), decodeValueMax(planetMax, cell.xMaxEnc),\n                                                        decodeValueMin(planetMax, cell.yMinEnc), decodeValueMax(planetMax, cell.yMaxEnc),\n                                                        decodeValueMin(planetMax, cell.zMinEnc), decodeValueMax(planetMax, cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+decodeValueMin(planetMax, cell.xMinEnc)+\" maxx=\"+decodeValueMax(planetMax, cell.xMaxEnc)+\n              \" miny=\"+decodeValueMin(planetMax, cell.yMinEnc)+\" maxy=\"+decodeValueMax(planetMax, cell.yMaxEnc)+\n              \" minz=\"+decodeValueMin(planetMax, cell.zMinEnc)+\" maxz=\"+decodeValueMax(planetMax, cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(planetMax, docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(planetMax, docs[docID])) {\n                  if (VERBOSE) {\n                    log.println(\"    skip doc=\" + docID);\n                  }\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint quantized = quantize(planetMax, point);\n        boolean expected = shape.isWithin(quantized);\n\n        if (expected != shape.isWithin(point)) {\n          // Quantization changed the result; skip testing this doc:\n          continue;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not\");\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          log.println(\"  quantized=\" + quantize(planetMax, docs[docID]));\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    PlanetModel planetModel = getPlanetModel();\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = new GeoPoint(planetModel, toRadians(randomLat()), toRadians(randomLon()));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    double planetMax = planetModel.getMaximumMagnitude();\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape(planetModel);\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(planetMax, bounds.getMinimumX()),\n                           encodeValueLenient(planetMax, bounds.getMaximumX()),\n                           encodeValueLenient(planetMax, bounds.getMinimumY()),\n                           encodeValueLenient(planetMax, bounds.getMaximumY()),\n                           encodeValueLenient(planetMax, bounds.getMinimumZ()),\n                           encodeValueLenient(planetMax, bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(planetMax, point)) {\n              if (shape.isWithin(quantize(planetMax, point))) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(planetModel,\n                                                        decodeValueMin(planetMax, cell.xMinEnc), decodeValueMax(planetMax, cell.xMaxEnc),\n                                                        decodeValueMin(planetMax, cell.yMinEnc), decodeValueMax(planetMax, cell.yMaxEnc),\n                                                        decodeValueMin(planetMax, cell.zMinEnc), decodeValueMax(planetMax, cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+decodeValueMin(planetMax, cell.xMinEnc)+\" maxx=\"+decodeValueMax(planetMax, cell.xMaxEnc)+\n              \" miny=\"+decodeValueMin(planetMax, cell.yMinEnc)+\" maxy=\"+decodeValueMax(planetMax, cell.yMaxEnc)+\n              \" minz=\"+decodeValueMin(planetMax, cell.zMinEnc)+\" maxz=\"+decodeValueMax(planetMax, cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(planetMax, docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            break;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(planetMax, docs[docID])) {\n                  if (VERBOSE) {\n                    log.println(\"    skip doc=\" + docID);\n                  }\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint quantized = quantize(planetMax, point);\n        boolean expected = shape.isWithin(quantized);\n\n        if (expected != shape.isWithin(point)) {\n          // Quantization changed the result; skip testing this doc:\n          continue;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not\");\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          log.println(\"  quantized=\" + quantize(planetMax, docs[docID]));\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPointField#testGeo3DRelations().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/bkdtree3d/TestGeo3DPointField#testGeo3DRelations().mjava","sourceNew":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    PlanetModel planetModel = getPlanetModel();\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = new GeoPoint(planetModel, toRadians(randomLat()), toRadians(randomLon()));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    double planetMax = planetModel.getMaximumMagnitude();\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape(planetModel);\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMinimumX()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMaximumX()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMinimumY()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMaximumY()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMinimumZ()),\n                           Geo3DUtil.encodeValueLenient(planetMax, bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(planetMax, point)) {\n              if (shape.isWithin(quantize(planetMax, point))) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(planetModel,\n                                                        Geo3DUtil.decodeValueMin(planetMax, cell.xMinEnc), Geo3DUtil.decodeValueMax(planetMax, cell.xMaxEnc),\n                                                        Geo3DUtil.decodeValueMin(planetMax, cell.yMinEnc), Geo3DUtil.decodeValueMax(planetMax, cell.yMaxEnc),\n                                                        Geo3DUtil.decodeValueMin(planetMax, cell.zMinEnc), Geo3DUtil.decodeValueMax(planetMax, cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+Geo3DUtil.decodeValueMin(planetMax, cell.xMinEnc)+\" maxx=\"+Geo3DUtil.decodeValueMax(planetMax, cell.xMaxEnc)+\n              \" miny=\"+Geo3DUtil.decodeValueMin(planetMax, cell.yMinEnc)+\" maxy=\"+Geo3DUtil.decodeValueMax(planetMax, cell.yMaxEnc)+\n              \" minz=\"+Geo3DUtil.decodeValueMin(planetMax, cell.zMinEnc)+\" maxz=\"+Geo3DUtil.decodeValueMax(planetMax, cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(planetMax, docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(planetMax, docs[docID])) {\n                  if (VERBOSE) {\n                    log.println(\"    skip doc=\" + docID);\n                  }\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint quantized = quantize(planetMax, point);\n        boolean expected = shape.isWithin(quantized);\n\n        if (expected != shape.isWithin(point)) {\n          // Quantization changed the result; skip testing this doc:\n          continue;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not\");\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          log.println(\"  quantized=\" + quantize(planetMax, docs[docID]));\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoArea.getRelationship vs GeoShape.isWithin */\n  public void testGeo3DRelations() throws Exception {\n\n    PlanetModel planetModel = getPlanetModel();\n\n    int numDocs = atLeast(1000);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs\");\n    }\n\n    GeoPoint[] docs = new GeoPoint[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docs[docID] = new GeoPoint(planetModel, toRadians(randomLat()), toRadians(randomLon()));\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": \" + docs[docID]);\n      }\n    }\n\n    double planetMax = planetModel.getMaximumMagnitude();\n\n    int iters = atLeast(10);\n\n    int recurseDepth = RandomInts.randomIntBetween(random(), 5, 15);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n      GeoShape shape = randomShape(planetModel);\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"TEST: iter=\" + iter + \" shape=\" + shape);\n      }\n\n      XYZBounds bounds = new XYZBounds();\n      shape.getBounds(bounds);\n\n      // Start with the root cell that fully contains the shape:\n      Cell root = new Cell(null,\n                           encodeValueLenient(planetMax, bounds.getMinimumX()),\n                           encodeValueLenient(planetMax, bounds.getMaximumX()),\n                           encodeValueLenient(planetMax, bounds.getMinimumY()),\n                           encodeValueLenient(planetMax, bounds.getMaximumY()),\n                           encodeValueLenient(planetMax, bounds.getMinimumZ()),\n                           encodeValueLenient(planetMax, bounds.getMaximumZ()),\n                           0);\n\n      if (VERBOSE) {\n        log.println(\"  root cell: \" + root);\n      }\n\n      List<Cell> queue = new ArrayList<>();\n      queue.add(root);\n      Set<Integer> hits = new HashSet<>();\n\n      while (queue.size() > 0) {\n        Cell cell = queue.get(queue.size()-1);\n        queue.remove(queue.size()-1);\n        if (VERBOSE) {\n          log.println(\"  cycle: \" + cell + \" queue.size()=\" + queue.size());\n        }\n\n        if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {\n          if (VERBOSE) {\n            log.println(\"    leaf\");\n          }\n          // Leaf cell: brute force check all docs that fall within this cell:\n          for(int docID=0;docID<numDocs;docID++) {\n            GeoPoint point = docs[docID];\n            if (cell.contains(planetMax, point)) {\n              if (shape.isWithin(quantize(planetMax, point))) {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": match!\");\n                }\n                hits.add(docID);\n              } else {\n                if (VERBOSE) {\n                  log.println(\"    check doc=\" + docID + \": no match\");\n                }\n              }\n            }\n          }\n        } else {\n          \n          GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(planetModel,\n                                                        decodeValueMin(planetMax, cell.xMinEnc), decodeValueMax(planetMax, cell.xMaxEnc),\n                                                        decodeValueMin(planetMax, cell.yMinEnc), decodeValueMax(planetMax, cell.yMaxEnc),\n                                                        decodeValueMin(planetMax, cell.zMinEnc), decodeValueMax(planetMax, cell.zMaxEnc));\n\n          if (VERBOSE) {\n            log.println(\"    minx=\"+decodeValueMin(planetMax, cell.xMinEnc)+\" maxx=\"+decodeValueMax(planetMax, cell.xMaxEnc)+\n              \" miny=\"+decodeValueMin(planetMax, cell.yMinEnc)+\" maxy=\"+decodeValueMax(planetMax, cell.yMaxEnc)+\n              \" minz=\"+decodeValueMin(planetMax, cell.zMinEnc)+\" maxz=\"+decodeValueMax(planetMax, cell.zMaxEnc));\n          }\n\n          switch (xyzSolid.getRelationship(shape)) {          \n          case GeoArea.CONTAINS:\n            // Shape fully contains the cell: blindly add all docs in this cell:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.CONTAINS: now addAll\");\n            }\n            for(int docID=0;docID<numDocs;docID++) {\n              if (cell.contains(planetMax, docs[docID])) {\n                if (VERBOSE) {\n                  log.println(\"    addAll doc=\" + docID);\n                }\n                hits.add(docID);\n              }\n            }\n            continue;\n          case GeoArea.OVERLAPS:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.OVERLAPS: keep splitting\");\n            }\n            // They do overlap but neither contains the other:\n            //log.println(\"    crosses1\");\n            break;\n          case GeoArea.WITHIN:\n            if (VERBOSE) {\n              log.println(\"    GeoArea.WITHIN: keep splitting\");\n            }\n            // Cell fully contains the shape:\n            //log.println(\"    crosses2\");\n            break;\n          case GeoArea.DISJOINT:\n            // They do not overlap at all: don't recurse on this cell\n            //log.println(\"    outside\");\n            if (VERBOSE) {\n              log.println(\"    GeoArea.DISJOINT: drop this cell\");\n              for(int docID=0;docID<numDocs;docID++) {\n                if (cell.contains(planetMax, docs[docID])) {\n                  if (VERBOSE) {\n                    log.println(\"    skip doc=\" + docID);\n                  }\n                }\n              }\n            }\n            continue;\n          default:\n            assert false;\n          }\n\n          // Randomly split:\n          switch(random().nextInt(3)) {\n\n          case 0:\n            // Split on X:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.xMinEnc, cell.xMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on x=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, splitValue,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 splitValue, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 1:\n            // Split on Y:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.yMinEnc, cell.yMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on y=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, splitValue,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 splitValue, cell.yMaxEnc,\n                                 cell.zMinEnc, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n\n          case 2:\n            // Split on Z:\n            {\n              int splitValue = RandomInts.randomIntBetween(random(), cell.zMinEnc, cell.zMaxEnc);\n              if (VERBOSE) {\n                log.println(\"    now split on z=\" + splitValue);\n              }\n              Cell cell1 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 cell.zMinEnc, splitValue,\n                                 cell.splitCount+1);\n              Cell cell2 = new Cell(cell,\n                                 cell.xMinEnc, cell.xMaxEnc,\n                                 cell.yMinEnc, cell.yMaxEnc,\n                                 splitValue, cell.zMaxEnc,\n                                 cell.splitCount+1);\n              if (VERBOSE) {\n                log.println(\"    split cell1: \" + cell1);\n                log.println(\"    split cell2: \" + cell2);\n              }\n              queue.add(cell1);\n              queue.add(cell2);\n            }\n            break;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      // Done matching, now verify:\n      boolean fail = false;\n      for(int docID=0;docID<numDocs;docID++) {\n        GeoPoint point = docs[docID];\n        GeoPoint quantized = quantize(planetMax, point);\n        boolean expected = shape.isWithin(quantized);\n\n        if (expected != shape.isWithin(point)) {\n          // Quantization changed the result; skip testing this doc:\n          continue;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not\");\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should\");\n          }\n          log.println(\"  point=\" + docs[docID]);\n          log.println(\"  quantized=\" + quantize(planetMax, docs[docID]));\n          fail = true;\n        }\n      }\n\n      if (fail) {\n        System.out.print(sw.toString());\n        fail(\"invalid hits for shape=\" + shape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d8f71af177fad4bbfdf462d318247e573faac27f":["f64b7098768253180859cd8faeae6b1a185b06ed"],"f64b7098768253180859cd8faeae6b1a185b06ed":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"88ac68451dbfc2bd5d5f81f95e7d6ee30ed41100":["d8f71af177fad4bbfdf462d318247e573faac27f"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["88ac68451dbfc2bd5d5f81f95e7d6ee30ed41100"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1904709ea0185dc04e3d77ea01c79e909caf2796"]},"commit2Childs":{"d8f71af177fad4bbfdf462d318247e573faac27f":["88ac68451dbfc2bd5d5f81f95e7d6ee30ed41100"],"f64b7098768253180859cd8faeae6b1a185b06ed":["d8f71af177fad4bbfdf462d318247e573faac27f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f64b7098768253180859cd8faeae6b1a185b06ed"],"88ac68451dbfc2bd5d5f81f95e7d6ee30ed41100":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}