{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec8eab7160b056ec8e7148e8754bf056eb47e423","date":1341950673,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":["cbc3688252d4a8045d69a164236b2cf87b721f17","ba791bce8103c79e38f957e9c5a53a75871bd918"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99bfa1bcb7cecbfe48118f6e71f7ccc7a9247afc","date":1346106609,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a48377c9931ddb38c784846217ff68d7dcd0b44","date":1363202036,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    if (tfit instanceof TermFreqPayloadIterator) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ada2f7352a7f964fe49bccd13227c4ec38563d39","date":1381659982,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqPayloadIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqPayloadIterator tfit) throws IOException {\n    if (tfit.hasPayloads()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqIterator tfit) throws IOException {\n    if (tfit instanceof TermFreqPayloadIterator) {\n      throw new IllegalArgumentException(\"this suggester doesn't support payloads\");\n    }\n    File tempInput = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".input\", Sort.defaultTempDir());\n    File tempSorted = File.createTempFile(\n        FSTCompletionLookup.class.getSimpleName(), \".sorted\", Sort.defaultTempDir());\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    ExternalRefSorter sorter = null;\n\n    // Push floats up front before sequences to sort them. For now, assume they are non-negative.\n    // If negative floats are allowed some trickery needs to be done to find their byte order.\n    boolean success = false;\n    try {\n      byte [] buffer = new byte [0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef spare;\n      while ((spare = tfit.next()) != null) {\n        if (spare.length + 4 >= buffer.length) {\n          buffer = ArrayUtil.grow(buffer, spare.length + 4);\n        }\n\n        output.reset(buffer);\n        output.writeInt(encodeWeight(tfit.weight()));\n        output.writeBytes(spare.bytes, spare.offset, spare.length);\n        writer.write(buffer, 0, output.getPosition());\n      }\n      writer.close();\n\n      // We don't know the distribution of scores and we need to bucket them, so we'll sort\n      // and divide into equal buckets.\n      SortInfo info = new Sort().sort(tempInput, tempSorted);\n      tempInput.delete();\n      FSTCompletionBuilder builder = new FSTCompletionBuilder(\n          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);\n\n      final int inputLines = info.lines;\n      reader = new Sort.ByteSequencesReader(tempSorted);\n      long line = 0;\n      int previousBucket = 0;\n      int previousScore = 0;\n      ByteArrayDataInput input = new ByteArrayDataInput();\n      BytesRef tmp1 = new BytesRef();\n      BytesRef tmp2 = new BytesRef();\n      while (reader.read(tmp1)) {\n        input.reset(tmp1.bytes);\n        int currentScore = input.readInt();\n\n        int bucket;\n        if (line > 0 && currentScore == previousScore) {\n          bucket = previousBucket;\n        } else {\n          bucket = (int) (line * buckets / inputLines);\n        }\n        previousScore = currentScore;\n        previousBucket = bucket;\n\n        // Only append the input, discard the weight.\n        tmp2.bytes = tmp1.bytes;\n        tmp2.offset = input.getPosition();\n        tmp2.length = tmp1.length - input.getPosition();\n        builder.add(tmp2, bucket);\n\n        line++;\n      }\n\n      // The two FSTCompletions share the same automaton.\n      this.higherWeightsCompletion = builder.build();\n      this.normalCompletion = new FSTCompletion(\n          higherWeightsCompletion.getFST(), false, exactMatchFirst);\n      \n      success = true;\n    } finally {\n      if (success) \n        IOUtils.close(reader, writer, sorter);\n      else \n        IOUtils.closeWhileHandlingException(reader, writer, sorter);\n\n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"99bfa1bcb7cecbfe48118f6e71f7ccc7a9247afc":["ec8eab7160b056ec8e7148e8754bf056eb47e423"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aba371508186796cc6151d8223a5b4e16d02e26e":["b89678825b68eccaf09e6ab71675fc0b0af1e099","ec8eab7160b056ec8e7148e8754bf056eb47e423"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b89678825b68eccaf09e6ab71675fc0b0af1e099","ec8eab7160b056ec8e7148e8754bf056eb47e423"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5a48377c9931ddb38c784846217ff68d7dcd0b44":["99bfa1bcb7cecbfe48118f6e71f7ccc7a9247afc"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["aba371508186796cc6151d8223a5b4e16d02e26e","99bfa1bcb7cecbfe48118f6e71f7ccc7a9247afc"],"ec8eab7160b056ec8e7148e8754bf056eb47e423":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ada2f7352a7f964fe49bccd13227c4ec38563d39"],"ada2f7352a7f964fe49bccd13227c4ec38563d39":["5a48377c9931ddb38c784846217ff68d7dcd0b44"]},"commit2Childs":{"99bfa1bcb7cecbfe48118f6e71f7ccc7a9247afc":["5a48377c9931ddb38c784846217ff68d7dcd0b44","05a14b2611ead08655a2b2bdc61632eb31316e57"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","ec8eab7160b056ec8e7148e8754bf056eb47e423"],"aba371508186796cc6151d8223a5b4e16d02e26e":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"5a48377c9931ddb38c784846217ff68d7dcd0b44":["ada2f7352a7f964fe49bccd13227c4ec38563d39"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"ec8eab7160b056ec8e7148e8754bf056eb47e423":["99bfa1bcb7cecbfe48118f6e71f7ccc7a9247afc","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"ada2f7352a7f964fe49bccd13227c4ec38563d39":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","05a14b2611ead08655a2b2bdc61632eb31316e57","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}