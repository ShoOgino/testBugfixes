{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","commits":[{"id":"44de42d869f7d8e5235d43c4ad9a99f520363a2f","date":1389871557,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"/dev/null","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n\n    log.debug(\"overseer designates {}\", overseerDesignates);\n\n    List<String> children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);\n\n\n    if(children.size()<2) return;\n\n    LeaderElector.sortSeqs(children);\n    ArrayList<String> nodeNames = new ArrayList<>(children.size());\n    for (String c : children) nodeNames.add(LeaderElector.getNodeName(c));\n    boolean overseerDesignateAvailable = false;\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    String newOverseerDesignate = null;\n    log.debug(\"sorted nodes {}\", nodeNames);\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n      if (overseerDesignates.contains(s)) {\n        log.info(\" found an overseer designate to be promoted to the front : {}, pushing others back\", s);\n        overseerDesignateAvailable = true;\n        newOverseerDesignate = s;\n        for (int j = 1; j < i; j++) {\n          String nodeName = nodeNames.get(j);\n          log.debug(\"pushing back {} \", nodeName);\n          invokeRejoinOverseer(nodeName);\n        }\n        break;\n      }\n      if(overseerDesignateAvailable) break;\n    }\n\n    if(overseerDesignateAvailable){\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.currentTimeMillis() + 5000;\n\n      for(;System.currentTimeMillis()< timeout ;){\n        children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);\n        LeaderElector.sortSeqs(children);\n\n        String frontRunner = LeaderElector.getNodeName(children.get(1));\n        log.debug(\"Frontrunner : {}\", frontRunner);\n        if(newOverseerDesignate.equals(frontRunner)){\n          prioritizationComplete = true;\n          break;\n        }\n        Thread.sleep(50);\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"Could not make the Overseer designate '{}' the frontrunner\", newOverseerDesignate);\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available\");\n      return;\n    }\n\n\n\n    if(!overseerDesignates.contains( nodeNames.get(0)) && overseerDesignateAvailable){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      invokeRejoinOverseer(nodeNames.get(0));\n    }\n\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cb311c383e1415a29ce2598bbd9e2db0d061c61","date":1389885254,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n\n    log.debug(\"overseer designates {}\", overseerDesignates);\n\n    List<String> children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);\n\n\n    if(children.size()<2) return;\n\n    LeaderElector.sortSeqs(children);\n    ArrayList<String> nodeNames = new ArrayList<>(children.size());\n    for (String c : children) nodeNames.add(LeaderElector.getNodeName(c));\n    boolean overseerDesignateAvailable = false;\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    String newOverseerDesignate = null;\n    log.debug(\"sorted nodes {}\", nodeNames);\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n      if (overseerDesignates.contains(s)) {\n        log.info(\" found an overseer designate to be promoted to the front : {}, pushing others back\", s);\n        overseerDesignateAvailable = true;\n        newOverseerDesignate = s;\n        for (int j = 1; j < i; j++) {\n          String nodeName = nodeNames.get(j);\n          log.debug(\"pushing back {} \", nodeName);\n          invokeRejoinOverseer(nodeName);\n        }\n        break;\n      }\n      if(overseerDesignateAvailable) break;\n    }\n\n    if(overseerDesignateAvailable){\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.currentTimeMillis() + 5000;\n\n      for(;System.currentTimeMillis()< timeout ;){\n        children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);\n        LeaderElector.sortSeqs(children);\n\n        String frontRunner = LeaderElector.getNodeName(children.get(1));\n        log.debug(\"Frontrunner : {}\", frontRunner);\n        if(newOverseerDesignate.equals(frontRunner)){\n          prioritizationComplete = true;\n          break;\n        }\n        Thread.sleep(50);\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"Could not make the Overseer designate '{}' the frontrunner\", newOverseerDesignate);\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, nodes : \",overseerDesignates,nodeNames);\n      return;\n    }\n\n\n\n    if(!overseerDesignates.contains( nodeNames.get(0)) && overseerDesignateAvailable){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      invokeRejoinOverseer(nodeNames.get(0));\n    }\n\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n\n    log.debug(\"overseer designates {}\", overseerDesignates);\n\n    List<String> children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);\n\n\n    if(children.size()<2) return;\n\n    LeaderElector.sortSeqs(children);\n    ArrayList<String> nodeNames = new ArrayList<>(children.size());\n    for (String c : children) nodeNames.add(LeaderElector.getNodeName(c));\n    boolean overseerDesignateAvailable = false;\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    String newOverseerDesignate = null;\n    log.debug(\"sorted nodes {}\", nodeNames);\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n      if (overseerDesignates.contains(s)) {\n        log.info(\" found an overseer designate to be promoted to the front : {}, pushing others back\", s);\n        overseerDesignateAvailable = true;\n        newOverseerDesignate = s;\n        for (int j = 1; j < i; j++) {\n          String nodeName = nodeNames.get(j);\n          log.debug(\"pushing back {} \", nodeName);\n          invokeRejoinOverseer(nodeName);\n        }\n        break;\n      }\n      if(overseerDesignateAvailable) break;\n    }\n\n    if(overseerDesignateAvailable){\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.currentTimeMillis() + 5000;\n\n      for(;System.currentTimeMillis()< timeout ;){\n        children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);\n        LeaderElector.sortSeqs(children);\n\n        String frontRunner = LeaderElector.getNodeName(children.get(1));\n        log.debug(\"Frontrunner : {}\", frontRunner);\n        if(newOverseerDesignate.equals(frontRunner)){\n          prioritizationComplete = true;\n          break;\n        }\n        Thread.sleep(50);\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"Could not make the Overseer designate '{}' the frontrunner\", newOverseerDesignate);\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available\");\n      return;\n    }\n\n\n\n    if(!overseerDesignates.contains( nodeNames.get(0)) && overseerDesignateAvailable){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      invokeRejoinOverseer(nodeNames.get(0));\n    }\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"097d97da7591c3b0a99b055b589ff086a1132de8","date":1389965433,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n\n    log.debug(\"overseer designates {}\", overseerDesignates);\n\n    List<String> children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);\n\n\n    if(children.size()<2) return;\n\n    LeaderElector.sortSeqs(children);\n    ArrayList<String> nodeNames = new ArrayList<>(children.size());\n    for (String c : children) nodeNames.add(LeaderElector.getNodeName(c));\n    boolean overseerDesignateAvailable = false;\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    String newOverseerDesignate = null;\n    log.debug(\"sorted nodes {}\", nodeNames);\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n      if (overseerDesignates.contains(s)) {\n        log.info(\" found an overseer designate to be promoted to the front : {}, pushing others back\", s);\n        overseerDesignateAvailable = true;\n        newOverseerDesignate = s;\n        for (int j = 1; j < i; j++) {\n          String nodeName = nodeNames.get(j);\n          log.debug(\"pushing back {} \", nodeName);\n          invokeRejoinOverseer(nodeName);\n        }\n        break;\n      }\n      if(overseerDesignateAvailable) break;\n    }\n\n    if(overseerDesignateAvailable){\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.currentTimeMillis() + 5000;\n\n      for(;System.currentTimeMillis()< timeout ;){\n        children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);\n        LeaderElector.sortSeqs(children);\n\n        String frontRunner = LeaderElector.getNodeName(children.get(1));\n        log.debug(\"Frontrunner : {}\", frontRunner);\n        if(newOverseerDesignate.equals(frontRunner)){\n          prioritizationComplete = true;\n          break;\n        }\n        Thread.sleep(50);\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"Could not make the Overseer designate '{}' the frontrunner\", newOverseerDesignate);\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n\n\n    if(!overseerDesignates.contains( nodeNames.get(0)) && overseerDesignateAvailable){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      invokeRejoinOverseer(nodeNames.get(0));\n    }\n\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n\n    log.debug(\"overseer designates {}\", overseerDesignates);\n\n    List<String> children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);\n\n\n    if(children.size()<2) return;\n\n    LeaderElector.sortSeqs(children);\n    ArrayList<String> nodeNames = new ArrayList<>(children.size());\n    for (String c : children) nodeNames.add(LeaderElector.getNodeName(c));\n    boolean overseerDesignateAvailable = false;\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    String newOverseerDesignate = null;\n    log.debug(\"sorted nodes {}\", nodeNames);\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n      if (overseerDesignates.contains(s)) {\n        log.info(\" found an overseer designate to be promoted to the front : {}, pushing others back\", s);\n        overseerDesignateAvailable = true;\n        newOverseerDesignate = s;\n        for (int j = 1; j < i; j++) {\n          String nodeName = nodeNames.get(j);\n          log.debug(\"pushing back {} \", nodeName);\n          invokeRejoinOverseer(nodeName);\n        }\n        break;\n      }\n      if(overseerDesignateAvailable) break;\n    }\n\n    if(overseerDesignateAvailable){\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.currentTimeMillis() + 5000;\n\n      for(;System.currentTimeMillis()< timeout ;){\n        children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);\n        LeaderElector.sortSeqs(children);\n\n        String frontRunner = LeaderElector.getNodeName(children.get(1));\n        log.debug(\"Frontrunner : {}\", frontRunner);\n        if(newOverseerDesignate.equals(frontRunner)){\n          prioritizationComplete = true;\n          break;\n        }\n        Thread.sleep(50);\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"Could not make the Overseer designate '{}' the frontrunner\", newOverseerDesignate);\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, nodes : \",overseerDesignates,nodeNames);\n      return;\n    }\n\n\n\n    if(!overseerDesignates.contains( nodeNames.get(0)) && overseerDesignateAvailable){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      invokeRejoinOverseer(nodeNames.get(0));\n    }\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"82ed10ec58814cd9841195fb52bcbc1c2402e2cc","date":1390222136,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    Set<String> nodesTobePushedBack =  new HashSet<String>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    Set<String> availableDesignates = new HashSet<String>();\n\n    log.debug(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 0; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=0;j<i;j++){\n          if(!overseerDesignates.contains(nodeNames.get(j))) {\n            nodesTobePushedBack.add(nodeNames.get(j));\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeRejoinOverseer(s);\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.currentTimeMillis() + 2500;\n\n      for(;System.currentTimeMillis()< timeout ;){\n        List<String> currentNodeNames = getSortedNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    if(!overseerDesignates.contains( getLeaderNode(zkStateReader.getZkClient())) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      invokeRejoinOverseer(nodeNames.get(0));\n    }\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n\n    log.debug(\"overseer designates {}\", overseerDesignates);\n\n    List<String> children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);\n\n\n    if(children.size()<2) return;\n\n    LeaderElector.sortSeqs(children);\n    ArrayList<String> nodeNames = new ArrayList<>(children.size());\n    for (String c : children) nodeNames.add(LeaderElector.getNodeName(c));\n    boolean overseerDesignateAvailable = false;\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    String newOverseerDesignate = null;\n    log.debug(\"sorted nodes {}\", nodeNames);\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n      if (overseerDesignates.contains(s)) {\n        log.info(\" found an overseer designate to be promoted to the front : {}, pushing others back\", s);\n        overseerDesignateAvailable = true;\n        newOverseerDesignate = s;\n        for (int j = 1; j < i; j++) {\n          String nodeName = nodeNames.get(j);\n          log.debug(\"pushing back {} \", nodeName);\n          invokeRejoinOverseer(nodeName);\n        }\n        break;\n      }\n      if(overseerDesignateAvailable) break;\n    }\n\n    if(overseerDesignateAvailable){\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.currentTimeMillis() + 5000;\n\n      for(;System.currentTimeMillis()< timeout ;){\n        children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);\n        LeaderElector.sortSeqs(children);\n\n        String frontRunner = LeaderElector.getNodeName(children.get(1));\n        log.debug(\"Frontrunner : {}\", frontRunner);\n        if(newOverseerDesignate.equals(frontRunner)){\n          prioritizationComplete = true;\n          break;\n        }\n        Thread.sleep(50);\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"Could not make the Overseer designate '{}' the frontrunner\", newOverseerDesignate);\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n\n\n    if(!overseerDesignates.contains( nodeNames.get(0)) && overseerDesignateAvailable){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      invokeRejoinOverseer(nodeNames.get(0));\n    }\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e17ab2be80de52a97a870438adf8ac15f574359","date":1390380110,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    Set<String> nodesTobePushedBack =  new HashSet<String>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    Set<String> availableDesignates = new HashSet<String>();\n\n    log.debug(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 0; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=0;j<i;j++){\n          if(!overseerDesignates.contains(nodeNames.get(j))) {\n            nodesTobePushedBack.add(nodeNames.get(j));\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeRejoinOverseer(s);\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.currentTimeMillis() + 2500;\n\n      for(;System.currentTimeMillis()< timeout ;){\n        List<String> currentNodeNames = getSortedNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      log.info(\"I am not an overseerdesignate , rejoining election {} \", leaderNode);\n      invokeRejoinOverseer(leaderNode);\n    }\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    Set<String> nodesTobePushedBack =  new HashSet<String>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    Set<String> availableDesignates = new HashSet<String>();\n\n    log.debug(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 0; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=0;j<i;j++){\n          if(!overseerDesignates.contains(nodeNames.get(j))) {\n            nodesTobePushedBack.add(nodeNames.get(j));\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeRejoinOverseer(s);\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.currentTimeMillis() + 2500;\n\n      for(;System.currentTimeMillis()< timeout ;){\n        List<String> currentNodeNames = getSortedNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    if(!overseerDesignates.contains( getLeaderNode(zkStateReader.getZkClient())) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      invokeRejoinOverseer(nodeNames.get(0));\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"702f9eb5f4d8ac6dea3945928de043b9d25fa87d","date":1391001447,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<String>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 0; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=0;j<i;j++){\n          if(!overseerDesignates.contains(nodeNames.get(j))) {\n            if(!nodesTobePushedBack.contains(nodeNames.get(j))) nodesTobePushedBack.add(nodeNames.get(j));\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (int i = nodesTobePushedBack.size() - 1; i >= 0; i--) {\n         String s = nodesTobePushedBack.get(i);\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.currentTimeMillis() + 2500;\n\n      for(;System.currentTimeMillis()< timeout ;){\n        List<String> currentNodeNames = getSortedNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      String newLeader = availableDesignates.get(0);\n      log.info(\"I am not an overseerdesignate , forcing a new leader {} \", newLeader);\n      invokeOverseerOp(newLeader, \"leader\");\n    }\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    Set<String> nodesTobePushedBack =  new HashSet<String>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    Set<String> availableDesignates = new HashSet<String>();\n\n    log.debug(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 0; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=0;j<i;j++){\n          if(!overseerDesignates.contains(nodeNames.get(j))) {\n            nodesTobePushedBack.add(nodeNames.get(j));\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeRejoinOverseer(s);\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.currentTimeMillis() + 2500;\n\n      for(;System.currentTimeMillis()< timeout ;){\n        List<String> currentNodeNames = getSortedNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      log.info(\"I am not an overseerdesignate , rejoining election {} \", leaderNode);\n      invokeRejoinOverseer(leaderNode);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd5bc858b8426d40bbe90b94120ead37c77d7954","date":1393812525,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<String>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 0; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=0;j<i;j++){\n          if(!overseerDesignates.contains(nodeNames.get(j))) {\n            if(!nodesTobePushedBack.contains(nodeNames.get(j))) nodesTobePushedBack.add(nodeNames.get(j));\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (int i = nodesTobePushedBack.size() - 1; i >= 0; i--) {\n         String s = nodesTobePushedBack.get(i);\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      String newLeader = availableDesignates.get(0);\n      log.info(\"I am not an overseerdesignate , forcing a new leader {} \", newLeader);\n      invokeOverseerOp(newLeader, \"leader\");\n    }\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<String>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 0; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=0;j<i;j++){\n          if(!overseerDesignates.contains(nodeNames.get(j))) {\n            if(!nodesTobePushedBack.contains(nodeNames.get(j))) nodesTobePushedBack.add(nodeNames.get(j));\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (int i = nodesTobePushedBack.size() - 1; i >= 0; i--) {\n         String s = nodesTobePushedBack.get(i);\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.currentTimeMillis() + 2500;\n\n      for(;System.currentTimeMillis()< timeout ;){\n        List<String> currentNodeNames = getSortedNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      String newLeader = availableDesignates.get(0);\n      log.info(\"I am not an overseerdesignate , forcing a new leader {} \", newLeader);\n      invokeOverseerOp(newLeader, \"leader\");\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 0; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=0;j<i;j++){\n          if(!overseerDesignates.contains(nodeNames.get(j))) {\n            if(!nodesTobePushedBack.contains(nodeNames.get(j))) nodesTobePushedBack.add(nodeNames.get(j));\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (int i = nodesTobePushedBack.size() - 1; i >= 0; i--) {\n         String s = nodesTobePushedBack.get(i);\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      String newLeader = availableDesignates.get(0);\n      log.info(\"I am not an overseerdesignate , forcing a new leader {} \", newLeader);\n      invokeOverseerOp(newLeader, \"leader\");\n    }\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<String>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 0; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=0;j<i;j++){\n          if(!overseerDesignates.contains(nodeNames.get(j))) {\n            if(!nodesTobePushedBack.contains(nodeNames.get(j))) nodesTobePushedBack.add(nodeNames.get(j));\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (int i = nodesTobePushedBack.size() - 1; i >= 0; i--) {\n         String s = nodesTobePushedBack.get(i);\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      String newLeader = availableDesignates.get(0);\n      log.info(\"I am not an overseerdesignate , forcing a new leader {} \", newLeader);\n      invokeOverseerOp(newLeader, \"leader\");\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e66d99e5beccb546edd910c91f646fb7d831a94","date":1395391298,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 0; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=0;j<i;j++){\n          if(!overseerDesignates.contains(nodeNames.get(j))) {\n            if(!nodesTobePushedBack.contains(nodeNames.get(j))) nodesTobePushedBack.add(nodeNames.get(j));\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (int i = nodesTobePushedBack.size() - 1; i >= 0; i--) {\n         String s = nodesTobePushedBack.get(i);\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      String newLeader = availableDesignates.get(0);\n      log.info(\"I am not an overseerdesignate , forcing a new leader {} \", newLeader);\n      invokeOverseerOp(newLeader, \"leader\");\n    }\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 0; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=0;j<i;j++){\n          if(!overseerDesignates.contains(nodeNames.get(j))) {\n            if(!nodesTobePushedBack.contains(nodeNames.get(j))) nodesTobePushedBack.add(nodeNames.get(j));\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (int i = nodesTobePushedBack.size() - 1; i >= 0; i--) {\n         String s = nodesTobePushedBack.get(i);\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      String newLeader = availableDesignates.get(0);\n      log.info(\"I am not an overseerdesignate , forcing a new leader {} \", newLeader);\n      invokeOverseerOp(newLeader, \"leader\");\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b15576cafd8b5d06857055c28f26912321937e3","date":1396452121,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps( Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n    }\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 0; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=0;j<i;j++){\n          if(!overseerDesignates.contains(nodeNames.get(j))) {\n            if(!nodesTobePushedBack.contains(nodeNames.get(j))) nodesTobePushedBack.add(nodeNames.get(j));\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (int i = nodesTobePushedBack.size() - 1; i >= 0; i--) {\n         String s = nodesTobePushedBack.get(i);\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      String newLeader = availableDesignates.get(0);\n      log.info(\"I am not an overseerdesignate , forcing a new leader {} \", newLeader);\n      invokeOverseerOp(newLeader, \"leader\");\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8295a0e649f894ba19be89ef3b8887648978525f","date":1396508870,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes at {}\", LeaderElector.getNodeName(myId));\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n    boolean designateIsInFront = overseerDesignates.contains( nodeNames.get(0));\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;//we don't need to line up more than 2 designates\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else if(!designateIsInFront) {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) ){\n      List<String> sortedNodes = getSortedOverseerNodeNames(zk);\n\n      if(leaderNode.equals(sortedNodes.get(0))  ||         // I am leader and I am in front of the queue\n          overseerDesignates.contains(sortedNodes.get(0))) {// I am leader but somebody else is in the front , Screwed up leader election\n        //this means there are I am not a designate and the next guy is lined up to become the leader, kill myself\n        log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n      }\n    }\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps( Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes at {}\", LeaderElector.getNodeName(myId));\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n    boolean designateIsInFront = overseerDesignates.contains( nodeNames.get(0));\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;//we don't need to line up more than 2 designates\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else if(!designateIsInFront) {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) ){\n      List<String> sortedNodes = getSortedOverseerNodeNames(zk);\n\n      if(leaderNode.equals(sortedNodes.get(0))  ||         // I am leader and I am in front of the queue\n          overseerDesignates.contains(sortedNodes.get(0))) {// I am leader but somebody else is in the front , Screwed up leader election\n        //this means there are I am not a designate and the next guy is lined up to become the leader, kill myself\n        log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n      }\n    }\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes\");\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 0; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=0;j<i;j++){\n          if(!overseerDesignates.contains(nodeNames.get(j))) {\n            if(!nodesTobePushedBack.contains(nodeNames.get(j))) nodesTobePushedBack.add(nodeNames.get(j));\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (int i = nodesTobePushedBack.size() - 1; i >= 0; i--) {\n         String s = nodesTobePushedBack.get(i);\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) && !availableDesignates.isEmpty()){\n      //this means there are designated Overseer nodes and I am not one of them , kill myself\n      String newLeader = availableDesignates.get(0);\n      log.info(\"I am not an overseerdesignate , forcing a new leader {} \", newLeader);\n      invokeOverseerOp(newLeader, \"leader\");\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"88cbbe9e356acf78b7c0b780612767594fefcc5d","date":1400139979,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"prioritizing overseer nodes at {}\", LeaderElector.getNodeName(myId));\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n    boolean designateIsInFront = overseerDesignates.contains( nodeNames.get(0));\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;//we don't need to line up more than 2 designates\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else if(!designateIsInFront) {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) ){\n      List<String> sortedNodes = getSortedOverseerNodeNames(zk);\n\n      if(leaderNode.equals(sortedNodes.get(0))  ||         // I am leader and I am in front of the queue\n          overseerDesignates.contains(sortedNodes.get(0))) {// I am leader but somebody else is in the front , Screwed up leader election\n        //this means there are I am not a designate and the next guy is lined up to become the leader, kill myself\n        log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n      }\n    }\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes at {}\", LeaderElector.getNodeName(myId));\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n    boolean designateIsInFront = overseerDesignates.contains( nodeNames.get(0));\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;//we don't need to line up more than 2 designates\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else if(!designateIsInFront) {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) ){\n      List<String> sortedNodes = getSortedOverseerNodeNames(zk);\n\n      if(leaderNode.equals(sortedNodes.get(0))  ||         // I am leader and I am in front of the queue\n          overseerDesignates.contains(sortedNodes.get(0))) {// I am leader but somebody else is in the front , Screwed up leader election\n        //this means there are I am not a designate and the next guy is lined up to become the leader, kill myself\n        log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ccc69a67d5c846a04c7f71e28cb1914e3af895f3","date":1400252660,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"prioritizing overseer nodes at {}\", LeaderElector.getNodeName(myId));\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n    boolean designateIsInFront = overseerDesignates.contains( nodeNames.get(0));\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;//we don't need to line up more than 2 designates\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else if(!designateIsInFront) {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) ){\n      List<String> sortedNodes = getSortedOverseerNodeNames(zk);\n\n      if(leaderNode.equals(sortedNodes.get(0))  ||         // I am leader and I am in front of the queue\n          overseerDesignates.contains(sortedNodes.get(0))) {// I am leader but somebody else is in the front , Screwed up leader election\n        //this means there are I am not a designate and the next guy is lined up to become the leader, kill myself\n        log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n      }\n    }\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    log.info(\"prioritizing overseer nodes at {}\", LeaderElector.getNodeName(myId));\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n    boolean designateIsInFront = overseerDesignates.contains( nodeNames.get(0));\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;//we don't need to line up more than 2 designates\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else if(!designateIsInFront) {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) ){\n      List<String> sortedNodes = getSortedOverseerNodeNames(zk);\n\n      if(leaderNode.equals(sortedNodes.get(0))  ||         // I am leader and I am in front of the queue\n          overseerDesignates.contains(sortedNodes.get(0))) {// I am leader but somebody else is in the front , Screwed up leader election\n        //this means there are I am not a designate and the next guy is lined up to become the leader, kill myself\n        log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f26f74e4969851a019d28f10315cb1c77786f22","date":1400539241,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"prioritizing overseer nodes at {}\", LeaderElector.getNodeName(myId));\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n    boolean designateIsInFront = overseerDesignates.contains( nodeNames.get(0));\n\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.e at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;//we don't need to line up more than 2 designates\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else if(!designateIsInFront) {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) ){\n      List<String> sortedNodes = getSortedOverseerNodeNames(zk);\n\n      if(leaderNode.equals(sortedNodes.get(0))  ||         // I am leader and I am in front of the queue\n          overseerDesignates.contains(sortedNodes.get(0))) {// I am leader but somebody else is in the front , Screwed up leader election\n        //this means there are I am not a designate and the next guy is lined up to become the leader, kill myself\n        log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n      }\n    }\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"prioritizing overseer nodes at {}\", LeaderElector.getNodeName(myId));\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n    boolean designateIsInFront = overseerDesignates.contains( nodeNames.get(0));\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;//we don't need to line up more than 2 designates\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else if(!designateIsInFront) {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) ){\n      List<String> sortedNodes = getSortedOverseerNodeNames(zk);\n\n      if(leaderNode.equals(sortedNodes.get(0))  ||         // I am leader and I am in front of the queue\n          overseerDesignates.contains(sortedNodes.get(0))) {// I am leader but somebody else is in the front , Screwed up leader election\n        //this means there are I am not a designate and the next guy is lined up to become the leader, kill myself\n        log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"prioritizing overseer nodes at {}\", LeaderElector.getNodeName(myId));\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n    boolean designateIsInFront = overseerDesignates.contains( nodeNames.get(0));\n\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.e at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;//we don't need to line up more than 2 designates\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else if(!designateIsInFront) {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) ){\n      List<String> sortedNodes = getSortedOverseerNodeNames(zk);\n\n      if(leaderNode.equals(sortedNodes.get(0))  ||         // I am leader and I am in front of the queue\n          overseerDesignates.contains(sortedNodes.get(0))) {// I am leader but somebody else is in the front , Screwed up leader election\n        //this means there are I am not a designate and the next guy is lined up to become the leader, kill myself\n        log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n      }\n    }\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"prioritizing overseer nodes at {}\", LeaderElector.getNodeName(myId));\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n    boolean designateIsInFront = overseerDesignates.contains( nodeNames.get(0));\n\n//\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.r at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;//we don't need to line up more than 2 designates\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else if(!designateIsInFront) {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) ){\n      List<String> sortedNodes = getSortedOverseerNodeNames(zk);\n\n      if(leaderNode.equals(sortedNodes.get(0))  ||         // I am leader and I am in front of the queue\n          overseerDesignates.contains(sortedNodes.get(0))) {// I am leader but somebody else is in the front , Screwed up leader election\n        //this means there are I am not a designate and the next guy is lined up to become the leader, kill myself\n        log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d996c36bf85996da326201b915c87d41449d7f5","date":1403084374,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT,\n            \"id\",getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"prioritizing overseer nodes at {}\", LeaderElector.getNodeName(myId));\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n    boolean designateIsInFront = overseerDesignates.contains( nodeNames.get(0));\n\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.e at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;//we don't need to line up more than 2 designates\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else if(!designateIsInFront) {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) ){\n      List<String> sortedNodes = getSortedOverseerNodeNames(zk);\n\n      if(leaderNode.equals(sortedNodes.get(0))  ||         // I am leader and I am in front of the queue\n          overseerDesignates.contains(sortedNodes.get(0))) {// I am leader but somebody else is in the front , Screwed up leader election\n        //this means there are I am not a designate and the next guy is lined up to become the leader, kill myself\n        log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e57c73924f3b8c19defa62e96bfa34a4922d49c2","date":1403106358,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT,\n            \"id\",getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    if(overseerDesignates.size() == 1 && overseerDesignates.contains(getLeaderNode(zk))) return;\n    log.info(\"prioritizing overseer nodes at {}\", LeaderElector.getNodeName(myId));\n    log.info(\"overseer designates {}\", overseerDesignates);\n\n    List<String> nodeNames = getSortedOverseerNodeNames(zk);\n    if(nodeNames.size()<2) return;\n    boolean designateIsInFront = overseerDesignates.contains( nodeNames.get(0));\n\n    ArrayList<String> nodesTobePushedBack =  new ArrayList<>();\n    //ensure that the node right behind the leader , i.e at position 1 is a Overseer\n    List<String> availableDesignates = new ArrayList<>();\n\n    log.info(\"sorted nodes {}\", nodeNames);//TODO to be removed\n    for (int i = 1; i < nodeNames.size(); i++) {\n      String s = nodeNames.get(i);\n\n      if (overseerDesignates.contains(s)) {\n        availableDesignates.add(s);\n\n        for(int j=1;j<i;j++){\n          String n = nodeNames.get(j);\n          if(!overseerDesignates.contains(n)) {\n            if(!nodesTobePushedBack.contains(n)) nodesTobePushedBack.add(n);\n          }\n        }\n\n      }\n      if(availableDesignates.size()>1) break;//we don't need to line up more than 2 designates\n    }\n\n    if(!availableDesignates.isEmpty()){\n      for (String s : nodesTobePushedBack) {\n        log.info(\"pushing back {} \", s);\n        invokeOverseerOp(s, \"rejoin\");\n      }\n\n      //wait for a while to ensure the designate has indeed come in front\n      boolean prioritizationComplete = false;\n      long timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(2500, TimeUnit.MILLISECONDS);\n\n      while (System.nanoTime() < timeout) {\n        List<String> currentNodeNames = getSortedOverseerNodeNames(zk);\n\n        int totalLeaders = 0;\n\n        for(int i=0;i<availableDesignates.size();i++) {\n          if(overseerDesignates.contains(currentNodeNames.get(i))) totalLeaders++;\n        }\n        if(totalLeaders == availableDesignates.size()){\n          prioritizationComplete = true;\n          break;\n        }\n        try {\n          Thread.sleep(50);\n        } catch (InterruptedException e) {\n          log.warn(\"Thread interrupted\",e);\n          break;\n\n        }\n      }\n\n      if(!prioritizationComplete) {\n        log.warn(\"available designates and current state {} {} \", availableDesignates, getSortedOverseerNodeNames(zk));\n      }\n\n    } else if(!designateIsInFront) {\n      log.warn(\"No overseer designates are available, overseerDesignates: {}, live nodes : {}\",overseerDesignates,nodeNames);\n      return;\n    }\n\n    String leaderNode = getLeaderNode(zkStateReader.getZkClient());\n    if(leaderNode ==null) return;\n    if(!overseerDesignates.contains(leaderNode) ){\n      List<String> sortedNodes = getSortedOverseerNodeNames(zk);\n\n      if(leaderNode.equals(sortedNodes.get(0))  ||         // I am leader and I am in front of the queue\n          overseerDesignates.contains(sortedNodes.get(0))) {// I am leader but somebody else is in the front , Screwed up leader election\n        //this means there are I am not a designate and the next guy is lined up to become the leader, kill myself\n        log.info(\"I am not an overseer designate , forcing myself out {} \", leaderNode);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT)));\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c688f7052130cef7bd419c85e3c5be214f7b9e","date":1411018984,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.QUIT.toLower(),\n            \"id\",getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT,\n            \"id\",getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5455c7b3fed6c1671990a44c19071cb0488c2c25","date":1413557414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk, OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.QUIT.toLower(),\n            \"id\",getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.QUIT.toLower(),\n            \"id\",getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk, OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.QUIT.toLower(),\n            \"id\",getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.QUIT.toLower(),\n            \"id\",getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24a5da2a0d397ff29f3de8f6cf451d3412c2509a","date":1417276391,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk, OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\",getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk, OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.QUIT.toLower(),\n            \"id\",getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk, OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk, OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\",getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":5,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerNodePrioritizer#prioritizeOverseerNodes(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#prioritizeOverseerNodes().mjava","sourceNew":"  public synchronized void prioritizeOverseerNodes(String overseerId) throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = OverseerProcessor.getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", overseerId, overseerDesignates);\n    List<String> electionNodes = OverseerProcessor.getSortedElectionNodes(zk, OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", OverseerProcessor.getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","sourceOld":"  private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {\n    SolrZkClient zk = zkStateReader.getZkClient();\n    if(!zk.exists(ZkStateReader.ROLES,true))return;\n    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));\n\n    List overseerDesignates = (List) m.get(\"overseer\");\n    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;\n    String ldr = getLeaderNode(zk);\n    if(overseerDesignates.contains(ldr)) return;\n    log.info(\"prioritizing overseer nodes at {} overseer designates are {}\", myId, overseerDesignates);\n    List<String> electionNodes = getSortedElectionNodes(zk, OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE);\n    if(electionNodes.size()<2) return;\n    log.info(\"sorted nodes {}\", electionNodes);\n\n    String designateNodeId = null;\n    for (String electionNode : electionNodes) {\n      if(overseerDesignates.contains( LeaderElector.getNodeName(electionNode))){\n        designateNodeId = electionNode;\n        break;\n      }\n    }\n\n    if(designateNodeId == null){\n      log.warn(\"No live overseer designate \");\n      return;\n    }\n    if(!designateNodeId.equals( electionNodes.get(1))) { //checking if it is already at no:1\n      log.info(\"asking node {} to come join election at head\", designateNodeId);\n      invokeOverseerOp(designateNodeId, \"rejoinAtHead\"); //ask designate to come first\n      log.info(\"asking the old first in line {} to rejoin election  \",electionNodes.get(1) );\n      invokeOverseerOp(electionNodes.get(1), \"rejoin\");//ask second inline to go behind\n    }\n    //now ask the current leader to QUIT , so that the designate can takeover\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(\n        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", getLeaderId(zkStateReader.getZkClient()))));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5cb311c383e1415a29ce2598bbd9e2db0d061c61":["44de42d869f7d8e5235d43c4ad9a99f520363a2f"],"7d996c36bf85996da326201b915c87d41449d7f5":["6f26f74e4969851a019d28f10315cb1c77786f22"],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":["6f26f74e4969851a019d28f10315cb1c77786f22","7d996c36bf85996da326201b915c87d41449d7f5"],"097d97da7591c3b0a99b055b589ff086a1132de8":["5cb311c383e1415a29ce2598bbd9e2db0d061c61"],"b7605579001505896d48b07160075a5c8b8e128e":["88cbbe9e356acf78b7c0b780612767594fefcc5d","6f26f74e4969851a019d28f10315cb1c77786f22"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["7d996c36bf85996da326201b915c87d41449d7f5"],"44de42d869f7d8e5235d43c4ad9a99f520363a2f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["702f9eb5f4d8ac6dea3945928de043b9d25fa87d"],"ccc69a67d5c846a04c7f71e28cb1914e3af895f3":["8295a0e649f894ba19be89ef3b8887648978525f","88cbbe9e356acf78b7c0b780612767594fefcc5d"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["5455c7b3fed6c1671990a44c19071cb0488c2c25"],"5b15576cafd8b5d06857055c28f26912321937e3":["7e66d99e5beccb546edd910c91f646fb7d831a94"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"82ed10ec58814cd9841195fb52bcbc1c2402e2cc":["097d97da7591c3b0a99b055b589ff086a1132de8"],"7e66d99e5beccb546edd910c91f646fb7d831a94":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"6f26f74e4969851a019d28f10315cb1c77786f22":["88cbbe9e356acf78b7c0b780612767594fefcc5d"],"8295a0e649f894ba19be89ef3b8887648978525f":["5b15576cafd8b5d06857055c28f26912321937e3"],"5eb2511ababf862ea11e10761c70ee560cd84510":["7e66d99e5beccb546edd910c91f646fb7d831a94","8295a0e649f894ba19be89ef3b8887648978525f"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"88cbbe9e356acf78b7c0b780612767594fefcc5d":["8295a0e649f894ba19be89ef3b8887648978525f"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"5455c7b3fed6c1671990a44c19071cb0488c2c25":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"702f9eb5f4d8ac6dea3945928de043b9d25fa87d":["0e17ab2be80de52a97a870438adf8ac15f574359"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["30c688f7052130cef7bd419c85e3c5be214f7b9e","5455c7b3fed6c1671990a44c19071cb0488c2c25"],"0e17ab2be80de52a97a870438adf8ac15f574359":["82ed10ec58814cd9841195fb52bcbc1c2402e2cc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"]},"commit2Childs":{"5cb311c383e1415a29ce2598bbd9e2db0d061c61":["097d97da7591c3b0a99b055b589ff086a1132de8"],"7d996c36bf85996da326201b915c87d41449d7f5":["e57c73924f3b8c19defa62e96bfa34a4922d49c2","30c688f7052130cef7bd419c85e3c5be214f7b9e"],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":[],"097d97da7591c3b0a99b055b589ff086a1132de8":["82ed10ec58814cd9841195fb52bcbc1c2402e2cc"],"b7605579001505896d48b07160075a5c8b8e128e":[],"44de42d869f7d8e5235d43c4ad9a99f520363a2f":["5cb311c383e1415a29ce2598bbd9e2db0d061c61"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["5455c7b3fed6c1671990a44c19071cb0488c2c25","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"ccc69a67d5c846a04c7f71e28cb1914e3af895f3":[],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"5b15576cafd8b5d06857055c28f26912321937e3":["8295a0e649f894ba19be89ef3b8887648978525f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["44de42d869f7d8e5235d43c4ad9a99f520363a2f"],"82ed10ec58814cd9841195fb52bcbc1c2402e2cc":["0e17ab2be80de52a97a870438adf8ac15f574359"],"7e66d99e5beccb546edd910c91f646fb7d831a94":["5b15576cafd8b5d06857055c28f26912321937e3","5eb2511ababf862ea11e10761c70ee560cd84510"],"6f26f74e4969851a019d28f10315cb1c77786f22":["7d996c36bf85996da326201b915c87d41449d7f5","e57c73924f3b8c19defa62e96bfa34a4922d49c2","b7605579001505896d48b07160075a5c8b8e128e"],"8295a0e649f894ba19be89ef3b8887648978525f":["ccc69a67d5c846a04c7f71e28cb1914e3af895f3","5eb2511ababf862ea11e10761c70ee560cd84510","88cbbe9e356acf78b7c0b780612767594fefcc5d"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7e66d99e5beccb546edd910c91f646fb7d831a94"],"88cbbe9e356acf78b7c0b780612767594fefcc5d":["b7605579001505896d48b07160075a5c8b8e128e","ccc69a67d5c846a04c7f71e28cb1914e3af895f3","6f26f74e4969851a019d28f10315cb1c77786f22"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"5455c7b3fed6c1671990a44c19071cb0488c2c25":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"702f9eb5f4d8ac6dea3945928de043b9d25fa87d":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"0e17ab2be80de52a97a870438adf8ac15f574359":["702f9eb5f4d8ac6dea3945928de043b9d25fa87d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e57c73924f3b8c19defa62e96bfa34a4922d49c2","b7605579001505896d48b07160075a5c8b8e128e","ccc69a67d5c846a04c7f71e28cb1914e3af895f3","5eb2511ababf862ea11e10761c70ee560cd84510","0a22eafe3f72a4c2945eaad9547e6c78816978f4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}