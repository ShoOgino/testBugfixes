{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#incrementToken().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#incrementToken().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    //System.out.println(\"\\nS: incrToken inputSkipCount=\" + inputSkipCount + \" nextRead=\" + nextRead + \" nextWrite=\" + nextWrite);\n\n    while(true) {\n\n      // First play back any buffered future inputs/outputs\n      // w/o running parsing again:\n      while (inputSkipCount != 0) {\n        \n        // At each position, we first output the original\n        // token\n\n        // TODO: maybe just a PendingState class, holding\n        // both input & outputs?\n        final PendingInput input = futureInputs[nextRead];\n        final PendingOutputs outputs = futureOutputs[nextRead];\n        \n        //System.out.println(\"  cycle nextRead=\" + nextRead + \" nextWrite=\" + nextWrite + \" inputSkipCount=\"+ inputSkipCount + \" input.keepOrig=\" + input.keepOrig + \" input.consumed=\" + input.consumed + \" input.state=\" + input.state);\n\n        if (!input.consumed && (input.keepOrig || !input.matched)) {\n          if (input.state != null) {\n            // Return a previously saved token (because we\n            // had to lookahead):\n            restoreState(input.state);\n          } else {\n            // Pass-through case: return token we just pulled\n            // but didn't capture:\n            assert inputSkipCount == 1: \"inputSkipCount=\" + inputSkipCount + \" nextRead=\" + nextRead;\n          }\n          input.reset();\n          if (outputs.count > 0) {\n            outputs.posIncr = 0;\n          } else {\n            nextRead = rollIncr(nextRead);\n            inputSkipCount--;\n          }\n          //System.out.println(\"  return token=\" + termAtt.toString());\n          return true;\n        } else if (outputs.upto < outputs.count) {\n          // Still have pending outputs to replay at this\n          // position\n          input.reset();\n          final int posIncr = outputs.posIncr;\n          final CharsRef output = outputs.pullNext();\n          clearAttributes();\n          termAtt.copyBuffer(output.chars, output.offset, output.length);\n          typeAtt.setType(TYPE_SYNONYM);\n          int endOffset = outputs.getLastEndOffset();\n          if (endOffset == -1) {\n            endOffset = input.endOffset;\n          }\n          offsetAtt.setOffset(input.startOffset, endOffset);\n          posIncrAtt.setPositionIncrement(posIncr);\n          posLenAtt.setPositionLength(outputs.getLastPosLength());\n          if (outputs.count == 0) {\n            // Done with the buffered input and all outputs at\n            // this position\n            nextRead = rollIncr(nextRead);\n            inputSkipCount--;\n          }\n          //System.out.println(\"  return token=\" + termAtt.toString());\n          return true;\n        } else {\n          // Done with the buffered input and all outputs at\n          // this position\n          input.reset();\n          nextRead = rollIncr(nextRead);\n          inputSkipCount--;\n        }\n      }\n\n      if (finished && nextRead == nextWrite) {\n        // End case: if any output syns went beyond end of\n        // input stream, enumerate them now:\n        final PendingOutputs outputs = futureOutputs[nextRead];\n        if (outputs.upto < outputs.count) {\n          final int posIncr = outputs.posIncr;\n          final CharsRef output = outputs.pullNext();\n          futureInputs[nextRead].reset();\n          if (outputs.count == 0) {\n            nextWrite = nextRead = rollIncr(nextRead);\n          }\n          clearAttributes();\n          // Keep offset from last input token:\n          offsetAtt.setOffset(lastStartOffset, lastEndOffset);\n          termAtt.copyBuffer(output.chars, output.offset, output.length);\n          typeAtt.setType(TYPE_SYNONYM);\n          //System.out.println(\"  set posIncr=\" + outputs.posIncr + \" outputs=\" + outputs);\n          posIncrAtt.setPositionIncrement(posIncr);\n          //System.out.println(\"  return token=\" + termAtt.toString());\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      // Find new synonym matches:\n      parse();\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    //System.out.println(\"\\nS: incrToken inputSkipCount=\" + inputSkipCount + \" nextRead=\" + nextRead + \" nextWrite=\" + nextWrite);\n\n    while(true) {\n\n      // First play back any buffered future inputs/outputs\n      // w/o running parsing again:\n      while (inputSkipCount != 0) {\n        \n        // At each position, we first output the original\n        // token\n\n        // TODO: maybe just a PendingState class, holding\n        // both input & outputs?\n        final PendingInput input = futureInputs[nextRead];\n        final PendingOutputs outputs = futureOutputs[nextRead];\n        \n        //System.out.println(\"  cycle nextRead=\" + nextRead + \" nextWrite=\" + nextWrite + \" inputSkipCount=\"+ inputSkipCount + \" input.keepOrig=\" + input.keepOrig + \" input.consumed=\" + input.consumed + \" input.state=\" + input.state);\n\n        if (!input.consumed && (input.keepOrig || !input.matched)) {\n          if (input.state != null) {\n            // Return a previously saved token (because we\n            // had to lookahead):\n            restoreState(input.state);\n          } else {\n            // Pass-through case: return token we just pulled\n            // but didn't capture:\n            assert inputSkipCount == 1: \"inputSkipCount=\" + inputSkipCount + \" nextRead=\" + nextRead;\n          }\n          input.reset();\n          if (outputs.count > 0) {\n            outputs.posIncr = 0;\n          } else {\n            nextRead = rollIncr(nextRead);\n            inputSkipCount--;\n          }\n          //System.out.println(\"  return token=\" + termAtt.toString());\n          return true;\n        } else if (outputs.upto < outputs.count) {\n          // Still have pending outputs to replay at this\n          // position\n          input.reset();\n          final int posIncr = outputs.posIncr;\n          final CharsRef output = outputs.pullNext();\n          clearAttributes();\n          termAtt.copyBuffer(output.chars, output.offset, output.length);\n          typeAtt.setType(TYPE_SYNONYM);\n          int endOffset = outputs.getLastEndOffset();\n          if (endOffset == -1) {\n            endOffset = input.endOffset;\n          }\n          offsetAtt.setOffset(input.startOffset, endOffset);\n          posIncrAtt.setPositionIncrement(posIncr);\n          posLenAtt.setPositionLength(outputs.getLastPosLength());\n          if (outputs.count == 0) {\n            // Done with the buffered input and all outputs at\n            // this position\n            nextRead = rollIncr(nextRead);\n            inputSkipCount--;\n          }\n          //System.out.println(\"  return token=\" + termAtt.toString());\n          return true;\n        } else {\n          // Done with the buffered input and all outputs at\n          // this position\n          input.reset();\n          nextRead = rollIncr(nextRead);\n          inputSkipCount--;\n        }\n      }\n\n      if (finished && nextRead == nextWrite) {\n        // End case: if any output syns went beyond end of\n        // input stream, enumerate them now:\n        final PendingOutputs outputs = futureOutputs[nextRead];\n        if (outputs.upto < outputs.count) {\n          final int posIncr = outputs.posIncr;\n          final CharsRef output = outputs.pullNext();\n          futureInputs[nextRead].reset();\n          if (outputs.count == 0) {\n            nextWrite = nextRead = rollIncr(nextRead);\n          }\n          clearAttributes();\n          // Keep offset from last input token:\n          offsetAtt.setOffset(lastStartOffset, lastEndOffset);\n          termAtt.copyBuffer(output.chars, output.offset, output.length);\n          typeAtt.setType(TYPE_SYNONYM);\n          //System.out.println(\"  set posIncr=\" + outputs.posIncr + \" outputs=\" + outputs);\n          posIncrAtt.setPositionIncrement(posIncr);\n          //System.out.println(\"  return token=\" + termAtt.toString());\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      // Find new synonym matches:\n      parse();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}