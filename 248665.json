{"path":"lucene/core/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,char[]).mjava","commits":[{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,char[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","sourceNew":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. It is the\n   * responsibility of the caller to make sure that the destination array is large enough.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  // TODO: broken if chars.offset != 0\n  public static int UTF8toUTF16(byte[] utf8, int offset, int length, char[] out) {\n    int out_offset = 0;\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8: \"b = 0x\" + Integer.toHexString(b);\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    return out_offset;\n  }\n\n","sourceOld":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  // TODO: broken if chars.offset != 0\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8: \"b = 0x\" + Integer.toHexString(b);\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}