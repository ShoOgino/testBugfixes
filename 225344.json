{"path":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"modules/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ada2f7352a7f964fe49bccd13227c4ec38563d39","date":1381659982,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreqPayload[] keys = new TermFreqPayload[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreqPayload(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqPayloadArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41aee74b5f91a096e3fd950f4a336bc763f0e7a7","date":1381772070,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    Input[] keys = new Input[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new Input(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new InputArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreqPayload[] keys = new TermFreqPayload[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreqPayload(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqPayloadArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a645276cbaf5dc96a42fd473b9019bde352996c8","date":1391806699,"type":3,"author":"Areek Zillur","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    Input[] keys = new Input[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new Input(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(numWords, suggester.getCount());\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    Input[] keys = new Input[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new Input(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new InputArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    Input[] keys = new Input[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new Input(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(numWords, suggester.getCount());\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    Input[] keys = new Input[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new Input(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(numWords, suggester.getCount());\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n    \n    Input[] keys = new Input[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new Input(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(numWords, suggester.getCount());\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    Input[] keys = new Input[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new Input(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(numWords, suggester.getCount());\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n    \n    Input[] keys = new Input[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new Input(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(numWords, suggester.getCount());\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<>();\n\n      // TODO: could be faster... but it's slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n    \n    Input[] keys = new Input[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new Input(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(numWords, suggester.getCount());\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"867e3d9153fb761456b54a9dcce566e1545c5ef6","date":1444903098,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n    \n    Input[] keys = new Input[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new Input(s, weight);\n    }\n\n    Directory tempDir = getDirectory();\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(tempDir, \"wfst\", false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(numWords, suggester.getCount());\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<>();\n\n      // TODO: could be faster... but it's slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n    tempDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<>();\n    final TreeSet<String> allPrefixes = new TreeSet<>();\n    \n    Input[] keys = new Input[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new Input(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(numWords, suggester.getCount());\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check it's actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<>();\n\n      // TODO: could be faster... but it's slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        @Override\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["b89678825b68eccaf09e6ab71675fc0b0af1e099","7530de27b87b961b51f01bd1299b7004d46e8823"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"41aee74b5f91a096e3fd950f4a336bc763f0e7a7":["ada2f7352a7f964fe49bccd13227c4ec38563d39"],"6613659748fe4411a7dcf85266e55db1f95f7315":["a645276cbaf5dc96a42fd473b9019bde352996c8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a645276cbaf5dc96a42fd473b9019bde352996c8":["41aee74b5f91a096e3fd950f4a336bc763f0e7a7"],"7530de27b87b961b51f01bd1299b7004d46e8823":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"ada2f7352a7f964fe49bccd13227c4ec38563d39":["7530de27b87b961b51f01bd1299b7004d46e8823"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"41aee74b5f91a096e3fd950f4a336bc763f0e7a7":["a645276cbaf5dc96a42fd473b9019bde352996c8"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"a645276cbaf5dc96a42fd473b9019bde352996c8":["6613659748fe4411a7dcf85266e55db1f95f7315"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","ada2f7352a7f964fe49bccd13227c4ec38563d39"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ada2f7352a7f964fe49bccd13227c4ec38563d39":["41aee74b5f91a096e3fd950f4a336bc763f0e7a7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}