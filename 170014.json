{"path":"modules/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateHTMLStripCharFilterSupplementaryMacros#outputMacro(String,String).mjava","commits":[{"id":"e3a908bacd530957eaa6d2dfebdd534afd9ac60e","date":1327209646,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"modules/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateHTMLStripCharFilterSupplementaryMacros#outputMacro(String,String).mjava","pathOld":"/dev/null","sourceNew":"  // we have to carefully output the possibilities as compact utf-16\r\n  // range expressions, or jflex will OOM!\r\n  static void outputMacro(String name, String pattern) {\r\n    UnicodeSet set = new UnicodeSet(pattern);\r\n    set.removeAll(BMP);\r\n    System.out.println(name + \" = (\");\r\n    // if the set is empty, we have to do this or jflex will barf\r\n    if (set.isEmpty()) {\r\n      System.out.println(\"\\t  []\");\r\n    }\r\n\r\n    HashMap<Character,UnicodeSet> utf16ByLead = new HashMap<Character,UnicodeSet>();\r\n    for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.next();) {\r\n      char utf16[] = Character.toChars(it.codepoint);\r\n      UnicodeSet trails = utf16ByLead.get(utf16[0]);\r\n      if (trails == null) {\r\n        trails = new UnicodeSet();\r\n        utf16ByLead.put(utf16[0], trails);\r\n      }\r\n      trails.add(utf16[1]);\r\n    }\r\n    \r\n    Map<String,UnicodeSet> utf16ByTrail = new HashMap<String,UnicodeSet>();\r\n    for (Map.Entry<Character,UnicodeSet> entry : utf16ByLead.entrySet()) {\r\n      String trail = entry.getValue().getRegexEquivalent();\r\n      UnicodeSet leads = utf16ByTrail.get(trail);\r\n      if (leads == null) {\r\n        leads = new UnicodeSet();\r\n        utf16ByTrail.put(trail, leads);\r\n      }\r\n      leads.add(entry.getKey());\r\n    }\r\n\r\n    boolean isFirst = true;\r\n    for (Map.Entry<String,UnicodeSet> entry : utf16ByTrail.entrySet()) {\r\n      System.out.print( isFirst ? \"\\t  \" : \"\\t| \");\r\n      isFirst = false;\r\n      System.out.println(entry.getValue().getRegexEquivalent() + entry.getKey());\r\n    }\r\n    System.out.println(\")\");\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"579dc30b5d3235c34cda518b2b6018d71a61879c","date":1327235122,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"modules/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateHTMLStripCharFilterSupplementaryMacros#outputMacro(String,String).mjava","pathOld":"/dev/null","sourceNew":"  // we have to carefully output the possibilities as compact utf-16\r\n  // range expressions, or jflex will OOM!\r\n  static void outputMacro(String name, String pattern) {\r\n    UnicodeSet set = new UnicodeSet(pattern);\r\n    set.removeAll(BMP);\r\n    System.out.println(name + \" = (\");\r\n    // if the set is empty, we have to do this or jflex will barf\r\n    if (set.isEmpty()) {\r\n      System.out.println(\"\\t  []\");\r\n    }\r\n\r\n    HashMap<Character,UnicodeSet> utf16ByLead = new HashMap<Character,UnicodeSet>();\r\n    for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.next();) {\r\n      char utf16[] = Character.toChars(it.codepoint);\r\n      UnicodeSet trails = utf16ByLead.get(utf16[0]);\r\n      if (trails == null) {\r\n        trails = new UnicodeSet();\r\n        utf16ByLead.put(utf16[0], trails);\r\n      }\r\n      trails.add(utf16[1]);\r\n    }\r\n    \r\n    Map<String,UnicodeSet> utf16ByTrail = new HashMap<String,UnicodeSet>();\r\n    for (Map.Entry<Character,UnicodeSet> entry : utf16ByLead.entrySet()) {\r\n      String trail = entry.getValue().getRegexEquivalent();\r\n      UnicodeSet leads = utf16ByTrail.get(trail);\r\n      if (leads == null) {\r\n        leads = new UnicodeSet();\r\n        utf16ByTrail.put(trail, leads);\r\n      }\r\n      leads.add(entry.getKey());\r\n    }\r\n\r\n    boolean isFirst = true;\r\n    for (Map.Entry<String,UnicodeSet> entry : utf16ByTrail.entrySet()) {\r\n      System.out.print( isFirst ? \"\\t  \" : \"\\t| \");\r\n      isFirst = false;\r\n      System.out.println(entry.getValue().getRegexEquivalent() + entry.getKey());\r\n    }\r\n    System.out.println(\")\");\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"modules/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateHTMLStripCharFilterSupplementaryMacros#outputMacro(String,String).mjava","pathOld":"/dev/null","sourceNew":"  // we have to carefully output the possibilities as compact utf-16\r\n  // range expressions, or jflex will OOM!\r\n  static void outputMacro(String name, String pattern) {\r\n    UnicodeSet set = new UnicodeSet(pattern);\r\n    set.removeAll(BMP);\r\n    System.out.println(name + \" = (\");\r\n    // if the set is empty, we have to do this or jflex will barf\r\n    if (set.isEmpty()) {\r\n      System.out.println(\"\\t  []\");\r\n    }\r\n\r\n    HashMap<Character,UnicodeSet> utf16ByLead = new HashMap<Character,UnicodeSet>();\r\n    for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.next();) {\r\n      char utf16[] = Character.toChars(it.codepoint);\r\n      UnicodeSet trails = utf16ByLead.get(utf16[0]);\r\n      if (trails == null) {\r\n        trails = new UnicodeSet();\r\n        utf16ByLead.put(utf16[0], trails);\r\n      }\r\n      trails.add(utf16[1]);\r\n    }\r\n    \r\n    Map<String,UnicodeSet> utf16ByTrail = new HashMap<String,UnicodeSet>();\r\n    for (Map.Entry<Character,UnicodeSet> entry : utf16ByLead.entrySet()) {\r\n      String trail = entry.getValue().getRegexEquivalent();\r\n      UnicodeSet leads = utf16ByTrail.get(trail);\r\n      if (leads == null) {\r\n        leads = new UnicodeSet();\r\n        utf16ByTrail.put(trail, leads);\r\n      }\r\n      leads.add(entry.getKey());\r\n    }\r\n\r\n    boolean isFirst = true;\r\n    for (Map.Entry<String,UnicodeSet> entry : utf16ByTrail.entrySet()) {\r\n      System.out.print( isFirst ? \"\\t  \" : \"\\t| \");\r\n      isFirst = false;\r\n      System.out.println(entry.getValue().getRegexEquivalent() + entry.getKey());\r\n    }\r\n    System.out.println(\")\");\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23","date":1332766738,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateHTMLStripCharFilterSupplementaryMacros#outputMacro(String,String).mjava","pathOld":"modules/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateHTMLStripCharFilterSupplementaryMacros#outputMacro(String,String).mjava","sourceNew":"  // we have to carefully output the possibilities as compact utf-16\n  // range expressions, or jflex will OOM!\n  static void outputMacro(String name, String pattern) {\n    UnicodeSet set = new UnicodeSet(pattern);\n    set.removeAll(BMP);\n    System.out.println(name + \" = (\");\n    // if the set is empty, we have to do this or jflex will barf\n    if (set.isEmpty()) {\n      System.out.println(\"\\t  []\");\n    }\n\n    HashMap<Character,UnicodeSet> utf16ByLead = new HashMap<Character,UnicodeSet>();\n    for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.next();) {\n      char utf16[] = Character.toChars(it.codepoint);\n      UnicodeSet trails = utf16ByLead.get(utf16[0]);\n      if (trails == null) {\n        trails = new UnicodeSet();\n        utf16ByLead.put(utf16[0], trails);\n      }\n      trails.add(utf16[1]);\n    }\n    \n    Map<String,UnicodeSet> utf16ByTrail = new HashMap<String,UnicodeSet>();\n    for (Map.Entry<Character,UnicodeSet> entry : utf16ByLead.entrySet()) {\n      String trail = entry.getValue().getRegexEquivalent();\n      UnicodeSet leads = utf16ByTrail.get(trail);\n      if (leads == null) {\n        leads = new UnicodeSet();\n        utf16ByTrail.put(trail, leads);\n      }\n      leads.add(entry.getKey());\n    }\n\n    boolean isFirst = true;\n    for (Map.Entry<String,UnicodeSet> entry : utf16ByTrail.entrySet()) {\n      System.out.print( isFirst ? \"\\t  \" : \"\\t| \");\n      isFirst = false;\n      System.out.println(entry.getValue().getRegexEquivalent() + entry.getKey());\n    }\n    System.out.println(\")\");\n  }\n\n","sourceOld":"  // we have to carefully output the possibilities as compact utf-16\r\n  // range expressions, or jflex will OOM!\r\n  static void outputMacro(String name, String pattern) {\r\n    UnicodeSet set = new UnicodeSet(pattern);\r\n    set.removeAll(BMP);\r\n    System.out.println(name + \" = (\");\r\n    // if the set is empty, we have to do this or jflex will barf\r\n    if (set.isEmpty()) {\r\n      System.out.println(\"\\t  []\");\r\n    }\r\n\r\n    HashMap<Character,UnicodeSet> utf16ByLead = new HashMap<Character,UnicodeSet>();\r\n    for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.next();) {\r\n      char utf16[] = Character.toChars(it.codepoint);\r\n      UnicodeSet trails = utf16ByLead.get(utf16[0]);\r\n      if (trails == null) {\r\n        trails = new UnicodeSet();\r\n        utf16ByLead.put(utf16[0], trails);\r\n      }\r\n      trails.add(utf16[1]);\r\n    }\r\n    \r\n    Map<String,UnicodeSet> utf16ByTrail = new HashMap<String,UnicodeSet>();\r\n    for (Map.Entry<Character,UnicodeSet> entry : utf16ByLead.entrySet()) {\r\n      String trail = entry.getValue().getRegexEquivalent();\r\n      UnicodeSet leads = utf16ByTrail.get(trail);\r\n      if (leads == null) {\r\n        leads = new UnicodeSet();\r\n        utf16ByTrail.put(trail, leads);\r\n      }\r\n      leads.add(entry.getKey());\r\n    }\r\n\r\n    boolean isFirst = true;\r\n    for (Map.Entry<String,UnicodeSet> entry : utf16ByTrail.entrySet()) {\r\n      System.out.print( isFirst ? \"\\t  \" : \"\\t| \");\r\n      isFirst = false;\r\n      System.out.println(entry.getValue().getRegexEquivalent() + entry.getKey());\r\n    }\r\n    System.out.println(\")\");\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateHTMLStripCharFilterSupplementaryMacros#outputMacro(String,String).mjava","pathOld":"modules/analysis/icu/src/tools/java/org/apache/lucene/analysis/icu/GenerateHTMLStripCharFilterSupplementaryMacros#outputMacro(String,String).mjava","sourceNew":"  // we have to carefully output the possibilities as compact utf-16\n  // range expressions, or jflex will OOM!\n  static void outputMacro(String name, String pattern) {\n    UnicodeSet set = new UnicodeSet(pattern);\n    set.removeAll(BMP);\n    System.out.println(name + \" = (\");\n    // if the set is empty, we have to do this or jflex will barf\n    if (set.isEmpty()) {\n      System.out.println(\"\\t  []\");\n    }\n\n    HashMap<Character,UnicodeSet> utf16ByLead = new HashMap<Character,UnicodeSet>();\n    for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.next();) {\n      char utf16[] = Character.toChars(it.codepoint);\n      UnicodeSet trails = utf16ByLead.get(utf16[0]);\n      if (trails == null) {\n        trails = new UnicodeSet();\n        utf16ByLead.put(utf16[0], trails);\n      }\n      trails.add(utf16[1]);\n    }\n    \n    Map<String,UnicodeSet> utf16ByTrail = new HashMap<String,UnicodeSet>();\n    for (Map.Entry<Character,UnicodeSet> entry : utf16ByLead.entrySet()) {\n      String trail = entry.getValue().getRegexEquivalent();\n      UnicodeSet leads = utf16ByTrail.get(trail);\n      if (leads == null) {\n        leads = new UnicodeSet();\n        utf16ByTrail.put(trail, leads);\n      }\n      leads.add(entry.getKey());\n    }\n\n    boolean isFirst = true;\n    for (Map.Entry<String,UnicodeSet> entry : utf16ByTrail.entrySet()) {\n      System.out.print( isFirst ? \"\\t  \" : \"\\t| \");\n      isFirst = false;\n      System.out.println(entry.getValue().getRegexEquivalent() + entry.getKey());\n    }\n    System.out.println(\")\");\n  }\n\n","sourceOld":"  // we have to carefully output the possibilities as compact utf-16\n  // range expressions, or jflex will OOM!\n  static void outputMacro(String name, String pattern) {\n    UnicodeSet set = new UnicodeSet(pattern);\n    set.removeAll(BMP);\n    System.out.println(name + \" = (\");\n    // if the set is empty, we have to do this or jflex will barf\n    if (set.isEmpty()) {\n      System.out.println(\"\\t  []\");\n    }\n\n    HashMap<Character,UnicodeSet> utf16ByLead = new HashMap<Character,UnicodeSet>();\n    for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.next();) {\n      char utf16[] = Character.toChars(it.codepoint);\n      UnicodeSet trails = utf16ByLead.get(utf16[0]);\n      if (trails == null) {\n        trails = new UnicodeSet();\n        utf16ByLead.put(utf16[0], trails);\n      }\n      trails.add(utf16[1]);\n    }\n    \n    Map<String,UnicodeSet> utf16ByTrail = new HashMap<String,UnicodeSet>();\n    for (Map.Entry<Character,UnicodeSet> entry : utf16ByLead.entrySet()) {\n      String trail = entry.getValue().getRegexEquivalent();\n      UnicodeSet leads = utf16ByTrail.get(trail);\n      if (leads == null) {\n        leads = new UnicodeSet();\n        utf16ByTrail.put(trail, leads);\n      }\n      leads.add(entry.getKey());\n    }\n\n    boolean isFirst = true;\n    for (Map.Entry<String,UnicodeSet> entry : utf16ByTrail.entrySet()) {\n      System.out.print( isFirst ? \"\\t  \" : \"\\t| \");\n      isFirst = false;\n      System.out.println(entry.getValue().getRegexEquivalent() + entry.getKey());\n    }\n    System.out.println(\")\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23"],"5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23":["e3a908bacd530957eaa6d2dfebdd534afd9ac60e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e3a908bacd530957eaa6d2dfebdd534afd9ac60e"],"e3a908bacd530957eaa6d2dfebdd534afd9ac60e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"579dc30b5d3235c34cda518b2b6018d71a61879c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e3a908bacd530957eaa6d2dfebdd534afd9ac60e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","e3a908bacd530957eaa6d2dfebdd534afd9ac60e","579dc30b5d3235c34cda518b2b6018d71a61879c"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"e3a908bacd530957eaa6d2dfebdd534afd9ac60e":["5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","579dc30b5d3235c34cda518b2b6018d71a61879c"],"579dc30b5d3235c34cda518b2b6018d71a61879c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","579dc30b5d3235c34cda518b2b6018d71a61879c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}