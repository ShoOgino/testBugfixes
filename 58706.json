{"path":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"/dev/null","sourceNew":"  PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08932c793647a36953d1816b1060121f48820d3f","date":1277386540,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","sourceOld":"  PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","sourceOld":"  PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"163fe85a71d778fd2b7747f65ca27b54829e2e57","date":1279898785,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  // If unicodeSortOrder is true, we do the surrogates dance\n  // so that the terms are sorted by unicode sort order.\n  // This should be true when segments are used for \"normal\"\n  // searching; it's only false during testing, to create a\n  // pre-flex index, using the preflexrw codec under\n  // src/test.\n  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor, boolean unicodeSortOrder)\n    throws IOException {\n\n    si = info;\n    this.unicodeSortOrder = unicodeSortOrder;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","sourceOld":"  PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"399a364d374f2132b6d9ff9fd7f997a9f2ef734f","date":1279978822,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int,boolean).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","sourceOld":"  // If unicodeSortOrder is true, we do the surrogates dance\n  // so that the terms are sorted by unicode sort order.\n  // This should be true when segments are used for \"normal\"\n  // searching; it's only false during testing, to create a\n  // pre-flex index, using the preflexrw codec under\n  // src/test.\n  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor, boolean unicodeSortOrder)\n    throws IOException {\n\n    si = info;\n    this.unicodeSortOrder = unicodeSortOrder;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b103252dee6afa1b6d7a622c773d178788eb85a","date":1280180143,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","sourceOld":"  PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","sourceOld":"  PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"150488c1317972164a9a824be05b1ba2ba0fc68c","date":1284316090,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        preTerms.put(fieldInfo.name, new PreTerms(fieldInfo));\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"779d98b0c99c917811ad25cd9b03cd63607b4876","date":1289388180,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      final int numFields = fieldInfos.size();\n      for(int i=0;i<numFields;i++) {\n        final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n        if (fieldInfo.isIndexed) {\n          fields.put(fieldInfo.name, fieldInfo);\n          preTerms.put(fieldInfo.name, new PreTerms(fieldInfo));\n          if (!fieldInfo.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        preTerms.put(fieldInfo.name, new PreTerms(fieldInfo));\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85a883878c0af761245ab048babc63d099f835f3","date":1289553330,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      final int numFields = fieldInfos.size();\n      for(int i=0;i<numFields;i++) {\n        final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n        if (fieldInfo.isIndexed) {\n          fields.put(fieldInfo.name, fieldInfo);\n          preTerms.put(fieldInfo.name, new PreTerms(fieldInfo));\n          if (!fieldInfo.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        preTerms.put(fieldInfo.name, new PreTerms(fieldInfo));\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      final int numFields = fieldInfos.size();\n      for(int i=0;i<numFields;i++) {\n        final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n        if (fieldInfo.isIndexed) {\n          fields.put(fieldInfo.name, fieldInfo);\n          preTerms.put(fieldInfo.name, new PreTerms(fieldInfo));\n          if (!fieldInfo.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0c7a8f7304b75b1528814c5820fa23a96816c27","date":1298314239,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      final int numFields = fieldInfos.size();\n      for(int i=0;i<numFields;i++) {\n        final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n        if (fieldInfo.isIndexed) {\n          fields.put(fieldInfo.name, fieldInfo);\n          preTerms.put(fieldInfo.name, new PreTerms(fieldInfo));\n          if (!fieldInfo.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      final int numFields = fieldInfos.size();\n      for(int i=0;i<numFields;i++) {\n        final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n        if (fieldInfo.isIndexed) {\n          fields.put(fieldInfo.name, fieldInfo);\n          preTerms.put(fieldInfo.name, new PreTerms(fieldInfo));\n          if (!fieldInfo.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14ec33385f6fbb6ce172882d14605790418a5d31","date":1298910796,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      final int numFields = fieldInfos.size();\n      for(int i=0;i<numFields;i++) {\n        final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n        if (fieldInfo.isIndexed) {\n          fields.put(fieldInfo.name, fieldInfo);\n          preTerms.put(fieldInfo.name, new PreTerms(fieldInfo));\n          if (!fieldInfo.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1224a4027481acce15495b03bce9b48b93b42722","date":1300792329,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      final int numFields = fieldInfos.size();\n      for(int i=0;i<numFields;i++) {\n        final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n        if (fieldInfo.isIndexed) {\n          fields.put(fieldInfo.name, fieldInfo);\n          preTerms.put(fieldInfo.name, new PreTerms(fieldInfo));\n          if (!fieldInfo.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      final int numFields = fieldInfos.size();\n      for(int i=0;i<numFields;i++) {\n        final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n        if (fieldInfo.isIndexed) {\n          fields.put(fieldInfo.name, fieldInfo);\n          preTerms.put(fieldInfo.name, new PreTerms(fieldInfo));\n          if (!fieldInfo.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de46f3c4642734e9ebfc72ea87ea6639d8a77319","date":1308233896,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","date":1308291005,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.readBufferSize = readBufferSize;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION), readBufferSize);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (!fi.omitTermFreqAndPositions) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION), readBufferSize);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"779d98b0c99c917811ad25cd9b03cd63607b4876":["150488c1317972164a9a824be05b1ba2ba0fc68c"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["5f4e87790277826a2aea119328600dfb07761f32","4b103252dee6afa1b6d7a622c773d178788eb85a"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["08932c793647a36953d1816b1060121f48820d3f","399a364d374f2132b6d9ff9fd7f997a9f2ef734f"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["08932c793647a36953d1816b1060121f48820d3f"],"85a883878c0af761245ab048babc63d099f835f3":["150488c1317972164a9a824be05b1ba2ba0fc68c","779d98b0c99c917811ad25cd9b03cd63607b4876"],"de46f3c4642734e9ebfc72ea87ea6639d8a77319":["1224a4027481acce15495b03bce9b48b93b42722"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["de46f3c4642734e9ebfc72ea87ea6639d8a77319"],"5f4e87790277826a2aea119328600dfb07761f32":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","08932c793647a36953d1816b1060121f48820d3f"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["3242a09f703274d3b9283f2064a1a33064b53a1b","779d98b0c99c917811ad25cd9b03cd63607b4876"],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["1224a4027481acce15495b03bce9b48b93b42722","de46f3c4642734e9ebfc72ea87ea6639d8a77319"],"08932c793647a36953d1816b1060121f48820d3f":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"14ec33385f6fbb6ce172882d14605790418a5d31":["b0c7a8f7304b75b1528814c5820fa23a96816c27"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["85a883878c0af761245ab048babc63d099f835f3","1224a4027481acce15495b03bce9b48b93b42722"],"b0c7a8f7304b75b1528814c5820fa23a96816c27":["779d98b0c99c917811ad25cd9b03cd63607b4876"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"399a364d374f2132b6d9ff9fd7f997a9f2ef734f":["163fe85a71d778fd2b7747f65ca27b54829e2e57"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["de46f3c4642734e9ebfc72ea87ea6639d8a77319","639c36565ce03aed5b0fce7c9e4448e53a1f7efd"],"150488c1317972164a9a824be05b1ba2ba0fc68c":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","b0c7a8f7304b75b1528814c5820fa23a96816c27"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"1224a4027481acce15495b03bce9b48b93b42722":["14ec33385f6fbb6ce172882d14605790418a5d31"]},"commit2Childs":{"779d98b0c99c917811ad25cd9b03cd63607b4876":["85a883878c0af761245ab048babc63d099f835f3","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","b0c7a8f7304b75b1528814c5820fa23a96816c27"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["3242a09f703274d3b9283f2064a1a33064b53a1b","150488c1317972164a9a824be05b1ba2ba0fc68c"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["399a364d374f2132b6d9ff9fd7f997a9f2ef734f"],"85a883878c0af761245ab048babc63d099f835f3":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"de46f3c4642734e9ebfc72ea87ea6639d8a77319":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd","0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5f4e87790277826a2aea119328600dfb07761f32","08932c793647a36953d1816b1060121f48820d3f"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"5f4e87790277826a2aea119328600dfb07761f32":["3242a09f703274d3b9283f2064a1a33064b53a1b"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["5d004d0e0b3f65bb40da76d476d659d7888270e8"],"08932c793647a36953d1816b1060121f48820d3f":["4b103252dee6afa1b6d7a622c773d178788eb85a","163fe85a71d778fd2b7747f65ca27b54829e2e57","5f4e87790277826a2aea119328600dfb07761f32"],"14ec33385f6fbb6ce172882d14605790418a5d31":["1224a4027481acce15495b03bce9b48b93b42722"],"d619839baa8ce5503e496b94a9e42ad6f079293f":[],"b0c7a8f7304b75b1528814c5820fa23a96816c27":["14ec33385f6fbb6ce172882d14605790418a5d31","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"399a364d374f2132b6d9ff9fd7f997a9f2ef734f":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"150488c1317972164a9a824be05b1ba2ba0fc68c":["779d98b0c99c917811ad25cd9b03cd63607b4876","85a883878c0af761245ab048babc63d099f835f3"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"1224a4027481acce15495b03bce9b48b93b42722":["de46f3c4642734e9ebfc72ea87ea6639d8a77319","0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","d619839baa8ce5503e496b94a9e42ad6f079293f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d619839baa8ce5503e496b94a9e42ad6f079293f","5d004d0e0b3f65bb40da76d476d659d7888270e8","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}