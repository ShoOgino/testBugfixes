{"path":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    Set<Transition> tr = a.initial.getTransitions();\n    if (tr.size() == 1) {\n      Transition t = tr.iterator().next();\n      if (t.to == a.initial && t.min == Character.MIN_VALUE\n          && t.max == Character.MAX_VALUE) return;\n    }\n    a.totalize();\n    // make arrays for numbered states and effective alphabet\n    Set<State> ss = a.getStates();\n    State[] states = new State[ss.size()];\n    int number = 0;\n    for (State q : ss) {\n      states[number] = q;\n      q.number = number++;\n    }\n    char[] sigma = a.getStartPoints();\n    // initialize data structures\n    ArrayList<ArrayList<LinkedList<State>>> reverse = new ArrayList<ArrayList<LinkedList<State>>>();\n    for (int q = 0; q < states.length; q++) {\n      ArrayList<LinkedList<State>> v = new ArrayList<LinkedList<State>>();\n      initialize(v, sigma.length);\n      reverse.add(v);\n    }\n    boolean[][] reverse_nonempty = new boolean[states.length][sigma.length];\n    ArrayList<LinkedList<State>> partition = new ArrayList<LinkedList<State>>();\n    initialize(partition, states.length);\n    int[] block = new int[states.length];\n    StateList[][] active = new StateList[states.length][sigma.length];\n    StateListNode[][] active2 = new StateListNode[states.length][sigma.length];\n    LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    boolean[][] pending2 = new boolean[sigma.length][states.length];\n    ArrayList<State> split = new ArrayList<State>();\n    boolean[] split2 = new boolean[states.length];\n    ArrayList<Integer> refine = new ArrayList<Integer>();\n    boolean[] refine2 = new boolean[states.length];\n    ArrayList<ArrayList<State>> splitblock = new ArrayList<ArrayList<State>>();\n    initialize(splitblock, states.length);\n    for (int q = 0; q < states.length; q++) {\n      splitblock.set(q, new ArrayList<State>());\n      partition.set(q, new LinkedList<State>());\n      for (int x = 0; x < sigma.length; x++) {\n        reverse.get(q).set(x, new LinkedList<State>());\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < states.length; q++) {\n      State qq = states[q];\n      int j;\n      if (qq.accept) j = 0;\n      else j = 1;\n      partition.get(j).add(qq);\n      block[qq.number] = j;\n      for (int x = 0; x < sigma.length; x++) {\n        char y = sigma[x];\n        State p = qq.step(y);\n        reverse.get(p.number).get(x).add(qq);\n        reverse_nonempty[p.number][x] = true;\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++)\n      for (int x = 0; x < sigma.length; x++)\n        for (State qq : partition.get(j))\n          if (reverse_nonempty[qq.number][x]) active2[qq.number][x] = active[j][x]\n              .add(qq);\n    // initialize pending\n    for (int x = 0; x < sigma.length; x++) {\n      int a0 = active[0][x].size;\n      int a1 = active[1][x].size;\n      int j;\n      if (a0 <= a1) j = 0;\n      else j = 1;\n      pending.add(new IntPair(j, x));\n      pending2[x][j] = true;\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      int p = ip.n1;\n      int x = ip.n2;\n      pending2[x][p] = false;\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next)\n        for (State s : reverse.get(m.q.number).get(x))\n          if (!split2[s.number]) {\n            split2[s.number] = true;\n            split.add(s);\n            int j = block[s.number];\n            splitblock.get(j).add(s);\n            if (!refine2[j]) {\n              refine2[j] = true;\n              refine.add(j);\n            }\n          }\n      // refine blocks\n      for (int j : refine) {\n        if (splitblock.get(j).size() < partition.get(j).size()) {\n          LinkedList<State> b1 = partition.get(j);\n          LinkedList<State> b2 = partition.get(k);\n          for (State s : splitblock.get(j)) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigma.length; c++) {\n              StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigma.length; c++) {\n            int aj = active[j][c].size;\n            int ak = active[k][c].size;\n            if (!pending2[c][j] && 0 < aj && aj <= ak) {\n              pending2[c][j] = true;\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2[c][k] = true;\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        for (State s : splitblock.get(j))\n          split2[s.number] = false;\n        refine2[j] = false;\n        splitblock.get(j).clear();\n      }\n      split.clear();\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      State s = new State();\n      newstates[n] = s;\n      for (State q : partition.get(n)) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].transitions)\n        s.transitions.add(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["37c912faf599f699486dafb3b0c792c338f3b198"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5acb0ee59cc50caf85402e92d148fdb2af61bc19","date":1272929037,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    int[] sigma = a.getStartPoints();\n    // initialize data structures\n    ArrayList<ArrayList<LinkedList<State>>> reverse = new ArrayList<ArrayList<LinkedList<State>>>();\n    final State[] states = a.getNumberedStates();\n\n    for (int q = 0; q < states.length; q++) {\n      ArrayList<LinkedList<State>> v = new ArrayList<LinkedList<State>>();\n      initialize(v, sigma.length);\n      reverse.add(v);\n    }\n    boolean[][] reverse_nonempty = new boolean[states.length][sigma.length];\n    ArrayList<LinkedList<State>> partition = new ArrayList<LinkedList<State>>();\n    initialize(partition, states.length);\n    int[] block = new int[states.length];\n    StateList[][] active = new StateList[states.length][sigma.length];\n    StateListNode[][] active2 = new StateListNode[states.length][sigma.length];\n    LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    boolean[][] pending2 = new boolean[sigma.length][states.length];\n    ArrayList<State> split = new ArrayList<State>();\n    boolean[] split2 = new boolean[states.length];\n    ArrayList<Integer> refine = new ArrayList<Integer>();\n    boolean[] refine2 = new boolean[states.length];\n    ArrayList<ArrayList<State>> splitblock = new ArrayList<ArrayList<State>>();\n    initialize(splitblock, states.length);\n    for (int q = 0; q < states.length; q++) {\n      splitblock.set(q, new ArrayList<State>());\n      partition.set(q, new LinkedList<State>());\n      for (int x = 0; x < sigma.length; x++) {\n        reverse.get(q).set(x, new LinkedList<State>());\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < states.length; q++) {\n      State qq = states[q];\n      int j;\n      if (qq.accept) j = 0;\n      else j = 1;\n      partition.get(j).add(qq);\n      block[qq.number] = j;\n      for (int x = 0; x < sigma.length; x++) {\n        int y = sigma[x];\n        State p = qq.step(y);\n        reverse.get(p.number).get(x).add(qq);\n        reverse_nonempty[p.number][x] = true;\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++)\n      for (int x = 0; x < sigma.length; x++)\n        for (State qq : partition.get(j))\n          if (reverse_nonempty[qq.number][x]) active2[qq.number][x] = active[j][x]\n              .add(qq);\n    // initialize pending\n    for (int x = 0; x < sigma.length; x++) {\n      int a0 = active[0][x].size;\n      int a1 = active[1][x].size;\n      int j;\n      if (a0 <= a1) j = 0;\n      else j = 1;\n      pending.add(new IntPair(j, x));\n      pending2[x][j] = true;\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      int p = ip.n1;\n      int x = ip.n2;\n      pending2[x][p] = false;\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next)\n        for (State s : reverse.get(m.q.number).get(x))\n          if (!split2[s.number]) {\n            split2[s.number] = true;\n            split.add(s);\n            int j = block[s.number];\n            splitblock.get(j).add(s);\n            if (!refine2[j]) {\n              refine2[j] = true;\n              refine.add(j);\n            }\n          }\n      // refine blocks\n      for (int j : refine) {\n        if (splitblock.get(j).size() < partition.get(j).size()) {\n          LinkedList<State> b1 = partition.get(j);\n          LinkedList<State> b2 = partition.get(k);\n          for (State s : splitblock.get(j)) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigma.length; c++) {\n              StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigma.length; c++) {\n            int aj = active[j][c].size;\n            int ak = active[k][c].size;\n            if (!pending2[c][j] && 0 < aj && aj <= ak) {\n              pending2[c][j] = true;\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2[c][k] = true;\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        for (State s : splitblock.get(j))\n          split2[s.number] = false;\n        refine2[j] = false;\n        splitblock.get(j).clear();\n      }\n      split.clear();\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      State s = new State();\n      newstates[n] = s;\n      for (State q : partition.get(n)) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    Set<Transition> tr = a.initial.getTransitions();\n    if (tr.size() == 1) {\n      Transition t = tr.iterator().next();\n      if (t.to == a.initial && t.min == Character.MIN_VALUE\n          && t.max == Character.MAX_VALUE) return;\n    }\n    a.totalize();\n    // make arrays for numbered states and effective alphabet\n    Set<State> ss = a.getStates();\n    State[] states = new State[ss.size()];\n    int number = 0;\n    for (State q : ss) {\n      states[number] = q;\n      q.number = number++;\n    }\n    char[] sigma = a.getStartPoints();\n    // initialize data structures\n    ArrayList<ArrayList<LinkedList<State>>> reverse = new ArrayList<ArrayList<LinkedList<State>>>();\n    for (int q = 0; q < states.length; q++) {\n      ArrayList<LinkedList<State>> v = new ArrayList<LinkedList<State>>();\n      initialize(v, sigma.length);\n      reverse.add(v);\n    }\n    boolean[][] reverse_nonempty = new boolean[states.length][sigma.length];\n    ArrayList<LinkedList<State>> partition = new ArrayList<LinkedList<State>>();\n    initialize(partition, states.length);\n    int[] block = new int[states.length];\n    StateList[][] active = new StateList[states.length][sigma.length];\n    StateListNode[][] active2 = new StateListNode[states.length][sigma.length];\n    LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    boolean[][] pending2 = new boolean[sigma.length][states.length];\n    ArrayList<State> split = new ArrayList<State>();\n    boolean[] split2 = new boolean[states.length];\n    ArrayList<Integer> refine = new ArrayList<Integer>();\n    boolean[] refine2 = new boolean[states.length];\n    ArrayList<ArrayList<State>> splitblock = new ArrayList<ArrayList<State>>();\n    initialize(splitblock, states.length);\n    for (int q = 0; q < states.length; q++) {\n      splitblock.set(q, new ArrayList<State>());\n      partition.set(q, new LinkedList<State>());\n      for (int x = 0; x < sigma.length; x++) {\n        reverse.get(q).set(x, new LinkedList<State>());\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < states.length; q++) {\n      State qq = states[q];\n      int j;\n      if (qq.accept) j = 0;\n      else j = 1;\n      partition.get(j).add(qq);\n      block[qq.number] = j;\n      for (int x = 0; x < sigma.length; x++) {\n        char y = sigma[x];\n        State p = qq.step(y);\n        reverse.get(p.number).get(x).add(qq);\n        reverse_nonempty[p.number][x] = true;\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++)\n      for (int x = 0; x < sigma.length; x++)\n        for (State qq : partition.get(j))\n          if (reverse_nonempty[qq.number][x]) active2[qq.number][x] = active[j][x]\n              .add(qq);\n    // initialize pending\n    for (int x = 0; x < sigma.length; x++) {\n      int a0 = active[0][x].size;\n      int a1 = active[1][x].size;\n      int j;\n      if (a0 <= a1) j = 0;\n      else j = 1;\n      pending.add(new IntPair(j, x));\n      pending2[x][j] = true;\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      int p = ip.n1;\n      int x = ip.n2;\n      pending2[x][p] = false;\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next)\n        for (State s : reverse.get(m.q.number).get(x))\n          if (!split2[s.number]) {\n            split2[s.number] = true;\n            split.add(s);\n            int j = block[s.number];\n            splitblock.get(j).add(s);\n            if (!refine2[j]) {\n              refine2[j] = true;\n              refine.add(j);\n            }\n          }\n      // refine blocks\n      for (int j : refine) {\n        if (splitblock.get(j).size() < partition.get(j).size()) {\n          LinkedList<State> b1 = partition.get(j);\n          LinkedList<State> b2 = partition.get(k);\n          for (State s : splitblock.get(j)) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigma.length; c++) {\n              StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigma.length; c++) {\n            int aj = active[j][c].size;\n            int ak = active[k][c].size;\n            if (!pending2[c][j] && 0 < aj && aj <= ak) {\n              pending2[c][j] = true;\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2[c][k] = true;\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        for (State s : splitblock.get(j))\n          split2[s.number] = false;\n        refine2[j] = false;\n        splitblock.get(j).clear();\n      }\n      split.clear();\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      State s = new State();\n      newstates[n] = s;\n      for (State q : partition.get(n)) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].transitions)\n        s.transitions.add(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fafe06bbca25d645e021a31b2a8014baa537e1b9","date":1287700318,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings(\"unchecked\") final LinkedList<State>[][] reverse =\n      (LinkedList<State>[][]) new LinkedList[statesLen][sigmaLen];\n    @SuppressWarnings(\"unchecked\") final LinkedList<State>[] partition =\n      (LinkedList<State>[]) new LinkedList[statesLen];\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final boolean[][] pending2 = new boolean[sigmaLen][statesLen];\n    final ArrayList<State> split = new ArrayList<State>();\n    final boolean[] split2 = new boolean[statesLen];\n    final ArrayList<Integer> refine = new ArrayList<Integer>();\n    final boolean[] refine2 = new boolean[statesLen];\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new LinkedList<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[qq.number] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final LinkedList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new LinkedList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++)\n      for (int x = 0; x < sigmaLen; x++)\n        for (State qq : partition[j])\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2[x][j] = true;\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2[x][p] = false;\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final LinkedList<State> r = reverse[m.q.number][x];\n        if (r != null) for (State s : r) {\n          if (!split2[s.number]) {\n            split2[s.number] = true;\n            split.add(s);\n            final int j = block[s.number];\n            splitblock[j].add(s);\n            if (!refine2[j]) {\n              refine2[j] = true;\n              refine.add(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j : refine) {\n        if (splitblock[j].size() < partition[j].size()) {\n          final LinkedList<State> b1 = partition[j];\n          final LinkedList<State> b2 = partition[k];\n          for (State s : splitblock[j]) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size;\n            final int ak = active[k][c].size;\n            if (!pending2[c][j] && 0 < aj && aj <= ak) {\n              pending2[c][j] = true;\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2[c][k] = true;\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        for (State s : splitblock[j])\n          split2[s.number] = false;\n        refine2[j] = false;\n        splitblock[j].clear();\n      }\n      split.clear();\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    int[] sigma = a.getStartPoints();\n    // initialize data structures\n    ArrayList<ArrayList<LinkedList<State>>> reverse = new ArrayList<ArrayList<LinkedList<State>>>();\n    final State[] states = a.getNumberedStates();\n\n    for (int q = 0; q < states.length; q++) {\n      ArrayList<LinkedList<State>> v = new ArrayList<LinkedList<State>>();\n      initialize(v, sigma.length);\n      reverse.add(v);\n    }\n    boolean[][] reverse_nonempty = new boolean[states.length][sigma.length];\n    ArrayList<LinkedList<State>> partition = new ArrayList<LinkedList<State>>();\n    initialize(partition, states.length);\n    int[] block = new int[states.length];\n    StateList[][] active = new StateList[states.length][sigma.length];\n    StateListNode[][] active2 = new StateListNode[states.length][sigma.length];\n    LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    boolean[][] pending2 = new boolean[sigma.length][states.length];\n    ArrayList<State> split = new ArrayList<State>();\n    boolean[] split2 = new boolean[states.length];\n    ArrayList<Integer> refine = new ArrayList<Integer>();\n    boolean[] refine2 = new boolean[states.length];\n    ArrayList<ArrayList<State>> splitblock = new ArrayList<ArrayList<State>>();\n    initialize(splitblock, states.length);\n    for (int q = 0; q < states.length; q++) {\n      splitblock.set(q, new ArrayList<State>());\n      partition.set(q, new LinkedList<State>());\n      for (int x = 0; x < sigma.length; x++) {\n        reverse.get(q).set(x, new LinkedList<State>());\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < states.length; q++) {\n      State qq = states[q];\n      int j;\n      if (qq.accept) j = 0;\n      else j = 1;\n      partition.get(j).add(qq);\n      block[qq.number] = j;\n      for (int x = 0; x < sigma.length; x++) {\n        int y = sigma[x];\n        State p = qq.step(y);\n        reverse.get(p.number).get(x).add(qq);\n        reverse_nonempty[p.number][x] = true;\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++)\n      for (int x = 0; x < sigma.length; x++)\n        for (State qq : partition.get(j))\n          if (reverse_nonempty[qq.number][x]) active2[qq.number][x] = active[j][x]\n              .add(qq);\n    // initialize pending\n    for (int x = 0; x < sigma.length; x++) {\n      int a0 = active[0][x].size;\n      int a1 = active[1][x].size;\n      int j;\n      if (a0 <= a1) j = 0;\n      else j = 1;\n      pending.add(new IntPair(j, x));\n      pending2[x][j] = true;\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      int p = ip.n1;\n      int x = ip.n2;\n      pending2[x][p] = false;\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next)\n        for (State s : reverse.get(m.q.number).get(x))\n          if (!split2[s.number]) {\n            split2[s.number] = true;\n            split.add(s);\n            int j = block[s.number];\n            splitblock.get(j).add(s);\n            if (!refine2[j]) {\n              refine2[j] = true;\n              refine.add(j);\n            }\n          }\n      // refine blocks\n      for (int j : refine) {\n        if (splitblock.get(j).size() < partition.get(j).size()) {\n          LinkedList<State> b1 = partition.get(j);\n          LinkedList<State> b2 = partition.get(k);\n          for (State s : splitblock.get(j)) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigma.length; c++) {\n              StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigma.length; c++) {\n            int aj = active[j][c].size;\n            int ak = active[k][c].size;\n            if (!pending2[c][j] && 0 < aj && aj <= ak) {\n              pending2[c][j] = true;\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2[c][k] = true;\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        for (State s : splitblock.get(j))\n          split2[s.number] = false;\n        refine2[j] = false;\n        splitblock.get(j).clear();\n      }\n      split.clear();\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      State s = new State();\n      newstates[n] = s;\n      for (State q : partition.get(n)) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"27bd13b92a551e905ec3c36c903adb953110b079","date":1287710271,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    final BitSet[][] reverse = new BitSet[statesLen][sigmaLen];\n    final BitSet[] splitblock = new BitSet[statesLen], partition = new BitSet[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new BitSet(statesLen);\n      partition[q] = new BitSet(statesLen);\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].set(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final BitSet[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new BitSet();\n        r[x].set(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      final BitSet part = partition[j];\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int i = part.nextSetBit(0); i >= 0; i = part.nextSetBit(i+1)) {\n          if (reverse[i][x] != null)\n            active2[i][x] = active[j][x].add(states[i]);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final BitSet r = reverse[m.q.number][x];\n        if (r != null) for (int i = r.nextSetBit(0); i >= 0; i = r.nextSetBit(i+1)) {\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].set(i);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final BitSet sb = splitblock[j];\n        if (sb.cardinality() < partition[j].cardinality()) {\n          final BitSet b1 = partition[j], b2 = partition[k];\n          for (int i = sb.nextSetBit(0); i >= 0; i = sb.nextSetBit(i+1)) {\n            b1.clear(i);\n            b2.set(i);\n            block[i] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[i][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[i][c] = active[k][c].add(states[i]);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int i = sb.nextSetBit(0); i >= 0; i = sb.nextSetBit(i+1))\n          split.clear(i);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      BitSet part = partition[n];\n      for (int i = part.nextSetBit(0); i >= 0; i = part.nextSetBit(i+1)) {\n        final State q = states[i];\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings(\"unchecked\") final LinkedList<State>[][] reverse =\n      (LinkedList<State>[][]) new LinkedList[statesLen][sigmaLen];\n    @SuppressWarnings(\"unchecked\") final LinkedList<State>[] partition =\n      (LinkedList<State>[]) new LinkedList[statesLen];\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final boolean[][] pending2 = new boolean[sigmaLen][statesLen];\n    final ArrayList<State> split = new ArrayList<State>();\n    final boolean[] split2 = new boolean[statesLen];\n    final ArrayList<Integer> refine = new ArrayList<Integer>();\n    final boolean[] refine2 = new boolean[statesLen];\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new LinkedList<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[qq.number] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final LinkedList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new LinkedList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++)\n      for (int x = 0; x < sigmaLen; x++)\n        for (State qq : partition[j])\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2[x][j] = true;\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2[x][p] = false;\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final LinkedList<State> r = reverse[m.q.number][x];\n        if (r != null) for (State s : r) {\n          if (!split2[s.number]) {\n            split2[s.number] = true;\n            split.add(s);\n            final int j = block[s.number];\n            splitblock[j].add(s);\n            if (!refine2[j]) {\n              refine2[j] = true;\n              refine.add(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j : refine) {\n        if (splitblock[j].size() < partition[j].size()) {\n          final LinkedList<State> b1 = partition[j];\n          final LinkedList<State> b2 = partition[k];\n          for (State s : splitblock[j]) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size;\n            final int ak = active[k][c].size;\n            if (!pending2[c][j] && 0 < aj && aj <= ak) {\n              pending2[c][j] = true;\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2[c][k] = true;\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        for (State s : splitblock[j])\n          split2[s.number] = false;\n        refine2[j] = false;\n        splitblock[j].clear();\n      }\n      split.clear();\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":["37c912faf599f699486dafb3b0c792c338f3b198"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b12d3e81e0f95a4527b5703953c503f71120ffcc","date":1288080933,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    final BitSet[][] reverse = new BitSet[statesLen][sigmaLen];\n    final BitSet[] splitblock = new BitSet[statesLen], partition = new BitSet[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new BitSet(statesLen);\n      partition[q] = new BitSet(statesLen);\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].set(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final BitSet[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new BitSet();\n        r[x].set(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      final BitSet part = partition[j];\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int i = part.nextSetBit(0); i >= 0; i = part.nextSetBit(i+1)) {\n          if (reverse[i][x] != null)\n            active2[i][x] = active[j][x].add(states[i]);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final BitSet r = reverse[m.q.number][x];\n        if (r != null) for (int i = r.nextSetBit(0); i >= 0; i = r.nextSetBit(i+1)) {\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].set(i);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final BitSet sb = splitblock[j];\n        if (sb.cardinality() < partition[j].cardinality()) {\n          final BitSet b1 = partition[j], b2 = partition[k];\n          for (int i = sb.nextSetBit(0); i >= 0; i = sb.nextSetBit(i+1)) {\n            b1.clear(i);\n            b2.set(i);\n            block[i] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[i][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[i][c] = active[k][c].add(states[i]);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int i = sb.nextSetBit(0); i >= 0; i = sb.nextSetBit(i+1))\n          split.clear(i);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      BitSet part = partition[n];\n      for (int i = part.nextSetBit(0); i >= 0; i = part.nextSetBit(i+1)) {\n        final State q = states[i];\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    int[] sigma = a.getStartPoints();\n    // initialize data structures\n    ArrayList<ArrayList<LinkedList<State>>> reverse = new ArrayList<ArrayList<LinkedList<State>>>();\n    final State[] states = a.getNumberedStates();\n\n    for (int q = 0; q < states.length; q++) {\n      ArrayList<LinkedList<State>> v = new ArrayList<LinkedList<State>>();\n      initialize(v, sigma.length);\n      reverse.add(v);\n    }\n    boolean[][] reverse_nonempty = new boolean[states.length][sigma.length];\n    ArrayList<LinkedList<State>> partition = new ArrayList<LinkedList<State>>();\n    initialize(partition, states.length);\n    int[] block = new int[states.length];\n    StateList[][] active = new StateList[states.length][sigma.length];\n    StateListNode[][] active2 = new StateListNode[states.length][sigma.length];\n    LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    boolean[][] pending2 = new boolean[sigma.length][states.length];\n    ArrayList<State> split = new ArrayList<State>();\n    boolean[] split2 = new boolean[states.length];\n    ArrayList<Integer> refine = new ArrayList<Integer>();\n    boolean[] refine2 = new boolean[states.length];\n    ArrayList<ArrayList<State>> splitblock = new ArrayList<ArrayList<State>>();\n    initialize(splitblock, states.length);\n    for (int q = 0; q < states.length; q++) {\n      splitblock.set(q, new ArrayList<State>());\n      partition.set(q, new LinkedList<State>());\n      for (int x = 0; x < sigma.length; x++) {\n        reverse.get(q).set(x, new LinkedList<State>());\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < states.length; q++) {\n      State qq = states[q];\n      int j;\n      if (qq.accept) j = 0;\n      else j = 1;\n      partition.get(j).add(qq);\n      block[qq.number] = j;\n      for (int x = 0; x < sigma.length; x++) {\n        int y = sigma[x];\n        State p = qq.step(y);\n        reverse.get(p.number).get(x).add(qq);\n        reverse_nonempty[p.number][x] = true;\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++)\n      for (int x = 0; x < sigma.length; x++)\n        for (State qq : partition.get(j))\n          if (reverse_nonempty[qq.number][x]) active2[qq.number][x] = active[j][x]\n              .add(qq);\n    // initialize pending\n    for (int x = 0; x < sigma.length; x++) {\n      int a0 = active[0][x].size;\n      int a1 = active[1][x].size;\n      int j;\n      if (a0 <= a1) j = 0;\n      else j = 1;\n      pending.add(new IntPair(j, x));\n      pending2[x][j] = true;\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      int p = ip.n1;\n      int x = ip.n2;\n      pending2[x][p] = false;\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next)\n        for (State s : reverse.get(m.q.number).get(x))\n          if (!split2[s.number]) {\n            split2[s.number] = true;\n            split.add(s);\n            int j = block[s.number];\n            splitblock.get(j).add(s);\n            if (!refine2[j]) {\n              refine2[j] = true;\n              refine.add(j);\n            }\n          }\n      // refine blocks\n      for (int j : refine) {\n        if (splitblock.get(j).size() < partition.get(j).size()) {\n          LinkedList<State> b1 = partition.get(j);\n          LinkedList<State> b2 = partition.get(k);\n          for (State s : splitblock.get(j)) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigma.length; c++) {\n              StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigma.length; c++) {\n            int aj = active[j][c].size;\n            int ak = active[k][c].size;\n            if (!pending2[c][j] && 0 < aj && aj <= ak) {\n              pending2[c][j] = true;\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2[c][k] = true;\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        for (State s : splitblock.get(j))\n          split2[s.number] = false;\n        refine2[j] = false;\n        splitblock.get(j).clear();\n      }\n      split.clear();\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      State s = new State();\n      newstates[n] = s;\n      for (State q : partition.get(n)) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    final BitSet[][] reverse = new BitSet[statesLen][sigmaLen];\n    final BitSet[] splitblock = new BitSet[statesLen], partition = new BitSet[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new BitSet(statesLen);\n      partition[q] = new BitSet(statesLen);\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].set(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final BitSet[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new BitSet();\n        r[x].set(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      final BitSet part = partition[j];\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int i = part.nextSetBit(0); i >= 0; i = part.nextSetBit(i+1)) {\n          if (reverse[i][x] != null)\n            active2[i][x] = active[j][x].add(states[i]);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final BitSet r = reverse[m.q.number][x];\n        if (r != null) for (int i = r.nextSetBit(0); i >= 0; i = r.nextSetBit(i+1)) {\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].set(i);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final BitSet sb = splitblock[j];\n        if (sb.cardinality() < partition[j].cardinality()) {\n          final BitSet b1 = partition[j], b2 = partition[k];\n          for (int i = sb.nextSetBit(0); i >= 0; i = sb.nextSetBit(i+1)) {\n            b1.clear(i);\n            b2.set(i);\n            block[i] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[i][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[i][c] = active[k][c].add(states[i]);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int i = sb.nextSetBit(0); i >= 0; i = sb.nextSetBit(i+1))\n          split.clear(i);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      BitSet part = partition[n];\n      for (int i = part.nextSetBit(0); i >= 0; i = part.nextSetBit(i+1)) {\n        final State q = states[i];\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    int[] sigma = a.getStartPoints();\n    // initialize data structures\n    ArrayList<ArrayList<LinkedList<State>>> reverse = new ArrayList<ArrayList<LinkedList<State>>>();\n    final State[] states = a.getNumberedStates();\n\n    for (int q = 0; q < states.length; q++) {\n      ArrayList<LinkedList<State>> v = new ArrayList<LinkedList<State>>();\n      initialize(v, sigma.length);\n      reverse.add(v);\n    }\n    boolean[][] reverse_nonempty = new boolean[states.length][sigma.length];\n    ArrayList<LinkedList<State>> partition = new ArrayList<LinkedList<State>>();\n    initialize(partition, states.length);\n    int[] block = new int[states.length];\n    StateList[][] active = new StateList[states.length][sigma.length];\n    StateListNode[][] active2 = new StateListNode[states.length][sigma.length];\n    LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    boolean[][] pending2 = new boolean[sigma.length][states.length];\n    ArrayList<State> split = new ArrayList<State>();\n    boolean[] split2 = new boolean[states.length];\n    ArrayList<Integer> refine = new ArrayList<Integer>();\n    boolean[] refine2 = new boolean[states.length];\n    ArrayList<ArrayList<State>> splitblock = new ArrayList<ArrayList<State>>();\n    initialize(splitblock, states.length);\n    for (int q = 0; q < states.length; q++) {\n      splitblock.set(q, new ArrayList<State>());\n      partition.set(q, new LinkedList<State>());\n      for (int x = 0; x < sigma.length; x++) {\n        reverse.get(q).set(x, new LinkedList<State>());\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < states.length; q++) {\n      State qq = states[q];\n      int j;\n      if (qq.accept) j = 0;\n      else j = 1;\n      partition.get(j).add(qq);\n      block[qq.number] = j;\n      for (int x = 0; x < sigma.length; x++) {\n        int y = sigma[x];\n        State p = qq.step(y);\n        reverse.get(p.number).get(x).add(qq);\n        reverse_nonempty[p.number][x] = true;\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++)\n      for (int x = 0; x < sigma.length; x++)\n        for (State qq : partition.get(j))\n          if (reverse_nonempty[qq.number][x]) active2[qq.number][x] = active[j][x]\n              .add(qq);\n    // initialize pending\n    for (int x = 0; x < sigma.length; x++) {\n      int a0 = active[0][x].size;\n      int a1 = active[1][x].size;\n      int j;\n      if (a0 <= a1) j = 0;\n      else j = 1;\n      pending.add(new IntPair(j, x));\n      pending2[x][j] = true;\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      int p = ip.n1;\n      int x = ip.n2;\n      pending2[x][p] = false;\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next)\n        for (State s : reverse.get(m.q.number).get(x))\n          if (!split2[s.number]) {\n            split2[s.number] = true;\n            split.add(s);\n            int j = block[s.number];\n            splitblock.get(j).add(s);\n            if (!refine2[j]) {\n              refine2[j] = true;\n              refine.add(j);\n            }\n          }\n      // refine blocks\n      for (int j : refine) {\n        if (splitblock.get(j).size() < partition.get(j).size()) {\n          LinkedList<State> b1 = partition.get(j);\n          LinkedList<State> b2 = partition.get(k);\n          for (State s : splitblock.get(j)) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigma.length; c++) {\n              StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigma.length; c++) {\n            int aj = active[j][c].size;\n            int ak = active[k][c].size;\n            if (!pending2[c][j] && 0 < aj && aj <= ak) {\n              pending2[c][j] = true;\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2[c][k] = true;\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        for (State s : splitblock.get(j))\n          split2[s.number] = false;\n        refine2[j] = false;\n        splitblock.get(j).clear();\n      }\n      split.clear();\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      State s = new State();\n      newstates[n] = s;\n      for (State q : partition.get(n)) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37c912faf599f699486dafb3b0c792c338f3b198","date":1305548145,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings(\"unchecked\") final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new HashSet<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    final BitSet[][] reverse = new BitSet[statesLen][sigmaLen];\n    final BitSet[] splitblock = new BitSet[statesLen], partition = new BitSet[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new BitSet(statesLen);\n      partition[q] = new BitSet(statesLen);\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].set(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final BitSet[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new BitSet();\n        r[x].set(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      final BitSet part = partition[j];\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int i = part.nextSetBit(0); i >= 0; i = part.nextSetBit(i+1)) {\n          if (reverse[i][x] != null)\n            active2[i][x] = active[j][x].add(states[i]);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final BitSet r = reverse[m.q.number][x];\n        if (r != null) for (int i = r.nextSetBit(0); i >= 0; i = r.nextSetBit(i+1)) {\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].set(i);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final BitSet sb = splitblock[j];\n        if (sb.cardinality() < partition[j].cardinality()) {\n          final BitSet b1 = partition[j], b2 = partition[k];\n          for (int i = sb.nextSetBit(0); i >= 0; i = sb.nextSetBit(i+1)) {\n            b1.clear(i);\n            b2.set(i);\n            block[i] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[i][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[i][c] = active[k][c].add(states[i]);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int i = sb.nextSetBit(0); i >= 0; i = sb.nextSetBit(i+1))\n          split.clear(i);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      BitSet part = partition[n];\n      for (int i = part.nextSetBit(0); i >= 0; i = part.nextSetBit(i+1)) {\n        final State q = states[i];\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":["27bd13b92a551e905ec3c36c903adb953110b079","955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings(\"unchecked\") final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new HashSet<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    final BitSet[][] reverse = new BitSet[statesLen][sigmaLen];\n    final BitSet[] splitblock = new BitSet[statesLen], partition = new BitSet[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new BitSet(statesLen);\n      partition[q] = new BitSet(statesLen);\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].set(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final BitSet[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new BitSet();\n        r[x].set(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      final BitSet part = partition[j];\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int i = part.nextSetBit(0); i >= 0; i = part.nextSetBit(i+1)) {\n          if (reverse[i][x] != null)\n            active2[i][x] = active[j][x].add(states[i]);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final BitSet r = reverse[m.q.number][x];\n        if (r != null) for (int i = r.nextSetBit(0); i >= 0; i = r.nextSetBit(i+1)) {\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].set(i);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final BitSet sb = splitblock[j];\n        if (sb.cardinality() < partition[j].cardinality()) {\n          final BitSet b1 = partition[j], b2 = partition[k];\n          for (int i = sb.nextSetBit(0); i >= 0; i = sb.nextSetBit(i+1)) {\n            b1.clear(i);\n            b2.set(i);\n            block[i] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[i][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[i][c] = active[k][c].add(states[i]);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int i = sb.nextSetBit(0); i >= 0; i = sb.nextSetBit(i+1))\n          split.clear(i);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      BitSet part = partition[n];\n      for (int i = part.nextSetBit(0); i >= 0; i = part.nextSetBit(i+1)) {\n        final State q = states[i];\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings(\"unchecked\") final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new HashSet<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    final BitSet[][] reverse = new BitSet[statesLen][sigmaLen];\n    final BitSet[] splitblock = new BitSet[statesLen], partition = new BitSet[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new BitSet(statesLen);\n      partition[q] = new BitSet(statesLen);\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].set(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final BitSet[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new BitSet();\n        r[x].set(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      final BitSet part = partition[j];\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int i = part.nextSetBit(0); i >= 0; i = part.nextSetBit(i+1)) {\n          if (reverse[i][x] != null)\n            active2[i][x] = active[j][x].add(states[i]);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final BitSet r = reverse[m.q.number][x];\n        if (r != null) for (int i = r.nextSetBit(0); i >= 0; i = r.nextSetBit(i+1)) {\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].set(i);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final BitSet sb = splitblock[j];\n        if (sb.cardinality() < partition[j].cardinality()) {\n          final BitSet b1 = partition[j], b2 = partition[k];\n          for (int i = sb.nextSetBit(0); i >= 0; i = sb.nextSetBit(i+1)) {\n            b1.clear(i);\n            b2.set(i);\n            block[i] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[i][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[i][c] = active[k][c].add(states[i]);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int i = sb.nextSetBit(0); i >= 0; i = sb.nextSetBit(i+1))\n          split.clear(i);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      BitSet part = partition[n];\n      for (int i = part.nextSetBit(0); i >= 0; i = part.nextSetBit(i+1)) {\n        final State q = states[i];\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings(\"unchecked\") final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new HashSet<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings(\"unchecked\") final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new HashSet<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c3a8a449466c1ff7ce2274fe73dab487256964b4":["b12d3e81e0f95a4527b5703953c503f71120ffcc","37c912faf599f699486dafb3b0c792c338f3b198"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["37c912faf599f699486dafb3b0c792c338f3b198"],"a3776dccca01c11e7046323cfad46a3b4a471233":["27bd13b92a551e905ec3c36c903adb953110b079","37c912faf599f699486dafb3b0c792c338f3b198"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"37c912faf599f699486dafb3b0c792c338f3b198":["27bd13b92a551e905ec3c36c903adb953110b079"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["5acb0ee59cc50caf85402e92d148fdb2af61bc19","27bd13b92a551e905ec3c36c903adb953110b079"],"27bd13b92a551e905ec3c36c903adb953110b079":["fafe06bbca25d645e021a31b2a8014baa537e1b9"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5acb0ee59cc50caf85402e92d148fdb2af61bc19","27bd13b92a551e905ec3c36c903adb953110b079"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"fafe06bbca25d645e021a31b2a8014baa537e1b9":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"]},"commit2Childs":{"c3a8a449466c1ff7ce2274fe73dab487256964b4":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["b12d3e81e0f95a4527b5703953c503f71120ffcc","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","fafe06bbca25d645e021a31b2a8014baa537e1b9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"37c912faf599f699486dafb3b0c792c338f3b198":["c3a8a449466c1ff7ce2274fe73dab487256964b4","3a119bbc8703c10faa329ec201c654b3a35a1e3e","a3776dccca01c11e7046323cfad46a3b4a471233"],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["c3a8a449466c1ff7ce2274fe73dab487256964b4"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"27bd13b92a551e905ec3c36c903adb953110b079":["a3776dccca01c11e7046323cfad46a3b4a471233","37c912faf599f699486dafb3b0c792c338f3b198","b12d3e81e0f95a4527b5703953c503f71120ffcc","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"fafe06bbca25d645e021a31b2a8014baa537e1b9":["27bd13b92a551e905ec3c36c903adb953110b079"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}