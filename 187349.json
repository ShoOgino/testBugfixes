{"path":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","commits":[{"id":"069d686c3ab4d51d0d217cff30aad53b2b70ece0","date":1484748426,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","pathOld":"/dev/null","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    assertEquals((maxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["71da933d30aea361ccc224d6544c451cbf49916d","3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"302d34f2c66e8d489ee13078305c330cbf67b226","date":1484754357,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","pathOld":"/dev/null","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    assertEquals((maxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"089d14333bdf7e93e08b0a91376dea8456c3e9b3","date":1484816090,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    assertEquals((maxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    assertEquals((maxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    assertEquals((maxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    assertEquals((maxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7bf4a4201f0292caff0d8e8afd612aa13b3ac836","date":1485871209,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        });\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    assertEquals((maxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        });\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    assertEquals((maxPointsInLeafNode + 1) / 2,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        }));\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41f60ea1802fda42d3c91d023406066d00ddb5f8","date":1535615991,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (FutureArrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n                FutureArrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        });\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (StringHelper.compare(3, uniquePointValue, 0, maxPackedValue, 0) > 0 ||\n                StringHelper.compare(3, uniquePointValue, 0, minPackedValue, 0) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        });\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (Arrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n                Arrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        });\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (FutureArrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n                FutureArrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        });\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c09c5c6cd995294d83f12c1bdf8d47d8e749f49","date":1570176835,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue);\n          } while (Arrays.equals(pointValue, uniquePointValue));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(pointCount, docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (Arrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n                Arrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        });\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["7bf4a4201f0292caff0d8e8afd612aa13b3ac836","069d686c3ab4d51d0d217cff30aad53b2b70ece0","b88a121b875f9ae2ac50f85cf46dcb680f126357"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue);\n          } while (Arrays.equals(pointValue, uniquePointValue));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(pointCount, docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        do {\n          random().nextBytes(pointValue);\n        } while (Arrays.equals(pointValue, uniquePointValue));\n        doc.add(new BinaryPoint(\"f\", pointValue));\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) numDocs / maxPointsInLeafNode);\n    assertEquals(numLeaves * maxPointsInLeafNode,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }));\n\n    // Return 0 if no points match\n    assertEquals(0,\n        points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return Relation.CELL_OUTSIDE_QUERY;\n          }\n        }));\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(new IntersectVisitor() {\n          @Override\n          public void visit(int docID, byte[] packedValue) throws IOException {}\n          \n          @Override\n          public void visit(int docID) throws IOException {}\n          \n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            if (Arrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n                Arrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n              return Relation.CELL_OUTSIDE_QUERY;\n            }\n            return Relation.CELL_CROSSES_QUERY;\n          }\n        });\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71da933d30aea361ccc224d6544c451cbf49916d","date":1579874339,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = TEST_NIGHTLY ? atLeast(10000) : atLeast(500); // at night, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue);\n          } while (Arrays.equals(pointValue, uniquePointValue));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(pointCount, docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = atLeast(10000); // make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue);\n          } while (Arrays.equals(pointValue, uniquePointValue));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(pointCount, docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["069d686c3ab4d51d0d217cff30aad53b2b70ece0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d1b1f6bc8b7827c951e135141bea776bf57ac7e","date":1580115145,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = TEST_NIGHTLY ? atLeast(10000) : atLeast(500); // at night, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue);\n          } while (Arrays.equals(pointValue, uniquePointValue));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = TEST_NIGHTLY ? atLeast(10000) : atLeast(500); // at night, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue);\n          } while (Arrays.equals(pointValue, uniquePointValue));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(pointCount, docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = TEST_NIGHTLY ? atLeast(10000) : atLeast(500); // at night, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue);\n          } while (Arrays.equals(pointValue, uniquePointValue));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = TEST_NIGHTLY ? atLeast(10000) : atLeast(500); // at night, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue);\n          } while (Arrays.equals(pointValue, uniquePointValue));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":6,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene86/TestLucene86PointsFormat#testEstimatePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene60/TestLucene60PointsFormat#testEstimatePointCount().mjava","sourceNew":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = TEST_NIGHTLY ? atLeast(10000) : atLeast(500); // at night, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue);\n          } while (Arrays.equals(pointValue, uniquePointValue));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testEstimatePointCount() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Avoid mockRandomMP since it may cause non-optimal merges that make the\n    // number of points per leaf hard to predict\n    while (iwc.getMergePolicy() instanceof MockRandomMergePolicy) {\n      iwc.setMergePolicy(newMergePolicy());\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n    byte[] pointValue = new byte[3];\n    byte[] uniquePointValue = new byte[3];\n    random().nextBytes(uniquePointValue);\n    final int numDocs = TEST_NIGHTLY ? atLeast(10000) : atLeast(500); // at night, make sure we have several leaves\n    final boolean multiValues = random().nextBoolean();\n    for (int i = 0; i < numDocs; ++i) {\n      Document doc = new Document();\n      if (i == numDocs / 2) {\n        doc.add(new BinaryPoint(\"f\", uniquePointValue));\n      } else {\n        final int numValues = (multiValues) ? TestUtil.nextInt(random(), 2, 100) : 1;\n        for (int j = 0; j < numValues; j ++) {\n          do {\n            random().nextBytes(pointValue);\n          } while (Arrays.equals(pointValue, uniquePointValue));\n          doc.add(new BinaryPoint(\"f\", pointValue));\n        }\n      }\n      w.addDocument(doc);\n    }\n    w.forceMerge(1);\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n    final LeafReader lr = getOnlyLeafReader(r);\n    PointValues points = lr.getPointValues(\"f\");\n\n    // If all points match, then the point count is numLeaves * maxPointsInLeafNode\n    final int numLeaves = (int) Math.ceil((double) points.size() / maxPointsInLeafNode);\n\n    IntersectVisitor allPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_INSIDE_QUERY;\n      }\n    };\n\n    assertEquals(numLeaves * maxPointsInLeafNode, points.estimatePointCount(allPointsVisitor));\n    assertEquals(numDocs, points.estimateDocCount(allPointsVisitor));\n\n    IntersectVisitor noPointsVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        return Relation.CELL_OUTSIDE_QUERY;\n      }\n    };\n\n    // Return 0 if no points match\n    assertEquals(0, points.estimatePointCount(noPointsVisitor));\n    assertEquals(0, points.estimateDocCount(noPointsVisitor));\n\n    IntersectVisitor onePointMatchVisitor = new IntersectVisitor() {\n      @Override\n      public void visit(int docID, byte[] packedValue) throws IOException {}\n\n      @Override\n      public void visit(int docID) throws IOException {}\n\n      @Override\n      public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (Arrays.compareUnsigned(uniquePointValue, 0, 3, maxPackedValue, 0, 3) > 0 ||\n            Arrays.compareUnsigned(uniquePointValue, 0, 3, minPackedValue, 0, 3) < 0) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        }\n        return Relation.CELL_CROSSES_QUERY;\n      }\n    };\n\n    // If only one point matches, then the point count is (maxPointsInLeafNode + 1) / 2\n    // in general, or maybe 2x that if the point is a split value\n    final long pointCount = points.estimatePointCount(onePointMatchVisitor);\n    assertTrue(\"\"+pointCount,\n        pointCount == (maxPointsInLeafNode + 1) / 2 || // common case\n        pointCount == 2*((maxPointsInLeafNode + 1) / 2)); // if the point is a split value\n\n    final long docCount = points.estimateDocCount(onePointMatchVisitor);\n\n    if (multiValues) {\n      assertEquals(docCount, (long) (docCount * (1d - Math.pow( (numDocs -  pointCount) / points.size() , points.size() / docCount))));\n    } else {\n      assertEquals(Math.min(pointCount, numDocs), docCount);\n    }\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"069d686c3ab4d51d0d217cff30aad53b2b70ece0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","7bf4a4201f0292caff0d8e8afd612aa13b3ac836"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["302d34f2c66e8d489ee13078305c330cbf67b226","089d14333bdf7e93e08b0a91376dea8456c3e9b3"],"302d34f2c66e8d489ee13078305c330cbf67b226":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","069d686c3ab4d51d0d217cff30aad53b2b70ece0"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"7bf4a4201f0292caff0d8e8afd612aa13b3ac836":["089d14333bdf7e93e08b0a91376dea8456c3e9b3"],"0d1b1f6bc8b7827c951e135141bea776bf57ac7e":["71da933d30aea361ccc224d6544c451cbf49916d"],"089d14333bdf7e93e08b0a91376dea8456c3e9b3":["069d686c3ab4d51d0d217cff30aad53b2b70ece0"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["7bf4a4201f0292caff0d8e8afd612aa13b3ac836"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["0d1b1f6bc8b7827c951e135141bea776bf57ac7e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"71da933d30aea361ccc224d6544c451cbf49916d":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"],"3c09c5c6cd995294d83f12c1bdf8d47d8e749f49":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"b0b597c65628ca9e73913a07e81691f8229bae35":["b88a121b875f9ae2ac50f85cf46dcb680f126357","3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"]},"commit2Childs":{"069d686c3ab4d51d0d217cff30aad53b2b70ece0":["302d34f2c66e8d489ee13078305c330cbf67b226","089d14333bdf7e93e08b0a91376dea8456c3e9b3"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"302d34f2c66e8d489ee13078305c330cbf67b226":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"7bf4a4201f0292caff0d8e8afd612aa13b3ac836":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","41f60ea1802fda42d3c91d023406066d00ddb5f8"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49","b0b597c65628ca9e73913a07e81691f8229bae35"],"089d14333bdf7e93e08b0a91376dea8456c3e9b3":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","7bf4a4201f0292caff0d8e8afd612aa13b3ac836"],"0d1b1f6bc8b7827c951e135141bea776bf57ac7e":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["069d686c3ab4d51d0d217cff30aad53b2b70ece0","302d34f2c66e8d489ee13078305c330cbf67b226"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"71da933d30aea361ccc224d6544c451cbf49916d":["0d1b1f6bc8b7827c951e135141bea776bf57ac7e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"3c09c5c6cd995294d83f12c1bdf8d47d8e749f49":["71da933d30aea361ccc224d6544c451cbf49916d","b0b597c65628ca9e73913a07e81691f8229bae35"],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}