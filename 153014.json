{"path":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","commits":[{"id":"26cb11ce089e71fb909641e7030b53c7d9e3fff3","date":1390348343,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String).mjava","sourceNew":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName(),\n            props.getStr(ZkStateReader.CORE_NAME_PROP));\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<String>();\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().numRecordsToKeep, true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName(),\n            props.getStr(ZkStateReader.CORE_NAME_PROP));\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<String>();\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().numRecordsToKeep, true, true);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName(),\n            props.getStr(ZkStateReader.CORE_NAME_PROP));\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>();\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().numRecordsToKeep, true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName(),\n            props.getStr(ZkStateReader.CORE_NAME_PROP));\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<String>();\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().numRecordsToKeep, true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a81e7d9c7ad18b6ec658ebdb132dd51a2164f039","date":1405209123,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>();\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().numRecordsToKeep, true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName(),\n            props.getStr(ZkStateReader.CORE_NAME_PROP));\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>();\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().numRecordsToKeep, true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f3c1f22c5fe0011e187dac3151422365ae857f3","date":1425728437,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>();\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>();\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().numRecordsToKeep, true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>();\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>();\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().numRecordsToKeep, true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bfdc2557c90b5d141fd515eb1c557f0fc9451076","date":1453814785,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>();\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac88193d9fe80e165a43bb0555c43afa83da8330","date":1453823827,"type":3,"author":"jbernste","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>();\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"979e22aa7c63c9dc651adf861610c7e444d45832","date":1454615713,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1704c078ec59838c9d95d5bf5738b393b537494","date":1454693901,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>();\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a2658bad9ac95d1beab4cb8bdbe8ae909970cdc","date":1455819841,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb62cc3362417c3e5136f2f26d34a1072ad633eb","date":1475149102,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private PeerSync.PeerSyncResult syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return PeerSync.PeerSyncResult.success();\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private PeerSync.PeerSyncResult syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return PeerSync.PeerSyncResult.success();\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private PeerSync.PeerSyncResult syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return PeerSync.PeerSyncResult.success();\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private boolean syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return true;\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","date":1529486762,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private PeerSync.PeerSyncResult syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return PeerSync.PeerSyncResult.success();\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private PeerSync.PeerSyncResult syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return PeerSync.PeerSyncResult.success();\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private PeerSync.PeerSyncResult syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return PeerSync.PeerSyncResult.success();\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private PeerSync.PeerSyncResult syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return PeerSync.PeerSyncResult.success();\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private PeerSync.PeerSyncResult syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return PeerSync.PeerSyncResult.success();\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private PeerSync.PeerSyncResult syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return PeerSync.PeerSyncResult.success();\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private PeerSync.PeerSyncResult syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (isClosed) {\n      log.info(\"We have been closed, won't sync with replicas\");\n      return PeerSync.PeerSyncResult.failure();\n    }\n    \n    if (nodes == null) {\n      // I have no replicas\n      return PeerSync.PeerSyncResult.success();\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","sourceOld":"  private PeerSync.PeerSyncResult syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (nodes == null) {\n      // I have no replicas\n      return PeerSync.PeerSyncResult.success();\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6e01fcbda8c04bde654f99836a2f8813f9444f3","date":1589564391,"type":3,"author":"erick","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/SyncStrategy#syncWithReplicas(ZkController,SolrCore,ZkNodeProps,String,String,boolean).mjava","sourceNew":"  private PeerSync.PeerSyncResult syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) throws Exception {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (isClosed) {\n      log.info(\"We have been closed, won't sync with replicas\");\n      return PeerSync.PeerSyncResult.failure();\n    }\n    \n    if (nodes == null) {\n      // I have no replicas\n      return PeerSync.PeerSyncResult.success();\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    try (PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, peerSyncOnlyWithActive, false)) {\n      return peerSync.sync();\n    }\n  }\n\n","sourceOld":"  private PeerSync.PeerSyncResult syncWithReplicas(ZkController zkController, SolrCore core,\n      ZkNodeProps props, String collection, String shardId, boolean peerSyncOnlyWithActive) {\n    List<ZkCoreNodeProps> nodes = zkController.getZkStateReader()\n        .getReplicaProps(collection, shardId,core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (isClosed) {\n      log.info(\"We have been closed, won't sync with replicas\");\n      return PeerSync.PeerSyncResult.failure();\n    }\n    \n    if (nodes == null) {\n      // I have no replicas\n      return PeerSync.PeerSyncResult.success();\n    }\n    \n    List<String> syncWith = new ArrayList<>(nodes.size());\n    for (ZkCoreNodeProps node : nodes) {\n      syncWith.add(node.getCoreUrl());\n    }\n    \n    // if we can't reach a replica for sync, we still consider the overall sync a success\n    // TODO: as an assurance, we should still try and tell the sync nodes that we couldn't reach\n    // to recover once more?\n    // Fingerprinting here is off because the we currently rely on having at least one of the nodes return \"true\", and if replicas are out-of-sync\n    // we still need to pick one as leader.  A followup sync from the replica to the new leader (with fingerprinting on) should then fail and\n    // initiate recovery-by-replication.\n    PeerSync peerSync = new PeerSync(core, syncWith, core.getUpdateHandler().getUpdateLog().getNumRecordsToKeep(), true, peerSyncOnlyWithActive, false);\n    return peerSync.sync();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["26cb11ce089e71fb909641e7030b53c7d9e3fff3"],"ac88193d9fe80e165a43bb0555c43afa83da8330":["6f3c1f22c5fe0011e187dac3151422365ae857f3","bfdc2557c90b5d141fd515eb1c557f0fc9451076"],"e6e01fcbda8c04bde654f99836a2f8813f9444f3":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["6f3c1f22c5fe0011e187dac3151422365ae857f3","979e22aa7c63c9dc651adf861610c7e444d45832"],"bb62cc3362417c3e5136f2f26d34a1072ad633eb":["5a2658bad9ac95d1beab4cb8bdbe8ae909970cdc"],"6f3c1f22c5fe0011e187dac3151422365ae857f3":["a81e7d9c7ad18b6ec658ebdb132dd51a2164f039"],"bfdc2557c90b5d141fd515eb1c557f0fc9451076":["6f3c1f22c5fe0011e187dac3151422365ae857f3"],"5a2658bad9ac95d1beab4cb8bdbe8ae909970cdc":["979e22aa7c63c9dc651adf861610c7e444d45832"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5a2658bad9ac95d1beab4cb8bdbe8ae909970cdc","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a81e7d9c7ad18b6ec658ebdb132dd51a2164f039","6f3c1f22c5fe0011e187dac3151422365ae857f3"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"a81e7d9c7ad18b6ec658ebdb132dd51a2164f039":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["5a2658bad9ac95d1beab4cb8bdbe8ae909970cdc","bb62cc3362417c3e5136f2f26d34a1072ad633eb"],"979e22aa7c63c9dc651adf861610c7e444d45832":["ac88193d9fe80e165a43bb0555c43afa83da8330"],"b1704c078ec59838c9d95d5bf5738b393b537494":["ac88193d9fe80e165a43bb0555c43afa83da8330","979e22aa7c63c9dc651adf861610c7e444d45832"],"26cb11ce089e71fb909641e7030b53c7d9e3fff3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e6e01fcbda8c04bde654f99836a2f8813f9444f3"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a81e7d9c7ad18b6ec658ebdb132dd51a2164f039"],"ac88193d9fe80e165a43bb0555c43afa83da8330":["979e22aa7c63c9dc651adf861610c7e444d45832","b1704c078ec59838c9d95d5bf5738b393b537494"],"e6e01fcbda8c04bde654f99836a2f8813f9444f3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e6e01fcbda8c04bde654f99836a2f8813f9444f3"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"bb62cc3362417c3e5136f2f26d34a1072ad633eb":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"6f3c1f22c5fe0011e187dac3151422365ae857f3":["ac88193d9fe80e165a43bb0555c43afa83da8330","1e6acbaae7af722f17204ceccf0f7db5753eccf3","bfdc2557c90b5d141fd515eb1c557f0fc9451076","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"bfdc2557c90b5d141fd515eb1c557f0fc9451076":["ac88193d9fe80e165a43bb0555c43afa83da8330"],"5a2658bad9ac95d1beab4cb8bdbe8ae909970cdc":["bb62cc3362417c3e5136f2f26d34a1072ad633eb","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a81e7d9c7ad18b6ec658ebdb132dd51a2164f039":["6f3c1f22c5fe0011e187dac3151422365ae857f3","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["26cb11ce089e71fb909641e7030b53c7d9e3fff3"],"979e22aa7c63c9dc651adf861610c7e444d45832":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","5a2658bad9ac95d1beab4cb8bdbe8ae909970cdc","b1704c078ec59838c9d95d5bf5738b393b537494"],"b1704c078ec59838c9d95d5bf5738b393b537494":[],"26cb11ce089e71fb909641e7030b53c7d9e3fff3":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","b1704c078ec59838c9d95d5bf5738b393b537494","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}