{"path":"solr/core/src/java/org/apache/solr/cloud/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","commits":[{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","pathOld":"/dev/null","sourceNew":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 0 : 1,\n              replicaType == Replica.Type.TLOG ? 0 : 1,\n              replicaType == Replica.Type.PULL ? 0 : 1\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica\", node);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","sourceNew":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 0 : 1,\n              replicaType == Replica.Type.TLOG ? 0 : 1,\n              replicaType == Replica.Type.PULL ? 0 : 1\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica\", node);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","sourceOld":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 0 : 1,\n              replicaType == Replica.Type.TLOG ? 0 : 1,\n              replicaType == Replica.Type.PULL ? 0 : 1\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica\", node);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","sourceNew":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 0 : 1,\n              replicaType == Replica.Type.TLOG ? 0 : 1,\n              replicaType == Replica.Type.PULL ? 0 : 1\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica\", node);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","sourceOld":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 0 : 1,\n              replicaType == Replica.Type.TLOG ? 0 : 1,\n              replicaType == Replica.Type.PULL ? 0 : 1\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica\", node);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}