{"path":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","commits":[{"id":"2a6ee6c302710254b6c2474ccd2755f9f2323ee3","date":1330700384,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive bottom=\" + bottom + \" queue.size()=\" + queue.size());\n\n      if (bottom != null) {\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator);\n\n      newPath.input.grow(path.input.length+1);\n      System.arraycopy(path.input.ints, 0, newPath.input.ints, 0, path.input.length);\n      newPath.input.ints[path.input.length] = path.arc.label;\n      newPath.input.length = path.input.length+1;\n\n      //System.out.println(\"    add path=\" + newPath);\n      queue.add(newPath);\n      if (bottom != null) {\n        final FSTPath<T> removed = queue.pollLast();\n        assert removed == bottom;\n        bottom = queue.last();\n        //System.out.println(\"    now re-set bottom: \" + bottom + \" queue=\" + queue);\n      } else if (queue.size() == topN) {\n        // Queue just filled up:\n        bottom = queue.last();\n        //System.out.println(\"    now set bottom: \" + bottom);\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath path) {\n\n      assert queue != null;\n\n      long cost = path.cost + path.arc.output;\n      //System.out.println(\"  addIfCompetitive bottom=\" + bottom + \" queue.size()=\" + queue.size());\n\n      if (bottom != null) {\n\n        if (cost > bottom.cost) {\n          // Doesn't compete\n          return;\n        } else if (cost == bottom.cost) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      final FSTPath newPath = new FSTPath(cost, path.arc);\n\n      newPath.input.grow(path.input.length+1);\n      System.arraycopy(path.input.ints, 0, newPath.input.ints, 0, path.input.length);\n      newPath.input.ints[path.input.length] = path.arc.label;\n      newPath.input.length = path.input.length+1;\n\n      //System.out.println(\"    add path=\" + newPath);\n      queue.add(newPath);\n      if (bottom != null) {\n        final FSTPath removed = queue.pollLast();\n        assert removed == bottom;\n        bottom = queue.last();\n        //System.out.println(\"    now re-set bottom: \" + bottom + \" queue=\" + queue);\n      } else if (queue.size() == topN) {\n        // Queue just filled up:\n        bottom = queue.last();\n        //System.out.println(\"    now set bottom: \" + bottom);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"/dev/null","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive bottom=\" + bottom + \" queue.size()=\" + queue.size());\n\n      if (bottom != null) {\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator);\n\n      newPath.input.grow(path.input.length+1);\n      System.arraycopy(path.input.ints, 0, newPath.input.ints, 0, path.input.length);\n      newPath.input.ints[path.input.length] = path.arc.label;\n      newPath.input.length = path.input.length+1;\n\n      //System.out.println(\"    add path=\" + newPath);\n      queue.add(newPath);\n      if (bottom != null) {\n        final FSTPath<T> removed = queue.pollLast();\n        assert removed == bottom;\n        bottom = queue.last();\n        //System.out.println(\"    now re-set bottom: \" + bottom + \" queue=\" + queue);\n      } else if (queue.size() == topN) {\n        // Queue just filled up:\n        bottom = queue.last();\n        //System.out.println(\"    now set bottom: \" + bottom);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6ce825e9276493231308229152c48f755ce1a0a5","date":1348871483,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive bottom=\" + bottom + \" queue.size()=\" + queue.size());\n\n      if (bottom != null) {\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      // this is pointless right?  we do it above already:\n      //newPath.input.grow(path.input.length+1);\n      //System.arraycopy(path.input.ints, 0, newPath.input.ints, 0, path.input.length);\n      //newPath.input.ints[path.input.length] = path.arc.label;\n      //newPath.input.length = path.input.length+1;\n\n      //System.out.println(\"    add path=\" + newPath);\n      queue.add(newPath);\n      if (bottom != null) {\n        final FSTPath<T> removed = queue.pollLast();\n        assert removed == bottom;\n        bottom = queue.last();\n        //System.out.println(\"    now re-set bottom: \" + bottom + \" queue=\" + queue);\n      } else if (queue.size() == topN) {\n        // Queue just filled up:\n        bottom = queue.last();\n        //System.out.println(\"    now set bottom: \" + bottom);\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive bottom=\" + bottom + \" queue.size()=\" + queue.size());\n\n      if (bottom != null) {\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator);\n\n      newPath.input.grow(path.input.length+1);\n      System.arraycopy(path.input.ints, 0, newPath.input.ints, 0, path.input.length);\n      newPath.input.ints[path.input.length] = path.arc.label;\n      newPath.input.length = path.input.length+1;\n\n      //System.out.println(\"    add path=\" + newPath);\n      queue.add(newPath);\n      if (bottom != null) {\n        final FSTPath<T> removed = queue.pollLast();\n        assert removed == bottom;\n        bottom = queue.last();\n        //System.out.println(\"    now re-set bottom: \" + bottom + \" queue=\" + queue);\n      } else if (queue.size() == topN) {\n        // Queue just filled up:\n        bottom = queue.last();\n        //System.out.println(\"    now set bottom: \" + bottom);\n      }\n    }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","32eace34e207608926e4c83409c65d968e530bf2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc41b743423981e7ec17a024ce7e107096e472fe","date":1349975327,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive bottom=\" + bottom + \" queue.size()=\" + queue.size());\n\n      if (bottom != null) {\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      // this is pointless right?  we do it above already:\n      //newPath.input.grow(path.input.length+1);\n      //System.arraycopy(path.input.ints, 0, newPath.input.ints, 0, path.input.length);\n      //newPath.input.ints[path.input.length] = path.arc.label;\n      //newPath.input.length = path.input.length+1;\n\n      //System.out.println(\"    add path=\" + newPath + (bottom == null ? \"\" : (\" newPath.compareTo(bottom)=\" + newPath.compareTo(bottom))) + \" bottom=\" + bottom + \" topN=\" + topN);\n\n      // We should never see dups:\n      assert bottom == null || newPath.compareTo(bottom) != 0;\n      queue.add(newPath);\n\n      if (bottom != null) {\n        final FSTPath<T> removed = queue.pollLast();\n        assert removed == bottom;\n        if (queue.size() == 0) {\n          bottom = null;\n        } else {\n          bottom = queue.last();\n        }\n        //System.out.println(\"    now re-set bottom: \" + bottom + \" queue=\" + queue);\n      } else if (queue.size() == topN) {\n        // Queue just filled up:\n        bottom = queue.last();\n        //System.out.println(\"    now set bottom: \" + bottom);\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive bottom=\" + bottom + \" queue.size()=\" + queue.size());\n\n      if (bottom != null) {\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      // this is pointless right?  we do it above already:\n      //newPath.input.grow(path.input.length+1);\n      //System.arraycopy(path.input.ints, 0, newPath.input.ints, 0, path.input.length);\n      //newPath.input.ints[path.input.length] = path.arc.label;\n      //newPath.input.length = path.input.length+1;\n\n      //System.out.println(\"    add path=\" + newPath);\n      queue.add(newPath);\n      if (bottom != null) {\n        final FSTPath<T> removed = queue.pollLast();\n        assert removed == bottom;\n        bottom = queue.last();\n        //System.out.println(\"    now re-set bottom: \" + bottom + \" queue=\" + queue);\n      } else if (queue.size() == topN) {\n        // Queue just filled up:\n        bottom = queue.last();\n        //System.out.println(\"    now set bottom: \" + bottom);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"32eace34e207608926e4c83409c65d968e530bf2","date":1350054443,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == topN) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == topN+1) {\n        queue.pollLast();\n      } \n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive bottom=\" + bottom + \" queue.size()=\" + queue.size());\n\n      if (bottom != null) {\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      // this is pointless right?  we do it above already:\n      //newPath.input.grow(path.input.length+1);\n      //System.arraycopy(path.input.ints, 0, newPath.input.ints, 0, path.input.length);\n      //newPath.input.ints[path.input.length] = path.arc.label;\n      //newPath.input.length = path.input.length+1;\n\n      //System.out.println(\"    add path=\" + newPath);\n      queue.add(newPath);\n      if (bottom != null) {\n        final FSTPath<T> removed = queue.pollLast();\n        assert removed == bottom;\n        bottom = queue.last();\n        //System.out.println(\"    now re-set bottom: \" + bottom + \" queue=\" + queue);\n      } else if (queue.size() == topN) {\n        // Queue just filled up:\n        bottom = queue.last();\n        //System.out.println(\"    now set bottom: \" + bottom);\n      }\n    }\n\n","bugFix":["2a6ee6c302710254b6c2474ccd2755f9f2323ee3","6ce825e9276493231308229152c48f755ce1a0a5","bede0ec3497c48e70d55196c5065d97a4bc1db3d"],"bugIntro":["414aae1db83a83d247caa9514e383e4ca3d43da5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6efad415dcdbcca7d440f909743e6e3152eeb6c0","date":1350055371,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == topN) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == topN+1) {\n        queue.pollLast();\n      } \n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive bottom=\" + bottom + \" queue.size()=\" + queue.size());\n\n      if (bottom != null) {\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      // this is pointless right?  we do it above already:\n      //newPath.input.grow(path.input.length+1);\n      //System.arraycopy(path.input.ints, 0, newPath.input.ints, 0, path.input.length);\n      //newPath.input.ints[path.input.length] = path.arc.label;\n      //newPath.input.length = path.input.length+1;\n\n      //System.out.println(\"    add path=\" + newPath + (bottom == null ? \"\" : (\" newPath.compareTo(bottom)=\" + newPath.compareTo(bottom))) + \" bottom=\" + bottom + \" topN=\" + topN);\n\n      // We should never see dups:\n      assert bottom == null || newPath.compareTo(bottom) != 0;\n      queue.add(newPath);\n\n      if (bottom != null) {\n        final FSTPath<T> removed = queue.pollLast();\n        assert removed == bottom;\n        if (queue.size() == 0) {\n          bottom = null;\n        } else {\n          bottom = queue.last();\n        }\n        //System.out.println(\"    now re-set bottom: \" + bottom + \" queue=\" + queue);\n      } else if (queue.size() == topN) {\n        // Queue just filled up:\n        bottom = queue.last();\n        //System.out.println(\"    now set bottom: \" + bottom);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d82832af39f94dbb58a3130fd216ff1d49435589","date":1350147242,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == topN) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == topN+1) {\n        queue.pollLast();\n      } \n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive bottom=\" + bottom + \" queue.size()=\" + queue.size());\n\n      if (bottom != null) {\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      // this is pointless right?  we do it above already:\n      //newPath.input.grow(path.input.length+1);\n      //System.arraycopy(path.input.ints, 0, newPath.input.ints, 0, path.input.length);\n      //newPath.input.ints[path.input.length] = path.arc.label;\n      //newPath.input.length = path.input.length+1;\n\n      //System.out.println(\"    add path=\" + newPath);\n      queue.add(newPath);\n      if (bottom != null) {\n        final FSTPath<T> removed = queue.pollLast();\n        assert removed == bottom;\n        bottom = queue.last();\n        //System.out.println(\"    now re-set bottom: \" + bottom + \" queue=\" + queue);\n      } else if (queue.size() == topN) {\n        // Queue just filled up:\n        bottom = queue.last();\n        //System.out.println(\"    now set bottom: \" + bottom);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59aedb6464136dd3cd73d343e814ba8acf3da155","date":1350729779,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      // LUCENE-4481: TODO: re-enable this pruning if we can make this admissible:\n      /*\n      if (queue.size() == topN) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n      */\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      queue.add(newPath);\n\n      // LUCENE-4481: TODO: re-enable this pruning if we can make this admissible:\n      /*\n      if (queue.size() == topN+1) {\n        queue.pollLast();\n      }\n      */\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == topN) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == topN+1) {\n        queue.pollLast();\n      } \n    }\n\n","bugFix":null,"bugIntro":["414aae1db83a83d247caa9514e383e4ca3d43da5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"414aae1db83a83d247caa9514e383e4ca3d43da5","date":1350824365,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      // LUCENE-4481: TODO: re-enable this pruning if we can make this admissible:\n      /*\n      if (queue.size() == topN) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n      */\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      queue.add(newPath);\n\n      // LUCENE-4481: TODO: re-enable this pruning if we can make this admissible:\n      /*\n      if (queue.size() == topN+1) {\n        queue.pollLast();\n      }\n      */\n    }\n\n","bugFix":["59aedb6464136dd3cd73d343e814ba8acf3da155","32eace34e207608926e4c83409c65d968e530bf2"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"62e52115b56781006682fd92c6938efaf174304d","date":1351014780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == topN) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == topN+1) {\n        queue.pollLast();\n      } \n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","date":1351615637,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n          assert cmp != 0;\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a81c53232b7a347a2a79b731a0b152059237a4b5","date":1351810824,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, comparator, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0af0c31a687dd847212ae59f661152896c76516","date":1380727430,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    private void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<>(cost, path.arc, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.append(path.arc.label);\n          final int cmp = bottom.input.get().compareTo(path.input.get());\n          path.input.setLength(path.input.length() - 1);\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRefBuilder newInput = new IntsRefBuilder();\n      newInput.copyInts(path.input.get());\n      newInput.append(path.arc.label);\n      final FSTPath<T> newPath = new FSTPath<>(cost, path.arc, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.grow(path.input.length+1);\n          path.input.ints[path.input.length++] = path.arc.label;\n          final int cmp = bottom.input.compareTo(path.input);\n          path.input.length--;\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRef newInput = new IntsRef(path.input.length+1);     \n      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);\n      newInput.ints[path.input.length] = path.arc.label;\n      newInput.length = path.input.length+1;\n      final FSTPath<T> newPath = new FSTPath<>(cost, path.arc, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","bugFix":["6ce825e9276493231308229152c48f755ce1a0a5","bede0ec3497c48e70d55196c5065d97a4bc1db3d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8c33f6677a2078739058f81eca1df69d12cd62b0","date":1432799589,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.append(path.arc.label);\n          final int cmp = bottom.input.get().compareTo(path.input.get());\n          path.input.setLength(path.input.length() - 1);\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRefBuilder newInput = new IntsRefBuilder();\n      newInput.copyInts(path.input.get());\n      newInput.append(path.arc.label);\n\n      queue.add(path.newPath(cost, newInput));\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.append(path.arc.label);\n          final int cmp = bottom.input.get().compareTo(path.input.get());\n          path.input.setLength(path.input.length() - 1);\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRefBuilder newInput = new IntsRefBuilder();\n      newInput.copyInts(path.input.get());\n      newInput.append(path.arc.label);\n      final FSTPath<T> newPath = new FSTPath<>(cost, path.arc, newInput);\n\n      queue.add(newPath);\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"13975b8f26b2a9600a5333689974923927b7b8ab","date":1432835215,"type":3,"author":"Areek Zillur","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = pathComparator.compare(path, bottom);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.append(path.arc.label);\n          final int cmp = bottom.input.get().compareTo(path.input.get());\n          path.input.setLength(path.input.length() - 1);\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRefBuilder newInput = new IntsRefBuilder();\n      newInput.copyInts(path.input.get());\n      newInput.append(path.arc.label);\n\n      queue.add(path.newPath(cost, newInput));\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = comparator.compare(cost, bottom.cost);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.append(path.arc.label);\n          final int cmp = bottom.input.get().compareTo(path.input.get());\n          path.input.setLength(path.input.length() - 1);\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRefBuilder newInput = new IntsRefBuilder();\n      newInput.copyInts(path.input.get());\n      newInput.append(path.arc.label);\n\n      queue.add(path.newPath(cost, newInput));\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","bugFix":["2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"902a92b60648a8925bfd9bb53a78669cd2ea98fd","date":1487797466,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T output = fst.outputs.add(path.output, path.arc.output);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = pathComparator.compare(path, bottom);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.append(path.arc.label);\n          final int cmp = bottom.input.get().compareTo(path.input.get());\n          path.input.setLength(path.input.length() - 1);\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRefBuilder newInput = new IntsRefBuilder();\n      newInput.copyInts(path.input.get());\n      newInput.append(path.arc.label);\n\n      FSTPath<T> newPath = path.newPath(output, newInput);\n      if (acceptPartialPath(newPath)) {\n        queue.add(newPath);\n        if (queue.size() == maxQueueDepth+1) {\n          queue.pollLast();\n        }\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T cost = fst.outputs.add(path.cost, path.arc.output);\n      //System.out.println(\"  addIfCompetitive queue.size()=\" + queue.size() + \" path=\" + path + \" + label=\" + path.arc.label);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = pathComparator.compare(path, bottom);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.append(path.arc.label);\n          final int cmp = bottom.input.get().compareTo(path.input.get());\n          path.input.setLength(path.input.length() - 1);\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRefBuilder newInput = new IntsRefBuilder();\n      newInput.copyInts(path.input.get());\n      newInput.append(path.arc.label);\n\n      queue.add(path.newPath(cost, newInput));\n\n      if (queue.size() == maxQueueDepth+1) {\n        queue.pollLast();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T output = fst.outputs.add(path.output, path.arc.output());\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = pathComparator.compare(path, bottom);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.append(path.arc.label());\n          final int cmp = bottom.input.get().compareTo(path.input.get());\n          path.input.setLength(path.input.length() - 1);\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      }\n      // else ... Queue isn't full yet, so any path we hit competes:\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRefBuilder newInput = new IntsRefBuilder();\n      newInput.copyInts(path.input.get());\n      newInput.append(path.arc.label());\n\n      FSTPath<T> newPath = path.newPath(output, newInput);\n      if (acceptPartialPath(newPath)) {\n        queue.add(newPath);\n        if (queue.size() == maxQueueDepth+1) {\n          queue.pollLast();\n        }\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T output = fst.outputs.add(path.output, path.arc.output);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = pathComparator.compare(path, bottom);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.append(path.arc.label);\n          final int cmp = bottom.input.get().compareTo(path.input.get());\n          path.input.setLength(path.input.length() - 1);\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRefBuilder newInput = new IntsRefBuilder();\n      newInput.copyInts(path.input.get());\n      newInput.append(path.arc.label);\n\n      FSTPath<T> newPath = path.newPath(output, newInput);\n      if (acceptPartialPath(newPath)) {\n        queue.add(newPath);\n        if (queue.size() == maxQueueDepth+1) {\n          queue.pollLast();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#addIfCompetitive(FSTPath[T]).mjava","sourceNew":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T output = fst.outputs.add(path.output, path.arc.output());\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = pathComparator.compare(path, bottom);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.append(path.arc.label());\n          final int cmp = bottom.input.get().compareTo(path.input.get());\n          path.input.setLength(path.input.length() - 1);\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      }\n      // else ... Queue isn't full yet, so any path we hit competes:\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRefBuilder newInput = new IntsRefBuilder();\n      newInput.copyInts(path.input.get());\n      newInput.append(path.arc.label());\n\n      FSTPath<T> newPath = path.newPath(output, newInput);\n      if (acceptPartialPath(newPath)) {\n        queue.add(newPath);\n        if (queue.size() == maxQueueDepth+1) {\n          queue.pollLast();\n        }\n      }\n    }\n\n","sourceOld":"    // If back plus this arc is competitive then add to queue:\n    protected void addIfCompetitive(FSTPath<T> path) {\n\n      assert queue != null;\n\n      T output = fst.outputs.add(path.output, path.arc.output);\n\n      if (queue.size() == maxQueueDepth) {\n        FSTPath<T> bottom = queue.last();\n        int comp = pathComparator.compare(path, bottom);\n        if (comp > 0) {\n          // Doesn't compete\n          return;\n        } else if (comp == 0) {\n          // Tie break by alpha sort on the input:\n          path.input.append(path.arc.label);\n          final int cmp = bottom.input.get().compareTo(path.input.get());\n          path.input.setLength(path.input.length() - 1);\n\n          // We should never see dups:\n          assert cmp != 0;\n\n          if (cmp < 0) {\n            // Doesn't compete\n            return;\n          }\n        }\n        // Competes\n      } else {\n        // Queue isn't full yet, so any path we hit competes:\n      }\n\n      // copy over the current input to the new input\n      // and add the arc.label to the end\n      IntsRefBuilder newInput = new IntsRefBuilder();\n      newInput.copyInts(path.input.get());\n      newInput.append(path.arc.label);\n\n      FSTPath<T> newPath = path.newPath(output, newInput);\n      if (acceptPartialPath(newPath)) {\n        queue.add(newPath);\n        if (queue.size() == maxQueueDepth+1) {\n          queue.pollLast();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d0af0c31a687dd847212ae59f661152896c76516"],"59aedb6464136dd3cd73d343e814ba8acf3da155":["32eace34e207608926e4c83409c65d968e530bf2"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"a81c53232b7a347a2a79b731a0b152059237a4b5":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"414aae1db83a83d247caa9514e383e4ca3d43da5":["59aedb6464136dd3cd73d343e814ba8acf3da155"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"902a92b60648a8925bfd9bb53a78669cd2ea98fd":["13975b8f26b2a9600a5333689974923927b7b8ab"],"32eace34e207608926e4c83409c65d968e530bf2":["6ce825e9276493231308229152c48f755ce1a0a5"],"2a6ee6c302710254b6c2474ccd2755f9f2323ee3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f8061ddd97f3352007d927dae445884a6f3d857b":["902a92b60648a8925bfd9bb53a78669cd2ea98fd","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"6efad415dcdbcca7d440f909743e6e3152eeb6c0":["cc41b743423981e7ec17a024ce7e107096e472fe","32eace34e207608926e4c83409c65d968e530bf2"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["902a92b60648a8925bfd9bb53a78669cd2ea98fd"],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["414aae1db83a83d247caa9514e383e4ca3d43da5","62e52115b56781006682fd92c6938efaf174304d"],"62e52115b56781006682fd92c6938efaf174304d":["6efad415dcdbcca7d440f909743e6e3152eeb6c0","414aae1db83a83d247caa9514e383e4ca3d43da5"],"d0af0c31a687dd847212ae59f661152896c76516":["a81c53232b7a347a2a79b731a0b152059237a4b5"],"cc41b743423981e7ec17a024ce7e107096e472fe":["6ce825e9276493231308229152c48f755ce1a0a5"],"d82832af39f94dbb58a3130fd216ff1d49435589":["6ce825e9276493231308229152c48f755ce1a0a5","32eace34e207608926e4c83409c65d968e530bf2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6ce825e9276493231308229152c48f755ce1a0a5":["2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"13975b8f26b2a9600a5333689974923927b7b8ab":["8c33f6677a2078739058f81eca1df69d12cd62b0"],"8c33f6677a2078739058f81eca1df69d12cd62b0":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54204c8a3ca26aeafd273139fc29baf70d0f6786"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"59aedb6464136dd3cd73d343e814ba8acf3da155":["414aae1db83a83d247caa9514e383e4ca3d43da5"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"a81c53232b7a347a2a79b731a0b152059237a4b5":["d0af0c31a687dd847212ae59f661152896c76516"],"414aae1db83a83d247caa9514e383e4ca3d43da5":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","62e52115b56781006682fd92c6938efaf174304d"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["8c33f6677a2078739058f81eca1df69d12cd62b0"],"32eace34e207608926e4c83409c65d968e530bf2":["59aedb6464136dd3cd73d343e814ba8acf3da155","6efad415dcdbcca7d440f909743e6e3152eeb6c0","d82832af39f94dbb58a3130fd216ff1d49435589"],"2a6ee6c302710254b6c2474ccd2755f9f2323ee3":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","6ce825e9276493231308229152c48f755ce1a0a5"],"902a92b60648a8925bfd9bb53a78669cd2ea98fd":["f8061ddd97f3352007d927dae445884a6f3d857b","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"6efad415dcdbcca7d440f909743e6e3152eeb6c0":["62e52115b56781006682fd92c6938efaf174304d"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["a81c53232b7a347a2a79b731a0b152059237a4b5"],"62e52115b56781006682fd92c6938efaf174304d":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"d0af0c31a687dd847212ae59f661152896c76516":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cc41b743423981e7ec17a024ce7e107096e472fe":["6efad415dcdbcca7d440f909743e6e3152eeb6c0"],"d82832af39f94dbb58a3130fd216ff1d49435589":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"6ce825e9276493231308229152c48f755ce1a0a5":["32eace34e207608926e4c83409c65d968e530bf2","cc41b743423981e7ec17a024ce7e107096e472fe","d82832af39f94dbb58a3130fd216ff1d49435589"],"13975b8f26b2a9600a5333689974923927b7b8ab":["902a92b60648a8925bfd9bb53a78669cd2ea98fd"],"8c33f6677a2078739058f81eca1df69d12cd62b0":["13975b8f26b2a9600a5333689974923927b7b8ab"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f8061ddd97f3352007d927dae445884a6f3d857b","d82832af39f94dbb58a3130fd216ff1d49435589","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}