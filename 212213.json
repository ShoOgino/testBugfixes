{"path":"lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum#setLinear(int).mjava","commits":[{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum#setLinear(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","sourceNew":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position: we set an upper bound and \n   * act like a TermRangeQuery for this portion of the term space.\n   */\n  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n\n","sourceOld":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position: we set an upper bound and \n   * act like a TermRangeQuery for this portion of the term space.\n   */\n  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#setLinear(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum#setLinear(int).mjava","sourceNew":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position: we set an upper bound and \n   * act like a TermRangeQuery for this portion of the term space.\n   */\n  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n\n","sourceOld":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position: we set an upper bound and \n   * act like a TermRangeQuery for this portion of the term space.\n   */\n  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}