{"path":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","commits":[{"id":"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","date":1297021734,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (!getClass().getName().startsWith(\"org.apache.solr\")) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName() \n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (!getClass().getName().startsWith(\"org.apache.solr\")) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName() \n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (!getClass().getName().startsWith(\"org.apache.solr\")) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName() \n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (!getClass().getName().startsWith(\"org.apache.solr\")) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName() \n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":1,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (!getClass().getName().startsWith(\"org.apache.solr\")) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName()\n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (!getClass().getName().startsWith(\"org.apache.solr\")) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName()\n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd6abb7020b5aeeff86624594e1d9aacedfe2d5d","date":1301021377,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName() \n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (!getClass().getName().startsWith(\"org.apache.solr\")) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName() \n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":null,"bugIntro":["558b125bbf6fa91eb5355da7e849d46edaf735bc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName() \n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (!getClass().getName().startsWith(\"org.apache.solr\")) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName() \n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName()\n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (!getClass().getName().startsWith(\"org.apache.solr\")) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName()\n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName()\n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName() \n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName()\n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName() \n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f0dc13f9e59664be282b46015a020c945dc2a48","date":1305657127,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    if (!testsFailed) {\n      // Note: we allow a test to go straight from SETUP -> TEARDOWN (without ever entering the RANTEST state)\n      // because if you assume() inside setUp(), it skips the test and the TestWatchman has no way to know...\n      assertTrue(\"ensure your setUp() calls super.setUp()!!!\", state == State.RANTEST || state == State.SETUP);\n    }\n    state = State.TEARDOWN;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName()\n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName()\n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":["e42b97f2dcf8cca9bf6437e7d0dd3e8711f7413f","37087ea13c0fde1ce1a3b5579f60f827414045a9"],"bugIntro":["558b125bbf6fa91eb5355da7e849d46edaf735bc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    if (!testsFailed) {\n      // Note: we allow a test to go straight from SETUP -> TEARDOWN (without ever entering the RANTEST state)\n      // because if you assume() inside setUp(), it skips the test and the TestWatchman has no way to know...\n      assertTrue(\"ensure your setUp() calls super.setUp()!!!\", state == State.RANTEST || state == State.SETUP);\n    }\n    state = State.TEARDOWN;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName()\n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName()\n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    if (!testsFailed) {\n      // Note: we allow a test to go straight from SETUP -> TEARDOWN (without ever entering the RANTEST state)\n      // because if you assume() inside setUp(), it skips the test and the TestWatchman has no way to know...\n      assertTrue(\"ensure your setUp() calls super.setUp()!!!\", state == State.RANTEST || state == State.SETUP);\n    }\n    state = State.TEARDOWN;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName()\n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    assertTrue(\"ensure your setUp() calls super.setUp()!!!\", setup);\n    setup = false;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName() \n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test \n      // classes call it directly from the scope where the index readers \n      // are used, because they could be gc'ed just before this tearDown \n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact \n      // \"violates\" FieldCache sanity, then you should either explicitly \n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are \n      // isolated in distinct test methods  \n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"558b125bbf6fa91eb5355da7e849d46edaf735bc","date":1314371299,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    State oldState = state; // capture test execution state\n    state = State.TEARDOWN; // set the state for subsequent tests\n    \n    // NOTE: with junit 4.7, we don't get a reproduceWith because our Watchman\n    // does not know if something fails in tearDown. so we ensure this happens ourselves for now.\n    // we can remove this if we upgrade to 4.8\n    Throwable problem = null;\n    \n    try {\n      if (!testsFailed) {\n        // Note: we allow a test to go straight from SETUP -> TEARDOWN (without ever entering the RANTEST state)\n        // because if you assume() inside setUp(), it skips the test and the TestWatchman has no way to know...\n        assertTrue(\"ensure your setUp() calls super.setUp()!!!\", oldState == State.RANTEST || oldState == State.SETUP);\n      }\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n\n    // if you didn't call super.setUp, you can get a confusing IAE here.\n    if (problem != null) {\n      BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    }\n\n    // this won't throw any exceptions or fail the test\n    // if we change this, then change this logic\n    checkRogueThreadsAfter();\n    // restore the default uncaught exception handler\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    \n    try {\n      checkUncaughtExceptionsAfter();\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n    \n    try {\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n    \n    purgeFieldCache(FieldCache.DEFAULT);\n    \n    if (problem != null) {\n      testsFailed = true;\n      reportAdditionalFailureInfo();\n      throw new RuntimeException(problem);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    if (!testsFailed) {\n      // Note: we allow a test to go straight from SETUP -> TEARDOWN (without ever entering the RANTEST state)\n      // because if you assume() inside setUp(), it skips the test and the TestWatchman has no way to know...\n      assertTrue(\"ensure your setUp() calls super.setUp()!!!\", state == State.RANTEST || state == State.SETUP);\n    }\n    state = State.TEARDOWN;\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    if (\"perMethod\".equals(TEST_CLEAN_THREADS)) {\n      int rogueThreads = threadCleanup(\"test method: '\" + getName() + \"'\");\n      if (rogueThreads > 0) {\n        System.err.println(\"RESOURCE LEAK: test method: '\" + getName()\n            + \"' left \" + rogueThreads + \" thread(s) running\");\n        // TODO: fail, but print seed for now.\n        if (!testsFailed && uncaughtExceptions.isEmpty()) {\n          reportAdditionalFailureInfo();\n        }\n      }\n    }\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    try {\n\n      if (!uncaughtExceptions.isEmpty()) {\n        testsFailed = true;\n        reportAdditionalFailureInfo();\n        System.err.println(\"The following exceptions were thrown by threads:\");\n        for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n          System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n          entry.exception.printStackTrace(System.err);\n        }\n        fail(\"Some threads threw uncaught exceptions!\");\n      }\n\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":["f1dccbb7b01a3abbed915804b0d7aa34238b966f","5f0dc13f9e59664be282b46015a020c945dc2a48","36dab8b0f369908af9460781f02512c5f364ba6a","ea91947285bbf66f9f3839a31d6b1f9eb8ba4d4d","937baa6efeb42f311b60e55631e1e8b006ea8d84","f470b537db3da4e8d0c39bc72fae5f9865a9ec3c","e69f59b863731d864bf3047235e718f0f88f8841","48a042c3df37e281328101a2e1dbb50202b08915","bde51b089eb7f86171eb3406e38a274743f9b7ac","bd6abb7020b5aeeff86624594e1d9aacedfe2d5d","43b04c27924fe393e38e9f0986e32c634f261859"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c222b73c174715bead7cc12cb95463116870e79","date":1314377937,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    State oldState = state; // capture test execution state\n    state = State.TEARDOWN; // set the state for subsequent tests\n    \n    // NOTE: with junit 4.7, we don't get a reproduceWith because our Watchman\n    // does not know if something fails in tearDown. so we ensure this happens ourselves for now.\n    // we can remove this if we upgrade to 4.8\n    Throwable problem = null;\n    \n    try {\n      if (!testsFailed) {\n        // Note: we allow a test to go straight from SETUP -> TEARDOWN (without ever entering the RANTEST state)\n        // because if you assume() inside setUp(), it skips the test and the TestWatchman has no way to know...\n        assertTrue(\"ensure your setUp() calls super.setUp()!!!\", oldState == State.RANTEST || oldState == State.SETUP);\n      }\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n\n    // this won't throw any exceptions or fail the test\n    // if we change this, then change this logic\n    checkRogueThreadsAfter();\n    // restore the default uncaught exception handler\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    \n    try {\n      checkUncaughtExceptionsAfter();\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n    \n    try {\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n    \n    purgeFieldCache(FieldCache.DEFAULT);\n    \n    if (problem != null) {\n      testsFailed = true;\n      reportAdditionalFailureInfo();\n      throw new RuntimeException(problem);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    State oldState = state; // capture test execution state\n    state = State.TEARDOWN; // set the state for subsequent tests\n    \n    // NOTE: with junit 4.7, we don't get a reproduceWith because our Watchman\n    // does not know if something fails in tearDown. so we ensure this happens ourselves for now.\n    // we can remove this if we upgrade to 4.8\n    Throwable problem = null;\n    \n    try {\n      if (!testsFailed) {\n        // Note: we allow a test to go straight from SETUP -> TEARDOWN (without ever entering the RANTEST state)\n        // because if you assume() inside setUp(), it skips the test and the TestWatchman has no way to know...\n        assertTrue(\"ensure your setUp() calls super.setUp()!!!\", oldState == State.RANTEST || oldState == State.SETUP);\n      }\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n\n    // if you didn't call super.setUp, you can get a confusing IAE here.\n    if (problem != null) {\n      BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    }\n\n    // this won't throw any exceptions or fail the test\n    // if we change this, then change this logic\n    checkRogueThreadsAfter();\n    // restore the default uncaught exception handler\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    \n    try {\n      checkUncaughtExceptionsAfter();\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n    \n    try {\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n    \n    purgeFieldCache(FieldCache.DEFAULT);\n    \n    if (problem != null) {\n      testsFailed = true;\n      reportAdditionalFailureInfo();\n      throw new RuntimeException(problem);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    State oldState = state; // capture test execution state\n    state = State.TEARDOWN; // set the state for subsequent tests\n    \n    // NOTE: with junit 4.7, we don't get a reproduceWith because our Watchman\n    // does not know if something fails in tearDown. so we ensure this happens ourselves for now.\n    // we can remove this if we upgrade to 4.8\n    Throwable problem = null;\n    \n    try {\n      if (!testsFailed) {\n        // Note: we allow a test to go straight from SETUP -> TEARDOWN (without ever entering the RANTEST state)\n        // because if you assume() inside setUp(), it skips the test and the TestWatchman has no way to know...\n        assertTrue(\"ensure your setUp() calls super.setUp()!!!\", oldState == State.RANTEST || oldState == State.SETUP);\n      }\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n\n    // this won't throw any exceptions or fail the test\n    // if we change this, then change this logic\n    checkRogueThreadsAfter();\n    // restore the default uncaught exception handler\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    \n    try {\n      checkUncaughtExceptionsAfter();\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n    \n    try {\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n    \n    purgeFieldCache(FieldCache.DEFAULT);\n    \n    if (problem != null) {\n      testsFailed = true;\n      reportAdditionalFailureInfo();\n      throw new RuntimeException(problem);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    State oldState = state; // capture test execution state\n    state = State.TEARDOWN; // set the state for subsequent tests\n    \n    // NOTE: with junit 4.7, we don't get a reproduceWith because our Watchman\n    // does not know if something fails in tearDown. so we ensure this happens ourselves for now.\n    // we can remove this if we upgrade to 4.8\n    Throwable problem = null;\n    \n    try {\n      if (!testsFailed) {\n        // Note: we allow a test to go straight from SETUP -> TEARDOWN (without ever entering the RANTEST state)\n        // because if you assume() inside setUp(), it skips the test and the TestWatchman has no way to know...\n        assertTrue(\"ensure your setUp() calls super.setUp()!!!\", oldState == State.RANTEST || oldState == State.SETUP);\n      }\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n\n    // this won't throw any exceptions or fail the test\n    // if we change this, then change this logic\n    checkRogueThreadsAfter();\n    // restore the default uncaught exception handler\n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    \n    try {\n      checkUncaughtExceptionsAfter();\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n    \n    try {\n      // calling assertSaneFieldCaches here isn't as useful as having test\n      // classes call it directly from the scope where the index readers\n      // are used, because they could be gc'ed just before this tearDown\n      // method is called.\n      //\n      // But it's better then nothing.\n      //\n      // If you are testing functionality that you know for a fact\n      // \"violates\" FieldCache sanity, then you should either explicitly\n      // call purgeFieldCache at the end of your test method, or refactor\n      // your Test class so that the inconsistant FieldCache usages are\n      // isolated in distinct test methods\n      assertSaneFieldCaches(getTestLabel());\n    } catch (Throwable t) {\n      if (problem == null) problem = t;\n    }\n    \n    purgeFieldCache(FieldCache.DEFAULT);\n    \n    if (problem != null) {\n      testsFailed = true;\n      reportAdditionalFailureInfo();\n      throw new RuntimeException(problem);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5c222b73c174715bead7cc12cb95463116870e79":["558b125bbf6fa91eb5355da7e849d46edaf735bc"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["d619839baa8ce5503e496b94a9e42ad6f079293f","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["bd6abb7020b5aeeff86624594e1d9aacedfe2d5d","c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"bd6abb7020b5aeeff86624594e1d9aacedfe2d5d":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7b91922b55d15444d554721b352861d028eb8278":["5c222b73c174715bead7cc12cb95463116870e79"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["bde51b089eb7f86171eb3406e38a274743f9b7ac","bd6abb7020b5aeeff86624594e1d9aacedfe2d5d"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["135621f3a0670a9394eb563224a3b76cc4dddc0f","5f0dc13f9e59664be282b46015a020c945dc2a48"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["29ef99d61cda9641b6250bf9567329a6e65f901d","bd6abb7020b5aeeff86624594e1d9aacedfe2d5d"],"a3776dccca01c11e7046323cfad46a3b4a471233":["bd6abb7020b5aeeff86624594e1d9aacedfe2d5d","5f0dc13f9e59664be282b46015a020c945dc2a48"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"558b125bbf6fa91eb5355da7e849d46edaf735bc":["5f0dc13f9e59664be282b46015a020c945dc2a48"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5f0dc13f9e59664be282b46015a020c945dc2a48":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"]},"commit2Childs":{"5c222b73c174715bead7cc12cb95463116870e79":["7b91922b55d15444d554721b352861d028eb8278"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["c3a8a449466c1ff7ce2274fe73dab487256964b4"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["135621f3a0670a9394eb563224a3b76cc4dddc0f","5f0dc13f9e59664be282b46015a020c945dc2a48"],"bd6abb7020b5aeeff86624594e1d9aacedfe2d5d":["b3e06be49006ecac364d39d12b9c9f74882f9b9f","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f","a3776dccca01c11e7046323cfad46a3b4a471233"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["bd6abb7020b5aeeff86624594e1d9aacedfe2d5d","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":[],"d619839baa8ce5503e496b94a9e42ad6f079293f":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"558b125bbf6fa91eb5355da7e849d46edaf735bc":["5c222b73c174715bead7cc12cb95463116870e79"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"5f0dc13f9e59664be282b46015a020c945dc2a48":["c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233","558b125bbf6fa91eb5355da7e849d46edaf735bc"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}