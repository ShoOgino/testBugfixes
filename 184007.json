{"path":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","sourceNew":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n    \n    sort.setSort (new SortField (\"int\", SortField.Type.INT) );\n    assertMatches (full, queryF, sort, \"IZJ\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT, true) );\n    assertMatches (full, queryF, sort, \"JZI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort (new SortField (\"nosuchfield\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random, 2, 8));\n    IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n    \n    sort.setSort (new SortField (\"int\", SortField.Type.INT) );\n    assertMatches (full, queryF, sort, \"IZJ\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT, true) );\n    assertMatches (full, queryF, sort, \"JZI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort (new SortField (\"nosuchfield\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random, 2, 8));\n    IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","sourceNew":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n    \n    sort.setSort (new SortField (\"int\", SortField.Type.INT) );\n    assertMatches (full, queryF, sort, \"IZJ\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT, true) );\n    assertMatches (full, queryF, sort, \"JZI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort (new SortField (\"nosuchfield\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8));\n    IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n    \n    sort.setSort (new SortField (\"int\", SortField.Type.INT) );\n    assertMatches (full, queryF, sort, \"IZJ\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT, true) );\n    assertMatches (full, queryF, sort, \"JZI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort (new SortField (\"nosuchfield\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random, 2, 8));\n    IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c8719b2c0b382be11f5b193b6fc14bc310e906b","date":1344770591,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","sourceNew":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n    \n    sort.setSort (new SortField (\"int\", SortField.Type.INT) );\n    assertMatches (full, queryF, sort, \"IZJ\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT, true) );\n    assertMatches (full, queryF, sort, \"JZI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort (new SortField (\"nosuchfield\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory(\"testEmptyFieldSort\"));\n    IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n    \n    sort.setSort (new SortField (\"int\", SortField.Type.INT) );\n    assertMatches (full, queryF, sort, \"IZJ\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT, true) );\n    assertMatches (full, queryF, sort, \"JZI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort (new SortField (\"nosuchfield\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8));\n    IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","sourceNew":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n    \n    sort.setSort (new SortField (\"int\", SortField.Type.INT) );\n    assertMatches (full, queryF, sort, \"IZJ\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT, true) );\n    assertMatches (full, queryF, sort, \"JZI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort (new SortField (\"nosuchfield\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory(\"testEmptyFieldSort\"));\n    IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n    \n    sort.setSort (new SortField (\"int\", SortField.Type.INT) );\n    assertMatches (full, queryF, sort, \"IZJ\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT, true) );\n    assertMatches (full, queryF, sort, \"JZI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort (new SortField (\"nosuchfield\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8));\n    IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","sourceNew":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n    \n    sort.setSort (new SortField (\"int\", SortField.Type.INT) );\n    assertMatches (full, queryF, sort, \"IZJ\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT, true) );\n    assertMatches (full, queryF, sort, \"JZI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort (new SortField (\"nosuchfield\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory(\"testEmptyFieldSort\"));\n    IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n    \n    sort.setSort (new SortField (\"int\", SortField.Type.INT) );\n    assertMatches (full, queryF, sort, \"IZJ\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT, true) );\n    assertMatches (full, queryF, sort, \"JZI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort (new SortField (\"nosuchfield\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8));\n    IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e29774db46ad98ca4a8d7fcbfab633ebc01f358","date":1355170812,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","sourceNew":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort(new SortField(\"string\", SortField.Type.STRING));\n    assertMatches(full, queryF, sort, \"ZJI\");\n\n    sort.setSort(new SortField(\"string\", SortField.Type.STRING, true));\n    assertMatches(full, queryF, sort, \"IJZ\");\n    \n    sort.setSort(new SortField(\"int\", SortField.Type.INT));\n    assertMatches(full, queryF, sort, \"IZJ\");\n\n    sort.setSort(new SortField(\"int\", SortField.Type.INT, true));\n    assertMatches(full, queryF, sort, \"JZI\");\n\n    sort.setSort(new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort(new SortField(\"nosuchfield\", SortField.Type.STRING),\n        new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(full, queryF, sort, \"ZJI\");\n\n    sort.setSort(new SortField(\"float\", SortField.Type.FLOAT, true));\n    assertMatches(full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n        new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n                 new SortField(\"float\", SortField.Type.FLOAT, true));\n    assertMatches(full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory(\"testEmptyFieldSort\"));\n    IndexSearcher parallelSearcher = new IndexSearcher(full.getIndexReader(), exec);\n\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n                 new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n                 new SortField(\"float\", SortField.Type.FLOAT, true));\n    assertMatches(parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n    \n    sort.setSort (new SortField (\"int\", SortField.Type.INT) );\n    assertMatches (full, queryF, sort, \"IZJ\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT, true) );\n    assertMatches (full, queryF, sort, \"JZI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort (new SortField (\"nosuchfield\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory(\"testEmptyFieldSort\"));\n    IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","sourceNew":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort(new SortField(\"string\", SortField.Type.STRING));\n    assertMatches(full, queryF, sort, \"ZJI\");\n\n    sort.setSort(new SortField(\"string\", SortField.Type.STRING, true));\n    assertMatches(full, queryF, sort, \"IJZ\");\n    \n    sort.setSort(new SortField(\"int\", SortField.Type.INT));\n    assertMatches(full, queryF, sort, \"IZJ\");\n\n    sort.setSort(new SortField(\"int\", SortField.Type.INT, true));\n    assertMatches(full, queryF, sort, \"JZI\");\n\n    sort.setSort(new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort(new SortField(\"nosuchfield\", SortField.Type.STRING),\n        new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(full, queryF, sort, \"ZJI\");\n\n    sort.setSort(new SortField(\"float\", SortField.Type.FLOAT, true));\n    assertMatches(full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n        new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n                 new SortField(\"float\", SortField.Type.FLOAT, true));\n    assertMatches(full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory(\"testEmptyFieldSort\"));\n    IndexSearcher parallelSearcher = new IndexSearcher(full.getIndexReader(), exec);\n\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n                 new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n                 new SortField(\"float\", SortField.Type.FLOAT, true));\n    assertMatches(parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"string\", SortField.Type.STRING, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n    \n    sort.setSort (new SortField (\"int\", SortField.Type.INT) );\n    assertMatches (full, queryF, sort, \"IZJ\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT, true) );\n    assertMatches (full, queryF, sort, \"JZI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort (new SortField (\"nosuchfield\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryF, sort, \"ZJI\");\n\n    sort.setSort (new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n        new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                                new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory(\"testEmptyFieldSort\"));\n    IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort (new SortField (\"int\", SortField.Type.INT),\n                  new SortField (\"string\", SortField.Type.STRING),\n                  new SortField (\"float\", SortField.Type.FLOAT, true) );\n    assertMatches (parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":["8b241ea5e635d896cc0af83cd96ffd0322e0aba7","090a0320e4de4a3674376aef96b9701f47564f86","63bc3238545c6012bd44f5d294077997f236bc4e","28088b0a688977b79dec2cc9119cff2fb4aab7ee"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f183729ece15402db94402d482f29ebac4f7f54","date":1360963151,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","sourceNew":null,"sourceOld":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort(new SortField(\"string\", SortField.Type.STRING));\n    assertMatches(full, queryF, sort, \"ZJI\");\n\n    sort.setSort(new SortField(\"string\", SortField.Type.STRING, true));\n    assertMatches(full, queryF, sort, \"IJZ\");\n    \n    sort.setSort(new SortField(\"int\", SortField.Type.INT));\n    assertMatches(full, queryF, sort, \"IZJ\");\n\n    sort.setSort(new SortField(\"int\", SortField.Type.INT, true));\n    assertMatches(full, queryF, sort, \"JZI\");\n\n    sort.setSort(new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort(new SortField(\"nosuchfield\", SortField.Type.STRING),\n        new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(full, queryF, sort, \"ZJI\");\n\n    sort.setSort(new SortField(\"float\", SortField.Type.FLOAT, true));\n    assertMatches(full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n        new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n                 new SortField(\"float\", SortField.Type.FLOAT, true));\n    assertMatches(full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory(\"testEmptyFieldSort\"));\n    IndexSearcher parallelSearcher = new IndexSearcher(full.getIndexReader(), exec);\n\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n                 new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n                 new SortField(\"float\", SortField.Type.FLOAT, true));\n    assertMatches(parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"95303ff3749680c743b9425f9cf99e6e4065e8a8","date":1361061922,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testEmptyFieldSort().mjava","sourceNew":null,"sourceOld":"  // test sorting when the sort field is empty (undefined) for some of the documents\n  public void testEmptyFieldSort() throws Exception {\n\n    // NOTE: do not test DocValues fields here, since you\n    // can't sort when some documents don't have the field\n    sort.setSort(new SortField(\"string\", SortField.Type.STRING));\n    assertMatches(full, queryF, sort, \"ZJI\");\n\n    sort.setSort(new SortField(\"string\", SortField.Type.STRING, true));\n    assertMatches(full, queryF, sort, \"IJZ\");\n    \n    sort.setSort(new SortField(\"int\", SortField.Type.INT));\n    assertMatches(full, queryF, sort, \"IZJ\");\n\n    sort.setSort(new SortField(\"int\", SortField.Type.INT, true));\n    assertMatches(full, queryF, sort, \"JZI\");\n\n    sort.setSort(new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(full, queryF, sort, \"ZJI\");\n\n    // using a nonexisting field as first sort key shouldn't make a difference:\n    sort.setSort(new SortField(\"nosuchfield\", SortField.Type.STRING),\n        new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(full, queryF, sort, \"ZJI\");\n\n    sort.setSort(new SortField(\"float\", SortField.Type.FLOAT, true));\n    assertMatches(full, queryF, sort, \"IJZ\");\n\n    // When a field is null for both documents, the next SortField should be used.\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n        new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(full, queryG, sort, \"ZWXY\");\n\n    // Reverse the last criterium to make sure the test didn't pass by chance\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n                 new SortField(\"float\", SortField.Type.FLOAT, true));\n    assertMatches(full, queryG, sort, \"ZYXW\");\n\n    // Do the same for a ParallelMultiSearcher\n    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory(\"testEmptyFieldSort\"));\n    IndexSearcher parallelSearcher = new IndexSearcher(full.getIndexReader(), exec);\n\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n                 new SortField(\"float\", SortField.Type.FLOAT));\n    assertMatches(parallelSearcher, queryG, sort, \"ZWXY\");\n\n    sort.setSort(new SortField(\"int\", SortField.Type.INT),\n                 new SortField(\"string\", SortField.Type.STRING),\n                 new SortField(\"float\", SortField.Type.FLOAT, true));\n    assertMatches(parallelSearcher, queryG, sort, \"ZYXW\");\n    exec.shutdown();\n    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5f183729ece15402db94402d482f29ebac4f7f54":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["1c8719b2c0b382be11f5b193b6fc14bc310e906b","3e29774db46ad98ca4a8d7fcbfab633ebc01f358"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":["d4d69c535930b5cce125cff868d40f6373dc27d4","5f183729ece15402db94402d482f29ebac4f7f54"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3e29774db46ad98ca4a8d7fcbfab633ebc01f358":["1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5f183729ece15402db94402d482f29ebac4f7f54"],"1c8719b2c0b382be11f5b193b6fc14bc310e906b":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"]},"commit2Childs":{"5f183729ece15402db94402d482f29ebac4f7f54":["95303ff3749680c743b9425f9cf99e6e4065e8a8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"d4d69c535930b5cce125cff868d40f6373dc27d4":["5f183729ece15402db94402d482f29ebac4f7f54","95303ff3749680c743b9425f9cf99e6e4065e8a8"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"3e29774db46ad98ca4a8d7fcbfab633ebc01f358":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":[],"1c8719b2c0b382be11f5b193b6fc14bc310e906b":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d4d69c535930b5cce125cff868d40f6373dc27d4","3e29774db46ad98ca4a8d7fcbfab633ebc01f358","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c7869f64c874ebf7f317d22c00baf2b6857797a6","95303ff3749680c743b9425f9cf99e6e4065e8a8","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}