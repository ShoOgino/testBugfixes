{"path":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#doCheckMaxScores(Random,Query,IndexSearcher).mjava","commits":[{"id":"523cc6563c99a55527ef7993efc5413c6648852d","date":1518704038,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#doCheckMaxScores(Random,Query,IndexSearcher).mjava","pathOld":"/dev/null","sourceNew":"  private static void doCheckMaxScores(Random random, Query query, IndexSearcher searcher) throws IOException {\n    Weight w1 = searcher.createNormalizedWeight(query, ScoreMode.COMPLETE);\n    Weight w2 = searcher.createNormalizedWeight(query, ScoreMode.TOP_SCORES);\n\n    // Check boundaries and max scores when iterating all matches\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n      int upTo = -1;\n      float maxScore = 0;\n      float minScore = 0;\n      for (int doc2 = approx2.nextDoc(); ; doc2 = approx2.nextDoc()) {\n        int doc1;\n        for (doc1 = approx1.nextDoc(); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        Assert.assertEquals(doc1, doc2);\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (doc2 > upTo) {\n          upTo = s2.advanceShallow(doc2);\n          Assert.assertTrue(upTo >= doc2);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n\n    // Now check advancing\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n\n      int upTo = -1;\n      float minScore = 0;\n      float maxScore = 0;\n      while (true) {\n        int doc2 = s2.docID();\n        boolean advance;\n        int target;\n        if (random.nextBoolean()) {\n          advance = false;\n          target = doc2 + 1;\n        } else {\n          advance = true;\n          int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc2);\n          target = s2.docID() + delta;\n        }\n\n        if (target > upTo && random.nextBoolean()) {\n          int delta = Math.min(random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - target);\n          upTo = target + delta;\n          int m = s2.advanceShallow(target);\n          assertTrue(m >= target);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (advance) {\n          doc2 = approx2.advance(target);\n        } else {\n          doc2 = approx2.nextDoc();\n        }\n\n        int doc1;\n        for (doc1 = approx1.advance(target); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        assertEquals(doc1, doc2);\n\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n\n          if (doc2 > upTo) {\n            upTo = s2.advanceShallow(doc2);\n            Assert.assertTrue(upTo >= doc2);\n            maxScore = s2.getMaxScore(upTo);\n          }\n\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"475584d5e08a22ad3fc7babefe006d77bc744567","date":1523282824,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#doCheckMaxScores(Random,Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#doCheckMaxScores(Random,Query,IndexSearcher).mjava","sourceNew":"  private static void doCheckMaxScores(Random random, Query query, IndexSearcher searcher) throws IOException {\n    query = searcher.rewrite(query);\n    Weight w1 = searcher.createWeight(query, ScoreMode.COMPLETE, 1);\n    Weight w2 = searcher.createWeight(query, ScoreMode.TOP_SCORES, 1);\n\n    // Check boundaries and max scores when iterating all matches\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n      int upTo = -1;\n      float maxScore = 0;\n      float minScore = 0;\n      for (int doc2 = approx2.nextDoc(); ; doc2 = approx2.nextDoc()) {\n        int doc1;\n        for (doc1 = approx1.nextDoc(); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        Assert.assertEquals(doc1, doc2);\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (doc2 > upTo) {\n          upTo = s2.advanceShallow(doc2);\n          Assert.assertTrue(upTo >= doc2);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n\n    // Now check advancing\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n\n      int upTo = -1;\n      float minScore = 0;\n      float maxScore = 0;\n      while (true) {\n        int doc2 = s2.docID();\n        boolean advance;\n        int target;\n        if (random.nextBoolean()) {\n          advance = false;\n          target = doc2 + 1;\n        } else {\n          advance = true;\n          int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc2);\n          target = s2.docID() + delta;\n        }\n\n        if (target > upTo && random.nextBoolean()) {\n          int delta = Math.min(random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - target);\n          upTo = target + delta;\n          int m = s2.advanceShallow(target);\n          assertTrue(m >= target);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (advance) {\n          doc2 = approx2.advance(target);\n        } else {\n          doc2 = approx2.nextDoc();\n        }\n\n        int doc1;\n        for (doc1 = approx1.advance(target); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        assertEquals(doc1, doc2);\n\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n\n          if (doc2 > upTo) {\n            upTo = s2.advanceShallow(doc2);\n            Assert.assertTrue(upTo >= doc2);\n            maxScore = s2.getMaxScore(upTo);\n          }\n\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private static void doCheckMaxScores(Random random, Query query, IndexSearcher searcher) throws IOException {\n    Weight w1 = searcher.createNormalizedWeight(query, ScoreMode.COMPLETE);\n    Weight w2 = searcher.createNormalizedWeight(query, ScoreMode.TOP_SCORES);\n\n    // Check boundaries and max scores when iterating all matches\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n      int upTo = -1;\n      float maxScore = 0;\n      float minScore = 0;\n      for (int doc2 = approx2.nextDoc(); ; doc2 = approx2.nextDoc()) {\n        int doc1;\n        for (doc1 = approx1.nextDoc(); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        Assert.assertEquals(doc1, doc2);\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (doc2 > upTo) {\n          upTo = s2.advanceShallow(doc2);\n          Assert.assertTrue(upTo >= doc2);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n\n    // Now check advancing\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n\n      int upTo = -1;\n      float minScore = 0;\n      float maxScore = 0;\n      while (true) {\n        int doc2 = s2.docID();\n        boolean advance;\n        int target;\n        if (random.nextBoolean()) {\n          advance = false;\n          target = doc2 + 1;\n        } else {\n          advance = true;\n          int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc2);\n          target = s2.docID() + delta;\n        }\n\n        if (target > upTo && random.nextBoolean()) {\n          int delta = Math.min(random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - target);\n          upTo = target + delta;\n          int m = s2.advanceShallow(target);\n          assertTrue(m >= target);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (advance) {\n          doc2 = approx2.advance(target);\n        } else {\n          doc2 = approx2.nextDoc();\n        }\n\n        int doc1;\n        for (doc1 = approx1.advance(target); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        assertEquals(doc1, doc2);\n\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n\n          if (doc2 > upTo) {\n            upTo = s2.advanceShallow(doc2);\n            Assert.assertTrue(upTo >= doc2);\n            maxScore = s2.getMaxScore(upTo);\n          }\n\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58e44159788900f4a2113b84463dc3fbbf80f20","date":1523319203,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#doCheckMaxScores(Random,Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#doCheckMaxScores(Random,Query,IndexSearcher).mjava","sourceNew":"  private static void doCheckMaxScores(Random random, Query query, IndexSearcher searcher) throws IOException {\n    query = searcher.rewrite(query);\n    Weight w1 = searcher.createWeight(query, ScoreMode.COMPLETE, 1);\n    Weight w2 = searcher.createWeight(query, ScoreMode.TOP_SCORES, 1);\n\n    // Check boundaries and max scores when iterating all matches\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n      int upTo = -1;\n      float maxScore = 0;\n      float minScore = 0;\n      for (int doc2 = approx2.nextDoc(); ; doc2 = approx2.nextDoc()) {\n        int doc1;\n        for (doc1 = approx1.nextDoc(); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        Assert.assertEquals(doc1, doc2);\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (doc2 > upTo) {\n          upTo = s2.advanceShallow(doc2);\n          Assert.assertTrue(upTo >= doc2);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n\n    // Now check advancing\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n\n      int upTo = -1;\n      float minScore = 0;\n      float maxScore = 0;\n      while (true) {\n        int doc2 = s2.docID();\n        boolean advance;\n        int target;\n        if (random.nextBoolean()) {\n          advance = false;\n          target = doc2 + 1;\n        } else {\n          advance = true;\n          int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc2);\n          target = s2.docID() + delta;\n        }\n\n        if (target > upTo && random.nextBoolean()) {\n          int delta = Math.min(random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - target);\n          upTo = target + delta;\n          int m = s2.advanceShallow(target);\n          assertTrue(m >= target);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (advance) {\n          doc2 = approx2.advance(target);\n        } else {\n          doc2 = approx2.nextDoc();\n        }\n\n        int doc1;\n        for (doc1 = approx1.advance(target); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        assertEquals(doc1, doc2);\n\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n\n          if (doc2 > upTo) {\n            upTo = s2.advanceShallow(doc2);\n            Assert.assertTrue(upTo >= doc2);\n            maxScore = s2.getMaxScore(upTo);\n          }\n\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private static void doCheckMaxScores(Random random, Query query, IndexSearcher searcher) throws IOException {\n    Weight w1 = searcher.createNormalizedWeight(query, ScoreMode.COMPLETE);\n    Weight w2 = searcher.createNormalizedWeight(query, ScoreMode.TOP_SCORES);\n\n    // Check boundaries and max scores when iterating all matches\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n      int upTo = -1;\n      float maxScore = 0;\n      float minScore = 0;\n      for (int doc2 = approx2.nextDoc(); ; doc2 = approx2.nextDoc()) {\n        int doc1;\n        for (doc1 = approx1.nextDoc(); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        Assert.assertEquals(doc1, doc2);\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (doc2 > upTo) {\n          upTo = s2.advanceShallow(doc2);\n          Assert.assertTrue(upTo >= doc2);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n\n    // Now check advancing\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n\n      int upTo = -1;\n      float minScore = 0;\n      float maxScore = 0;\n      while (true) {\n        int doc2 = s2.docID();\n        boolean advance;\n        int target;\n        if (random.nextBoolean()) {\n          advance = false;\n          target = doc2 + 1;\n        } else {\n          advance = true;\n          int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc2);\n          target = s2.docID() + delta;\n        }\n\n        if (target > upTo && random.nextBoolean()) {\n          int delta = Math.min(random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - target);\n          upTo = target + delta;\n          int m = s2.advanceShallow(target);\n          assertTrue(m >= target);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (advance) {\n          doc2 = approx2.advance(target);\n        } else {\n          doc2 = approx2.nextDoc();\n        }\n\n        int doc1;\n        for (doc1 = approx1.advance(target); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        assertEquals(doc1, doc2);\n\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n\n          if (doc2 > upTo) {\n            upTo = s2.advanceShallow(doc2);\n            Assert.assertTrue(upTo >= doc2);\n            maxScore = s2.getMaxScore(upTo);\n          }\n\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a692be6c8e120ef6dbfcd5dde3de42815813cd2","date":1525265372,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#doCheckMaxScores(Random,Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#doCheckMaxScores(Random,Query,IndexSearcher).mjava","sourceNew":"  private static void doCheckMaxScores(Random random, Query query, IndexSearcher searcher) throws IOException {\n    query = searcher.rewrite(query);\n    Weight w1 = searcher.createWeight(query, ScoreMode.COMPLETE, 1);\n    Weight w2 = searcher.createWeight(query, ScoreMode.TOP_SCORES, 1);\n\n    // Check boundaries and max scores when iterating all matches\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n      int upTo = -1;\n      float maxScore = 0;\n      float minScore = 0;\n      for (int doc2 = approx2.nextDoc(); ; doc2 = approx2.nextDoc()) {\n        int doc1;\n        for (doc1 = approx1.nextDoc(); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        Assert.assertEquals(doc1, doc2);\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (doc2 > upTo) {\n          upTo = s2.advanceShallow(doc2);\n          Assert.assertTrue(upTo >= doc2);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n          Assert.assertTrue(score + \" > \" + maxScore + \" up to \" + upTo, score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n\n    // Now check advancing\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n\n      int upTo = -1;\n      float minScore = 0;\n      float maxScore = 0;\n      while (true) {\n        int doc2 = s2.docID();\n        boolean advance;\n        int target;\n        if (random.nextBoolean()) {\n          advance = false;\n          target = doc2 + 1;\n        } else {\n          advance = true;\n          int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc2);\n          target = s2.docID() + delta;\n        }\n\n        if (target > upTo && random.nextBoolean()) {\n          int delta = Math.min(random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - target);\n          upTo = target + delta;\n          int m = s2.advanceShallow(target);\n          assertTrue(m >= target);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (advance) {\n          doc2 = approx2.advance(target);\n        } else {\n          doc2 = approx2.nextDoc();\n        }\n\n        int doc1;\n        for (doc1 = approx1.advance(target); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        assertEquals(doc1, doc2);\n\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n\n          if (doc2 > upTo) {\n            upTo = s2.advanceShallow(doc2);\n            Assert.assertTrue(upTo >= doc2);\n            maxScore = s2.getMaxScore(upTo);\n          }\n\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private static void doCheckMaxScores(Random random, Query query, IndexSearcher searcher) throws IOException {\n    query = searcher.rewrite(query);\n    Weight w1 = searcher.createWeight(query, ScoreMode.COMPLETE, 1);\n    Weight w2 = searcher.createWeight(query, ScoreMode.TOP_SCORES, 1);\n\n    // Check boundaries and max scores when iterating all matches\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n      int upTo = -1;\n      float maxScore = 0;\n      float minScore = 0;\n      for (int doc2 = approx2.nextDoc(); ; doc2 = approx2.nextDoc()) {\n        int doc1;\n        for (doc1 = approx1.nextDoc(); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        Assert.assertEquals(doc1, doc2);\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (doc2 > upTo) {\n          upTo = s2.advanceShallow(doc2);\n          Assert.assertTrue(upTo >= doc2);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n\n    // Now check advancing\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n\n      int upTo = -1;\n      float minScore = 0;\n      float maxScore = 0;\n      while (true) {\n        int doc2 = s2.docID();\n        boolean advance;\n        int target;\n        if (random.nextBoolean()) {\n          advance = false;\n          target = doc2 + 1;\n        } else {\n          advance = true;\n          int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc2);\n          target = s2.docID() + delta;\n        }\n\n        if (target > upTo && random.nextBoolean()) {\n          int delta = Math.min(random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - target);\n          upTo = target + delta;\n          int m = s2.advanceShallow(target);\n          assertTrue(m >= target);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (advance) {\n          doc2 = approx2.advance(target);\n        } else {\n          doc2 = approx2.nextDoc();\n        }\n\n        int doc1;\n        for (doc1 = approx1.advance(target); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        assertEquals(doc1, doc2);\n\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n\n          if (doc2 > upTo) {\n            upTo = s2.advanceShallow(doc2);\n            Assert.assertTrue(upTo >= doc2);\n            maxScore = s2.getMaxScore(upTo);\n          }\n\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#doCheckMaxScores(Random,Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#doCheckMaxScores(Random,Query,IndexSearcher).mjava","sourceNew":"  private static void doCheckMaxScores(Random random, Query query, IndexSearcher searcher) throws IOException {\n    query = searcher.rewrite(query);\n    Weight w1 = searcher.createWeight(query, ScoreMode.COMPLETE, 1);\n    Weight w2 = searcher.createWeight(query, ScoreMode.TOP_SCORES, 1);\n\n    // Check boundaries and max scores when iterating all matches\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n      int upTo = -1;\n      float maxScore = 0;\n      float minScore = 0;\n      for (int doc2 = approx2.nextDoc(); ; doc2 = approx2.nextDoc()) {\n        int doc1;\n        for (doc1 = approx1.nextDoc(); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            assertTrue(s1.score() < minScore);\n          }\n        }\n        assertEquals(doc1, doc2);\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (doc2 > upTo) {\n          upTo = s2.advanceShallow(doc2);\n          assertTrue(upTo >= doc2);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          assertEquals(s1.score(), score, 0);\n          assertTrue(score + \" > \" + maxScore + \" up to \" + upTo, score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n\n    // Now check advancing\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n\n      int upTo = -1;\n      float minScore = 0;\n      float maxScore = 0;\n      while (true) {\n        int doc2 = s2.docID();\n        boolean advance;\n        int target;\n        if (random.nextBoolean()) {\n          advance = false;\n          target = doc2 + 1;\n        } else {\n          advance = true;\n          int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc2);\n          target = s2.docID() + delta;\n        }\n\n        if (target > upTo && random.nextBoolean()) {\n          int delta = Math.min(random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - target);\n          upTo = target + delta;\n          int m = s2.advanceShallow(target);\n          assertTrue(m >= target);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (advance) {\n          doc2 = approx2.advance(target);\n        } else {\n          doc2 = approx2.nextDoc();\n        }\n\n        int doc1;\n        for (doc1 = approx1.advance(target); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            assertTrue(s1.score() < minScore);\n          }\n        }\n        assertEquals(doc1, doc2);\n\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          assertEquals(s1.score(), score, 0);\n\n          if (doc2 > upTo) {\n            upTo = s2.advanceShallow(doc2);\n            assertTrue(upTo >= doc2);\n            maxScore = s2.getMaxScore(upTo);\n          }\n\n          assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private static void doCheckMaxScores(Random random, Query query, IndexSearcher searcher) throws IOException {\n    query = searcher.rewrite(query);\n    Weight w1 = searcher.createWeight(query, ScoreMode.COMPLETE, 1);\n    Weight w2 = searcher.createWeight(query, ScoreMode.TOP_SCORES, 1);\n\n    // Check boundaries and max scores when iterating all matches\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n      int upTo = -1;\n      float maxScore = 0;\n      float minScore = 0;\n      for (int doc2 = approx2.nextDoc(); ; doc2 = approx2.nextDoc()) {\n        int doc1;\n        for (doc1 = approx1.nextDoc(); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        Assert.assertEquals(doc1, doc2);\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (doc2 > upTo) {\n          upTo = s2.advanceShallow(doc2);\n          Assert.assertTrue(upTo >= doc2);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n          Assert.assertTrue(score + \" > \" + maxScore + \" up to \" + upTo, score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n\n    // Now check advancing\n    for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {\n      Scorer s1 = w1.scorer(ctx);\n      Scorer s2 = w2.scorer(ctx);\n      if (s1 == null) {\n        Assert.assertTrue(s2 == null || s2.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);\n        continue;\n      }\n      TwoPhaseIterator twoPhase1 = s1.twoPhaseIterator();\n      TwoPhaseIterator twoPhase2 = s2.twoPhaseIterator();\n      DocIdSetIterator approx1 = twoPhase1 == null ? s1.iterator() : twoPhase1.approximation;\n      DocIdSetIterator approx2 = twoPhase2 == null ? s2.iterator() : twoPhase2.approximation;\n\n      int upTo = -1;\n      float minScore = 0;\n      float maxScore = 0;\n      while (true) {\n        int doc2 = s2.docID();\n        boolean advance;\n        int target;\n        if (random.nextBoolean()) {\n          advance = false;\n          target = doc2 + 1;\n        } else {\n          advance = true;\n          int delta = Math.min(1 + random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - doc2);\n          target = s2.docID() + delta;\n        }\n\n        if (target > upTo && random.nextBoolean()) {\n          int delta = Math.min(random.nextInt(512), DocIdSetIterator.NO_MORE_DOCS - target);\n          upTo = target + delta;\n          int m = s2.advanceShallow(target);\n          assertTrue(m >= target);\n          maxScore = s2.getMaxScore(upTo);\n        }\n\n        if (advance) {\n          doc2 = approx2.advance(target);\n        } else {\n          doc2 = approx2.nextDoc();\n        }\n\n        int doc1;\n        for (doc1 = approx1.advance(target); doc1 < doc2; doc1 = approx1.nextDoc()) {\n          if (twoPhase1 == null || twoPhase1.matches()) {\n            Assert.assertTrue(s1.score() < minScore);\n          }\n        }\n        assertEquals(doc1, doc2);\n\n        if (doc2 == DocIdSetIterator.NO_MORE_DOCS) {\n          break;\n        }\n\n        if (twoPhase2 == null || twoPhase2.matches()) {\n          Assert.assertTrue(twoPhase1 == null || twoPhase1.matches());\n          float score = s2.score();\n          Assert.assertEquals(s1.score(), score);\n\n          if (doc2 > upTo) {\n            upTo = s2.advanceShallow(doc2);\n            Assert.assertTrue(upTo >= doc2);\n            maxScore = s2.getMaxScore(upTo);\n          }\n\n          Assert.assertTrue(score <= maxScore);\n\n          if (score >= minScore && random.nextInt(10) == 0) {\n            // On some scorers, changing the min score changes the way that docs are iterated\n            minScore = score;\n            s2.setMinCompetitiveScore(minScore);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d58e44159788900f4a2113b84463dc3fbbf80f20":["523cc6563c99a55527ef7993efc5413c6648852d","475584d5e08a22ad3fc7babefe006d77bc744567"],"475584d5e08a22ad3fc7babefe006d77bc744567":["523cc6563c99a55527ef7993efc5413c6648852d"],"6a692be6c8e120ef6dbfcd5dde3de42815813cd2":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["6a692be6c8e120ef6dbfcd5dde3de42815813cd2"],"523cc6563c99a55527ef7993efc5413c6648852d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"]},"commit2Childs":{"d58e44159788900f4a2113b84463dc3fbbf80f20":["6a692be6c8e120ef6dbfcd5dde3de42815813cd2"],"475584d5e08a22ad3fc7babefe006d77bc744567":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"6a692be6c8e120ef6dbfcd5dde3de42815813cd2":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["523cc6563c99a55527ef7993efc5413c6648852d"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"523cc6563c99a55527ef7993efc5413c6648852d":["d58e44159788900f4a2113b84463dc3fbbf80f20","475584d5e08a22ad3fc7babefe006d77bc744567"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}