{"path":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","commits":[{"id":"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe","date":1459623422,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","sourceNew":"  private static Polygon surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2","date":1460953142,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","sourceNew":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"713122036535651642e6d4fe57ce12b449e18473","date":1461000510,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","sourceNew":"  private static Polygon surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = nextLatitude();\n      double centerLon = nextLongitude();\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":"  private static Polygon surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"713122036535651642e6d4fe57ce12b449e18473":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe","3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["713122036535651642e6d4fe57ce12b449e18473"]},"commit2Childs":{"713122036535651642e6d4fe57ce12b449e18473":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["713122036535651642e6d4fe57ce12b449e18473","3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2"],"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2":["713122036535651642e6d4fe57ce12b449e18473"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}