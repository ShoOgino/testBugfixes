{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/DocRouter#partitionRange(int,Range,float).mjava","commits":[{"id":"7cac1f2920f8057198f04505797cbabf74dd9a97","date":1546884894,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocRouter#partitionRange(int,Range,float).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Split the range into partitions with inexact sizes.\n   * @param partitions number of partitions\n   * @param range range to split\n   * @param fuzz value between 0 (inclusive) and 0.5 (exclusive) indicating inexact split, i.e. percentage\n   *        of variation in resulting ranges - odd ranges will be larger and even ranges will be smaller\n   *        by up to that percentage.\n   */\n  public List<Range> partitionRange(int partitions, Range range, float fuzz) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (fuzz > 0.5f) {\n      throw new IllegalArgumentException(\"'fuzz' parameter must be <= 0.5f but was \" + fuzz);\n    } else if (fuzz < 0.0f) {\n      fuzz = 0.0f;\n    }\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n    long fuzzStep = Math.round(rangeStep * (double)fuzz / 2.0);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n    boolean odd = true;\n\n    while (end < max) {\n      end = start + rangeStep;\n      if (fuzzStep > 0) {\n        if (odd) {\n          end = end + fuzzStep;\n        } else {\n          end = end - fuzzStep;\n        }\n        odd = !odd;\n      }\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7dfea4f7c80813344b0152e37fc18b31369e8ff","date":1592136683,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocRouter#partitionRange(int,Range,float).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocRouter#partitionRange(int,Range,float).mjava","sourceNew":"  /**\n   * Split the range into partitions with inexact sizes.\n   * @param partitions number of partitions\n   * @param range range to split\n   * @param fuzz value between 0 (inclusive) and 0.5 (exclusive) indicating inexact split, i.e. percentage\n   *        of variation in resulting ranges - odd ranges will be larger and even ranges will be smaller\n   *        by up to that percentage.\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public List<Range> partitionRange(int partitions, Range range, float fuzz) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (fuzz > 0.5f) {\n      throw new IllegalArgumentException(\"'fuzz' parameter must be <= 0.5f but was \" + fuzz);\n    } else if (fuzz < 0.0f) {\n      fuzz = 0.0f;\n    }\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n    long fuzzStep = Math.round(rangeStep * (double)fuzz / 2.0);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n    boolean odd = true;\n\n    while (end < max) {\n      end = start + rangeStep;\n      if (fuzzStep > 0) {\n        if (odd) {\n          end = end + fuzzStep;\n        } else {\n          end = end - fuzzStep;\n        }\n        odd = !odd;\n      }\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n\n","sourceOld":"  /**\n   * Split the range into partitions with inexact sizes.\n   * @param partitions number of partitions\n   * @param range range to split\n   * @param fuzz value between 0 (inclusive) and 0.5 (exclusive) indicating inexact split, i.e. percentage\n   *        of variation in resulting ranges - odd ranges will be larger and even ranges will be smaller\n   *        by up to that percentage.\n   */\n  public List<Range> partitionRange(int partitions, Range range, float fuzz) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (fuzz > 0.5f) {\n      throw new IllegalArgumentException(\"'fuzz' parameter must be <= 0.5f but was \" + fuzz);\n    } else if (fuzz < 0.0f) {\n      fuzz = 0.0f;\n    }\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n    long fuzzStep = Math.round(rangeStep * (double)fuzz / 2.0);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n    boolean odd = true;\n\n    while (end < max) {\n      end = start + rangeStep;\n      if (fuzzStep > 0) {\n        if (odd) {\n          end = end + fuzzStep;\n        } else {\n          end = end - fuzzStep;\n        }\n        odd = !odd;\n      }\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3adc4d119a7deba35b2721853853464857d9d0a9","date":1594608068,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocRouter#partitionRange(int,Range,float).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocRouter#partitionRange(int,Range,float).mjava","sourceNew":"  /**\n   * Split the range into partitions with inexact sizes.\n   * @param partitions number of partitions\n   * @param range range to split\n   * @param fuzz value between 0 (inclusive) and 0.5 (exclusive) indicating inexact split, i.e. percentage\n   *        of variation in resulting ranges - odd ranges will be larger and even ranges will be smaller\n   *        by up to that percentage.\n   */\n  public List<Range> partitionRange(int partitions, Range range, float fuzz) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (fuzz > 0.5f) {\n      throw new IllegalArgumentException(\"'fuzz' parameter must be <= 0.5f but was \" + fuzz);\n    } else if (fuzz < 0.0f) {\n      fuzz = 0.0f;\n    }\n    if (partitions == 0) return Collections.emptyList();\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n    long fuzzStep = Math.round(rangeStep * (double)fuzz / 2.0);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n    boolean odd = true;\n\n    while (end < max) {\n      end = start + rangeStep;\n      if (fuzzStep > 0) {\n        if (odd) {\n          end = end + fuzzStep;\n        } else {\n          end = end - fuzzStep;\n        }\n        odd = !odd;\n      }\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n\n","sourceOld":"  /**\n   * Split the range into partitions with inexact sizes.\n   * @param partitions number of partitions\n   * @param range range to split\n   * @param fuzz value between 0 (inclusive) and 0.5 (exclusive) indicating inexact split, i.e. percentage\n   *        of variation in resulting ranges - odd ranges will be larger and even ranges will be smaller\n   *        by up to that percentage.\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public List<Range> partitionRange(int partitions, Range range, float fuzz) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (fuzz > 0.5f) {\n      throw new IllegalArgumentException(\"'fuzz' parameter must be <= 0.5f but was \" + fuzz);\n    } else if (fuzz < 0.0f) {\n      fuzz = 0.0f;\n    }\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n    long fuzzStep = Math.round(rangeStep * (double)fuzz / 2.0);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n    boolean odd = true;\n\n    while (end < max) {\n      end = start + rangeStep;\n      if (fuzzStep > 0) {\n        if (odd) {\n          end = end + fuzzStep;\n        } else {\n          end = end - fuzzStep;\n        }\n        odd = !odd;\n      }\n      // make last range always end exactly on MAX_VALUE\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7cac1f2920f8057198f04505797cbabf74dd9a97":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3adc4d119a7deba35b2721853853464857d9d0a9":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["7cac1f2920f8057198f04505797cbabf74dd9a97"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3adc4d119a7deba35b2721853853464857d9d0a9"]},"commit2Childs":{"7cac1f2920f8057198f04505797cbabf74dd9a97":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"],"3adc4d119a7deba35b2721853853464857d9d0a9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7cac1f2920f8057198f04505797cbabf74dd9a97"],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["3adc4d119a7deba35b2721853853464857d9d0a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}