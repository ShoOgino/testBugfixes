{"path":"lucene/core/src/java/org/apache/lucene/util/compress/LZ4.HighCompressionHashTable#get(int).mjava","commits":[{"id":"9407318969e8504257b4c5764c65755a043e5404","date":1579873617,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/compress/LZ4.HighCompressionHashTable#get(int).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    int get(int off) {\n      assert off > next;\n      assert off < end;\n\n      for (; next < off; next++) {\n        addHash(next);\n      }\n\n      final int v = readInt(bytes, off);\n      final int h = hashHC(v);\n\n      attempts = 0;\n      int ref = hashTable[h];\n      if (ref >= off) {\n        // remainder from a previous call to compress()\n        return -1;\n      }\n      for (int min = Math.max(base, off - MAX_DISTANCE + 1);\n          ref >= min && attempts < MAX_ATTEMPTS;\n          ref -= chainTable[ref & MASK] & 0xFFFF, attempts++) {\n        if (readInt(bytes, ref) == v) {\n          return ref;\n        }\n      }\n      return -1;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9aefce86de8b17eed91ab011fb54d704d91102ef","date":1599128224,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/compress/LZ4.HighCompressionHashTable#get(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/compress/LZ4.HighCompressionHashTable#get(int).mjava","sourceNew":"    @Override\n    int get(int off) {\n      assert off >= next;\n      assert off < end;\n\n      for (; next < off; next++) {\n        addHash(next);\n      }\n\n      final int v = readInt(bytes, off);\n      final int h = hashHC(v);\n\n      attempts = 0;\n      int ref = hashTable[h];\n      if (ref >= off) {\n        // remainder from a previous call to compress()\n        return -1;\n      }\n      for (int min = Math.max(base, off - MAX_DISTANCE + 1);\n          ref >= min && attempts < MAX_ATTEMPTS;\n          ref -= chainTable[ref & MASK] & 0xFFFF, attempts++) {\n        if (readInt(bytes, ref) == v) {\n          return ref;\n        }\n      }\n      return -1;\n    }\n\n","sourceOld":"    @Override\n    int get(int off) {\n      assert off > next;\n      assert off < end;\n\n      for (; next < off; next++) {\n        addHash(next);\n      }\n\n      final int v = readInt(bytes, off);\n      final int h = hashHC(v);\n\n      attempts = 0;\n      int ref = hashTable[h];\n      if (ref >= off) {\n        // remainder from a previous call to compress()\n        return -1;\n      }\n      for (int min = Math.max(base, off - MAX_DISTANCE + 1);\n          ref >= min && attempts < MAX_ATTEMPTS;\n          ref -= chainTable[ref & MASK] & 0xFFFF, attempts++) {\n        if (readInt(bytes, ref) == v) {\n          return ref;\n        }\n      }\n      return -1;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9aefce86de8b17eed91ab011fb54d704d91102ef":["9407318969e8504257b4c5764c65755a043e5404"],"9407318969e8504257b4c5764c65755a043e5404":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9aefce86de8b17eed91ab011fb54d704d91102ef"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9407318969e8504257b4c5764c65755a043e5404"],"9aefce86de8b17eed91ab011fb54d704d91102ef":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9407318969e8504257b4c5764c65755a043e5404":["9aefce86de8b17eed91ab011fb54d704d91102ef"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}