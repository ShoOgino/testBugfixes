{"path":"lucene/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","commits":[{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    DocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    DocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c99bc7b4d9f186ec629b191eeef99bc1ac4e1612","date":1327859675,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    DocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8493985e6883b3fa8231d172694d2aa3a85cb182","date":1327920390,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    DocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"8493985e6883b3fa8231d172694d2aa3a85cb182":["c99bc7b4d9f186ec629b191eeef99bc1ac4e1612"],"c99bc7b4d9f186ec629b191eeef99bc1ac4e1612":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["a0ae5e3ed1232483b7b8a014f175a5fe43595982","8493985e6883b3fa8231d172694d2aa3a85cb182"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"8493985e6883b3fa8231d172694d2aa3a85cb182":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"c99bc7b4d9f186ec629b191eeef99bc1ac4e1612":["8493985e6883b3fa8231d172694d2aa3a85cb182"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["c99bc7b4d9f186ec629b191eeef99bc1ac4e1612","5cab9a86bd67202d20b6adc463008c8e982b070a"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}