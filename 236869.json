{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testCloseDuringCommit().mjava","commits":[{"id":"5ea6955c7bfffe05682ad0a667afb2a6fa85e9da","date":1408027865,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testCloseDuringCommit().mjava","pathOld":"/dev/null","sourceNew":"  /** Make sure that close waits for any still-running commits. */\n  public void testCloseDuringCommit() throws Exception {\n\n    final CountDownLatch startCommit = new CountDownLatch(1);\n    final CountDownLatch finishCommit = new CountDownLatch(1);\n\n    // infostream that \"takes a long time\" to commit\n    InfoStream slowCommittingInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (message.equals(\"finishStartCommit\")) {\n          startCommit.countDown();\n          try {\n            Thread.sleep(10);\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(slowCommittingInfoStream);\n    final IndexWriter iw = new IndexWriter(dir, iwc);\n    Document doc = new Document();\n    new Thread() {\n      @Override\n      public void run() {\n        try {\n          iw.commit();\n          finishCommit.countDown();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n      }\n    }.start();\n    startCommit.await();\n    try {\n      iw.close();\n      fail(\"didn't hit exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n    finishCommit.await();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a3f71c2eba7602f47ed1d28362b47d29a8d5d08","date":1408034000,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testCloseDuringCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testCloseDuringCommit().mjava","sourceNew":"  /** Make sure that close waits for any still-running commits. */\n  public void testCloseDuringCommit() throws Exception {\n\n    final CountDownLatch startCommit = new CountDownLatch(1);\n    final CountDownLatch finishCommit = new CountDownLatch(1);\n\n    // infostream that \"takes a long time\" to commit\n    InfoStream slowCommittingInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (message.equals(\"finishStartCommit\")) {\n          startCommit.countDown();\n          try {\n            Thread.sleep(10);\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(slowCommittingInfoStream);\n    final IndexWriter iw = new IndexWriter(dir, iwc);\n    Document doc = new Document();\n    new Thread() {\n      @Override\n      public void run() {\n        try {\n          iw.commit();\n          finishCommit.countDown();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n      }\n    }.start();\n    startCommit.await();\n    try {\n      iw.close();\n    } catch (IllegalStateException ise) {\n      // OK, but not required (depends on thread scheduling)\n    }\n    finishCommit.await();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure that close waits for any still-running commits. */\n  public void testCloseDuringCommit() throws Exception {\n\n    final CountDownLatch startCommit = new CountDownLatch(1);\n    final CountDownLatch finishCommit = new CountDownLatch(1);\n\n    // infostream that \"takes a long time\" to commit\n    InfoStream slowCommittingInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (message.equals(\"finishStartCommit\")) {\n          startCommit.countDown();\n          try {\n            Thread.sleep(10);\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(slowCommittingInfoStream);\n    final IndexWriter iw = new IndexWriter(dir, iwc);\n    Document doc = new Document();\n    new Thread() {\n      @Override\n      public void run() {\n        try {\n          iw.commit();\n          finishCommit.countDown();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n      }\n    }.start();\n    startCommit.await();\n    try {\n      iw.close();\n      fail(\"didn't hit exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n    finishCommit.await();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19f6ad6759fbc831a41372e6b2b1303fbccd52b","date":1410985754,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testCloseDuringCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testCloseDuringCommit().mjava","sourceNew":"  /** Make sure that close waits for any still-running commits. */\n  public void testCloseDuringCommit() throws Exception {\n\n    final CountDownLatch startCommit = new CountDownLatch(1);\n    final CountDownLatch finishCommit = new CountDownLatch(1);\n\n    // infostream that \"takes a long time\" to commit\n    InfoStream slowCommittingInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (message.equals(\"finishStartCommit\")) {\n          startCommit.countDown();\n          try {\n            Thread.sleep(10);\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(slowCommittingInfoStream);\n    final IndexWriter iw = new IndexWriter(dir, iwc);\n    new Thread() {\n      @Override\n      public void run() {\n        try {\n          iw.commit();\n          finishCommit.countDown();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n      }\n    }.start();\n    startCommit.await();\n    try {\n      iw.close();\n    } catch (IllegalStateException ise) {\n      // OK, but not required (depends on thread scheduling)\n    }\n    finishCommit.await();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure that close waits for any still-running commits. */\n  public void testCloseDuringCommit() throws Exception {\n\n    final CountDownLatch startCommit = new CountDownLatch(1);\n    final CountDownLatch finishCommit = new CountDownLatch(1);\n\n    // infostream that \"takes a long time\" to commit\n    InfoStream slowCommittingInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (message.equals(\"finishStartCommit\")) {\n          startCommit.countDown();\n          try {\n            Thread.sleep(10);\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(slowCommittingInfoStream);\n    final IndexWriter iw = new IndexWriter(dir, iwc);\n    Document doc = new Document();\n    new Thread() {\n      @Override\n      public void run() {\n        try {\n          iw.commit();\n          finishCommit.countDown();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n      }\n    }.start();\n    startCommit.await();\n    try {\n      iw.close();\n    } catch (IllegalStateException ise) {\n      // OK, but not required (depends on thread scheduling)\n    }\n    finishCommit.await();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2165505a28a4f836f04ed5eb23bc64a6faae1b1e","date":1418824313,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testCloseDuringCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testCloseDuringCommit().mjava","sourceNew":"  /** Make sure that close waits for any still-running commits. */\n  public void testCloseDuringCommit() throws Exception {\n\n    final CountDownLatch startCommit = new CountDownLatch(1);\n    final CountDownLatch finishCommit = new CountDownLatch(1);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    // use an infostream that \"takes a long time\" to commit\n    final IndexWriter iw = RandomIndexWriter.mockIndexWriter(dir, iwc, new RandomIndexWriter.TestPoint() {\n      @Override\n      public void apply(String message) {\n        if (message.equals(\"finishStartCommit\")) {\n          startCommit.countDown();\n          try {\n            Thread.sleep(10);\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n      }\n    });\n    new Thread() {\n      @Override\n      public void run() {\n        try {\n          iw.commit();\n          finishCommit.countDown();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n      }\n    }.start();\n    startCommit.await();\n    try {\n      iw.close();\n    } catch (IllegalStateException ise) {\n      // OK, but not required (depends on thread scheduling)\n    }\n    finishCommit.await();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure that close waits for any still-running commits. */\n  public void testCloseDuringCommit() throws Exception {\n\n    final CountDownLatch startCommit = new CountDownLatch(1);\n    final CountDownLatch finishCommit = new CountDownLatch(1);\n\n    // infostream that \"takes a long time\" to commit\n    InfoStream slowCommittingInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (message.equals(\"finishStartCommit\")) {\n          startCommit.countDown();\n          try {\n            Thread.sleep(10);\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(slowCommittingInfoStream);\n    final IndexWriter iw = new IndexWriter(dir, iwc);\n    new Thread() {\n      @Override\n      public void run() {\n        try {\n          iw.commit();\n          finishCommit.countDown();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n      }\n    }.start();\n    startCommit.await();\n    try {\n      iw.close();\n    } catch (IllegalStateException ise) {\n      // OK, but not required (depends on thread scheduling)\n    }\n    finishCommit.await();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6b82a3644db30161c3cbd3e23aeefe19cb88113","date":1435478870,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testCloseDuringCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testCloseDuringCommit().mjava","sourceNew":"  /** Make sure that close waits for any still-running commits. */\n  public void testCloseDuringCommit() throws Exception {\n\n    final CountDownLatch startCommit = new CountDownLatch(1);\n    final CountDownLatch finishCommit = new CountDownLatch(1);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    // use an infostream that \"takes a long time\" to commit\n    final IndexWriter iw = RandomIndexWriter.mockIndexWriter(random(), dir, iwc, new RandomIndexWriter.TestPoint() {\n      @Override\n      public void apply(String message) {\n        if (message.equals(\"finishStartCommit\")) {\n          startCommit.countDown();\n          try {\n            Thread.sleep(10);\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n      }\n    });\n    new Thread() {\n      @Override\n      public void run() {\n        try {\n          iw.commit();\n          finishCommit.countDown();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n      }\n    }.start();\n    startCommit.await();\n    try {\n      iw.close();\n    } catch (IllegalStateException ise) {\n      // OK, but not required (depends on thread scheduling)\n    }\n    finishCommit.await();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure that close waits for any still-running commits. */\n  public void testCloseDuringCommit() throws Exception {\n\n    final CountDownLatch startCommit = new CountDownLatch(1);\n    final CountDownLatch finishCommit = new CountDownLatch(1);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    // use an infostream that \"takes a long time\" to commit\n    final IndexWriter iw = RandomIndexWriter.mockIndexWriter(dir, iwc, new RandomIndexWriter.TestPoint() {\n      @Override\n      public void apply(String message) {\n        if (message.equals(\"finishStartCommit\")) {\n          startCommit.countDown();\n          try {\n            Thread.sleep(10);\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n      }\n    });\n    new Thread() {\n      @Override\n      public void run() {\n        try {\n          iw.commit();\n          finishCommit.countDown();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n      }\n    }.start();\n    startCommit.await();\n    try {\n      iw.close();\n    } catch (IllegalStateException ise) {\n      // OK, but not required (depends on thread scheduling)\n    }\n    finishCommit.await();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7a3f71c2eba7602f47ed1d28362b47d29a8d5d08":["5ea6955c7bfffe05682ad0a667afb2a6fa85e9da"],"5ea6955c7bfffe05682ad0a667afb2a6fa85e9da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a6b82a3644db30161c3cbd3e23aeefe19cb88113":["2165505a28a4f836f04ed5eb23bc64a6faae1b1e"],"e19f6ad6759fbc831a41372e6b2b1303fbccd52b":["7a3f71c2eba7602f47ed1d28362b47d29a8d5d08"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a6b82a3644db30161c3cbd3e23aeefe19cb88113"],"2165505a28a4f836f04ed5eb23bc64a6faae1b1e":["e19f6ad6759fbc831a41372e6b2b1303fbccd52b"]},"commit2Childs":{"7a3f71c2eba7602f47ed1d28362b47d29a8d5d08":["e19f6ad6759fbc831a41372e6b2b1303fbccd52b"],"5ea6955c7bfffe05682ad0a667afb2a6fa85e9da":["7a3f71c2eba7602f47ed1d28362b47d29a8d5d08"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5ea6955c7bfffe05682ad0a667afb2a6fa85e9da"],"a6b82a3644db30161c3cbd3e23aeefe19cb88113":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e19f6ad6759fbc831a41372e6b2b1303fbccd52b":["2165505a28a4f836f04ed5eb23bc64a6faae1b1e"],"2165505a28a4f836f04ed5eb23bc64a6faae1b1e":["a6b82a3644db30161c3cbd3e23aeefe19cb88113"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}