{"path":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","commits":[{"id":"01f60198ece724a6e96cd0b45f289cf42ff83d4f","date":1286864103,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues,\n      Values value, List<Values> valueVarList, boolean withDeletions,\n      int multOfSeven) throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Fieldable field = random.nextBoolean()? new ValuesField(value.name()):newField(value.name(), _TestUtil.randomRealisticUnicodeString(random, 10), IDX_VALUES[random.nextInt(IDX_VALUES.length)]);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    // \n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n    \n    // nocommit test unoptimized with deletions\n    if(withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["fa0f44f887719e97183771e977cfc4bfb485b766","fa0f44f887719e97183771e977cfc4bfb485b766","fa0f44f887719e97183771e977cfc4bfb485b766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e28c49f1fb6215a550fdadcf3805aa629b63ec0","date":1288081775,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), IDX_VALUES[random.nextInt(IDX_VALUES.length)]);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    // \n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n\n    // nocommit test unoptimized with deletions\n    if (true || withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues,\n      Values value, List<Values> valueVarList, boolean withDeletions,\n      int multOfSeven) throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Fieldable field = random.nextBoolean()? new ValuesField(value.name()):newField(value.name(), _TestUtil.randomRealisticUnicodeString(random, 10), IDX_VALUES[random.nextInt(IDX_VALUES.length)]);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    // \n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n    \n    // nocommit test unoptimized with deletions\n    if(withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"39f3757037aa8f710c0cbf9a76a332de735f58b0","date":1288384416,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    // \n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      ;\n    w.optimize();\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), IDX_VALUES[random.nextInt(IDX_VALUES.length)]);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    // \n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n\n    // nocommit test unoptimized with deletions\n    if (true || withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0637f89202e27b25802435a9cf789fc0890c8a67","date":1288436161,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    // \n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    // \n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      ;\n    w.optimize();\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b5c559c875836474bafae7243263d93b1b1965db","date":1289581659,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    // \n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    // \n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"39f3757037aa8f710c0cbf9a76a332de735f58b0":["0e28c49f1fb6215a550fdadcf3805aa629b63ec0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0637f89202e27b25802435a9cf789fc0890c8a67":["39f3757037aa8f710c0cbf9a76a332de735f58b0"],"0e28c49f1fb6215a550fdadcf3805aa629b63ec0":["01f60198ece724a6e96cd0b45f289cf42ff83d4f"],"01f60198ece724a6e96cd0b45f289cf42ff83d4f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b5c559c875836474bafae7243263d93b1b1965db":["0637f89202e27b25802435a9cf789fc0890c8a67"]},"commit2Childs":{"39f3757037aa8f710c0cbf9a76a332de735f58b0":["0637f89202e27b25802435a9cf789fc0890c8a67"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["01f60198ece724a6e96cd0b45f289cf42ff83d4f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0e28c49f1fb6215a550fdadcf3805aa629b63ec0":["39f3757037aa8f710c0cbf9a76a332de735f58b0"],"0637f89202e27b25802435a9cf789fc0890c8a67":["b5c559c875836474bafae7243263d93b1b1965db"],"01f60198ece724a6e96cd0b45f289cf42ff83d4f":["0e28c49f1fb6215a550fdadcf3805aa629b63ec0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b5c559c875836474bafae7243263d93b1b1965db":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b5c559c875836474bafae7243263d93b1b1965db"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}