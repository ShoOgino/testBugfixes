{"path":"lucene/contrib/misc/src/test/org/apache/lucene/index/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","commits":[{"id":"76364fe9e16e51702b00a59a9ae3ed0646080deb","date":1320780791,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/contrib/misc/src/test/org/apache/lucene/index/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"df16fc2e9b615e0138edac46655ae628f5d098ad","date":1320876869,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/index/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"df16fc2e9b615e0138edac46655ae628f5d098ad":["76364fe9e16e51702b00a59a9ae3ed0646080deb"],"76364fe9e16e51702b00a59a9ae3ed0646080deb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["df16fc2e9b615e0138edac46655ae628f5d098ad"]},"commit2Childs":{"df16fc2e9b615e0138edac46655ae628f5d098ad":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"76364fe9e16e51702b00a59a9ae3ed0646080deb":["df16fc2e9b615e0138edac46655ae628f5d098ad"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["76364fe9e16e51702b00a59a9ae3ed0646080deb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}