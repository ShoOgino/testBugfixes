{"path":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","commits":[{"id":"3470ed04f0378c1ceb02e540e3296dd27c0ae3d5","date":1552136881,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","pathOld":"/dev/null","sourceNew":"  public void getColStatus(NamedList<Object> results) {\n    Collection<String> collections;\n    String col = props.getStr(ZkStateReader.COLLECTION_PROP);\n    if (col == null) {\n      collections = new HashSet<>(clusterState.getCollectionsMap().keySet());\n    } else {\n      collections = Collections.singleton(col);\n    }\n    boolean withFieldInfo = props.getBool(FIELD_INFO_PROP, false);\n    boolean withSegments = props.getBool(SEGMENTS_PROP, false);\n    boolean withCoreInfo = props.getBool(CORE_INFO_PROP, false);\n    boolean withSizeInfo = props.getBool(SIZE_INFO_PROP, false);\n    if (withFieldInfo || withSizeInfo) {\n      withSegments = true;\n    }\n    for (String collection : collections) {\n      DocCollection coll = clusterState.getCollectionOrNull(collection);\n      if (coll == null) {\n        continue;\n      }\n      SimpleOrderedMap<Object> colMap = new SimpleOrderedMap<>();\n      colMap.add(\"stateFormat\", coll.getStateFormat());\n      colMap.add(\"znodeVersion\", coll.getZNodeVersion());\n      Map<String, Object> props = new TreeMap<>(coll.getProperties());\n      props.remove(\"shards\");\n      colMap.add(\"properties\", props);\n      colMap.add(\"activeShards\", coll.getActiveSlices().size());\n      colMap.add(\"inactiveShards\", coll.getSlices().size() - coll.getActiveSlices().size());\n      results.add(collection, colMap);\n\n      Set<String> nonCompliant = new TreeSet<>();\n\n      SimpleOrderedMap<Object> shards = new SimpleOrderedMap<>();\n      for (Slice s : coll.getSlices()) {\n        SimpleOrderedMap<Object> sliceMap = new SimpleOrderedMap<>();\n        shards.add(s.getName(), sliceMap);\n        SimpleOrderedMap<Object> replicaMap = new SimpleOrderedMap<>();\n        int totalReplicas = s.getReplicas().size();\n        int activeReplicas = 0;\n        int downReplicas = 0;\n        int recoveringReplicas = 0;\n        int recoveryFailedReplicas = 0;\n        for (Replica r : s.getReplicas()) {\n          switch (r.getState()) {\n            case ACTIVE:\n              activeReplicas++;\n              break;\n            case DOWN:\n              downReplicas++;\n              break;\n            case RECOVERING:\n              recoveringReplicas++;\n              break;\n            case RECOVERY_FAILED:\n              recoveryFailedReplicas++;\n              break;\n          }\n        }\n        replicaMap.add(\"total\", totalReplicas);\n        replicaMap.add(\"active\", activeReplicas);\n        replicaMap.add(\"down\", downReplicas);\n        replicaMap.add(\"recovering\", recoveringReplicas);\n        replicaMap.add(\"recovery_failed\", recoveryFailedReplicas);\n        sliceMap.add(\"state\", s.getState().toString());\n        sliceMap.add(\"range\", s.getRange().toString());\n        Map<String, RoutingRule> rules = s.getRoutingRules();\n        if (rules != null && !rules.isEmpty()) {\n          sliceMap.add(\"routingRules\", rules);\n        }\n        sliceMap.add(\"replicas\", replicaMap);\n        Replica leader = s.getLeader();\n        if (leader == null) { // pick the first one\n          leader = s.getReplicas().size() > 0 ? s.getReplicas().iterator().next() : null;\n        }\n        if (leader == null) {\n          continue;\n        }\n        SimpleOrderedMap<Object> leaderMap = new SimpleOrderedMap<>();\n        sliceMap.add(\"leader\", leaderMap);\n        leaderMap.add(\"coreNode\", leader.getName());\n        leaderMap.addAll(leader.getProperties());\n        String url = ZkCoreNodeProps.getCoreUrl(leader);\n        try (SolrClient client = solrClientCache.getHttpSolrClient(url)) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.add(CommonParams.QT, \"/admin/segments\");\n          params.add(FIELD_INFO_PROP, \"true\");\n          params.add(CORE_INFO_PROP, String.valueOf(withCoreInfo));\n          params.add(SIZE_INFO_PROP, String.valueOf(withSizeInfo));\n          QueryRequest req = new QueryRequest(params);\n          NamedList<Object> rsp = client.request(req);\n          rsp.remove(\"responseHeader\");\n          leaderMap.add(\"segInfos\", rsp);\n          NamedList<Object> segs = (NamedList<Object>)rsp.get(\"segments\");\n          if (segs != null) {\n            for (Map.Entry<String, Object> entry : segs) {\n              NamedList<Object> fields = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"fields\");\n              if (fields != null) {\n                for (Map.Entry<String, Object> fEntry : fields) {\n                  Object nc = ((NamedList<Object>)fEntry.getValue()).get(\"nonCompliant\");\n                  if (nc != null) {\n                    nonCompliant.add(fEntry.getKey());\n                  }\n                }\n              }\n              if (!withFieldInfo) {\n                ((NamedList<Object>)entry.getValue()).remove(\"fields\");\n              }\n            }\n          }\n          if (!withSegments) {\n            rsp.remove(\"segments\");\n          }\n          if (!withFieldInfo) {\n            rsp.remove(\"fieldInfoLegend\");\n          }\n        } catch (SolrServerException | IOException e) {\n          log.warn(\"Error getting details of replica segments from \" + url, e);\n        }\n      }\n      if (nonCompliant.isEmpty()) {\n        nonCompliant.add(\"(NONE)\");\n      }\n      colMap.add(\"schemaNonCompliant\", nonCompliant);\n      colMap.add(\"shards\", shards);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dad6a48950aafc9c2f5dc54740f8c6ab81304203","date":1552999379,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","sourceNew":"  public void getColStatus(NamedList<Object> results) {\n    Collection<String> collections;\n    String col = props.getStr(ZkStateReader.COLLECTION_PROP);\n    if (col == null) {\n      collections = new HashSet<>(clusterState.getCollectionsMap().keySet());\n    } else {\n      collections = Collections.singleton(col);\n    }\n    boolean withFieldInfo = props.getBool(FIELD_INFO_PROP, false);\n    boolean withSegments = props.getBool(SEGMENTS_PROP, false);\n    boolean withCoreInfo = props.getBool(CORE_INFO_PROP, false);\n    boolean withSizeInfo = props.getBool(SIZE_INFO_PROP, false);\n    if (withFieldInfo || withSizeInfo) {\n      withSegments = true;\n    }\n    for (String collection : collections) {\n      DocCollection coll = clusterState.getCollectionOrNull(collection);\n      if (coll == null) {\n        continue;\n      }\n      SimpleOrderedMap<Object> colMap = new SimpleOrderedMap<>();\n      colMap.add(\"stateFormat\", coll.getStateFormat());\n      colMap.add(\"znodeVersion\", coll.getZNodeVersion());\n      Map<String, Object> props = new TreeMap<>(coll.getProperties());\n      props.remove(\"shards\");\n      colMap.add(\"properties\", props);\n      colMap.add(\"activeShards\", coll.getActiveSlices().size());\n      colMap.add(\"inactiveShards\", coll.getSlices().size() - coll.getActiveSlices().size());\n      results.add(collection, colMap);\n\n      Set<String> nonCompliant = new TreeSet<>();\n\n      SimpleOrderedMap<Object> shards = new SimpleOrderedMap<>();\n      for (Slice s : coll.getSlices()) {\n        SimpleOrderedMap<Object> sliceMap = new SimpleOrderedMap<>();\n        shards.add(s.getName(), sliceMap);\n        SimpleOrderedMap<Object> replicaMap = new SimpleOrderedMap<>();\n        int totalReplicas = s.getReplicas().size();\n        int activeReplicas = 0;\n        int downReplicas = 0;\n        int recoveringReplicas = 0;\n        int recoveryFailedReplicas = 0;\n        for (Replica r : s.getReplicas()) {\n          switch (r.getState()) {\n            case ACTIVE:\n              activeReplicas++;\n              break;\n            case DOWN:\n              downReplicas++;\n              break;\n            case RECOVERING:\n              recoveringReplicas++;\n              break;\n            case RECOVERY_FAILED:\n              recoveryFailedReplicas++;\n              break;\n          }\n        }\n        replicaMap.add(\"total\", totalReplicas);\n        replicaMap.add(\"active\", activeReplicas);\n        replicaMap.add(\"down\", downReplicas);\n        replicaMap.add(\"recovering\", recoveringReplicas);\n        replicaMap.add(\"recovery_failed\", recoveryFailedReplicas);\n        sliceMap.add(\"state\", s.getState().toString());\n        sliceMap.add(\"range\", s.getRange().toString());\n        Map<String, RoutingRule> rules = s.getRoutingRules();\n        if (rules != null && !rules.isEmpty()) {\n          sliceMap.add(\"routingRules\", rules);\n        }\n        sliceMap.add(\"replicas\", replicaMap);\n        Replica leader = s.getLeader();\n        if (leader == null) { // pick the first one\n          leader = s.getReplicas().size() > 0 ? s.getReplicas().iterator().next() : null;\n        }\n        if (leader == null) {\n          continue;\n        }\n        SimpleOrderedMap<Object> leaderMap = new SimpleOrderedMap<>();\n        sliceMap.add(\"leader\", leaderMap);\n        leaderMap.add(\"coreNode\", leader.getName());\n        leaderMap.addAll(leader.getProperties());\n        if (!leader.isActive(clusterState.getLiveNodes())) {\n          continue;\n        }\n        String url = ZkCoreNodeProps.getCoreUrl(leader);\n        try (SolrClient client = solrClientCache.getHttpSolrClient(url)) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.add(CommonParams.QT, \"/admin/segments\");\n          params.add(FIELD_INFO_PROP, \"true\");\n          params.add(CORE_INFO_PROP, String.valueOf(withCoreInfo));\n          params.add(SIZE_INFO_PROP, String.valueOf(withSizeInfo));\n          QueryRequest req = new QueryRequest(params);\n          NamedList<Object> rsp = client.request(req);\n          rsp.remove(\"responseHeader\");\n          leaderMap.add(\"segInfos\", rsp);\n          NamedList<Object> segs = (NamedList<Object>)rsp.get(\"segments\");\n          if (segs != null) {\n            for (Map.Entry<String, Object> entry : segs) {\n              NamedList<Object> fields = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"fields\");\n              if (fields != null) {\n                for (Map.Entry<String, Object> fEntry : fields) {\n                  Object nc = ((NamedList<Object>)fEntry.getValue()).get(\"nonCompliant\");\n                  if (nc != null) {\n                    nonCompliant.add(fEntry.getKey());\n                  }\n                }\n              }\n              if (!withFieldInfo) {\n                ((NamedList<Object>)entry.getValue()).remove(\"fields\");\n              }\n            }\n          }\n          if (!withSegments) {\n            rsp.remove(\"segments\");\n          }\n          if (!withFieldInfo) {\n            rsp.remove(\"fieldInfoLegend\");\n          }\n        } catch (SolrServerException | IOException e) {\n          log.warn(\"Error getting details of replica segments from \" + url, e);\n        }\n      }\n      if (nonCompliant.isEmpty()) {\n        nonCompliant.add(\"(NONE)\");\n      }\n      colMap.add(\"schemaNonCompliant\", nonCompliant);\n      colMap.add(\"shards\", shards);\n    }\n  }\n\n","sourceOld":"  public void getColStatus(NamedList<Object> results) {\n    Collection<String> collections;\n    String col = props.getStr(ZkStateReader.COLLECTION_PROP);\n    if (col == null) {\n      collections = new HashSet<>(clusterState.getCollectionsMap().keySet());\n    } else {\n      collections = Collections.singleton(col);\n    }\n    boolean withFieldInfo = props.getBool(FIELD_INFO_PROP, false);\n    boolean withSegments = props.getBool(SEGMENTS_PROP, false);\n    boolean withCoreInfo = props.getBool(CORE_INFO_PROP, false);\n    boolean withSizeInfo = props.getBool(SIZE_INFO_PROP, false);\n    if (withFieldInfo || withSizeInfo) {\n      withSegments = true;\n    }\n    for (String collection : collections) {\n      DocCollection coll = clusterState.getCollectionOrNull(collection);\n      if (coll == null) {\n        continue;\n      }\n      SimpleOrderedMap<Object> colMap = new SimpleOrderedMap<>();\n      colMap.add(\"stateFormat\", coll.getStateFormat());\n      colMap.add(\"znodeVersion\", coll.getZNodeVersion());\n      Map<String, Object> props = new TreeMap<>(coll.getProperties());\n      props.remove(\"shards\");\n      colMap.add(\"properties\", props);\n      colMap.add(\"activeShards\", coll.getActiveSlices().size());\n      colMap.add(\"inactiveShards\", coll.getSlices().size() - coll.getActiveSlices().size());\n      results.add(collection, colMap);\n\n      Set<String> nonCompliant = new TreeSet<>();\n\n      SimpleOrderedMap<Object> shards = new SimpleOrderedMap<>();\n      for (Slice s : coll.getSlices()) {\n        SimpleOrderedMap<Object> sliceMap = new SimpleOrderedMap<>();\n        shards.add(s.getName(), sliceMap);\n        SimpleOrderedMap<Object> replicaMap = new SimpleOrderedMap<>();\n        int totalReplicas = s.getReplicas().size();\n        int activeReplicas = 0;\n        int downReplicas = 0;\n        int recoveringReplicas = 0;\n        int recoveryFailedReplicas = 0;\n        for (Replica r : s.getReplicas()) {\n          switch (r.getState()) {\n            case ACTIVE:\n              activeReplicas++;\n              break;\n            case DOWN:\n              downReplicas++;\n              break;\n            case RECOVERING:\n              recoveringReplicas++;\n              break;\n            case RECOVERY_FAILED:\n              recoveryFailedReplicas++;\n              break;\n          }\n        }\n        replicaMap.add(\"total\", totalReplicas);\n        replicaMap.add(\"active\", activeReplicas);\n        replicaMap.add(\"down\", downReplicas);\n        replicaMap.add(\"recovering\", recoveringReplicas);\n        replicaMap.add(\"recovery_failed\", recoveryFailedReplicas);\n        sliceMap.add(\"state\", s.getState().toString());\n        sliceMap.add(\"range\", s.getRange().toString());\n        Map<String, RoutingRule> rules = s.getRoutingRules();\n        if (rules != null && !rules.isEmpty()) {\n          sliceMap.add(\"routingRules\", rules);\n        }\n        sliceMap.add(\"replicas\", replicaMap);\n        Replica leader = s.getLeader();\n        if (leader == null) { // pick the first one\n          leader = s.getReplicas().size() > 0 ? s.getReplicas().iterator().next() : null;\n        }\n        if (leader == null) {\n          continue;\n        }\n        SimpleOrderedMap<Object> leaderMap = new SimpleOrderedMap<>();\n        sliceMap.add(\"leader\", leaderMap);\n        leaderMap.add(\"coreNode\", leader.getName());\n        leaderMap.addAll(leader.getProperties());\n        String url = ZkCoreNodeProps.getCoreUrl(leader);\n        try (SolrClient client = solrClientCache.getHttpSolrClient(url)) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.add(CommonParams.QT, \"/admin/segments\");\n          params.add(FIELD_INFO_PROP, \"true\");\n          params.add(CORE_INFO_PROP, String.valueOf(withCoreInfo));\n          params.add(SIZE_INFO_PROP, String.valueOf(withSizeInfo));\n          QueryRequest req = new QueryRequest(params);\n          NamedList<Object> rsp = client.request(req);\n          rsp.remove(\"responseHeader\");\n          leaderMap.add(\"segInfos\", rsp);\n          NamedList<Object> segs = (NamedList<Object>)rsp.get(\"segments\");\n          if (segs != null) {\n            for (Map.Entry<String, Object> entry : segs) {\n              NamedList<Object> fields = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"fields\");\n              if (fields != null) {\n                for (Map.Entry<String, Object> fEntry : fields) {\n                  Object nc = ((NamedList<Object>)fEntry.getValue()).get(\"nonCompliant\");\n                  if (nc != null) {\n                    nonCompliant.add(fEntry.getKey());\n                  }\n                }\n              }\n              if (!withFieldInfo) {\n                ((NamedList<Object>)entry.getValue()).remove(\"fields\");\n              }\n            }\n          }\n          if (!withSegments) {\n            rsp.remove(\"segments\");\n          }\n          if (!withFieldInfo) {\n            rsp.remove(\"fieldInfoLegend\");\n          }\n        } catch (SolrServerException | IOException e) {\n          log.warn(\"Error getting details of replica segments from \" + url, e);\n        }\n      }\n      if (nonCompliant.isEmpty()) {\n        nonCompliant.add(\"(NONE)\");\n      }\n      colMap.add(\"schemaNonCompliant\", nonCompliant);\n      colMap.add(\"shards\", shards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e4583dbd381e291c87e23144564c59ba3391b188","date":1560187306,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","sourceNew":"  public void getColStatus(NamedList<Object> results) {\n    Collection<String> collections;\n    String col = props.getStr(ZkStateReader.COLLECTION_PROP);\n    if (col == null) {\n      collections = new HashSet<>(clusterState.getCollectionsMap().keySet());\n    } else {\n      collections = Collections.singleton(col);\n    }\n    boolean withFieldInfo = props.getBool(FIELD_INFO_PROP, false);\n    boolean withSegments = props.getBool(SEGMENTS_PROP, false);\n    boolean withCoreInfo = props.getBool(CORE_INFO_PROP, false);\n    boolean withSizeInfo = props.getBool(SIZE_INFO_PROP, false);\n    boolean withRawSizeInfo = props.getBool(RAW_SIZE_PROP, false);\n    boolean withRawSizeSummary = props.getBool(RAW_SIZE_SUMMARY_PROP, false);\n    boolean withRawSizeDetails = props.getBool(RAW_SIZE_DETAILS_PROP, false);\n    Object samplingPercentVal = props.get(RAW_SIZE_SAMPLING_PERCENT_PROP);\n    Float samplingPercent = samplingPercentVal != null ? Float.parseFloat(String.valueOf(samplingPercentVal)) : null;\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo = true;\n    }\n    if (withFieldInfo || withSizeInfo) {\n      withSegments = true;\n    }\n    for (String collection : collections) {\n      DocCollection coll = clusterState.getCollectionOrNull(collection);\n      if (coll == null) {\n        continue;\n      }\n      SimpleOrderedMap<Object> colMap = new SimpleOrderedMap<>();\n      colMap.add(\"stateFormat\", coll.getStateFormat());\n      colMap.add(\"znodeVersion\", coll.getZNodeVersion());\n      Map<String, Object> props = new TreeMap<>(coll.getProperties());\n      props.remove(\"shards\");\n      colMap.add(\"properties\", props);\n      colMap.add(\"activeShards\", coll.getActiveSlices().size());\n      colMap.add(\"inactiveShards\", coll.getSlices().size() - coll.getActiveSlices().size());\n      results.add(collection, colMap);\n\n      Set<String> nonCompliant = new TreeSet<>();\n\n      SimpleOrderedMap<Object> shards = new SimpleOrderedMap<>();\n      for (Slice s : coll.getSlices()) {\n        SimpleOrderedMap<Object> sliceMap = new SimpleOrderedMap<>();\n        shards.add(s.getName(), sliceMap);\n        SimpleOrderedMap<Object> replicaMap = new SimpleOrderedMap<>();\n        int totalReplicas = s.getReplicas().size();\n        int activeReplicas = 0;\n        int downReplicas = 0;\n        int recoveringReplicas = 0;\n        int recoveryFailedReplicas = 0;\n        for (Replica r : s.getReplicas()) {\n          switch (r.getState()) {\n            case ACTIVE:\n              activeReplicas++;\n              break;\n            case DOWN:\n              downReplicas++;\n              break;\n            case RECOVERING:\n              recoveringReplicas++;\n              break;\n            case RECOVERY_FAILED:\n              recoveryFailedReplicas++;\n              break;\n          }\n        }\n        replicaMap.add(\"total\", totalReplicas);\n        replicaMap.add(\"active\", activeReplicas);\n        replicaMap.add(\"down\", downReplicas);\n        replicaMap.add(\"recovering\", recoveringReplicas);\n        replicaMap.add(\"recovery_failed\", recoveryFailedReplicas);\n        sliceMap.add(\"state\", s.getState().toString());\n        sliceMap.add(\"range\", s.getRange().toString());\n        Map<String, RoutingRule> rules = s.getRoutingRules();\n        if (rules != null && !rules.isEmpty()) {\n          sliceMap.add(\"routingRules\", rules);\n        }\n        sliceMap.add(\"replicas\", replicaMap);\n        Replica leader = s.getLeader();\n        if (leader == null) { // pick the first one\n          leader = s.getReplicas().size() > 0 ? s.getReplicas().iterator().next() : null;\n        }\n        if (leader == null) {\n          continue;\n        }\n        SimpleOrderedMap<Object> leaderMap = new SimpleOrderedMap<>();\n        sliceMap.add(\"leader\", leaderMap);\n        leaderMap.add(\"coreNode\", leader.getName());\n        leaderMap.addAll(leader.getProperties());\n        if (!leader.isActive(clusterState.getLiveNodes())) {\n          continue;\n        }\n        String url = ZkCoreNodeProps.getCoreUrl(leader);\n        try (SolrClient client = solrClientCache.getHttpSolrClient(url)) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.add(CommonParams.QT, \"/admin/segments\");\n          params.add(FIELD_INFO_PROP, \"true\");\n          params.add(CORE_INFO_PROP, String.valueOf(withCoreInfo));\n          params.add(SIZE_INFO_PROP, String.valueOf(withSizeInfo));\n          params.add(RAW_SIZE_PROP, String.valueOf(withRawSizeInfo));\n          params.add(RAW_SIZE_SUMMARY_PROP, String.valueOf(withRawSizeSummary));\n          params.add(RAW_SIZE_DETAILS_PROP, String.valueOf(withRawSizeDetails));\n          if (samplingPercent != null) {\n            params.add(RAW_SIZE_SAMPLING_PERCENT_PROP, String.valueOf(samplingPercent));\n          }\n          QueryRequest req = new QueryRequest(params);\n          NamedList<Object> rsp = client.request(req);\n          rsp.remove(\"responseHeader\");\n          leaderMap.add(\"segInfos\", rsp);\n          NamedList<Object> segs = (NamedList<Object>)rsp.get(\"segments\");\n          if (segs != null) {\n            for (Map.Entry<String, Object> entry : segs) {\n              NamedList<Object> fields = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"fields\");\n              if (fields != null) {\n                for (Map.Entry<String, Object> fEntry : fields) {\n                  Object nc = ((NamedList<Object>)fEntry.getValue()).get(\"nonCompliant\");\n                  if (nc != null) {\n                    nonCompliant.add(fEntry.getKey());\n                  }\n                }\n              }\n              if (!withFieldInfo) {\n                ((NamedList<Object>)entry.getValue()).remove(\"fields\");\n              }\n            }\n          }\n          if (!withSegments) {\n            rsp.remove(\"segments\");\n          }\n          if (!withFieldInfo) {\n            rsp.remove(\"fieldInfoLegend\");\n          }\n        } catch (SolrServerException | IOException e) {\n          log.warn(\"Error getting details of replica segments from \" + url, e);\n        }\n      }\n      if (nonCompliant.isEmpty()) {\n        nonCompliant.add(\"(NONE)\");\n      }\n      colMap.add(\"schemaNonCompliant\", nonCompliant);\n      colMap.add(\"shards\", shards);\n    }\n  }\n\n","sourceOld":"  public void getColStatus(NamedList<Object> results) {\n    Collection<String> collections;\n    String col = props.getStr(ZkStateReader.COLLECTION_PROP);\n    if (col == null) {\n      collections = new HashSet<>(clusterState.getCollectionsMap().keySet());\n    } else {\n      collections = Collections.singleton(col);\n    }\n    boolean withFieldInfo = props.getBool(FIELD_INFO_PROP, false);\n    boolean withSegments = props.getBool(SEGMENTS_PROP, false);\n    boolean withCoreInfo = props.getBool(CORE_INFO_PROP, false);\n    boolean withSizeInfo = props.getBool(SIZE_INFO_PROP, false);\n    if (withFieldInfo || withSizeInfo) {\n      withSegments = true;\n    }\n    for (String collection : collections) {\n      DocCollection coll = clusterState.getCollectionOrNull(collection);\n      if (coll == null) {\n        continue;\n      }\n      SimpleOrderedMap<Object> colMap = new SimpleOrderedMap<>();\n      colMap.add(\"stateFormat\", coll.getStateFormat());\n      colMap.add(\"znodeVersion\", coll.getZNodeVersion());\n      Map<String, Object> props = new TreeMap<>(coll.getProperties());\n      props.remove(\"shards\");\n      colMap.add(\"properties\", props);\n      colMap.add(\"activeShards\", coll.getActiveSlices().size());\n      colMap.add(\"inactiveShards\", coll.getSlices().size() - coll.getActiveSlices().size());\n      results.add(collection, colMap);\n\n      Set<String> nonCompliant = new TreeSet<>();\n\n      SimpleOrderedMap<Object> shards = new SimpleOrderedMap<>();\n      for (Slice s : coll.getSlices()) {\n        SimpleOrderedMap<Object> sliceMap = new SimpleOrderedMap<>();\n        shards.add(s.getName(), sliceMap);\n        SimpleOrderedMap<Object> replicaMap = new SimpleOrderedMap<>();\n        int totalReplicas = s.getReplicas().size();\n        int activeReplicas = 0;\n        int downReplicas = 0;\n        int recoveringReplicas = 0;\n        int recoveryFailedReplicas = 0;\n        for (Replica r : s.getReplicas()) {\n          switch (r.getState()) {\n            case ACTIVE:\n              activeReplicas++;\n              break;\n            case DOWN:\n              downReplicas++;\n              break;\n            case RECOVERING:\n              recoveringReplicas++;\n              break;\n            case RECOVERY_FAILED:\n              recoveryFailedReplicas++;\n              break;\n          }\n        }\n        replicaMap.add(\"total\", totalReplicas);\n        replicaMap.add(\"active\", activeReplicas);\n        replicaMap.add(\"down\", downReplicas);\n        replicaMap.add(\"recovering\", recoveringReplicas);\n        replicaMap.add(\"recovery_failed\", recoveryFailedReplicas);\n        sliceMap.add(\"state\", s.getState().toString());\n        sliceMap.add(\"range\", s.getRange().toString());\n        Map<String, RoutingRule> rules = s.getRoutingRules();\n        if (rules != null && !rules.isEmpty()) {\n          sliceMap.add(\"routingRules\", rules);\n        }\n        sliceMap.add(\"replicas\", replicaMap);\n        Replica leader = s.getLeader();\n        if (leader == null) { // pick the first one\n          leader = s.getReplicas().size() > 0 ? s.getReplicas().iterator().next() : null;\n        }\n        if (leader == null) {\n          continue;\n        }\n        SimpleOrderedMap<Object> leaderMap = new SimpleOrderedMap<>();\n        sliceMap.add(\"leader\", leaderMap);\n        leaderMap.add(\"coreNode\", leader.getName());\n        leaderMap.addAll(leader.getProperties());\n        if (!leader.isActive(clusterState.getLiveNodes())) {\n          continue;\n        }\n        String url = ZkCoreNodeProps.getCoreUrl(leader);\n        try (SolrClient client = solrClientCache.getHttpSolrClient(url)) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.add(CommonParams.QT, \"/admin/segments\");\n          params.add(FIELD_INFO_PROP, \"true\");\n          params.add(CORE_INFO_PROP, String.valueOf(withCoreInfo));\n          params.add(SIZE_INFO_PROP, String.valueOf(withSizeInfo));\n          QueryRequest req = new QueryRequest(params);\n          NamedList<Object> rsp = client.request(req);\n          rsp.remove(\"responseHeader\");\n          leaderMap.add(\"segInfos\", rsp);\n          NamedList<Object> segs = (NamedList<Object>)rsp.get(\"segments\");\n          if (segs != null) {\n            for (Map.Entry<String, Object> entry : segs) {\n              NamedList<Object> fields = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"fields\");\n              if (fields != null) {\n                for (Map.Entry<String, Object> fEntry : fields) {\n                  Object nc = ((NamedList<Object>)fEntry.getValue()).get(\"nonCompliant\");\n                  if (nc != null) {\n                    nonCompliant.add(fEntry.getKey());\n                  }\n                }\n              }\n              if (!withFieldInfo) {\n                ((NamedList<Object>)entry.getValue()).remove(\"fields\");\n              }\n            }\n          }\n          if (!withSegments) {\n            rsp.remove(\"segments\");\n          }\n          if (!withFieldInfo) {\n            rsp.remove(\"fieldInfoLegend\");\n          }\n        } catch (SolrServerException | IOException e) {\n          log.warn(\"Error getting details of replica segments from \" + url, e);\n        }\n      }\n      if (nonCompliant.isEmpty()) {\n        nonCompliant.add(\"(NONE)\");\n      }\n      colMap.add(\"schemaNonCompliant\", nonCompliant);\n      colMap.add(\"shards\", shards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0dad9b7f87a8b63745f1abe3772caaeb25f16cbd","date":1572959165,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","sourceNew":"  public void getColStatus(NamedList<Object> results) {\n    Collection<String> collections;\n    String col = props.getStr(ZkStateReader.COLLECTION_PROP);\n    if (col == null) {\n      collections = new HashSet<>(clusterState.getCollectionsMap().keySet());\n    } else {\n      collections = Collections.singleton(col);\n    }\n    boolean withFieldInfo = props.getBool(FIELD_INFO_PROP, false);\n    boolean withSegments = props.getBool(SEGMENTS_PROP, false);\n    boolean withCoreInfo = props.getBool(CORE_INFO_PROP, false);\n    boolean withSizeInfo = props.getBool(SIZE_INFO_PROP, false);\n    boolean withRawSizeInfo = props.getBool(RAW_SIZE_PROP, false);\n    boolean withRawSizeSummary = props.getBool(RAW_SIZE_SUMMARY_PROP, false);\n    boolean withRawSizeDetails = props.getBool(RAW_SIZE_DETAILS_PROP, false);\n    Object samplingPercentVal = props.get(RAW_SIZE_SAMPLING_PERCENT_PROP);\n    Float samplingPercent = samplingPercentVal != null ? Float.parseFloat(String.valueOf(samplingPercentVal)) : null;\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo = true;\n    }\n    if (withFieldInfo || withSizeInfo) {\n      withSegments = true;\n    }\n    for (String collection : collections) {\n      DocCollection coll = clusterState.getCollectionOrNull(collection);\n      if (coll == null) {\n        continue;\n      }\n      SimpleOrderedMap<Object> colMap = new SimpleOrderedMap<>();\n      colMap.add(\"stateFormat\", coll.getStateFormat());\n      colMap.add(\"znodeVersion\", coll.getZNodeVersion());\n      Map<String, Object> props = new TreeMap<>(coll.getProperties());\n      props.remove(\"shards\");\n      colMap.add(\"properties\", props);\n      colMap.add(\"activeShards\", coll.getActiveSlices().size());\n      colMap.add(\"inactiveShards\", coll.getSlices().size() - coll.getActiveSlices().size());\n      results.add(collection, colMap);\n\n      Set<String> nonCompliant = new TreeSet<>();\n\n      SimpleOrderedMap<Object> shards = new SimpleOrderedMap<>();\n      for (Slice s : coll.getSlices()) {\n        SimpleOrderedMap<Object> sliceMap = new SimpleOrderedMap<>();\n        shards.add(s.getName(), sliceMap);\n        SimpleOrderedMap<Object> replicaMap = new SimpleOrderedMap<>();\n        int totalReplicas = s.getReplicas().size();\n        int activeReplicas = 0;\n        int downReplicas = 0;\n        int recoveringReplicas = 0;\n        int recoveryFailedReplicas = 0;\n        for (Replica r : s.getReplicas()) {\n          // replica may still be marked as ACTIVE even though its node is no longer live\n          if (! r.isActive(clusterState.getLiveNodes())) {\n            downReplicas++;\n            continue;\n          }\n          switch (r.getState()) {\n            case ACTIVE:\n              activeReplicas++;\n              break;\n            case DOWN:\n              downReplicas++;\n              break;\n            case RECOVERING:\n              recoveringReplicas++;\n              break;\n            case RECOVERY_FAILED:\n              recoveryFailedReplicas++;\n              break;\n          }\n        }\n        replicaMap.add(\"total\", totalReplicas);\n        replicaMap.add(\"active\", activeReplicas);\n        replicaMap.add(\"down\", downReplicas);\n        replicaMap.add(\"recovering\", recoveringReplicas);\n        replicaMap.add(\"recovery_failed\", recoveryFailedReplicas);\n        sliceMap.add(\"state\", s.getState().toString());\n        sliceMap.add(\"range\", s.getRange().toString());\n        Map<String, RoutingRule> rules = s.getRoutingRules();\n        if (rules != null && !rules.isEmpty()) {\n          sliceMap.add(\"routingRules\", rules);\n        }\n        sliceMap.add(\"replicas\", replicaMap);\n        Replica leader = s.getLeader();\n        if (leader == null) { // pick the first one\n          leader = s.getReplicas().size() > 0 ? s.getReplicas().iterator().next() : null;\n        }\n        if (leader == null) {\n          continue;\n        }\n        SimpleOrderedMap<Object> leaderMap = new SimpleOrderedMap<>();\n        sliceMap.add(\"leader\", leaderMap);\n        leaderMap.add(\"coreNode\", leader.getName());\n        leaderMap.addAll(leader.getProperties());\n        if (!leader.isActive(clusterState.getLiveNodes())) {\n          continue;\n        }\n        String url = ZkCoreNodeProps.getCoreUrl(leader);\n        try (SolrClient client = solrClientCache.getHttpSolrClient(url)) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.add(CommonParams.QT, \"/admin/segments\");\n          params.add(FIELD_INFO_PROP, \"true\");\n          params.add(CORE_INFO_PROP, String.valueOf(withCoreInfo));\n          params.add(SIZE_INFO_PROP, String.valueOf(withSizeInfo));\n          params.add(RAW_SIZE_PROP, String.valueOf(withRawSizeInfo));\n          params.add(RAW_SIZE_SUMMARY_PROP, String.valueOf(withRawSizeSummary));\n          params.add(RAW_SIZE_DETAILS_PROP, String.valueOf(withRawSizeDetails));\n          if (samplingPercent != null) {\n            params.add(RAW_SIZE_SAMPLING_PERCENT_PROP, String.valueOf(samplingPercent));\n          }\n          QueryRequest req = new QueryRequest(params);\n          NamedList<Object> rsp = client.request(req);\n          rsp.remove(\"responseHeader\");\n          leaderMap.add(\"segInfos\", rsp);\n          NamedList<Object> segs = (NamedList<Object>)rsp.get(\"segments\");\n          if (segs != null) {\n            for (Map.Entry<String, Object> entry : segs) {\n              NamedList<Object> fields = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"fields\");\n              if (fields != null) {\n                for (Map.Entry<String, Object> fEntry : fields) {\n                  Object nc = ((NamedList<Object>)fEntry.getValue()).get(\"nonCompliant\");\n                  if (nc != null) {\n                    nonCompliant.add(fEntry.getKey());\n                  }\n                }\n              }\n              if (!withFieldInfo) {\n                ((NamedList<Object>)entry.getValue()).remove(\"fields\");\n              }\n            }\n          }\n          if (!withSegments) {\n            rsp.remove(\"segments\");\n          }\n          if (!withFieldInfo) {\n            rsp.remove(\"fieldInfoLegend\");\n          }\n        } catch (SolrServerException | IOException e) {\n          log.warn(\"Error getting details of replica segments from \" + url, e);\n        }\n      }\n      if (nonCompliant.isEmpty()) {\n        nonCompliant.add(\"(NONE)\");\n      }\n      colMap.add(\"schemaNonCompliant\", nonCompliant);\n      colMap.add(\"shards\", shards);\n    }\n  }\n\n","sourceOld":"  public void getColStatus(NamedList<Object> results) {\n    Collection<String> collections;\n    String col = props.getStr(ZkStateReader.COLLECTION_PROP);\n    if (col == null) {\n      collections = new HashSet<>(clusterState.getCollectionsMap().keySet());\n    } else {\n      collections = Collections.singleton(col);\n    }\n    boolean withFieldInfo = props.getBool(FIELD_INFO_PROP, false);\n    boolean withSegments = props.getBool(SEGMENTS_PROP, false);\n    boolean withCoreInfo = props.getBool(CORE_INFO_PROP, false);\n    boolean withSizeInfo = props.getBool(SIZE_INFO_PROP, false);\n    boolean withRawSizeInfo = props.getBool(RAW_SIZE_PROP, false);\n    boolean withRawSizeSummary = props.getBool(RAW_SIZE_SUMMARY_PROP, false);\n    boolean withRawSizeDetails = props.getBool(RAW_SIZE_DETAILS_PROP, false);\n    Object samplingPercentVal = props.get(RAW_SIZE_SAMPLING_PERCENT_PROP);\n    Float samplingPercent = samplingPercentVal != null ? Float.parseFloat(String.valueOf(samplingPercentVal)) : null;\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo = true;\n    }\n    if (withFieldInfo || withSizeInfo) {\n      withSegments = true;\n    }\n    for (String collection : collections) {\n      DocCollection coll = clusterState.getCollectionOrNull(collection);\n      if (coll == null) {\n        continue;\n      }\n      SimpleOrderedMap<Object> colMap = new SimpleOrderedMap<>();\n      colMap.add(\"stateFormat\", coll.getStateFormat());\n      colMap.add(\"znodeVersion\", coll.getZNodeVersion());\n      Map<String, Object> props = new TreeMap<>(coll.getProperties());\n      props.remove(\"shards\");\n      colMap.add(\"properties\", props);\n      colMap.add(\"activeShards\", coll.getActiveSlices().size());\n      colMap.add(\"inactiveShards\", coll.getSlices().size() - coll.getActiveSlices().size());\n      results.add(collection, colMap);\n\n      Set<String> nonCompliant = new TreeSet<>();\n\n      SimpleOrderedMap<Object> shards = new SimpleOrderedMap<>();\n      for (Slice s : coll.getSlices()) {\n        SimpleOrderedMap<Object> sliceMap = new SimpleOrderedMap<>();\n        shards.add(s.getName(), sliceMap);\n        SimpleOrderedMap<Object> replicaMap = new SimpleOrderedMap<>();\n        int totalReplicas = s.getReplicas().size();\n        int activeReplicas = 0;\n        int downReplicas = 0;\n        int recoveringReplicas = 0;\n        int recoveryFailedReplicas = 0;\n        for (Replica r : s.getReplicas()) {\n          switch (r.getState()) {\n            case ACTIVE:\n              activeReplicas++;\n              break;\n            case DOWN:\n              downReplicas++;\n              break;\n            case RECOVERING:\n              recoveringReplicas++;\n              break;\n            case RECOVERY_FAILED:\n              recoveryFailedReplicas++;\n              break;\n          }\n        }\n        replicaMap.add(\"total\", totalReplicas);\n        replicaMap.add(\"active\", activeReplicas);\n        replicaMap.add(\"down\", downReplicas);\n        replicaMap.add(\"recovering\", recoveringReplicas);\n        replicaMap.add(\"recovery_failed\", recoveryFailedReplicas);\n        sliceMap.add(\"state\", s.getState().toString());\n        sliceMap.add(\"range\", s.getRange().toString());\n        Map<String, RoutingRule> rules = s.getRoutingRules();\n        if (rules != null && !rules.isEmpty()) {\n          sliceMap.add(\"routingRules\", rules);\n        }\n        sliceMap.add(\"replicas\", replicaMap);\n        Replica leader = s.getLeader();\n        if (leader == null) { // pick the first one\n          leader = s.getReplicas().size() > 0 ? s.getReplicas().iterator().next() : null;\n        }\n        if (leader == null) {\n          continue;\n        }\n        SimpleOrderedMap<Object> leaderMap = new SimpleOrderedMap<>();\n        sliceMap.add(\"leader\", leaderMap);\n        leaderMap.add(\"coreNode\", leader.getName());\n        leaderMap.addAll(leader.getProperties());\n        if (!leader.isActive(clusterState.getLiveNodes())) {\n          continue;\n        }\n        String url = ZkCoreNodeProps.getCoreUrl(leader);\n        try (SolrClient client = solrClientCache.getHttpSolrClient(url)) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.add(CommonParams.QT, \"/admin/segments\");\n          params.add(FIELD_INFO_PROP, \"true\");\n          params.add(CORE_INFO_PROP, String.valueOf(withCoreInfo));\n          params.add(SIZE_INFO_PROP, String.valueOf(withSizeInfo));\n          params.add(RAW_SIZE_PROP, String.valueOf(withRawSizeInfo));\n          params.add(RAW_SIZE_SUMMARY_PROP, String.valueOf(withRawSizeSummary));\n          params.add(RAW_SIZE_DETAILS_PROP, String.valueOf(withRawSizeDetails));\n          if (samplingPercent != null) {\n            params.add(RAW_SIZE_SAMPLING_PERCENT_PROP, String.valueOf(samplingPercent));\n          }\n          QueryRequest req = new QueryRequest(params);\n          NamedList<Object> rsp = client.request(req);\n          rsp.remove(\"responseHeader\");\n          leaderMap.add(\"segInfos\", rsp);\n          NamedList<Object> segs = (NamedList<Object>)rsp.get(\"segments\");\n          if (segs != null) {\n            for (Map.Entry<String, Object> entry : segs) {\n              NamedList<Object> fields = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"fields\");\n              if (fields != null) {\n                for (Map.Entry<String, Object> fEntry : fields) {\n                  Object nc = ((NamedList<Object>)fEntry.getValue()).get(\"nonCompliant\");\n                  if (nc != null) {\n                    nonCompliant.add(fEntry.getKey());\n                  }\n                }\n              }\n              if (!withFieldInfo) {\n                ((NamedList<Object>)entry.getValue()).remove(\"fields\");\n              }\n            }\n          }\n          if (!withSegments) {\n            rsp.remove(\"segments\");\n          }\n          if (!withFieldInfo) {\n            rsp.remove(\"fieldInfoLegend\");\n          }\n        } catch (SolrServerException | IOException e) {\n          log.warn(\"Error getting details of replica segments from \" + url, e);\n        }\n      }\n      if (nonCompliant.isEmpty()) {\n        nonCompliant.add(\"(NONE)\");\n      }\n      colMap.add(\"schemaNonCompliant\", nonCompliant);\n      colMap.add(\"shards\", shards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","sourceNew":"  public void getColStatus(NamedList<Object> results) {\n    Collection<String> collections;\n    String col = props.getStr(ZkStateReader.COLLECTION_PROP);\n    if (col == null) {\n      collections = new HashSet<>(clusterState.getCollectionsMap().keySet());\n    } else {\n      collections = Collections.singleton(col);\n    }\n    boolean withFieldInfo = props.getBool(FIELD_INFO_PROP, false);\n    boolean withSegments = props.getBool(SEGMENTS_PROP, false);\n    boolean withCoreInfo = props.getBool(CORE_INFO_PROP, false);\n    boolean withSizeInfo = props.getBool(SIZE_INFO_PROP, false);\n    boolean withRawSizeInfo = props.getBool(RAW_SIZE_PROP, false);\n    boolean withRawSizeSummary = props.getBool(RAW_SIZE_SUMMARY_PROP, false);\n    boolean withRawSizeDetails = props.getBool(RAW_SIZE_DETAILS_PROP, false);\n    Object samplingPercentVal = props.get(RAW_SIZE_SAMPLING_PERCENT_PROP);\n    Float samplingPercent = samplingPercentVal != null ? Float.parseFloat(String.valueOf(samplingPercentVal)) : null;\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo = true;\n    }\n    if (withFieldInfo || withSizeInfo) {\n      withSegments = true;\n    }\n    for (String collection : collections) {\n      DocCollection coll = clusterState.getCollectionOrNull(collection);\n      if (coll == null) {\n        continue;\n      }\n      SimpleOrderedMap<Object> colMap = new SimpleOrderedMap<>();\n      colMap.add(\"stateFormat\", coll.getStateFormat());\n      colMap.add(\"znodeVersion\", coll.getZNodeVersion());\n      Map<String, Object> props = new TreeMap<>(coll.getProperties());\n      props.remove(\"shards\");\n      colMap.add(\"properties\", props);\n      colMap.add(\"activeShards\", coll.getActiveSlices().size());\n      colMap.add(\"inactiveShards\", coll.getSlices().size() - coll.getActiveSlices().size());\n      results.add(collection, colMap);\n\n      Set<String> nonCompliant = new TreeSet<>();\n\n      SimpleOrderedMap<Object> shards = new SimpleOrderedMap<>();\n      for (Slice s : coll.getSlices()) {\n        SimpleOrderedMap<Object> sliceMap = new SimpleOrderedMap<>();\n        shards.add(s.getName(), sliceMap);\n        SimpleOrderedMap<Object> replicaMap = new SimpleOrderedMap<>();\n        int totalReplicas = s.getReplicas().size();\n        int activeReplicas = 0;\n        int downReplicas = 0;\n        int recoveringReplicas = 0;\n        int recoveryFailedReplicas = 0;\n        for (Replica r : s.getReplicas()) {\n          // replica may still be marked as ACTIVE even though its node is no longer live\n          if (! r.isActive(clusterState.getLiveNodes())) {\n            downReplicas++;\n            continue;\n          }\n          switch (r.getState()) {\n            case ACTIVE:\n              activeReplicas++;\n              break;\n            case DOWN:\n              downReplicas++;\n              break;\n            case RECOVERING:\n              recoveringReplicas++;\n              break;\n            case RECOVERY_FAILED:\n              recoveryFailedReplicas++;\n              break;\n          }\n        }\n        replicaMap.add(\"total\", totalReplicas);\n        replicaMap.add(\"active\", activeReplicas);\n        replicaMap.add(\"down\", downReplicas);\n        replicaMap.add(\"recovering\", recoveringReplicas);\n        replicaMap.add(\"recovery_failed\", recoveryFailedReplicas);\n        sliceMap.add(\"state\", s.getState().toString());\n        sliceMap.add(\"range\", s.getRange().toString());\n        Map<String, RoutingRule> rules = s.getRoutingRules();\n        if (rules != null && !rules.isEmpty()) {\n          sliceMap.add(\"routingRules\", rules);\n        }\n        sliceMap.add(\"replicas\", replicaMap);\n        Replica leader = s.getLeader();\n        if (leader == null) { // pick the first one\n          leader = s.getReplicas().size() > 0 ? s.getReplicas().iterator().next() : null;\n        }\n        if (leader == null) {\n          continue;\n        }\n        SimpleOrderedMap<Object> leaderMap = new SimpleOrderedMap<>();\n        sliceMap.add(\"leader\", leaderMap);\n        leaderMap.add(\"coreNode\", leader.getName());\n        leaderMap.addAll(leader.getProperties());\n        if (!leader.isActive(clusterState.getLiveNodes())) {\n          continue;\n        }\n        String url = ZkCoreNodeProps.getCoreUrl(leader);\n        try (SolrClient client = solrClientCache.getHttpSolrClient(url)) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.add(CommonParams.QT, \"/admin/segments\");\n          params.add(FIELD_INFO_PROP, \"true\");\n          params.add(CORE_INFO_PROP, String.valueOf(withCoreInfo));\n          params.add(SIZE_INFO_PROP, String.valueOf(withSizeInfo));\n          params.add(RAW_SIZE_PROP, String.valueOf(withRawSizeInfo));\n          params.add(RAW_SIZE_SUMMARY_PROP, String.valueOf(withRawSizeSummary));\n          params.add(RAW_SIZE_DETAILS_PROP, String.valueOf(withRawSizeDetails));\n          if (samplingPercent != null) {\n            params.add(RAW_SIZE_SAMPLING_PERCENT_PROP, String.valueOf(samplingPercent));\n          }\n          QueryRequest req = new QueryRequest(params);\n          NamedList<Object> rsp = client.request(req);\n          rsp.remove(\"responseHeader\");\n          leaderMap.add(\"segInfos\", rsp);\n          NamedList<Object> segs = (NamedList<Object>)rsp.get(\"segments\");\n          if (segs != null) {\n            for (Map.Entry<String, Object> entry : segs) {\n              NamedList<Object> fields = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"fields\");\n              if (fields != null) {\n                for (Map.Entry<String, Object> fEntry : fields) {\n                  Object nc = ((NamedList<Object>)fEntry.getValue()).get(\"nonCompliant\");\n                  if (nc != null) {\n                    nonCompliant.add(fEntry.getKey());\n                  }\n                }\n              }\n              if (!withFieldInfo) {\n                ((NamedList<Object>)entry.getValue()).remove(\"fields\");\n              }\n            }\n          }\n          if (!withSegments) {\n            rsp.remove(\"segments\");\n          }\n          if (!withFieldInfo) {\n            rsp.remove(\"fieldInfoLegend\");\n          }\n        } catch (SolrServerException | IOException e) {\n          log.warn(\"Error getting details of replica segments from {}\", url, e);\n        }\n      }\n      if (nonCompliant.isEmpty()) {\n        nonCompliant.add(\"(NONE)\");\n      }\n      colMap.add(\"schemaNonCompliant\", nonCompliant);\n      colMap.add(\"shards\", shards);\n    }\n  }\n\n","sourceOld":"  public void getColStatus(NamedList<Object> results) {\n    Collection<String> collections;\n    String col = props.getStr(ZkStateReader.COLLECTION_PROP);\n    if (col == null) {\n      collections = new HashSet<>(clusterState.getCollectionsMap().keySet());\n    } else {\n      collections = Collections.singleton(col);\n    }\n    boolean withFieldInfo = props.getBool(FIELD_INFO_PROP, false);\n    boolean withSegments = props.getBool(SEGMENTS_PROP, false);\n    boolean withCoreInfo = props.getBool(CORE_INFO_PROP, false);\n    boolean withSizeInfo = props.getBool(SIZE_INFO_PROP, false);\n    boolean withRawSizeInfo = props.getBool(RAW_SIZE_PROP, false);\n    boolean withRawSizeSummary = props.getBool(RAW_SIZE_SUMMARY_PROP, false);\n    boolean withRawSizeDetails = props.getBool(RAW_SIZE_DETAILS_PROP, false);\n    Object samplingPercentVal = props.get(RAW_SIZE_SAMPLING_PERCENT_PROP);\n    Float samplingPercent = samplingPercentVal != null ? Float.parseFloat(String.valueOf(samplingPercentVal)) : null;\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo = true;\n    }\n    if (withFieldInfo || withSizeInfo) {\n      withSegments = true;\n    }\n    for (String collection : collections) {\n      DocCollection coll = clusterState.getCollectionOrNull(collection);\n      if (coll == null) {\n        continue;\n      }\n      SimpleOrderedMap<Object> colMap = new SimpleOrderedMap<>();\n      colMap.add(\"stateFormat\", coll.getStateFormat());\n      colMap.add(\"znodeVersion\", coll.getZNodeVersion());\n      Map<String, Object> props = new TreeMap<>(coll.getProperties());\n      props.remove(\"shards\");\n      colMap.add(\"properties\", props);\n      colMap.add(\"activeShards\", coll.getActiveSlices().size());\n      colMap.add(\"inactiveShards\", coll.getSlices().size() - coll.getActiveSlices().size());\n      results.add(collection, colMap);\n\n      Set<String> nonCompliant = new TreeSet<>();\n\n      SimpleOrderedMap<Object> shards = new SimpleOrderedMap<>();\n      for (Slice s : coll.getSlices()) {\n        SimpleOrderedMap<Object> sliceMap = new SimpleOrderedMap<>();\n        shards.add(s.getName(), sliceMap);\n        SimpleOrderedMap<Object> replicaMap = new SimpleOrderedMap<>();\n        int totalReplicas = s.getReplicas().size();\n        int activeReplicas = 0;\n        int downReplicas = 0;\n        int recoveringReplicas = 0;\n        int recoveryFailedReplicas = 0;\n        for (Replica r : s.getReplicas()) {\n          // replica may still be marked as ACTIVE even though its node is no longer live\n          if (! r.isActive(clusterState.getLiveNodes())) {\n            downReplicas++;\n            continue;\n          }\n          switch (r.getState()) {\n            case ACTIVE:\n              activeReplicas++;\n              break;\n            case DOWN:\n              downReplicas++;\n              break;\n            case RECOVERING:\n              recoveringReplicas++;\n              break;\n            case RECOVERY_FAILED:\n              recoveryFailedReplicas++;\n              break;\n          }\n        }\n        replicaMap.add(\"total\", totalReplicas);\n        replicaMap.add(\"active\", activeReplicas);\n        replicaMap.add(\"down\", downReplicas);\n        replicaMap.add(\"recovering\", recoveringReplicas);\n        replicaMap.add(\"recovery_failed\", recoveryFailedReplicas);\n        sliceMap.add(\"state\", s.getState().toString());\n        sliceMap.add(\"range\", s.getRange().toString());\n        Map<String, RoutingRule> rules = s.getRoutingRules();\n        if (rules != null && !rules.isEmpty()) {\n          sliceMap.add(\"routingRules\", rules);\n        }\n        sliceMap.add(\"replicas\", replicaMap);\n        Replica leader = s.getLeader();\n        if (leader == null) { // pick the first one\n          leader = s.getReplicas().size() > 0 ? s.getReplicas().iterator().next() : null;\n        }\n        if (leader == null) {\n          continue;\n        }\n        SimpleOrderedMap<Object> leaderMap = new SimpleOrderedMap<>();\n        sliceMap.add(\"leader\", leaderMap);\n        leaderMap.add(\"coreNode\", leader.getName());\n        leaderMap.addAll(leader.getProperties());\n        if (!leader.isActive(clusterState.getLiveNodes())) {\n          continue;\n        }\n        String url = ZkCoreNodeProps.getCoreUrl(leader);\n        try (SolrClient client = solrClientCache.getHttpSolrClient(url)) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.add(CommonParams.QT, \"/admin/segments\");\n          params.add(FIELD_INFO_PROP, \"true\");\n          params.add(CORE_INFO_PROP, String.valueOf(withCoreInfo));\n          params.add(SIZE_INFO_PROP, String.valueOf(withSizeInfo));\n          params.add(RAW_SIZE_PROP, String.valueOf(withRawSizeInfo));\n          params.add(RAW_SIZE_SUMMARY_PROP, String.valueOf(withRawSizeSummary));\n          params.add(RAW_SIZE_DETAILS_PROP, String.valueOf(withRawSizeDetails));\n          if (samplingPercent != null) {\n            params.add(RAW_SIZE_SAMPLING_PERCENT_PROP, String.valueOf(samplingPercent));\n          }\n          QueryRequest req = new QueryRequest(params);\n          NamedList<Object> rsp = client.request(req);\n          rsp.remove(\"responseHeader\");\n          leaderMap.add(\"segInfos\", rsp);\n          NamedList<Object> segs = (NamedList<Object>)rsp.get(\"segments\");\n          if (segs != null) {\n            for (Map.Entry<String, Object> entry : segs) {\n              NamedList<Object> fields = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"fields\");\n              if (fields != null) {\n                for (Map.Entry<String, Object> fEntry : fields) {\n                  Object nc = ((NamedList<Object>)fEntry.getValue()).get(\"nonCompliant\");\n                  if (nc != null) {\n                    nonCompliant.add(fEntry.getKey());\n                  }\n                }\n              }\n              if (!withFieldInfo) {\n                ((NamedList<Object>)entry.getValue()).remove(\"fields\");\n              }\n            }\n          }\n          if (!withSegments) {\n            rsp.remove(\"segments\");\n          }\n          if (!withFieldInfo) {\n            rsp.remove(\"fieldInfoLegend\");\n          }\n        } catch (SolrServerException | IOException e) {\n          log.warn(\"Error getting details of replica segments from \" + url, e);\n        }\n      }\n      if (nonCompliant.isEmpty()) {\n        nonCompliant.add(\"(NONE)\");\n      }\n      colMap.add(\"schemaNonCompliant\", nonCompliant);\n      colMap.add(\"shards\", shards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba055e19afc289adcb5bedaf68513793a7254012","date":1591268575,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public void getColStatus(NamedList<Object> results) {\n    Collection<String> collections;\n    String col = props.getStr(ZkStateReader.COLLECTION_PROP);\n    if (col == null) {\n      collections = new HashSet<>(clusterState.getCollectionsMap().keySet());\n    } else {\n      collections = Collections.singleton(col);\n    }\n    boolean withFieldInfo = props.getBool(FIELD_INFO_PROP, false);\n    boolean withSegments = props.getBool(SEGMENTS_PROP, false);\n    boolean withCoreInfo = props.getBool(CORE_INFO_PROP, false);\n    boolean withSizeInfo = props.getBool(SIZE_INFO_PROP, false);\n    boolean withRawSizeInfo = props.getBool(RAW_SIZE_PROP, false);\n    boolean withRawSizeSummary = props.getBool(RAW_SIZE_SUMMARY_PROP, false);\n    boolean withRawSizeDetails = props.getBool(RAW_SIZE_DETAILS_PROP, false);\n    Object samplingPercentVal = props.get(RAW_SIZE_SAMPLING_PERCENT_PROP);\n    Float samplingPercent = samplingPercentVal != null ? Float.parseFloat(String.valueOf(samplingPercentVal)) : null;\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo = true;\n    }\n    if (withFieldInfo || withSizeInfo) {\n      withSegments = true;\n    }\n    for (String collection : collections) {\n      DocCollection coll = clusterState.getCollectionOrNull(collection);\n      if (coll == null) {\n        continue;\n      }\n      SimpleOrderedMap<Object> colMap = new SimpleOrderedMap<>();\n      colMap.add(\"stateFormat\", coll.getStateFormat());\n      colMap.add(\"znodeVersion\", coll.getZNodeVersion());\n      Map<String, Object> props = new TreeMap<>(coll.getProperties());\n      props.remove(\"shards\");\n      colMap.add(\"properties\", props);\n      colMap.add(\"activeShards\", coll.getActiveSlices().size());\n      colMap.add(\"inactiveShards\", coll.getSlices().size() - coll.getActiveSlices().size());\n      results.add(collection, colMap);\n\n      Set<String> nonCompliant = new TreeSet<>();\n\n      SimpleOrderedMap<Object> shards = new SimpleOrderedMap<>();\n      for (Slice s : coll.getSlices()) {\n        SimpleOrderedMap<Object> sliceMap = new SimpleOrderedMap<>();\n        shards.add(s.getName(), sliceMap);\n        SimpleOrderedMap<Object> replicaMap = new SimpleOrderedMap<>();\n        int totalReplicas = s.getReplicas().size();\n        int activeReplicas = 0;\n        int downReplicas = 0;\n        int recoveringReplicas = 0;\n        int recoveryFailedReplicas = 0;\n        for (Replica r : s.getReplicas()) {\n          // replica may still be marked as ACTIVE even though its node is no longer live\n          if (! r.isActive(clusterState.getLiveNodes())) {\n            downReplicas++;\n            continue;\n          }\n          switch (r.getState()) {\n            case ACTIVE:\n              activeReplicas++;\n              break;\n            case DOWN:\n              downReplicas++;\n              break;\n            case RECOVERING:\n              recoveringReplicas++;\n              break;\n            case RECOVERY_FAILED:\n              recoveryFailedReplicas++;\n              break;\n          }\n        }\n        replicaMap.add(\"total\", totalReplicas);\n        replicaMap.add(\"active\", activeReplicas);\n        replicaMap.add(\"down\", downReplicas);\n        replicaMap.add(\"recovering\", recoveringReplicas);\n        replicaMap.add(\"recovery_failed\", recoveryFailedReplicas);\n        sliceMap.add(\"state\", s.getState().toString());\n        sliceMap.add(\"range\", s.getRange().toString());\n        Map<String, RoutingRule> rules = s.getRoutingRules();\n        if (rules != null && !rules.isEmpty()) {\n          sliceMap.add(\"routingRules\", rules);\n        }\n        sliceMap.add(\"replicas\", replicaMap);\n        Replica leader = s.getLeader();\n        if (leader == null) { // pick the first one\n          leader = s.getReplicas().size() > 0 ? s.getReplicas().iterator().next() : null;\n        }\n        if (leader == null) {\n          continue;\n        }\n        SimpleOrderedMap<Object> leaderMap = new SimpleOrderedMap<>();\n        sliceMap.add(\"leader\", leaderMap);\n        leaderMap.add(\"coreNode\", leader.getName());\n        leaderMap.addAll(leader.getProperties());\n        if (!leader.isActive(clusterState.getLiveNodes())) {\n          continue;\n        }\n        String url = ZkCoreNodeProps.getCoreUrl(leader);\n        try (SolrClient client = solrClientCache.getHttpSolrClient(url)) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.add(CommonParams.QT, \"/admin/segments\");\n          params.add(FIELD_INFO_PROP, \"true\");\n          params.add(CORE_INFO_PROP, String.valueOf(withCoreInfo));\n          params.add(SIZE_INFO_PROP, String.valueOf(withSizeInfo));\n          params.add(RAW_SIZE_PROP, String.valueOf(withRawSizeInfo));\n          params.add(RAW_SIZE_SUMMARY_PROP, String.valueOf(withRawSizeSummary));\n          params.add(RAW_SIZE_DETAILS_PROP, String.valueOf(withRawSizeDetails));\n          if (samplingPercent != null) {\n            params.add(RAW_SIZE_SAMPLING_PERCENT_PROP, String.valueOf(samplingPercent));\n          }\n          QueryRequest req = new QueryRequest(params);\n          NamedList<Object> rsp = client.request(req);\n          rsp.remove(\"responseHeader\");\n          leaderMap.add(\"segInfos\", rsp);\n          NamedList<Object> segs = (NamedList<Object>)rsp.get(\"segments\");\n          if (segs != null) {\n            for (Map.Entry<String, Object> entry : segs) {\n              NamedList<Object> fields = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"fields\");\n              if (fields != null) {\n                for (Map.Entry<String, Object> fEntry : fields) {\n                  Object nc = ((NamedList<Object>)fEntry.getValue()).get(\"nonCompliant\");\n                  if (nc != null) {\n                    nonCompliant.add(fEntry.getKey());\n                  }\n                }\n              }\n              if (!withFieldInfo) {\n                ((NamedList<Object>)entry.getValue()).remove(\"fields\");\n              }\n            }\n          }\n          if (!withSegments) {\n            rsp.remove(\"segments\");\n          }\n          if (!withFieldInfo) {\n            rsp.remove(\"fieldInfoLegend\");\n          }\n        } catch (SolrServerException | IOException e) {\n          log.warn(\"Error getting details of replica segments from {}\", url, e);\n        }\n      }\n      if (nonCompliant.isEmpty()) {\n        nonCompliant.add(\"(NONE)\");\n      }\n      colMap.add(\"schemaNonCompliant\", nonCompliant);\n      colMap.add(\"shards\", shards);\n    }\n  }\n\n","sourceOld":"  public void getColStatus(NamedList<Object> results) {\n    Collection<String> collections;\n    String col = props.getStr(ZkStateReader.COLLECTION_PROP);\n    if (col == null) {\n      collections = new HashSet<>(clusterState.getCollectionsMap().keySet());\n    } else {\n      collections = Collections.singleton(col);\n    }\n    boolean withFieldInfo = props.getBool(FIELD_INFO_PROP, false);\n    boolean withSegments = props.getBool(SEGMENTS_PROP, false);\n    boolean withCoreInfo = props.getBool(CORE_INFO_PROP, false);\n    boolean withSizeInfo = props.getBool(SIZE_INFO_PROP, false);\n    boolean withRawSizeInfo = props.getBool(RAW_SIZE_PROP, false);\n    boolean withRawSizeSummary = props.getBool(RAW_SIZE_SUMMARY_PROP, false);\n    boolean withRawSizeDetails = props.getBool(RAW_SIZE_DETAILS_PROP, false);\n    Object samplingPercentVal = props.get(RAW_SIZE_SAMPLING_PERCENT_PROP);\n    Float samplingPercent = samplingPercentVal != null ? Float.parseFloat(String.valueOf(samplingPercentVal)) : null;\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo = true;\n    }\n    if (withFieldInfo || withSizeInfo) {\n      withSegments = true;\n    }\n    for (String collection : collections) {\n      DocCollection coll = clusterState.getCollectionOrNull(collection);\n      if (coll == null) {\n        continue;\n      }\n      SimpleOrderedMap<Object> colMap = new SimpleOrderedMap<>();\n      colMap.add(\"stateFormat\", coll.getStateFormat());\n      colMap.add(\"znodeVersion\", coll.getZNodeVersion());\n      Map<String, Object> props = new TreeMap<>(coll.getProperties());\n      props.remove(\"shards\");\n      colMap.add(\"properties\", props);\n      colMap.add(\"activeShards\", coll.getActiveSlices().size());\n      colMap.add(\"inactiveShards\", coll.getSlices().size() - coll.getActiveSlices().size());\n      results.add(collection, colMap);\n\n      Set<String> nonCompliant = new TreeSet<>();\n\n      SimpleOrderedMap<Object> shards = new SimpleOrderedMap<>();\n      for (Slice s : coll.getSlices()) {\n        SimpleOrderedMap<Object> sliceMap = new SimpleOrderedMap<>();\n        shards.add(s.getName(), sliceMap);\n        SimpleOrderedMap<Object> replicaMap = new SimpleOrderedMap<>();\n        int totalReplicas = s.getReplicas().size();\n        int activeReplicas = 0;\n        int downReplicas = 0;\n        int recoveringReplicas = 0;\n        int recoveryFailedReplicas = 0;\n        for (Replica r : s.getReplicas()) {\n          // replica may still be marked as ACTIVE even though its node is no longer live\n          if (! r.isActive(clusterState.getLiveNodes())) {\n            downReplicas++;\n            continue;\n          }\n          switch (r.getState()) {\n            case ACTIVE:\n              activeReplicas++;\n              break;\n            case DOWN:\n              downReplicas++;\n              break;\n            case RECOVERING:\n              recoveringReplicas++;\n              break;\n            case RECOVERY_FAILED:\n              recoveryFailedReplicas++;\n              break;\n          }\n        }\n        replicaMap.add(\"total\", totalReplicas);\n        replicaMap.add(\"active\", activeReplicas);\n        replicaMap.add(\"down\", downReplicas);\n        replicaMap.add(\"recovering\", recoveringReplicas);\n        replicaMap.add(\"recovery_failed\", recoveryFailedReplicas);\n        sliceMap.add(\"state\", s.getState().toString());\n        sliceMap.add(\"range\", s.getRange().toString());\n        Map<String, RoutingRule> rules = s.getRoutingRules();\n        if (rules != null && !rules.isEmpty()) {\n          sliceMap.add(\"routingRules\", rules);\n        }\n        sliceMap.add(\"replicas\", replicaMap);\n        Replica leader = s.getLeader();\n        if (leader == null) { // pick the first one\n          leader = s.getReplicas().size() > 0 ? s.getReplicas().iterator().next() : null;\n        }\n        if (leader == null) {\n          continue;\n        }\n        SimpleOrderedMap<Object> leaderMap = new SimpleOrderedMap<>();\n        sliceMap.add(\"leader\", leaderMap);\n        leaderMap.add(\"coreNode\", leader.getName());\n        leaderMap.addAll(leader.getProperties());\n        if (!leader.isActive(clusterState.getLiveNodes())) {\n          continue;\n        }\n        String url = ZkCoreNodeProps.getCoreUrl(leader);\n        try (SolrClient client = solrClientCache.getHttpSolrClient(url)) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.add(CommonParams.QT, \"/admin/segments\");\n          params.add(FIELD_INFO_PROP, \"true\");\n          params.add(CORE_INFO_PROP, String.valueOf(withCoreInfo));\n          params.add(SIZE_INFO_PROP, String.valueOf(withSizeInfo));\n          params.add(RAW_SIZE_PROP, String.valueOf(withRawSizeInfo));\n          params.add(RAW_SIZE_SUMMARY_PROP, String.valueOf(withRawSizeSummary));\n          params.add(RAW_SIZE_DETAILS_PROP, String.valueOf(withRawSizeDetails));\n          if (samplingPercent != null) {\n            params.add(RAW_SIZE_SAMPLING_PERCENT_PROP, String.valueOf(samplingPercent));\n          }\n          QueryRequest req = new QueryRequest(params);\n          NamedList<Object> rsp = client.request(req);\n          rsp.remove(\"responseHeader\");\n          leaderMap.add(\"segInfos\", rsp);\n          NamedList<Object> segs = (NamedList<Object>)rsp.get(\"segments\");\n          if (segs != null) {\n            for (Map.Entry<String, Object> entry : segs) {\n              NamedList<Object> fields = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"fields\");\n              if (fields != null) {\n                for (Map.Entry<String, Object> fEntry : fields) {\n                  Object nc = ((NamedList<Object>)fEntry.getValue()).get(\"nonCompliant\");\n                  if (nc != null) {\n                    nonCompliant.add(fEntry.getKey());\n                  }\n                }\n              }\n              if (!withFieldInfo) {\n                ((NamedList<Object>)entry.getValue()).remove(\"fields\");\n              }\n            }\n          }\n          if (!withSegments) {\n            rsp.remove(\"segments\");\n          }\n          if (!withFieldInfo) {\n            rsp.remove(\"fieldInfoLegend\");\n          }\n        } catch (SolrServerException | IOException e) {\n          log.warn(\"Error getting details of replica segments from {}\", url, e);\n        }\n      }\n      if (nonCompliant.isEmpty()) {\n        nonCompliant.add(\"(NONE)\");\n      }\n      colMap.add(\"schemaNonCompliant\", nonCompliant);\n      colMap.add(\"shards\", shards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ColStatus#getColStatus(NamedList[Object]).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public void getColStatus(NamedList<Object> results) {\n    Collection<String> collections;\n    String col = props.getStr(ZkStateReader.COLLECTION_PROP);\n    if (col == null) {\n      collections = new HashSet<>(clusterState.getCollectionsMap().keySet());\n    } else {\n      collections = Collections.singleton(col);\n    }\n    boolean withFieldInfo = props.getBool(FIELD_INFO_PROP, false);\n    boolean withSegments = props.getBool(SEGMENTS_PROP, false);\n    boolean withCoreInfo = props.getBool(CORE_INFO_PROP, false);\n    boolean withSizeInfo = props.getBool(SIZE_INFO_PROP, false);\n    boolean withRawSizeInfo = props.getBool(RAW_SIZE_PROP, false);\n    boolean withRawSizeSummary = props.getBool(RAW_SIZE_SUMMARY_PROP, false);\n    boolean withRawSizeDetails = props.getBool(RAW_SIZE_DETAILS_PROP, false);\n    Object samplingPercentVal = props.get(RAW_SIZE_SAMPLING_PERCENT_PROP);\n    Float samplingPercent = samplingPercentVal != null ? Float.parseFloat(String.valueOf(samplingPercentVal)) : null;\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo = true;\n    }\n    if (withFieldInfo || withSizeInfo) {\n      withSegments = true;\n    }\n    for (String collection : collections) {\n      DocCollection coll = clusterState.getCollectionOrNull(collection);\n      if (coll == null) {\n        continue;\n      }\n      SimpleOrderedMap<Object> colMap = new SimpleOrderedMap<>();\n      colMap.add(\"znodeVersion\", coll.getZNodeVersion());\n      Map<String, Object> props = new TreeMap<>(coll.getProperties());\n      props.remove(\"shards\");\n      colMap.add(\"properties\", props);\n      colMap.add(\"activeShards\", coll.getActiveSlices().size());\n      colMap.add(\"inactiveShards\", coll.getSlices().size() - coll.getActiveSlices().size());\n      results.add(collection, colMap);\n\n      Set<String> nonCompliant = new TreeSet<>();\n\n      SimpleOrderedMap<Object> shards = new SimpleOrderedMap<>();\n      for (Slice s : coll.getSlices()) {\n        SimpleOrderedMap<Object> sliceMap = new SimpleOrderedMap<>();\n        shards.add(s.getName(), sliceMap);\n        SimpleOrderedMap<Object> replicaMap = new SimpleOrderedMap<>();\n        int totalReplicas = s.getReplicas().size();\n        int activeReplicas = 0;\n        int downReplicas = 0;\n        int recoveringReplicas = 0;\n        int recoveryFailedReplicas = 0;\n        for (Replica r : s.getReplicas()) {\n          // replica may still be marked as ACTIVE even though its node is no longer live\n          if (! r.isActive(clusterState.getLiveNodes())) {\n            downReplicas++;\n            continue;\n          }\n          switch (r.getState()) {\n            case ACTIVE:\n              activeReplicas++;\n              break;\n            case DOWN:\n              downReplicas++;\n              break;\n            case RECOVERING:\n              recoveringReplicas++;\n              break;\n            case RECOVERY_FAILED:\n              recoveryFailedReplicas++;\n              break;\n          }\n        }\n        replicaMap.add(\"total\", totalReplicas);\n        replicaMap.add(\"active\", activeReplicas);\n        replicaMap.add(\"down\", downReplicas);\n        replicaMap.add(\"recovering\", recoveringReplicas);\n        replicaMap.add(\"recovery_failed\", recoveryFailedReplicas);\n        sliceMap.add(\"state\", s.getState().toString());\n        sliceMap.add(\"range\", s.getRange().toString());\n        Map<String, RoutingRule> rules = s.getRoutingRules();\n        if (rules != null && !rules.isEmpty()) {\n          sliceMap.add(\"routingRules\", rules);\n        }\n        sliceMap.add(\"replicas\", replicaMap);\n        Replica leader = s.getLeader();\n        if (leader == null) { // pick the first one\n          leader = s.getReplicas().size() > 0 ? s.getReplicas().iterator().next() : null;\n        }\n        if (leader == null) {\n          continue;\n        }\n        SimpleOrderedMap<Object> leaderMap = new SimpleOrderedMap<>();\n        sliceMap.add(\"leader\", leaderMap);\n        leaderMap.add(\"coreNode\", leader.getName());\n        leaderMap.addAll(leader.getProperties());\n        if (!leader.isActive(clusterState.getLiveNodes())) {\n          continue;\n        }\n        String url = ZkCoreNodeProps.getCoreUrl(leader);\n        try (SolrClient client = solrClientCache.getHttpSolrClient(url)) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.add(CommonParams.QT, \"/admin/segments\");\n          params.add(FIELD_INFO_PROP, \"true\");\n          params.add(CORE_INFO_PROP, String.valueOf(withCoreInfo));\n          params.add(SIZE_INFO_PROP, String.valueOf(withSizeInfo));\n          params.add(RAW_SIZE_PROP, String.valueOf(withRawSizeInfo));\n          params.add(RAW_SIZE_SUMMARY_PROP, String.valueOf(withRawSizeSummary));\n          params.add(RAW_SIZE_DETAILS_PROP, String.valueOf(withRawSizeDetails));\n          if (samplingPercent != null) {\n            params.add(RAW_SIZE_SAMPLING_PERCENT_PROP, String.valueOf(samplingPercent));\n          }\n          QueryRequest req = new QueryRequest(params);\n          NamedList<Object> rsp = client.request(req);\n          rsp.remove(\"responseHeader\");\n          leaderMap.add(\"segInfos\", rsp);\n          NamedList<Object> segs = (NamedList<Object>)rsp.get(\"segments\");\n          if (segs != null) {\n            for (Map.Entry<String, Object> entry : segs) {\n              NamedList<Object> fields = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"fields\");\n              if (fields != null) {\n                for (Map.Entry<String, Object> fEntry : fields) {\n                  Object nc = ((NamedList<Object>)fEntry.getValue()).get(\"nonCompliant\");\n                  if (nc != null) {\n                    nonCompliant.add(fEntry.getKey());\n                  }\n                }\n              }\n              if (!withFieldInfo) {\n                ((NamedList<Object>)entry.getValue()).remove(\"fields\");\n              }\n            }\n          }\n          if (!withSegments) {\n            rsp.remove(\"segments\");\n          }\n          if (!withFieldInfo) {\n            rsp.remove(\"fieldInfoLegend\");\n          }\n        } catch (SolrServerException | IOException e) {\n          log.warn(\"Error getting details of replica segments from {}\", url, e);\n        }\n      }\n      if (nonCompliant.isEmpty()) {\n        nonCompliant.add(\"(NONE)\");\n      }\n      colMap.add(\"schemaNonCompliant\", nonCompliant);\n      colMap.add(\"shards\", shards);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  public void getColStatus(NamedList<Object> results) {\n    Collection<String> collections;\n    String col = props.getStr(ZkStateReader.COLLECTION_PROP);\n    if (col == null) {\n      collections = new HashSet<>(clusterState.getCollectionsMap().keySet());\n    } else {\n      collections = Collections.singleton(col);\n    }\n    boolean withFieldInfo = props.getBool(FIELD_INFO_PROP, false);\n    boolean withSegments = props.getBool(SEGMENTS_PROP, false);\n    boolean withCoreInfo = props.getBool(CORE_INFO_PROP, false);\n    boolean withSizeInfo = props.getBool(SIZE_INFO_PROP, false);\n    boolean withRawSizeInfo = props.getBool(RAW_SIZE_PROP, false);\n    boolean withRawSizeSummary = props.getBool(RAW_SIZE_SUMMARY_PROP, false);\n    boolean withRawSizeDetails = props.getBool(RAW_SIZE_DETAILS_PROP, false);\n    Object samplingPercentVal = props.get(RAW_SIZE_SAMPLING_PERCENT_PROP);\n    Float samplingPercent = samplingPercentVal != null ? Float.parseFloat(String.valueOf(samplingPercentVal)) : null;\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo = true;\n    }\n    if (withFieldInfo || withSizeInfo) {\n      withSegments = true;\n    }\n    for (String collection : collections) {\n      DocCollection coll = clusterState.getCollectionOrNull(collection);\n      if (coll == null) {\n        continue;\n      }\n      SimpleOrderedMap<Object> colMap = new SimpleOrderedMap<>();\n      colMap.add(\"stateFormat\", coll.getStateFormat());\n      colMap.add(\"znodeVersion\", coll.getZNodeVersion());\n      Map<String, Object> props = new TreeMap<>(coll.getProperties());\n      props.remove(\"shards\");\n      colMap.add(\"properties\", props);\n      colMap.add(\"activeShards\", coll.getActiveSlices().size());\n      colMap.add(\"inactiveShards\", coll.getSlices().size() - coll.getActiveSlices().size());\n      results.add(collection, colMap);\n\n      Set<String> nonCompliant = new TreeSet<>();\n\n      SimpleOrderedMap<Object> shards = new SimpleOrderedMap<>();\n      for (Slice s : coll.getSlices()) {\n        SimpleOrderedMap<Object> sliceMap = new SimpleOrderedMap<>();\n        shards.add(s.getName(), sliceMap);\n        SimpleOrderedMap<Object> replicaMap = new SimpleOrderedMap<>();\n        int totalReplicas = s.getReplicas().size();\n        int activeReplicas = 0;\n        int downReplicas = 0;\n        int recoveringReplicas = 0;\n        int recoveryFailedReplicas = 0;\n        for (Replica r : s.getReplicas()) {\n          // replica may still be marked as ACTIVE even though its node is no longer live\n          if (! r.isActive(clusterState.getLiveNodes())) {\n            downReplicas++;\n            continue;\n          }\n          switch (r.getState()) {\n            case ACTIVE:\n              activeReplicas++;\n              break;\n            case DOWN:\n              downReplicas++;\n              break;\n            case RECOVERING:\n              recoveringReplicas++;\n              break;\n            case RECOVERY_FAILED:\n              recoveryFailedReplicas++;\n              break;\n          }\n        }\n        replicaMap.add(\"total\", totalReplicas);\n        replicaMap.add(\"active\", activeReplicas);\n        replicaMap.add(\"down\", downReplicas);\n        replicaMap.add(\"recovering\", recoveringReplicas);\n        replicaMap.add(\"recovery_failed\", recoveryFailedReplicas);\n        sliceMap.add(\"state\", s.getState().toString());\n        sliceMap.add(\"range\", s.getRange().toString());\n        Map<String, RoutingRule> rules = s.getRoutingRules();\n        if (rules != null && !rules.isEmpty()) {\n          sliceMap.add(\"routingRules\", rules);\n        }\n        sliceMap.add(\"replicas\", replicaMap);\n        Replica leader = s.getLeader();\n        if (leader == null) { // pick the first one\n          leader = s.getReplicas().size() > 0 ? s.getReplicas().iterator().next() : null;\n        }\n        if (leader == null) {\n          continue;\n        }\n        SimpleOrderedMap<Object> leaderMap = new SimpleOrderedMap<>();\n        sliceMap.add(\"leader\", leaderMap);\n        leaderMap.add(\"coreNode\", leader.getName());\n        leaderMap.addAll(leader.getProperties());\n        if (!leader.isActive(clusterState.getLiveNodes())) {\n          continue;\n        }\n        String url = ZkCoreNodeProps.getCoreUrl(leader);\n        try (SolrClient client = solrClientCache.getHttpSolrClient(url)) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.add(CommonParams.QT, \"/admin/segments\");\n          params.add(FIELD_INFO_PROP, \"true\");\n          params.add(CORE_INFO_PROP, String.valueOf(withCoreInfo));\n          params.add(SIZE_INFO_PROP, String.valueOf(withSizeInfo));\n          params.add(RAW_SIZE_PROP, String.valueOf(withRawSizeInfo));\n          params.add(RAW_SIZE_SUMMARY_PROP, String.valueOf(withRawSizeSummary));\n          params.add(RAW_SIZE_DETAILS_PROP, String.valueOf(withRawSizeDetails));\n          if (samplingPercent != null) {\n            params.add(RAW_SIZE_SAMPLING_PERCENT_PROP, String.valueOf(samplingPercent));\n          }\n          QueryRequest req = new QueryRequest(params);\n          NamedList<Object> rsp = client.request(req);\n          rsp.remove(\"responseHeader\");\n          leaderMap.add(\"segInfos\", rsp);\n          NamedList<Object> segs = (NamedList<Object>)rsp.get(\"segments\");\n          if (segs != null) {\n            for (Map.Entry<String, Object> entry : segs) {\n              NamedList<Object> fields = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"fields\");\n              if (fields != null) {\n                for (Map.Entry<String, Object> fEntry : fields) {\n                  Object nc = ((NamedList<Object>)fEntry.getValue()).get(\"nonCompliant\");\n                  if (nc != null) {\n                    nonCompliant.add(fEntry.getKey());\n                  }\n                }\n              }\n              if (!withFieldInfo) {\n                ((NamedList<Object>)entry.getValue()).remove(\"fields\");\n              }\n            }\n          }\n          if (!withSegments) {\n            rsp.remove(\"segments\");\n          }\n          if (!withFieldInfo) {\n            rsp.remove(\"fieldInfoLegend\");\n          }\n        } catch (SolrServerException | IOException e) {\n          log.warn(\"Error getting details of replica segments from {}\", url, e);\n        }\n      }\n      if (nonCompliant.isEmpty()) {\n        nonCompliant.add(\"(NONE)\");\n      }\n      colMap.add(\"schemaNonCompliant\", nonCompliant);\n      colMap.add(\"shards\", shards);\n    }\n  }\n\n","bugFix":["3470ed04f0378c1ceb02e540e3296dd27c0ae3d5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0dad9b7f87a8b63745f1abe3772caaeb25f16cbd":["e4583dbd381e291c87e23144564c59ba3391b188"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["ba055e19afc289adcb5bedaf68513793a7254012"],"ba055e19afc289adcb5bedaf68513793a7254012":["575e66bd4b2349209027f6801184da7fc3cba13f"],"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["3470ed04f0378c1ceb02e540e3296dd27c0ae3d5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3470ed04f0378c1ceb02e540e3296dd27c0ae3d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"575e66bd4b2349209027f6801184da7fc3cba13f":["0dad9b7f87a8b63745f1abe3772caaeb25f16cbd"],"e4583dbd381e291c87e23144564c59ba3391b188":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"]},"commit2Childs":{"0dad9b7f87a8b63745f1abe3772caaeb25f16cbd":["575e66bd4b2349209027f6801184da7fc3cba13f"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ba055e19afc289adcb5bedaf68513793a7254012":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["e4583dbd381e291c87e23144564c59ba3391b188"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3470ed04f0378c1ceb02e540e3296dd27c0ae3d5"],"3470ed04f0378c1ceb02e540e3296dd27c0ae3d5":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"575e66bd4b2349209027f6801184da7fc3cba13f":["ba055e19afc289adcb5bedaf68513793a7254012"],"e4583dbd381e291c87e23144564c59ba3391b188":["0dad9b7f87a8b63745f1abe3772caaeb25f16cbd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}