{"path":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)args.get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        req = new LocalSolrQueryRequest(core,params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)args.get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        req = new LocalSolrQueryRequest(core,params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)args.get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        req = new LocalSolrQueryRequest(core,params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)args.get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        req = new LocalSolrQueryRequest(core,params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)args.get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        req = new LocalSolrQueryRequest(core,params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)args.get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        req = new LocalSolrQueryRequest(core,params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b41a90736699e11a4fbb2bffe4d3838af44986b4","date":1328036096,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)args.get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(core,params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)args.get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        req = new LocalSolrQueryRequest(core,params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fc36ff77fb8122d4271e41e900d24f775097f795","date":1351228105,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)args.get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(core,params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).docs;\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)args.get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(core,params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)args.get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(core,params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).docs;\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)args.get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(core,params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).docs;\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)args.get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(core,params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        core.execute(core.getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).docs;\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc","date":1440797084,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).docs;\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4750614f6dd69a084ba692ac13eac93df7e36b83","date":1467144700,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    boolean createNewReqInfo = SolrRequestInfo.getRequestInfo() == null;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        if (createNewReqInfo) {\n          // SolrRequerstInfo for this thread could have been transferred from the parent\n          // thread.\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        }\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        if (createNewReqInfo) SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":["227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    boolean createNewReqInfo = SolrRequestInfo.getRequestInfo() == null;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        if (createNewReqInfo) {\n          // SolrRequerstInfo for this thread could have been transferred from the parent\n          // thread.\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        }\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        if (createNewReqInfo) SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01624b85de12fb02335810bdf325124e59040772","date":1490254940,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    boolean createNewReqInfo = SolrRequestInfo.getRequestInfo() == null;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(DISTRIB) == null) {\n          params.add(DISTRIB, false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        if (createNewReqInfo) {\n          // SolrRequerstInfo for this thread could have been transferred from the parent\n          // thread.\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        }\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        if (createNewReqInfo) SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    boolean createNewReqInfo = SolrRequestInfo.getRequestInfo() == null;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        if (createNewReqInfo) {\n          // SolrRequerstInfo for this thread could have been transferred from the parent\n          // thread.\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        }\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        if (createNewReqInfo) SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f4c5d3859373c3a74734e85efa122b17514e3e8","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    boolean createNewReqInfo = SolrRequestInfo.getRequestInfo() == null;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(DISTRIB) == null) {\n          params.add(DISTRIB, false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        if (createNewReqInfo) {\n          // SolrRequerstInfo for this thread could have been transferred from the parent\n          // thread.\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        }\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        if (createNewReqInfo) SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    boolean createNewReqInfo = SolrRequestInfo.getRequestInfo() == null;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(\"distrib\") == null) {\n          params.add(\"distrib\", false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        if (createNewReqInfo) {\n          // SolrRequerstInfo for this thread could have been transferred from the parent\n          // thread.\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        }\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        if (createNewReqInfo) SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to {}\", newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    boolean createNewReqInfo = SolrRequestInfo.getRequestInfo() == null;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(DISTRIB) == null) {\n          params.add(DISTRIB, false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        if (createNewReqInfo) {\n          // SolrRequerstInfo for this thread could have been transferred from the parent\n          // thread.\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        }\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        if (createNewReqInfo) SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to \" + newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    boolean createNewReqInfo = SolrRequestInfo.getRequestInfo() == null;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(DISTRIB) == null) {\n          params.add(DISTRIB, false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        if (createNewReqInfo) {\n          // SolrRequerstInfo for this thread could have been transferred from the parent\n          // thread.\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        }\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        if (createNewReqInfo) SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0dfcb99e767e8eafdede3faac6831984ac849fc","date":1589042999,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.debug(\"QuerySenderListener sending requests to {}\", newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    boolean createNewReqInfo = SolrRequestInfo.getRequestInfo() == null;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(DISTRIB) == null) {\n          params.add(DISTRIB, false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        if (createNewReqInfo) {\n          // SolrRequerstInfo for this thread could have been transferred from the parent\n          // thread.\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        }\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        if (createNewReqInfo) SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.info(\"QuerySenderListener sending requests to {}\", newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    boolean createNewReqInfo = SolrRequestInfo.getRequestInfo() == null;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(DISTRIB) == null) {\n          params.add(DISTRIB, false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        if (createNewReqInfo) {\n          // SolrRequerstInfo for this thread could have been transferred from the parent\n          // thread.\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        }\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        if (createNewReqInfo) SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75237075d8425856bf4bbf52a6be4f9162b8187d","date":1591103291,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.debug(\"QuerySenderListener sending requests to {}\", newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    boolean createNewReqInfo = SolrRequestInfo.getRequestInfo() == null;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(DISTRIB) == null) {\n          params.add(DISTRIB, false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        if (createNewReqInfo) {\n          // SolrRequerstInfo for this thread could have been transferred from the parent\n          // thread.\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        }\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        if (createNewReqInfo) SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.debug(\"QuerySenderListener sending requests to {}\", newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    boolean createNewReqInfo = SolrRequestInfo.getRequestInfo() == null;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(DISTRIB) == null) {\n          params.add(DISTRIB, false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        if (createNewReqInfo) {\n          // SolrRequerstInfo for this thread could have been transferred from the parent\n          // thread.\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        }\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        if (createNewReqInfo) SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4","date":1592286410,"type":3,"author":"Nazerke Seidan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/QuerySenderListener#newSearcher(SolrIndexSearcher,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.debug(\"QuerySenderListener sending requests to {}\", newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    for (NamedList nlst : allLists) {\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(DISTRIB) == null) {\n          params.add(DISTRIB, false);\n        }\n        SolrQueryRequest req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n          // Retrieve the Document instances (not just the ids) to warm\n          // the OS disk cache, and any Solr document cache.  Only the top\n          // level values in the NamedList are checked for DocLists.\n          NamedList values = rsp.getValues();\n          for (int i=0; i<values.size(); i++) {\n            Object o = values.getVal(i);\n            if (o instanceof ResultContext) {\n              o = ((ResultContext)o).getDocList();\n            }\n            if (o instanceof DocList) {\n              DocList docs = (DocList)o;\n              for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n                newSearcher.doc(iter.nextDoc());\n              }\n            }\n          }\n        } finally {\n          try {\n            req.close();\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void newSearcher(SolrIndexSearcher newSearcher, SolrIndexSearcher currentSearcher) {\n    final SolrIndexSearcher searcher = newSearcher;\n    log.debug(\"QuerySenderListener sending requests to {}\", newSearcher);\n    List<NamedList> allLists = (List<NamedList>)getArgs().get(\"queries\");\n    if (allLists == null) return;\n    boolean createNewReqInfo = SolrRequestInfo.getRequestInfo() == null;\n    for (NamedList nlst : allLists) {\n      SolrQueryRequest req = null;\n      try {\n        // bind the request to a particular searcher (the newSearcher)\n        NamedList params = addEventParms(currentSearcher, nlst);\n        // for this, we default to distrib = false\n        if (params.get(DISTRIB) == null) {\n          params.add(DISTRIB, false);\n        }\n        req = new LocalSolrQueryRequest(getCore(),params) {\n          @Override public SolrIndexSearcher getSearcher() { return searcher; }\n          @Override public void close() { }\n        };\n\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        if (createNewReqInfo) {\n          // SolrRequerstInfo for this thread could have been transferred from the parent\n          // thread.\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        }\n        getCore().execute(getCore().getRequestHandler(req.getParams().get(CommonParams.QT)), req, rsp);\n\n        // Retrieve the Document instances (not just the ids) to warm\n        // the OS disk cache, and any Solr document cache.  Only the top\n        // level values in the NamedList are checked for DocLists.\n        NamedList values = rsp.getValues();\n        for (int i=0; i<values.size(); i++) {\n          Object o = values.getVal(i);\n          if (o instanceof ResultContext) {\n            o = ((ResultContext)o).getDocList();\n          }\n          if (o instanceof DocList) {\n            DocList docs = (DocList)o;\n            for (DocIterator iter = docs.iterator(); iter.hasNext();) {\n              newSearcher.doc(iter.nextDoc());\n            }\n          }\n        }\n\n      } catch (Exception e) {\n        // do nothing... we want to continue with the other requests.\n        // the failure should have already been logged.\n      } finally {\n        if (req != null) req.close();\n        if (createNewReqInfo) SolrRequestInfo.clearRequestInfo();\n      }\n    }\n    log.info(\"QuerySenderListener done.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc36ff77fb8122d4271e41e900d24f775097f795":["b41a90736699e11a4fbb2bffe4d3838af44986b4"],"75237075d8425856bf4bbf52a6be4f9162b8187d":["b0dfcb99e767e8eafdede3faac6831984ac849fc"],"b0dfcb99e767e8eafdede3faac6831984ac849fc":["140be51d03394488536f4aacedace29f9b318347"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["4750614f6dd69a084ba692ac13eac93df7e36b83"],"a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4":["75237075d8425856bf4bbf52a6be4f9162b8187d"],"7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc":["08970e5b8411182a29412c177eff67ec1110095b"],"01624b85de12fb02335810bdf325124e59040772":["4750614f6dd69a084ba692ac13eac93df7e36b83"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc","4750614f6dd69a084ba692ac13eac93df7e36b83"],"4750614f6dd69a084ba692ac13eac93df7e36b83":["7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc"],"08970e5b8411182a29412c177eff67ec1110095b":["fc36ff77fb8122d4271e41e900d24f775097f795"],"b41a90736699e11a4fbb2bffe4d3838af44986b4":["c26f00b574427b55127e869b935845554afde1fa"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"140be51d03394488536f4aacedace29f9b318347":["01624b85de12fb02335810bdf325124e59040772"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f2126b84bd093fa3d921582a109a0ee578c28126":["b41a90736699e11a4fbb2bffe4d3838af44986b4","fc36ff77fb8122d4271e41e900d24f775097f795"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4"]},"commit2Childs":{"fc36ff77fb8122d4271e41e900d24f775097f795":["08970e5b8411182a29412c177eff67ec1110095b","f2126b84bd093fa3d921582a109a0ee578c28126"],"75237075d8425856bf4bbf52a6be4f9162b8187d":["a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4"],"b0dfcb99e767e8eafdede3faac6831984ac849fc":["75237075d8425856bf4bbf52a6be4f9162b8187d"],"c26f00b574427b55127e869b935845554afde1fa":["b41a90736699e11a4fbb2bffe4d3838af44986b4"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":[],"a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","4750614f6dd69a084ba692ac13eac93df7e36b83"],"01624b85de12fb02335810bdf325124e59040772":["140be51d03394488536f4aacedace29f9b318347"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"4750614f6dd69a084ba692ac13eac93df7e36b83":["6f4c5d3859373c3a74734e85efa122b17514e3e8","01624b85de12fb02335810bdf325124e59040772","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"08970e5b8411182a29412c177eff67ec1110095b":["7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc"],"b41a90736699e11a4fbb2bffe4d3838af44986b4":["fc36ff77fb8122d4271e41e900d24f775097f795","f2126b84bd093fa3d921582a109a0ee578c28126"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"140be51d03394488536f4aacedace29f9b318347":["b0dfcb99e767e8eafdede3faac6831984ac849fc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6f4c5d3859373c3a74734e85efa122b17514e3e8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a258fbb26824fd104ed795e5d9033d2d040049ee","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}