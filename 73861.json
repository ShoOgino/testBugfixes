{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest).mjava","commits":[{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#sendRequest(SolrRequest).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2fc9f4a33c8fefeb1260aea04273a36b0d32378e","date":1421852764,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c2f5223cebd58879933670af3e599b10d7e8f1a","date":1422450178,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":["bafca15d8e408346a67f4282ad1143b88023893b"],"bugIntro":["e6c86133b70c1a2f86eca01da72b4357774d2b5c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a20a867de92263c94258f9778db64a5efc7956d","date":1424955868,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7ca08c071cb75a8796c36ae6a1c90d7473c2a6df","date":1425554964,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":4,"author":"Ryan Ernst","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest).mjava","sourceNew":null,"sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4c2f5223cebd58879933670af3e599b10d7e8f1a":["2fc9f4a33c8fefeb1260aea04273a36b0d32378e"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["4c2f5223cebd58879933670af3e599b10d7e8f1a","7ca08c071cb75a8796c36ae6a1c90d7473c2a6df"],"0a20a867de92263c94258f9778db64a5efc7956d":["4c2f5223cebd58879933670af3e599b10d7e8f1a"],"2fc9f4a33c8fefeb1260aea04273a36b0d32378e":["bafca15d8e408346a67f4282ad1143b88023893b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bafca15d8e408346a67f4282ad1143b88023893b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7ca08c071cb75a8796c36ae6a1c90d7473c2a6df"],"7ca08c071cb75a8796c36ae6a1c90d7473c2a6df":["0a20a867de92263c94258f9778db64a5efc7956d"]},"commit2Childs":{"4c2f5223cebd58879933670af3e599b10d7e8f1a":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0a20a867de92263c94258f9778db64a5efc7956d"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"2fc9f4a33c8fefeb1260aea04273a36b0d32378e":["4c2f5223cebd58879933670af3e599b10d7e8f1a"],"0a20a867de92263c94258f9778db64a5efc7956d":["7ca08c071cb75a8796c36ae6a1c90d7473c2a6df"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bafca15d8e408346a67f4282ad1143b88023893b"],"bafca15d8e408346a67f4282ad1143b88023893b":["2fc9f4a33c8fefeb1260aea04273a36b0d32378e"],"7ca08c071cb75a8796c36ae6a1c90d7473c2a6df":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}