{"path":"contrib/extraction/src/main/java/org/apache/solr/handler/extraction/SolrContentHandler#newDocument().mjava","commits":[{"id":"46dfcd540005e76a7db876d494ac74e82c476523","date":1229095104,"type":1,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/extraction/src/main/java/org/apache/solr/handler/extraction/SolrContentHandler#newDocument().mjava","pathOld":"contrib/extraction/src/main/java/org/apache/solr/handler/SolrContentHandler#newDocument().mjava","sourceNew":"  /**\n   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding\n   * classes can use this hook to add in or change whatever they deem fit for the document at that time.\n   * The base implementation adds the metadata as fields, allowing for potential remapping.\n   *\n   * @return The {@link org.apache.solr.common.SolrInputDocument}.\n   */\n  public SolrInputDocument newDocument() {\n    float boost = 1.0f;\n    //handle the metadata extracted from the document\n    for (String name : metadata.names()) {\n      String[] vals = metadata.getValues(name);\n      name = findMappedMetadataName(name);\n      SchemaField schFld = schema.getFieldOrNull(name);\n      if (schFld != null) {\n        boost = getBoost(name);\n        if (schFld.multiValued()) {\n          for (int i = 0; i < vals.length; i++) {\n            String val = vals[i];\n            document.addField(name, transformValue(val, schFld), boost);\n          }\n        } else {\n          StringBuilder builder = new StringBuilder();\n          for (int i = 0; i < vals.length; i++) {\n            builder.append(vals[i]).append(' ');\n          }\n          document.addField(name, transformValue(builder.toString().trim(), schFld), boost);\n        }\n      } else {\n        //TODO: error or log?\n        if (ignoreUndeclaredFields == false) {\n          // Arguably we should handle this as a special case. Why? Because unlike basically\n          // all the other fields in metadata, this one was probably set not by Tika by in\n          // ExtractingDocumentLoader.load(). You shouldn't have to define a mapping for this\n          // field just because you specified a resource.name parameter to the handler, should\n          // you?\n          if (name != Metadata.RESOURCE_NAME_KEY) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid field: \" + name);\n          }\n        }\n      }\n    }\n    //handle the literals from the params\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String name = paramNames.next();\n      if (name.startsWith(LITERALS_PREFIX)) {\n        String fieldName = name.substring(LITERALS_PREFIX.length());\n        //no need to map names here, since they are literals from the user\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          String value = params.get(name);\n          boost = getBoost(fieldName);\n          //no need to transform here, b/c we can assume the user sent it in correctly\n          document.addField(fieldName, value, boost);\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //add in the content\n    document.addField(defaultFieldName, catchAllBuilder.toString(), getBoost(defaultFieldName));\n\n    //add in the captured content\n    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {\n      if (entry.getValue().length() > 0) {\n        String fieldName = findMappedName(entry.getKey());\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          document.addField(fieldName, transformValue(entry.getValue().toString(), schFld), getBoost(fieldName));\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //make sure we have a unique id, if one is needed\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    if (uniqueField != null) {\n      String uniqueFieldName = uniqueField.getName();\n      SolrInputField uniqFld = document.getField(uniqueFieldName);\n      if (uniqFld == null) {\n        String uniqId = generateId(uniqueField);\n        if (uniqId != null) {\n          document.addField(uniqueFieldName, uniqId);\n        }\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Doc: \" + document);\n    }\n    return document;\n  }\n\n","sourceOld":"  /**\n   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding\n   * classes can use this hook to add in or change whatever they deem fit for the document at that time.\n   * The base implementation adds the metadata as fields, allowing for potential remapping.\n   *\n   * @return The {@link org.apache.solr.common.SolrInputDocument}.\n   */\n  public SolrInputDocument newDocument() {\n    float boost = 1.0f;\n    //handle the metadata extracted from the document\n    for (String name : metadata.names()) {\n      String[] vals = metadata.getValues(name);\n      name = findMappedMetadataName(name);\n      SchemaField schFld = schema.getFieldOrNull(name);\n      if (schFld != null) {\n        boost = getBoost(name);\n        if (schFld.multiValued()) {\n          for (int i = 0; i < vals.length; i++) {\n            String val = vals[i];\n            document.addField(name, transformValue(val, schFld), boost);\n          }\n        } else {\n          StringBuilder builder = new StringBuilder();\n          for (int i = 0; i < vals.length; i++) {\n            builder.append(vals[i]).append(' ');\n          }\n          document.addField(name, transformValue(builder.toString().trim(), schFld), boost);\n        }\n      } else {\n        //TODO: error or log?\n        if (ignoreUndeclaredFields == false) {\n          // Arguably we should handle this as a special case. Why? Because unlike basically\n          // all the other fields in metadata, this one was probably set not by Tika by in\n          // ExtractingDocumentLoader.load(). You shouldn't have to define a mapping for this\n          // field just because you specified a resource.name parameter to the handler, should\n          // you?\n          if (name != Metadata.RESOURCE_NAME_KEY) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid field: \" + name);\n          }\n        }\n      }\n    }\n    //handle the literals from the params\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String name = paramNames.next();\n      if (name.startsWith(LITERALS_PREFIX)) {\n        String fieldName = name.substring(LITERALS_PREFIX.length());\n        //no need to map names here, since they are literals from the user\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          String value = params.get(name);\n          boost = getBoost(fieldName);\n          //no need to transform here, b/c we can assume the user sent it in correctly\n          document.addField(fieldName, value, boost);\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //add in the content\n    document.addField(defaultFieldName, catchAllBuilder.toString(), getBoost(defaultFieldName));\n\n    //add in the captured content\n    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {\n      if (entry.getValue().length() > 0) {\n        String fieldName = findMappedName(entry.getKey());\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          document.addField(fieldName, transformValue(entry.getValue().toString(), schFld), getBoost(fieldName));\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //make sure we have a unique id, if one is needed\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    if (uniqueField != null) {\n      String uniqueFieldName = uniqueField.getName();\n      SolrInputField uniqFld = document.getField(uniqueFieldName);\n      if (uniqFld == null) {\n        String uniqId = generateId(uniqueField);\n        if (uniqId != null) {\n          document.addField(uniqueFieldName, uniqId);\n        }\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Doc: \" + document);\n    }\n    return document;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a75028b56df82c87510ec21c236855cc806a39a1","date":1229226462,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/extraction/src/main/java/org/apache/solr/handler/extraction/SolrContentHandler#newDocument().mjava","pathOld":"contrib/extraction/src/main/java/org/apache/solr/handler/extraction/SolrContentHandler#newDocument().mjava","sourceNew":"  /**\n   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding\n   * classes can use this hook to add in or change whatever they deem fit for the document at that time.\n   * The base implementation adds the metadata as fields, allowing for potential remapping.\n   *\n   * @return The {@link org.apache.solr.common.SolrInputDocument}.\n   */\n  public SolrInputDocument newDocument() {\n    float boost = 1.0f;\n    //handle the metadata extracted from the document\n    for (String name : metadata.names()) {\n      String[] vals = metadata.getValues(name);\n      name = findMappedMetadataName(name);\n      SchemaField schFld = schema.getFieldOrNull(name);\n      if (schFld != null) {\n        boost = getBoost(name);\n        if (schFld.multiValued()) {\n          for (int i = 0; i < vals.length; i++) {\n            String val = vals[i];\n            document.addField(name, transformValue(val, schFld), boost);\n          }\n        } else {\n          StringBuilder builder = new StringBuilder();\n          for (int i = 0; i < vals.length; i++) {\n            builder.append(vals[i]).append(' ');\n          }\n          document.addField(name, transformValue(builder.toString().trim(), schFld), boost);\n        }\n      } else {\n        //TODO: error or log?\n        if (ignoreUndeclaredFields == false) {\n          // Arguably we should handle this as a special case. Why? Because unlike basically\n          // all the other fields in metadata, this one was probably set not by Tika by in\n          // ExtractingDocumentLoader.load(). You shouldn't have to define a mapping for this\n          // field just because you specified a resource.name parameter to the handler, should\n          // you?\n          if (name != Metadata.RESOURCE_NAME_KEY) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid field: \" + name);\n          }\n        }\n      }\n    }\n    //handle the literals from the params\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String name = paramNames.next();\n      if (name.startsWith(LITERALS_PREFIX)) {\n        String fieldName = name.substring(LITERALS_PREFIX.length());\n        //no need to map names here, since they are literals from the user\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          String[] values = params.getParams(name);\n          if (schFld.multiValued() == false && values.length > 1) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"The Field \" + fieldName + \" is not multivalued\");\n          }\n          boost = getBoost(fieldName);\n          for (int i = 0; i < values.length; i++) {\n            //no need to transform here, b/c we can assume the user sent it in correctly\n            document.addField(fieldName, values[i], boost);\n\n          }\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //add in the content\n    document.addField(defaultFieldName, catchAllBuilder.toString(), getBoost(defaultFieldName));\n\n    //add in the captured content\n    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {\n      if (entry.getValue().length() > 0) {\n        String fieldName = findMappedName(entry.getKey());\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          document.addField(fieldName, transformValue(entry.getValue().toString(), schFld), getBoost(fieldName));\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //make sure we have a unique id, if one is needed\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    if (uniqueField != null) {\n      String uniqueFieldName = uniqueField.getName();\n      SolrInputField uniqFld = document.getField(uniqueFieldName);\n      if (uniqFld == null) {\n        String uniqId = generateId(uniqueField);\n        if (uniqId != null) {\n          document.addField(uniqueFieldName, uniqId);\n        }\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Doc: \" + document);\n    }\n    return document;\n  }\n\n","sourceOld":"  /**\n   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding\n   * classes can use this hook to add in or change whatever they deem fit for the document at that time.\n   * The base implementation adds the metadata as fields, allowing for potential remapping.\n   *\n   * @return The {@link org.apache.solr.common.SolrInputDocument}.\n   */\n  public SolrInputDocument newDocument() {\n    float boost = 1.0f;\n    //handle the metadata extracted from the document\n    for (String name : metadata.names()) {\n      String[] vals = metadata.getValues(name);\n      name = findMappedMetadataName(name);\n      SchemaField schFld = schema.getFieldOrNull(name);\n      if (schFld != null) {\n        boost = getBoost(name);\n        if (schFld.multiValued()) {\n          for (int i = 0; i < vals.length; i++) {\n            String val = vals[i];\n            document.addField(name, transformValue(val, schFld), boost);\n          }\n        } else {\n          StringBuilder builder = new StringBuilder();\n          for (int i = 0; i < vals.length; i++) {\n            builder.append(vals[i]).append(' ');\n          }\n          document.addField(name, transformValue(builder.toString().trim(), schFld), boost);\n        }\n      } else {\n        //TODO: error or log?\n        if (ignoreUndeclaredFields == false) {\n          // Arguably we should handle this as a special case. Why? Because unlike basically\n          // all the other fields in metadata, this one was probably set not by Tika by in\n          // ExtractingDocumentLoader.load(). You shouldn't have to define a mapping for this\n          // field just because you specified a resource.name parameter to the handler, should\n          // you?\n          if (name != Metadata.RESOURCE_NAME_KEY) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid field: \" + name);\n          }\n        }\n      }\n    }\n    //handle the literals from the params\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String name = paramNames.next();\n      if (name.startsWith(LITERALS_PREFIX)) {\n        String fieldName = name.substring(LITERALS_PREFIX.length());\n        //no need to map names here, since they are literals from the user\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          String value = params.get(name);\n          boost = getBoost(fieldName);\n          //no need to transform here, b/c we can assume the user sent it in correctly\n          document.addField(fieldName, value, boost);\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //add in the content\n    document.addField(defaultFieldName, catchAllBuilder.toString(), getBoost(defaultFieldName));\n\n    //add in the captured content\n    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {\n      if (entry.getValue().length() > 0) {\n        String fieldName = findMappedName(entry.getKey());\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          document.addField(fieldName, transformValue(entry.getValue().toString(), schFld), getBoost(fieldName));\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //make sure we have a unique id, if one is needed\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    if (uniqueField != null) {\n      String uniqueFieldName = uniqueField.getName();\n      SolrInputField uniqFld = document.getField(uniqueFieldName);\n      if (uniqFld == null) {\n        String uniqId = generateId(uniqueField);\n        if (uniqId != null) {\n          document.addField(uniqueFieldName, uniqId);\n        }\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Doc: \" + document);\n    }\n    return document;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a34495372f0709e1ee7051e94886274dc993443","date":1234022561,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/extraction/src/main/java/org/apache/solr/handler/extraction/SolrContentHandler#newDocument().mjava","pathOld":"contrib/extraction/src/main/java/org/apache/solr/handler/extraction/SolrContentHandler#newDocument().mjava","sourceNew":"  /**\n   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding\n   * classes can use this hook to add in or change whatever they deem fit for the document at that time.\n   * The base implementation adds the metadata as fields, allowing for potential remapping.\n   *\n   * @return The {@link org.apache.solr.common.SolrInputDocument}.\n   */\n  public SolrInputDocument newDocument() {\n    float boost = 1.0f;\n    //handle the metadata extracted from the document\n    for (String name : metadata.names()) {\n      String[] vals = metadata.getValues(name);\n      name = findMappedMetadataName(name);\n      SchemaField schFld = schema.getFieldOrNull(name);\n      if (schFld != null) {\n        boost = getBoost(name);\n        if (schFld.multiValued()) {\n          for (int i = 0; i < vals.length; i++) {\n            String val = vals[i];\n            document.addField(name, transformValue(val, schFld), boost);\n          }\n        } else {\n          StringBuilder builder = new StringBuilder();\n          for (int i = 0; i < vals.length; i++) {\n            builder.append(vals[i]).append(' ');\n          }\n          document.addField(name, transformValue(builder.toString().trim(), schFld), boost);\n        }\n      } else {\n        //TODO: error or log?\n        if (ignoreUndeclaredFields == false) {\n          // Arguably we should handle this as a special case. Why? Because unlike basically\n          // all the other fields in metadata, this one was probably set not by Tika by in\n          // ExtractingDocumentLoader.load(). You shouldn't have to define a mapping for this\n          // field just because you specified a resource.name parameter to the handler, should\n          // you?\n          if (name != Metadata.RESOURCE_NAME_KEY) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid field: \" + name);\n          }\n        }\n      }\n    }\n    //handle the literals from the params\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String name = paramNames.next();\n      if (name.startsWith(LITERALS_PREFIX)) {\n        String fieldName = name.substring(LITERALS_PREFIX.length());\n        //no need to map names here, since they are literals from the user\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          String[] values = params.getParams(name);\n          if (schFld.multiValued() == false && values.length > 1) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"The Field \" + fieldName + \" is not multivalued\");\n          }\n          boost = getBoost(fieldName);\n          for (int i = 0; i < values.length; i++) {\n            //no need to transform here, b/c we can assume the user sent it in correctly\n            document.addField(fieldName, values[i], boost);\n\n          }\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //add in the content\n    document.addField(defaultFieldName, catchAllBuilder.toString(), getBoost(defaultFieldName));\n\n    //add in the captured content\n    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {\n      if (entry.getValue().length() > 0) {\n        String fieldName = findMappedName(entry.getKey());\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          document.addField(fieldName, transformValue(entry.getValue().toString(), schFld), getBoost(fieldName));\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Doc: \" + document);\n    }\n    return document;\n  }\n\n","sourceOld":"  /**\n   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding\n   * classes can use this hook to add in or change whatever they deem fit for the document at that time.\n   * The base implementation adds the metadata as fields, allowing for potential remapping.\n   *\n   * @return The {@link org.apache.solr.common.SolrInputDocument}.\n   */\n  public SolrInputDocument newDocument() {\n    float boost = 1.0f;\n    //handle the metadata extracted from the document\n    for (String name : metadata.names()) {\n      String[] vals = metadata.getValues(name);\n      name = findMappedMetadataName(name);\n      SchemaField schFld = schema.getFieldOrNull(name);\n      if (schFld != null) {\n        boost = getBoost(name);\n        if (schFld.multiValued()) {\n          for (int i = 0; i < vals.length; i++) {\n            String val = vals[i];\n            document.addField(name, transformValue(val, schFld), boost);\n          }\n        } else {\n          StringBuilder builder = new StringBuilder();\n          for (int i = 0; i < vals.length; i++) {\n            builder.append(vals[i]).append(' ');\n          }\n          document.addField(name, transformValue(builder.toString().trim(), schFld), boost);\n        }\n      } else {\n        //TODO: error or log?\n        if (ignoreUndeclaredFields == false) {\n          // Arguably we should handle this as a special case. Why? Because unlike basically\n          // all the other fields in metadata, this one was probably set not by Tika by in\n          // ExtractingDocumentLoader.load(). You shouldn't have to define a mapping for this\n          // field just because you specified a resource.name parameter to the handler, should\n          // you?\n          if (name != Metadata.RESOURCE_NAME_KEY) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid field: \" + name);\n          }\n        }\n      }\n    }\n    //handle the literals from the params\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String name = paramNames.next();\n      if (name.startsWith(LITERALS_PREFIX)) {\n        String fieldName = name.substring(LITERALS_PREFIX.length());\n        //no need to map names here, since they are literals from the user\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          String[] values = params.getParams(name);\n          if (schFld.multiValued() == false && values.length > 1) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"The Field \" + fieldName + \" is not multivalued\");\n          }\n          boost = getBoost(fieldName);\n          for (int i = 0; i < values.length; i++) {\n            //no need to transform here, b/c we can assume the user sent it in correctly\n            document.addField(fieldName, values[i], boost);\n\n          }\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //add in the content\n    document.addField(defaultFieldName, catchAllBuilder.toString(), getBoost(defaultFieldName));\n\n    //add in the captured content\n    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {\n      if (entry.getValue().length() > 0) {\n        String fieldName = findMappedName(entry.getKey());\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          document.addField(fieldName, transformValue(entry.getValue().toString(), schFld), getBoost(fieldName));\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //make sure we have a unique id, if one is needed\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    if (uniqueField != null) {\n      String uniqueFieldName = uniqueField.getName();\n      SolrInputField uniqFld = document.getField(uniqueFieldName);\n      if (uniqFld == null) {\n        String uniqId = generateId(uniqueField);\n        if (uniqId != null) {\n          document.addField(uniqueFieldName, uniqId);\n        }\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Doc: \" + document);\n    }\n    return document;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eecdad1988b0b00f74f945528b689ef1eebf763d","date":1247586785,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/extraction/src/main/java/org/apache/solr/handler/extraction/SolrContentHandler#newDocument().mjava","pathOld":"contrib/extraction/src/main/java/org/apache/solr/handler/extraction/SolrContentHandler#newDocument().mjava","sourceNew":"  /**\n   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding\n   * classes can use this hook to add in or change whatever they deem fit for the document at that time.\n   * The base implementation adds the metadata as fields, allowing for potential remapping.\n   *\n   * @return The {@link org.apache.solr.common.SolrInputDocument}.\n   */\n  public SolrInputDocument newDocument() {\n    float boost = 1.0f;\n    //handle the metadata extracted from the document\n    for (String name : metadata.names()) {\n      String[] vals = metadata.getValues(name);\n      addField(name, null, vals);\n    }\n\n    //handle the literals from the params\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String pname = paramNames.next();\n      if (!pname.startsWith(LITERALS_PREFIX)) continue;\n\n      String name = pname.substring(LITERALS_PREFIX.length());\n      addField(name, null, params.getParams(pname));\n    }\n\n\n    //add in the content\n    addField(contentFieldName, catchAllBuilder.toString(), null);\n\n    //add in the captured content\n    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {\n      if (entry.getValue().length() > 0) {\n        addField(entry.getKey(), entry.getValue().toString(), null);\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Doc: \" + document);\n    }\n    return document;\n  }\n\n","sourceOld":"  /**\n   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding\n   * classes can use this hook to add in or change whatever they deem fit for the document at that time.\n   * The base implementation adds the metadata as fields, allowing for potential remapping.\n   *\n   * @return The {@link org.apache.solr.common.SolrInputDocument}.\n   */\n  public SolrInputDocument newDocument() {\n    float boost = 1.0f;\n    //handle the metadata extracted from the document\n    for (String name : metadata.names()) {\n      String[] vals = metadata.getValues(name);\n      name = findMappedMetadataName(name);\n      SchemaField schFld = schema.getFieldOrNull(name);\n      if (schFld != null) {\n        boost = getBoost(name);\n        if (schFld.multiValued()) {\n          for (int i = 0; i < vals.length; i++) {\n            String val = vals[i];\n            document.addField(name, transformValue(val, schFld), boost);\n          }\n        } else {\n          StringBuilder builder = new StringBuilder();\n          for (int i = 0; i < vals.length; i++) {\n            builder.append(vals[i]).append(' ');\n          }\n          document.addField(name, transformValue(builder.toString().trim(), schFld), boost);\n        }\n      } else {\n        //TODO: error or log?\n        if (ignoreUndeclaredFields == false) {\n          // Arguably we should handle this as a special case. Why? Because unlike basically\n          // all the other fields in metadata, this one was probably set not by Tika by in\n          // ExtractingDocumentLoader.load(). You shouldn't have to define a mapping for this\n          // field just because you specified a resource.name parameter to the handler, should\n          // you?\n          if (name != Metadata.RESOURCE_NAME_KEY) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid field: \" + name);\n          }\n        }\n      }\n    }\n    //handle the literals from the params\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String name = paramNames.next();\n      if (name.startsWith(LITERALS_PREFIX)) {\n        String fieldName = name.substring(LITERALS_PREFIX.length());\n        //no need to map names here, since they are literals from the user\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          String[] values = params.getParams(name);\n          if (schFld.multiValued() == false && values.length > 1) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"The Field \" + fieldName + \" is not multivalued\");\n          }\n          boost = getBoost(fieldName);\n          for (int i = 0; i < values.length; i++) {\n            //no need to transform here, b/c we can assume the user sent it in correctly\n            document.addField(fieldName, values[i], boost);\n\n          }\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    //add in the content\n    document.addField(defaultFieldName, catchAllBuilder.toString(), getBoost(defaultFieldName));\n\n    //add in the captured content\n    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {\n      if (entry.getValue().length() > 0) {\n        String fieldName = findMappedName(entry.getKey());\n        SchemaField schFld = schema.getFieldOrNull(fieldName);\n        if (schFld != null) {\n          document.addField(fieldName, transformValue(entry.getValue().toString(), schFld), getBoost(fieldName));\n        } else {\n          handleUndeclaredField(fieldName);\n        }\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Doc: \" + document);\n    }\n    return document;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/extraction/src/main/java/org/apache/solr/handler/extraction/SolrContentHandler#newDocument().mjava","pathOld":"contrib/extraction/src/main/java/org/apache/solr/handler/extraction/SolrContentHandler#newDocument().mjava","sourceNew":"  /**\n   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding\n   * classes can use this hook to add in or change whatever they deem fit for the document at that time.\n   * The base implementation adds the metadata as fields, allowing for potential remapping.\n   *\n   * @return The {@link org.apache.solr.common.SolrInputDocument}.\n   */\n  public SolrInputDocument newDocument() {\n    float boost = 1.0f;\n    //handle the metadata extracted from the document\n    for (String name : metadata.names()) {\n      String[] vals = metadata.getValues(name);\n      addField(name, null, vals);\n    }\n\n    //handle the literals from the params\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String pname = paramNames.next();\n      if (!pname.startsWith(LITERALS_PREFIX)) continue;\n\n      String name = pname.substring(LITERALS_PREFIX.length());\n      addField(name, null, params.getParams(pname));\n    }\n\n\n    //add in the content\n    addField(contentFieldName, catchAllBuilder.toString(), null);\n\n    //add in the captured content\n    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {\n      if (entry.getValue().length() > 0) {\n        addField(entry.getKey(), entry.getValue().toString(), null);\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Doc: \" + document);\n    }\n    return document;\n  }\n\n","sourceOld":"  /**\n   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding\n   * classes can use this hook to add in or change whatever they deem fit for the document at that time.\n   * The base implementation adds the metadata as fields, allowing for potential remapping.\n   *\n   * @return The {@link org.apache.solr.common.SolrInputDocument}.\n   */\n  public SolrInputDocument newDocument() {\n    float boost = 1.0f;\n    //handle the metadata extracted from the document\n    for (String name : metadata.names()) {\n      String[] vals = metadata.getValues(name);\n      addField(name, null, vals);\n    }\n\n    //handle the literals from the params\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String pname = paramNames.next();\n      if (!pname.startsWith(LITERALS_PREFIX)) continue;\n\n      String name = pname.substring(LITERALS_PREFIX.length());\n      addField(name, null, params.getParams(pname));\n    }\n\n\n    //add in the content\n    addField(contentFieldName, catchAllBuilder.toString(), null);\n\n    //add in the captured content\n    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {\n      if (entry.getValue().length() > 0) {\n        addField(entry.getKey(), entry.getValue().toString(), null);\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Doc: \" + document);\n    }\n    return document;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a75028b56df82c87510ec21c236855cc806a39a1":["46dfcd540005e76a7db876d494ac74e82c476523"],"eecdad1988b0b00f74f945528b689ef1eebf763d":["3a34495372f0709e1ee7051e94886274dc993443"],"3a34495372f0709e1ee7051e94886274dc993443":["a75028b56df82c87510ec21c236855cc806a39a1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["eecdad1988b0b00f74f945528b689ef1eebf763d"],"46dfcd540005e76a7db876d494ac74e82c476523":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a75028b56df82c87510ec21c236855cc806a39a1":["3a34495372f0709e1ee7051e94886274dc993443"],"eecdad1988b0b00f74f945528b689ef1eebf763d":["ad94625fb8d088209f46650c8097196fec67f00c"],"3a34495372f0709e1ee7051e94886274dc993443":["eecdad1988b0b00f74f945528b689ef1eebf763d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["46dfcd540005e76a7db876d494ac74e82c476523"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"46dfcd540005e76a7db876d494ac74e82c476523":["a75028b56df82c87510ec21c236855cc806a39a1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}