{"path":"lucene/core/src/java/org/apache/lucene/geo/Polygon#crossesSlowly(double,double,double,double).mjava","commits":[{"id":"82235a501cff963da53cb98d86009e33e15cf47f","date":1459788663,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/Polygon#crossesSlowly(double,double,double,double).mjava","pathOld":"/dev/null","sourceNew":"  private boolean crossesSlowly(double minLat, double maxLat, final double minLon, final double maxLon) {\n    /*\n     * Accurately compute (within restrictions of cartesian decimal degrees) whether a rectangle crosses a polygon\n     */\n    final double[] boxLats = new double[] { minLat, minLat, maxLat, maxLat, minLat };\n    final double[] boxLons = new double[] { minLon, maxLon, maxLon, minLon, minLon };\n\n    // computes the intersection point between each bbox edge and the polygon edge\n    for (int b=0; b<4; ++b) {\n      double a1 = boxLats[b+1]-boxLats[b];\n      double b1 = boxLons[b]-boxLons[b+1];\n      double c1 = a1*boxLons[b+1] + b1*boxLats[b+1];\n      for (int p=0; p<polyLons.length-1; ++p) {\n        double a2 = polyLats[p+1]-polyLats[p];\n        double b2 = polyLons[p]-polyLons[p+1];\n        // compute determinant\n        double d = a1*b2 - a2*b1;\n        if (d != 0) {\n          // lines are not parallel, check intersecting points\n          double c2 = a2*polyLons[p+1] + b2*polyLats[p+1];\n          double s = (1/d)*(b2*c1 - b1*c2);\n          // todo TOLERANCE SHOULD MATCH EVERYWHERE this is currently blocked by LUCENE-7165\n          double x00 = Math.min(boxLons[b], boxLons[b+1]) - ENCODING_TOLERANCE;\n          if (x00 > s) {\n            continue; // out of range\n          }\n          double x01 = Math.max(boxLons[b], boxLons[b+1]) + ENCODING_TOLERANCE;\n          if (x01 < s) {\n            continue; // out of range\n          }\n          double x10 = Math.min(polyLons[p], polyLons[p+1]) - ENCODING_TOLERANCE;\n          if (x10 > s) {\n            continue; // out of range\n          }\n          double x11 = Math.max(polyLons[p], polyLons[p+1]) + ENCODING_TOLERANCE;\n          if (x11 < s) {\n            continue; // out of range\n          }\n\n          double t = (1/d)*(a1*c2 - a2*c1);\n          double y00 = Math.min(boxLats[b], boxLats[b+1]) - ENCODING_TOLERANCE;\n          if (y00 > t || (x00 == s && y00 == t)) {\n            continue; // out of range or touching\n          }\n          double y01 = Math.max(boxLats[b], boxLats[b+1]) + ENCODING_TOLERANCE;\n          if (y01 < t || (x01 == s && y01 == t)) {\n            continue; // out of range or touching\n          }\n          double y10 = Math.min(polyLats[p], polyLats[p+1]) - ENCODING_TOLERANCE;\n          if (y10 > t || (x10 == s && y10 == t)) {\n            continue; // out of range or touching\n          }\n          double y11 = Math.max(polyLats[p], polyLats[p+1]) + ENCODING_TOLERANCE;\n          if (y11 < t || (x11 == s && y11 == t)) {\n            continue; // out of range or touching\n          }\n          // if line segments are not touching and the intersection point is within the range of either segment\n          return true;\n        }\n      } // for each poly edge\n    } // for each bbox edge\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09af2c9610ce53a4b25fd99344299b40318a4a1a","date":1459876565,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/Polygon#crossesSlowly(double,double,double,double).mjava","pathOld":"/dev/null","sourceNew":"  private boolean crossesSlowly(double minLat, double maxLat, final double minLon, final double maxLon) {\n    /*\n     * Accurately compute (within restrictions of cartesian decimal degrees) whether a rectangle crosses a polygon\n     */\n    final double[] boxLats = new double[] { minLat, minLat, maxLat, maxLat, minLat };\n    final double[] boxLons = new double[] { minLon, maxLon, maxLon, minLon, minLon };\n\n    // computes the intersection point between each bbox edge and the polygon edge\n    for (int b=0; b<4; ++b) {\n      double a1 = boxLats[b+1]-boxLats[b];\n      double b1 = boxLons[b]-boxLons[b+1];\n      double c1 = a1*boxLons[b+1] + b1*boxLats[b+1];\n      for (int p=0; p<polyLons.length-1; ++p) {\n        double a2 = polyLats[p+1]-polyLats[p];\n        double b2 = polyLons[p]-polyLons[p+1];\n        // compute determinant\n        double d = a1*b2 - a2*b1;\n        if (d != 0) {\n          // lines are not parallel, check intersecting points\n          double c2 = a2*polyLons[p+1] + b2*polyLats[p+1];\n          double s = (1/d)*(b2*c1 - b1*c2);\n          // todo TOLERANCE SHOULD MATCH EVERYWHERE this is currently blocked by LUCENE-7165\n          double x00 = Math.min(boxLons[b], boxLons[b+1]) - ENCODING_TOLERANCE;\n          if (x00 > s) {\n            continue; // out of range\n          }\n          double x01 = Math.max(boxLons[b], boxLons[b+1]) + ENCODING_TOLERANCE;\n          if (x01 < s) {\n            continue; // out of range\n          }\n          double x10 = Math.min(polyLons[p], polyLons[p+1]) - ENCODING_TOLERANCE;\n          if (x10 > s) {\n            continue; // out of range\n          }\n          double x11 = Math.max(polyLons[p], polyLons[p+1]) + ENCODING_TOLERANCE;\n          if (x11 < s) {\n            continue; // out of range\n          }\n\n          double t = (1/d)*(a1*c2 - a2*c1);\n          double y00 = Math.min(boxLats[b], boxLats[b+1]) - ENCODING_TOLERANCE;\n          if (y00 > t || (x00 == s && y00 == t)) {\n            continue; // out of range or touching\n          }\n          double y01 = Math.max(boxLats[b], boxLats[b+1]) + ENCODING_TOLERANCE;\n          if (y01 < t || (x01 == s && y01 == t)) {\n            continue; // out of range or touching\n          }\n          double y10 = Math.min(polyLats[p], polyLats[p+1]) - ENCODING_TOLERANCE;\n          if (y10 > t || (x10 == s && y10 == t)) {\n            continue; // out of range or touching\n          }\n          double y11 = Math.max(polyLats[p], polyLats[p+1]) + ENCODING_TOLERANCE;\n          if (y11 < t || (x11 == s && y11 == t)) {\n            continue; // out of range or touching\n          }\n          // if line segments are not touching and the intersection point is within the range of either segment\n          return true;\n        }\n      } // for each poly edge\n    } // for each bbox edge\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"932ec0540b719f95130a329c7a43bfc02ca1c20f","date":1461025360,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/Polygon#crossesSlowly(double,double,double,double).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/geo/Polygon#crossesSlowly(double,double,double,double).mjava","sourceNew":"  /** Returns true if the box crosses our polygon */\n  private boolean crossesSlowly(double minLat, double maxLat, double minLon, double maxLon) {\n    // we compute line intersections of every polygon edge with every box line.\n    // if we find one, return true.\n    // for each box line (AB):\n    //   for each poly line (CD):\n    //     intersects = orient(C,D,A) * orient(C,D,B) <= 0 && orient(A,B,C) * orient(A,B,D) <= 0\n    for (int i = 1; i < polyLons.length; i++) {\n      double cy = polyLats[i - 1];\n      double dy = polyLats[i];\n      double cx = polyLons[i - 1];\n      double dx = polyLons[i];\n\n      // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n      // if not, don't waste our time trying more complicated stuff\n      if ((cy < minLat && dy < minLat) ||\n          (cy > maxLat && dy > maxLat) ||\n          (cx < minLon && dx < minLon) ||\n          (cx > maxLon && dx > maxLon)) {\n        continue;\n      }\n\n      // does box's top edge intersect polyline?\n      // ax = minLon, bx = maxLon, ay = maxLat, by = maxLat\n      if (orient(cx, cy, dx, dy, minLon, maxLat) * orient(cx, cy, dx, dy, maxLon, maxLat) <= 0 &&\n          orient(minLon, maxLat, maxLon, maxLat, cx, cy) * orient(minLon, maxLat, maxLon, maxLat, dx, dy) <= 0) {\n        return true;\n      }\n\n      // does box's right edge intersect polyline?\n      // ax = maxLon, bx = maxLon, ay = maxLat, by = minLat\n      if (orient(cx, cy, dx, dy, maxLon, maxLat) * orient(cx, cy, dx, dy, maxLon, minLat) <= 0 &&\n          orient(maxLon, maxLat, maxLon, minLat, cx, cy) * orient(maxLon, maxLat, maxLon, minLat, dx, dy) <= 0) {\n        return true;\n      }\n\n      // does box's bottom edge intersect polyline?\n      // ax = maxLon, bx = minLon, ay = minLat, by = minLat\n      if (orient(cx, cy, dx, dy, maxLon, minLat) * orient(cx, cy, dx, dy, minLon, minLat) <= 0 &&\n          orient(maxLon, minLat, minLon, minLat, cx, cy) * orient(maxLon, minLat, minLon, minLat, dx, dy) <= 0) {\n        return true;\n      }\n\n      // does box's left edge intersect polyline?\n      // ax = minLon, bx = minLon, ay = minLat, by = maxLat\n      if (orient(cx, cy, dx, dy, minLon, minLat) * orient(cx, cy, dx, dy, minLon, maxLat) <= 0 &&\n          orient(minLon, minLat, minLon, maxLat, cx, cy) * orient(minLon, minLat, minLon, maxLat, dx, dy) <= 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  private boolean crossesSlowly(double minLat, double maxLat, final double minLon, final double maxLon) {\n    /*\n     * Accurately compute (within restrictions of cartesian decimal degrees) whether a rectangle crosses a polygon\n     */\n    final double[] boxLats = new double[] { minLat, minLat, maxLat, maxLat, minLat };\n    final double[] boxLons = new double[] { minLon, maxLon, maxLon, minLon, minLon };\n\n    // computes the intersection point between each bbox edge and the polygon edge\n    for (int b=0; b<4; ++b) {\n      double a1 = boxLats[b+1]-boxLats[b];\n      double b1 = boxLons[b]-boxLons[b+1];\n      double c1 = a1*boxLons[b+1] + b1*boxLats[b+1];\n      for (int p=0; p<polyLons.length-1; ++p) {\n        double a2 = polyLats[p+1]-polyLats[p];\n        double b2 = polyLons[p]-polyLons[p+1];\n        // compute determinant\n        double d = a1*b2 - a2*b1;\n        if (d != 0) {\n          // lines are not parallel, check intersecting points\n          double c2 = a2*polyLons[p+1] + b2*polyLats[p+1];\n          double s = (1/d)*(b2*c1 - b1*c2);\n          // todo TOLERANCE SHOULD MATCH EVERYWHERE this is currently blocked by LUCENE-7165\n          double x00 = Math.min(boxLons[b], boxLons[b+1]) - ENCODING_TOLERANCE;\n          if (x00 > s) {\n            continue; // out of range\n          }\n          double x01 = Math.max(boxLons[b], boxLons[b+1]) + ENCODING_TOLERANCE;\n          if (x01 < s) {\n            continue; // out of range\n          }\n          double x10 = Math.min(polyLons[p], polyLons[p+1]) - ENCODING_TOLERANCE;\n          if (x10 > s) {\n            continue; // out of range\n          }\n          double x11 = Math.max(polyLons[p], polyLons[p+1]) + ENCODING_TOLERANCE;\n          if (x11 < s) {\n            continue; // out of range\n          }\n\n          double t = (1/d)*(a1*c2 - a2*c1);\n          double y00 = Math.min(boxLats[b], boxLats[b+1]) - ENCODING_TOLERANCE;\n          if (y00 > t || (x00 == s && y00 == t)) {\n            continue; // out of range or touching\n          }\n          double y01 = Math.max(boxLats[b], boxLats[b+1]) + ENCODING_TOLERANCE;\n          if (y01 < t || (x01 == s && y01 == t)) {\n            continue; // out of range or touching\n          }\n          double y10 = Math.min(polyLats[p], polyLats[p+1]) - ENCODING_TOLERANCE;\n          if (y10 > t || (x10 == s && y10 == t)) {\n            continue; // out of range or touching\n          }\n          double y11 = Math.max(polyLats[p], polyLats[p+1]) + ENCODING_TOLERANCE;\n          if (y11 < t || (x11 == s && y11 == t)) {\n            continue; // out of range or touching\n          }\n          // if line segments are not touching and the intersection point is within the range of either segment\n          return true;\n        }\n      } // for each poly edge\n    } // for each bbox edge\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e15955b4980562a0c1c81d08654904f3fadb83b","date":1461068916,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/Polygon#crossesSlowly(double,double,double,double).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/geo/Polygon#crossesSlowly(double,double,double,double).mjava","sourceNew":"  /** Returns true if the box crosses our polygon */\n  private boolean crossesSlowly(double minLat, double maxLat, double minLon, double maxLon) {\n    // we compute line intersections of every polygon edge with every box line.\n    // if we find one, return true.\n    // for each box line (AB):\n    //   for each poly line (CD):\n    //     intersects = orient(C,D,A) * orient(C,D,B) <= 0 && orient(A,B,C) * orient(A,B,D) <= 0\n    for (int i = 1; i < polyLons.length; i++) {\n      double cy = polyLats[i - 1];\n      double dy = polyLats[i];\n      double cx = polyLons[i - 1];\n      double dx = polyLons[i];\n\n      // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n      // if not, don't waste our time trying more complicated stuff\n      if ((cy < minLat && dy < minLat) ||\n          (cy > maxLat && dy > maxLat) ||\n          (cx < minLon && dx < minLon) ||\n          (cx > maxLon && dx > maxLon)) {\n        continue;\n      }\n\n      // does box's top edge intersect polyline?\n      // ax = minLon, bx = maxLon, ay = maxLat, by = maxLat\n      if (orient(cx, cy, dx, dy, minLon, maxLat) * orient(cx, cy, dx, dy, maxLon, maxLat) <= 0 &&\n          orient(minLon, maxLat, maxLon, maxLat, cx, cy) * orient(minLon, maxLat, maxLon, maxLat, dx, dy) <= 0) {\n        return true;\n      }\n\n      // does box's right edge intersect polyline?\n      // ax = maxLon, bx = maxLon, ay = maxLat, by = minLat\n      if (orient(cx, cy, dx, dy, maxLon, maxLat) * orient(cx, cy, dx, dy, maxLon, minLat) <= 0 &&\n          orient(maxLon, maxLat, maxLon, minLat, cx, cy) * orient(maxLon, maxLat, maxLon, minLat, dx, dy) <= 0) {\n        return true;\n      }\n\n      // does box's bottom edge intersect polyline?\n      // ax = maxLon, bx = minLon, ay = minLat, by = minLat\n      if (orient(cx, cy, dx, dy, maxLon, minLat) * orient(cx, cy, dx, dy, minLon, minLat) <= 0 &&\n          orient(maxLon, minLat, minLon, minLat, cx, cy) * orient(maxLon, minLat, minLon, minLat, dx, dy) <= 0) {\n        return true;\n      }\n\n      // does box's left edge intersect polyline?\n      // ax = minLon, bx = minLon, ay = minLat, by = maxLat\n      if (orient(cx, cy, dx, dy, minLon, minLat) * orient(cx, cy, dx, dy, minLon, maxLat) <= 0 &&\n          orient(minLon, minLat, minLon, maxLat, cx, cy) * orient(minLon, minLat, minLon, maxLat, dx, dy) <= 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  private boolean crossesSlowly(double minLat, double maxLat, final double minLon, final double maxLon) {\n    /*\n     * Accurately compute (within restrictions of cartesian decimal degrees) whether a rectangle crosses a polygon\n     */\n    final double[] boxLats = new double[] { minLat, minLat, maxLat, maxLat, minLat };\n    final double[] boxLons = new double[] { minLon, maxLon, maxLon, minLon, minLon };\n\n    // computes the intersection point between each bbox edge and the polygon edge\n    for (int b=0; b<4; ++b) {\n      double a1 = boxLats[b+1]-boxLats[b];\n      double b1 = boxLons[b]-boxLons[b+1];\n      double c1 = a1*boxLons[b+1] + b1*boxLats[b+1];\n      for (int p=0; p<polyLons.length-1; ++p) {\n        double a2 = polyLats[p+1]-polyLats[p];\n        double b2 = polyLons[p]-polyLons[p+1];\n        // compute determinant\n        double d = a1*b2 - a2*b1;\n        if (d != 0) {\n          // lines are not parallel, check intersecting points\n          double c2 = a2*polyLons[p+1] + b2*polyLats[p+1];\n          double s = (1/d)*(b2*c1 - b1*c2);\n          // todo TOLERANCE SHOULD MATCH EVERYWHERE this is currently blocked by LUCENE-7165\n          double x00 = Math.min(boxLons[b], boxLons[b+1]) - ENCODING_TOLERANCE;\n          if (x00 > s) {\n            continue; // out of range\n          }\n          double x01 = Math.max(boxLons[b], boxLons[b+1]) + ENCODING_TOLERANCE;\n          if (x01 < s) {\n            continue; // out of range\n          }\n          double x10 = Math.min(polyLons[p], polyLons[p+1]) - ENCODING_TOLERANCE;\n          if (x10 > s) {\n            continue; // out of range\n          }\n          double x11 = Math.max(polyLons[p], polyLons[p+1]) + ENCODING_TOLERANCE;\n          if (x11 < s) {\n            continue; // out of range\n          }\n\n          double t = (1/d)*(a1*c2 - a2*c1);\n          double y00 = Math.min(boxLats[b], boxLats[b+1]) - ENCODING_TOLERANCE;\n          if (y00 > t || (x00 == s && y00 == t)) {\n            continue; // out of range or touching\n          }\n          double y01 = Math.max(boxLats[b], boxLats[b+1]) + ENCODING_TOLERANCE;\n          if (y01 < t || (x01 == s && y01 == t)) {\n            continue; // out of range or touching\n          }\n          double y10 = Math.min(polyLats[p], polyLats[p+1]) - ENCODING_TOLERANCE;\n          if (y10 > t || (x10 == s && y10 == t)) {\n            continue; // out of range or touching\n          }\n          double y11 = Math.max(polyLats[p], polyLats[p+1]) + ENCODING_TOLERANCE;\n          if (y11 < t || (x11 == s && y11 == t)) {\n            continue; // out of range or touching\n          }\n          // if line segments are not touching and the intersection point is within the range of either segment\n          return true;\n        }\n      } // for each poly edge\n    } // for each bbox edge\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"925fce43f3bac029d912b9b7de03c789e258a333","date":1461612714,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/geo/Polygon#crossesSlowly(double,double,double,double).mjava","sourceNew":null,"sourceOld":"  /** Returns true if the box crosses our polygon */\n  private boolean crossesSlowly(double minLat, double maxLat, double minLon, double maxLon) {\n    // we compute line intersections of every polygon edge with every box line.\n    // if we find one, return true.\n    // for each box line (AB):\n    //   for each poly line (CD):\n    //     intersects = orient(C,D,A) * orient(C,D,B) <= 0 && orient(A,B,C) * orient(A,B,D) <= 0\n    for (int i = 1; i < polyLons.length; i++) {\n      double cy = polyLats[i - 1];\n      double dy = polyLats[i];\n      double cx = polyLons[i - 1];\n      double dx = polyLons[i];\n\n      // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n      // if not, don't waste our time trying more complicated stuff\n      if ((cy < minLat && dy < minLat) ||\n          (cy > maxLat && dy > maxLat) ||\n          (cx < minLon && dx < minLon) ||\n          (cx > maxLon && dx > maxLon)) {\n        continue;\n      }\n\n      // does box's top edge intersect polyline?\n      // ax = minLon, bx = maxLon, ay = maxLat, by = maxLat\n      if (orient(cx, cy, dx, dy, minLon, maxLat) * orient(cx, cy, dx, dy, maxLon, maxLat) <= 0 &&\n          orient(minLon, maxLat, maxLon, maxLat, cx, cy) * orient(minLon, maxLat, maxLon, maxLat, dx, dy) <= 0) {\n        return true;\n      }\n\n      // does box's right edge intersect polyline?\n      // ax = maxLon, bx = maxLon, ay = maxLat, by = minLat\n      if (orient(cx, cy, dx, dy, maxLon, maxLat) * orient(cx, cy, dx, dy, maxLon, minLat) <= 0 &&\n          orient(maxLon, maxLat, maxLon, minLat, cx, cy) * orient(maxLon, maxLat, maxLon, minLat, dx, dy) <= 0) {\n        return true;\n      }\n\n      // does box's bottom edge intersect polyline?\n      // ax = maxLon, bx = minLon, ay = minLat, by = minLat\n      if (orient(cx, cy, dx, dy, maxLon, minLat) * orient(cx, cy, dx, dy, minLon, minLat) <= 0 &&\n          orient(maxLon, minLat, minLon, minLat, cx, cy) * orient(maxLon, minLat, minLon, minLat, dx, dy) <= 0) {\n        return true;\n      }\n\n      // does box's left edge intersect polyline?\n      // ax = minLon, bx = minLon, ay = minLat, by = maxLat\n      if (orient(cx, cy, dx, dy, minLon, minLat) * orient(cx, cy, dx, dy, minLon, maxLat) <= 0 &&\n          orient(minLon, minLat, minLon, maxLat, cx, cy) * orient(minLon, minLat, minLon, maxLat, dx, dy) <= 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/geo/Polygon#crossesSlowly(double,double,double,double).mjava","sourceNew":null,"sourceOld":"  /** Returns true if the box crosses our polygon */\n  private boolean crossesSlowly(double minLat, double maxLat, double minLon, double maxLon) {\n    // we compute line intersections of every polygon edge with every box line.\n    // if we find one, return true.\n    // for each box line (AB):\n    //   for each poly line (CD):\n    //     intersects = orient(C,D,A) * orient(C,D,B) <= 0 && orient(A,B,C) * orient(A,B,D) <= 0\n    for (int i = 1; i < polyLons.length; i++) {\n      double cy = polyLats[i - 1];\n      double dy = polyLats[i];\n      double cx = polyLons[i - 1];\n      double dx = polyLons[i];\n\n      // optimization: see if the rectangle is outside of the \"bounding box\" of the polyline at all\n      // if not, don't waste our time trying more complicated stuff\n      if ((cy < minLat && dy < minLat) ||\n          (cy > maxLat && dy > maxLat) ||\n          (cx < minLon && dx < minLon) ||\n          (cx > maxLon && dx > maxLon)) {\n        continue;\n      }\n\n      // does box's top edge intersect polyline?\n      // ax = minLon, bx = maxLon, ay = maxLat, by = maxLat\n      if (orient(cx, cy, dx, dy, minLon, maxLat) * orient(cx, cy, dx, dy, maxLon, maxLat) <= 0 &&\n          orient(minLon, maxLat, maxLon, maxLat, cx, cy) * orient(minLon, maxLat, maxLon, maxLat, dx, dy) <= 0) {\n        return true;\n      }\n\n      // does box's right edge intersect polyline?\n      // ax = maxLon, bx = maxLon, ay = maxLat, by = minLat\n      if (orient(cx, cy, dx, dy, maxLon, maxLat) * orient(cx, cy, dx, dy, maxLon, minLat) <= 0 &&\n          orient(maxLon, maxLat, maxLon, minLat, cx, cy) * orient(maxLon, maxLat, maxLon, minLat, dx, dy) <= 0) {\n        return true;\n      }\n\n      // does box's bottom edge intersect polyline?\n      // ax = maxLon, bx = minLon, ay = minLat, by = minLat\n      if (orient(cx, cy, dx, dy, maxLon, minLat) * orient(cx, cy, dx, dy, minLon, minLat) <= 0 &&\n          orient(maxLon, minLat, minLon, minLat, cx, cy) * orient(maxLon, minLat, minLon, minLat, dx, dy) <= 0) {\n        return true;\n      }\n\n      // does box's left edge intersect polyline?\n      // ax = minLon, bx = minLon, ay = minLat, by = maxLat\n      if (orient(cx, cy, dx, dy, minLon, minLat) * orient(cx, cy, dx, dy, minLon, maxLat) <= 0 &&\n          orient(minLon, minLat, minLon, maxLat, cx, cy) * orient(minLon, minLat, minLon, maxLat, dx, dy) <= 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"82235a501cff963da53cb98d86009e33e15cf47f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","82235a501cff963da53cb98d86009e33e15cf47f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["0e15955b4980562a0c1c81d08654904f3fadb83b","925fce43f3bac029d912b9b7de03c789e258a333"],"0e15955b4980562a0c1c81d08654904f3fadb83b":["82235a501cff963da53cb98d86009e33e15cf47f","932ec0540b719f95130a329c7a43bfc02ca1c20f"],"932ec0540b719f95130a329c7a43bfc02ca1c20f":["82235a501cff963da53cb98d86009e33e15cf47f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"925fce43f3bac029d912b9b7de03c789e258a333":["0e15955b4980562a0c1c81d08654904f3fadb83b"]},"commit2Childs":{"82235a501cff963da53cb98d86009e33e15cf47f":["09af2c9610ce53a4b25fd99344299b40318a4a1a","0e15955b4980562a0c1c81d08654904f3fadb83b","932ec0540b719f95130a329c7a43bfc02ca1c20f"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["82235a501cff963da53cb98d86009e33e15cf47f","09af2c9610ce53a4b25fd99344299b40318a4a1a"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0e15955b4980562a0c1c81d08654904f3fadb83b":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","925fce43f3bac029d912b9b7de03c789e258a333"],"932ec0540b719f95130a329c7a43bfc02ca1c20f":["0e15955b4980562a0c1c81d08654904f3fadb83b"],"925fce43f3bac029d912b9b7de03c789e258a333":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09af2c9610ce53a4b25fd99344299b40318a4a1a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}