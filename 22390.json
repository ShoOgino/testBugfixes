{"path":"solr/core/src/test/org/apache/solr/legacy/TestMultiValuedNumericRangeQuery#testMultiValuedNRQ().mjava","commits":[{"id":"a178ac3dec643551e66363c457a9074f55545f86","date":1496133188,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/legacy/TestMultiValuedNumericRangeQuery#testMultiValuedNRQ().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/legacy/TestMultiValuedNumericRangeQuery#testMultiValuedNRQ().mjava","sourceNew":"  /** Tests LegacyNumericRangeQuery on a multi-valued field (multiple numeric values per document).\n   * This test ensures, that a classical TermRangeQuery returns exactly the same document numbers as\n   * LegacyNumericRangeQuery (see SOLR-1322 for discussion) and the multiple precision terms per numeric value\n   * do not interfere with multiple numeric values.\n   */\n  public void testMultiValuedNRQ() throws Exception {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000)));\n    \n    DecimalFormat format = new DecimalFormat(\"00000000000\", new DecimalFormatSymbols(Locale.ROOT));\n    \n    int num = atLeast(500);\n    for (int l = 0; l < num; l++) {\n      Document doc = new Document();\n      for (int m=0, c=random().nextInt(10); m<=c; m++) {\n        int value = random().nextInt(Integer.MAX_VALUE);\n        doc.add(newStringField(\"asc\", format.format(value), Field.Store.NO));\n        doc.add(new LegacyIntField(\"trie\", value, Field.Store.NO));\n      }\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    \n    IndexSearcher searcher=newSearcher(reader);\n    num = atLeast(50);\n    for (int i = 0; i < num; i++) {\n      int lower=random().nextInt(Integer.MAX_VALUE);\n      int upper=random().nextInt(Integer.MAX_VALUE);\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      TermRangeQuery cq=TermRangeQuery.newStringRange(\"asc\", format.format(lower), format.format(upper), true, true);\n      LegacyNumericRangeQuery<Integer> tq= LegacyNumericRangeQuery.newIntRange(\"trie\", lower, upper, true, true);\n      TopDocs trTopDocs = searcher.search(cq, 1);\n      TopDocs nrTopDocs = searcher.search(tq, 1);\n      assertEquals(\"Returned count for LegacyNumericRangeQuery and TermRangeQuery must be equal\", trTopDocs.totalHits, nrTopDocs.totalHits );\n    }\n    reader.close();\n    directory.close();\n  }\n\n","sourceOld":"  /** Tests LegacyNumericRangeQuery on a multi-valued field (multiple numeric values per document).\n   * This test ensures, that a classical TermRangeQuery returns exactly the same document numbers as\n   * LegacyNumericRangeQuery (see SOLR-1322 for discussion) and the multiple precision terms per numeric value\n   * do not interfere with multiple numeric values.\n   */\n  public void testMultiValuedNRQ() throws Exception {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000)));\n    \n    DecimalFormat format = new DecimalFormat(\"00000000000\", new DecimalFormatSymbols(Locale.ROOT));\n    \n    int num = atLeast(500);\n    for (int l = 0; l < num; l++) {\n      Document doc = new Document();\n      for (int m=0, c=random().nextInt(10); m<=c; m++) {\n        int value = random().nextInt(Integer.MAX_VALUE);\n        doc.add(newStringField(\"asc\", format.format(value), Field.Store.NO));\n        doc.add(new LegacyIntField(\"trie\", value, Field.Store.NO));\n      }\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    \n    IndexSearcher searcher=newSearcher(reader);\n    num = atLeast(50);\n    for (int i = 0; i < num; i++) {\n      int lower=random().nextInt(Integer.MAX_VALUE);\n      int upper=random().nextInt(Integer.MAX_VALUE);\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      TermRangeQuery cq=TermRangeQuery.newStringRange(\"asc\", format.format(lower), format.format(upper), true, true);\n      LegacyNumericRangeQuery<Integer> tq= LegacyNumericRangeQuery.newIntRange(\"trie\", lower, upper, true, true);\n      TopDocs trTopDocs = searcher.search(cq, 1);\n      TopDocs nrTopDocs = searcher.search(tq, 1);\n      assertEquals(\"Returned count for LegacyNumericRangeQuery and TermRangeQuery must be equal\", trTopDocs.totalHits, nrTopDocs.totalHits );\n    }\n    reader.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1f5728f32a4a256b36cfabd7a2636452f599bb9","date":1496231774,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/legacy/TestMultiValuedNumericRangeQuery#testMultiValuedNRQ().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/legacy/TestMultiValuedNumericRangeQuery#testMultiValuedNRQ().mjava","sourceNew":"  /** Tests LegacyNumericRangeQuery on a multi-valued field (multiple numeric values per document).\n   * This test ensures, that a classical TermRangeQuery returns exactly the same document numbers as\n   * LegacyNumericRangeQuery (see SOLR-1322 for discussion) and the multiple precision terms per numeric value\n   * do not interfere with multiple numeric values.\n   */\n  public void testMultiValuedNRQ() throws Exception {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000)));\n    \n    DecimalFormat format = new DecimalFormat(\"00000000000\", new DecimalFormatSymbols(Locale.ROOT));\n    \n    int num = atLeast(500);\n    for (int l = 0; l < num; l++) {\n      Document doc = new Document();\n      for (int m=0, c=random().nextInt(10); m<=c; m++) {\n        int value = random().nextInt(Integer.MAX_VALUE);\n        doc.add(newStringField(\"asc\", format.format(value), Field.Store.NO));\n        doc.add(new LegacyIntField(\"trie\", value, Field.Store.NO));\n      }\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    \n    IndexSearcher searcher=newSearcher(reader);\n    num = atLeast(50);\n    for (int i = 0; i < num; i++) {\n      int lower=random().nextInt(Integer.MAX_VALUE);\n      int upper=random().nextInt(Integer.MAX_VALUE);\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      TermRangeQuery cq=TermRangeQuery.newStringRange(\"asc\", format.format(lower), format.format(upper), true, true);\n      LegacyNumericRangeQuery<Integer> tq= LegacyNumericRangeQuery.newIntRange(\"trie\", lower, upper, true, true);\n      TopDocs trTopDocs = searcher.search(cq, 1);\n      TopDocs nrTopDocs = searcher.search(tq, 1);\n      assertEquals(\"Returned count for LegacyNumericRangeQuery and TermRangeQuery must be equal\", trTopDocs.totalHits, nrTopDocs.totalHits );\n    }\n    reader.close();\n    directory.close();\n  }\n\n","sourceOld":"  /** Tests LegacyNumericRangeQuery on a multi-valued field (multiple numeric values per document).\n   * This test ensures, that a classical TermRangeQuery returns exactly the same document numbers as\n   * LegacyNumericRangeQuery (see SOLR-1322 for discussion) and the multiple precision terms per numeric value\n   * do not interfere with multiple numeric values.\n   */\n  public void testMultiValuedNRQ() throws Exception {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000)));\n    \n    DecimalFormat format = new DecimalFormat(\"00000000000\", new DecimalFormatSymbols(Locale.ROOT));\n    \n    int num = atLeast(500);\n    for (int l = 0; l < num; l++) {\n      Document doc = new Document();\n      for (int m=0, c=random().nextInt(10); m<=c; m++) {\n        int value = random().nextInt(Integer.MAX_VALUE);\n        doc.add(newStringField(\"asc\", format.format(value), Field.Store.NO));\n        doc.add(new LegacyIntField(\"trie\", value, Field.Store.NO));\n      }\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    \n    IndexSearcher searcher=newSearcher(reader);\n    num = atLeast(50);\n    for (int i = 0; i < num; i++) {\n      int lower=random().nextInt(Integer.MAX_VALUE);\n      int upper=random().nextInt(Integer.MAX_VALUE);\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      TermRangeQuery cq=TermRangeQuery.newStringRange(\"asc\", format.format(lower), format.format(upper), true, true);\n      LegacyNumericRangeQuery<Integer> tq= LegacyNumericRangeQuery.newIntRange(\"trie\", lower, upper, true, true);\n      TopDocs trTopDocs = searcher.search(cq, 1);\n      TopDocs nrTopDocs = searcher.search(tq, 1);\n      assertEquals(\"Returned count for LegacyNumericRangeQuery and TermRangeQuery must be equal\", trTopDocs.totalHits, nrTopDocs.totalHits );\n    }\n    reader.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":1,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/legacy/TestMultiValuedNumericRangeQuery#testMultiValuedNRQ().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/legacy/TestMultiValuedNumericRangeQuery#testMultiValuedNRQ().mjava","sourceNew":"  /** Tests LegacyNumericRangeQuery on a multi-valued field (multiple numeric values per document).\n   * This test ensures, that a classical TermRangeQuery returns exactly the same document numbers as\n   * LegacyNumericRangeQuery (see SOLR-1322 for discussion) and the multiple precision terms per numeric value\n   * do not interfere with multiple numeric values.\n   */\n  public void testMultiValuedNRQ() throws Exception {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000)));\n    \n    DecimalFormat format = new DecimalFormat(\"00000000000\", new DecimalFormatSymbols(Locale.ROOT));\n    \n    int num = atLeast(500);\n    for (int l = 0; l < num; l++) {\n      Document doc = new Document();\n      for (int m=0, c=random().nextInt(10); m<=c; m++) {\n        int value = random().nextInt(Integer.MAX_VALUE);\n        doc.add(newStringField(\"asc\", format.format(value), Field.Store.NO));\n        doc.add(new LegacyIntField(\"trie\", value, Field.Store.NO));\n      }\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    \n    IndexSearcher searcher=newSearcher(reader);\n    num = atLeast(50);\n    for (int i = 0; i < num; i++) {\n      int lower=random().nextInt(Integer.MAX_VALUE);\n      int upper=random().nextInt(Integer.MAX_VALUE);\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      TermRangeQuery cq=TermRangeQuery.newStringRange(\"asc\", format.format(lower), format.format(upper), true, true);\n      LegacyNumericRangeQuery<Integer> tq= LegacyNumericRangeQuery.newIntRange(\"trie\", lower, upper, true, true);\n      TopDocs trTopDocs = searcher.search(cq, 1);\n      TopDocs nrTopDocs = searcher.search(tq, 1);\n      assertEquals(\"Returned count for LegacyNumericRangeQuery and TermRangeQuery must be equal\", trTopDocs.totalHits, nrTopDocs.totalHits );\n    }\n    reader.close();\n    directory.close();\n  }\n\n","sourceOld":"  /** Tests LegacyNumericRangeQuery on a multi-valued field (multiple numeric values per document).\n   * This test ensures, that a classical TermRangeQuery returns exactly the same document numbers as\n   * LegacyNumericRangeQuery (see SOLR-1322 for discussion) and the multiple precision terms per numeric value\n   * do not interfere with multiple numeric values.\n   */\n  public void testMultiValuedNRQ() throws Exception {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000)));\n    \n    DecimalFormat format = new DecimalFormat(\"00000000000\", new DecimalFormatSymbols(Locale.ROOT));\n    \n    int num = atLeast(500);\n    for (int l = 0; l < num; l++) {\n      Document doc = new Document();\n      for (int m=0, c=random().nextInt(10); m<=c; m++) {\n        int value = random().nextInt(Integer.MAX_VALUE);\n        doc.add(newStringField(\"asc\", format.format(value), Field.Store.NO));\n        doc.add(new LegacyIntField(\"trie\", value, Field.Store.NO));\n      }\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    \n    IndexSearcher searcher=newSearcher(reader);\n    num = atLeast(50);\n    for (int i = 0; i < num; i++) {\n      int lower=random().nextInt(Integer.MAX_VALUE);\n      int upper=random().nextInt(Integer.MAX_VALUE);\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      TermRangeQuery cq=TermRangeQuery.newStringRange(\"asc\", format.format(lower), format.format(upper), true, true);\n      LegacyNumericRangeQuery<Integer> tq= LegacyNumericRangeQuery.newIntRange(\"trie\", lower, upper, true, true);\n      TopDocs trTopDocs = searcher.search(cq, 1);\n      TopDocs nrTopDocs = searcher.search(tq, 1);\n      assertEquals(\"Returned count for LegacyNumericRangeQuery and TermRangeQuery must be equal\", trTopDocs.totalHits, nrTopDocs.totalHits );\n    }\n    reader.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/legacy/TestMultiValuedNumericRangeQuery#testMultiValuedNRQ().mjava","pathOld":"solr/core/src/test/org/apache/solr/legacy/TestMultiValuedNumericRangeQuery#testMultiValuedNRQ().mjava","sourceNew":"  /** Tests LegacyNumericRangeQuery on a multi-valued field (multiple numeric values per document).\n   * This test ensures, that a classical TermRangeQuery returns exactly the same document numbers as\n   * LegacyNumericRangeQuery (see SOLR-1322 for discussion) and the multiple precision terms per numeric value\n   * do not interfere with multiple numeric values.\n   */\n  public void testMultiValuedNRQ() throws Exception {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000)));\n    \n    DecimalFormat format = new DecimalFormat(\"00000000000\", new DecimalFormatSymbols(Locale.ROOT));\n    \n    int num = atLeast(500);\n    for (int l = 0; l < num; l++) {\n      Document doc = new Document();\n      for (int m=0, c=random().nextInt(10); m<=c; m++) {\n        int value = random().nextInt(Integer.MAX_VALUE);\n        doc.add(newStringField(\"asc\", format.format(value), Field.Store.NO));\n        doc.add(new LegacyIntField(\"trie\", value, Field.Store.NO));\n      }\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    \n    IndexSearcher searcher=newSearcher(reader);\n    num = atLeast(50);\n    for (int i = 0; i < num; i++) {\n      int lower=random().nextInt(Integer.MAX_VALUE);\n      int upper=random().nextInt(Integer.MAX_VALUE);\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      TermRangeQuery cq=TermRangeQuery.newStringRange(\"asc\", format.format(lower), format.format(upper), true, true);\n      LegacyNumericRangeQuery<Integer> tq= LegacyNumericRangeQuery.newIntRange(\"trie\", lower, upper, true, true);\n      TopDocs trTopDocs = searcher.search(cq, 1);\n      TopDocs nrTopDocs = searcher.search(tq, 1);\n      assertEquals(\"Returned count for LegacyNumericRangeQuery and TermRangeQuery must be equal\", trTopDocs.totalHits.value, nrTopDocs.totalHits.value );\n    }\n    reader.close();\n    directory.close();\n  }\n\n","sourceOld":"  /** Tests LegacyNumericRangeQuery on a multi-valued field (multiple numeric values per document).\n   * This test ensures, that a classical TermRangeQuery returns exactly the same document numbers as\n   * LegacyNumericRangeQuery (see SOLR-1322 for discussion) and the multiple precision terms per numeric value\n   * do not interfere with multiple numeric values.\n   */\n  public void testMultiValuedNRQ() throws Exception {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000)));\n    \n    DecimalFormat format = new DecimalFormat(\"00000000000\", new DecimalFormatSymbols(Locale.ROOT));\n    \n    int num = atLeast(500);\n    for (int l = 0; l < num; l++) {\n      Document doc = new Document();\n      for (int m=0, c=random().nextInt(10); m<=c; m++) {\n        int value = random().nextInt(Integer.MAX_VALUE);\n        doc.add(newStringField(\"asc\", format.format(value), Field.Store.NO));\n        doc.add(new LegacyIntField(\"trie\", value, Field.Store.NO));\n      }\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    \n    IndexSearcher searcher=newSearcher(reader);\n    num = atLeast(50);\n    for (int i = 0; i < num; i++) {\n      int lower=random().nextInt(Integer.MAX_VALUE);\n      int upper=random().nextInt(Integer.MAX_VALUE);\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      TermRangeQuery cq=TermRangeQuery.newStringRange(\"asc\", format.format(lower), format.format(upper), true, true);\n      LegacyNumericRangeQuery<Integer> tq= LegacyNumericRangeQuery.newIntRange(\"trie\", lower, upper, true, true);\n      TopDocs trTopDocs = searcher.search(cq, 1);\n      TopDocs nrTopDocs = searcher.search(tq, 1);\n      assertEquals(\"Returned count for LegacyNumericRangeQuery and TermRangeQuery must be equal\", trTopDocs.totalHits, nrTopDocs.totalHits );\n    }\n    reader.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a29e7cea4c01224ee9be13d9f2dfc42e3b446ffd","date":1542616968,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/legacy/TestMultiValuedNumericRangeQuery#testMultiValuedNRQ().mjava","pathOld":"solr/core/src/test/org/apache/solr/legacy/TestMultiValuedNumericRangeQuery#testMultiValuedNRQ().mjava","sourceNew":"  /** Tests LegacyNumericRangeQuery on a multi-valued field (multiple numeric values per document).\n   * This test ensures, that a classical TermRangeQuery returns exactly the same document numbers as\n   * LegacyNumericRangeQuery (see SOLR-1322 for discussion) and the multiple precision terms per numeric value\n   * do not interfere with multiple numeric values.\n   */\n  public void testMultiValuedNRQ() throws Exception {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000)));\n    \n    DecimalFormat format = new DecimalFormat(\"00000000000\", new DecimalFormatSymbols(Locale.ROOT));\n    \n    int num = atLeast(500);\n    for (int l = 0; l < num; l++) {\n      Document doc = new Document();\n      for (int m=0, c=random().nextInt(10); m<=c; m++) {\n        int value = random().nextInt(Integer.MAX_VALUE);\n        doc.add(newStringField(\"asc\", format.format(value), Field.Store.NO));\n        doc.add(new LegacyIntField(\"trie\", value, Field.Store.NO));\n      }\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    \n    IndexSearcher searcher=newSearcher(reader);\n    num = atLeast(50);\n    for (int i = 0; i < num; i++) {\n      int lower=random().nextInt(Integer.MAX_VALUE);\n      int upper=random().nextInt(Integer.MAX_VALUE);\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      TermRangeQuery cq=TermRangeQuery.newStringRange(\"asc\", format.format(lower), format.format(upper), true, true);\n      LegacyNumericRangeQuery<Integer> tq= LegacyNumericRangeQuery.newIntRange(\"trie\", lower, upper, true, true);\n      TopScoreDocCollector trCollector = TopScoreDocCollector.create(1, Integer.MAX_VALUE);\n      TopScoreDocCollector nrCollector = TopScoreDocCollector.create(1, Integer.MAX_VALUE);\n      searcher.search(cq, trCollector);\n      searcher.search(tq, nrCollector);\n      TopDocs trTopDocs = trCollector.topDocs();\n      TopDocs nrTopDocs = nrCollector.topDocs();\n      assertEquals(\"Returned count for LegacyNumericRangeQuery and TermRangeQuery must be equal\", trTopDocs.totalHits.value, nrTopDocs.totalHits.value );\n    }\n    reader.close();\n    directory.close();\n  }\n\n","sourceOld":"  /** Tests LegacyNumericRangeQuery on a multi-valued field (multiple numeric values per document).\n   * This test ensures, that a classical TermRangeQuery returns exactly the same document numbers as\n   * LegacyNumericRangeQuery (see SOLR-1322 for discussion) and the multiple precision terms per numeric value\n   * do not interfere with multiple numeric values.\n   */\n  public void testMultiValuedNRQ() throws Exception {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000)));\n    \n    DecimalFormat format = new DecimalFormat(\"00000000000\", new DecimalFormatSymbols(Locale.ROOT));\n    \n    int num = atLeast(500);\n    for (int l = 0; l < num; l++) {\n      Document doc = new Document();\n      for (int m=0, c=random().nextInt(10); m<=c; m++) {\n        int value = random().nextInt(Integer.MAX_VALUE);\n        doc.add(newStringField(\"asc\", format.format(value), Field.Store.NO));\n        doc.add(new LegacyIntField(\"trie\", value, Field.Store.NO));\n      }\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    \n    IndexSearcher searcher=newSearcher(reader);\n    num = atLeast(50);\n    for (int i = 0; i < num; i++) {\n      int lower=random().nextInt(Integer.MAX_VALUE);\n      int upper=random().nextInt(Integer.MAX_VALUE);\n      if (lower>upper) {\n        int a=lower; lower=upper; upper=a;\n      }\n      TermRangeQuery cq=TermRangeQuery.newStringRange(\"asc\", format.format(lower), format.format(upper), true, true);\n      LegacyNumericRangeQuery<Integer> tq= LegacyNumericRangeQuery.newIntRange(\"trie\", lower, upper, true, true);\n      TopDocs trTopDocs = searcher.search(cq, 1);\n      TopDocs nrTopDocs = searcher.search(tq, 1);\n      assertEquals(\"Returned count for LegacyNumericRangeQuery and TermRangeQuery must be equal\", trTopDocs.totalHits.value, nrTopDocs.totalHits.value );\n    }\n    reader.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a178ac3dec643551e66363c457a9074f55545f86":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a178ac3dec643551e66363c457a9074f55545f86"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a29e7cea4c01224ee9be13d9f2dfc42e3b446ffd":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a178ac3dec643551e66363c457a9074f55545f86"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a29e7cea4c01224ee9be13d9f2dfc42e3b446ffd"]},"commit2Childs":{"a178ac3dec643551e66363c457a9074f55545f86":["e9017cf144952056066919f1ebc7897ff9bd71b1","d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a178ac3dec643551e66363c457a9074f55545f86","e9017cf144952056066919f1ebc7897ff9bd71b1","d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"a29e7cea4c01224ee9be13d9f2dfc42e3b446ffd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["a29e7cea4c01224ee9be13d9f2dfc42e3b446ffd"],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}