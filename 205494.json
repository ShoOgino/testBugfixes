{"path":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random.nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(4)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      assertTrue(size >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random.nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(4)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      assertTrue(size >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(4)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      assertTrue(size >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random.nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(4)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      assertTrue(size >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e721522f9692a64e877e34a4467f58dbeba866eb","date":1340444282,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      assertTrue(size >= c);\n      assertTrue(c >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(4)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      assertTrue(size >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      assertTrue(size >= c);\n      assertTrue(c >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(4)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      assertTrue(size >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c8719b2c0b382be11f5b193b6fc14bc310e906b","date":1344770591,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      assertTrue(size >= c);\n      assertTrue(c >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      assertTrue(size >= c);\n      assertTrue(c >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24acb08412c25718ab57aac08306395faa2cd933","date":1344784256,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      final int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      assertTrue(size >= c);\n      assertTrue(c >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":["a8363efa169b169f300a07252db8fdec6ebfe48f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      final int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      assertTrue(size >= c);\n      assertTrue(c >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      final int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      assertTrue(size >= c);\n      assertTrue(c >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8363efa169b169f300a07252db8fdec6ebfe48f","date":1349387906,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=newSize(\"+newSize+\")\", size >= newSize);\n      size = newSize;\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      final int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":["24acb08412c25718ab57aac08306395faa2cd933"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          @Override\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=newSize(\"+newSize+\")\", size >= newSize);\n      size = newSize;\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=newSize(\"+newSize+\")\", size >= newSize);\n      size = newSize;\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          @Override\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=newSize(\"+newSize+\")\", size >= newSize);\n      size = newSize;\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=newSize(\"+newSize+\")\", size >= newSize);\n      size = newSize;\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"702ef053ffa12d6bc4fecda3ebf4fd0e897177be","date":1365845315,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap(random().nextBoolean());\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          @Override\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=newSize(\"+newSize+\")\", size >= newSize);\n      size = newSize;\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          @Override\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=newSize(\"+newSize+\")\", size >= newSize);\n      size = newSize;\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap(random().nextBoolean());\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          @Override\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=newSize(\"+newSize+\")\", size >= newSize);\n      size = newSize;\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap(random().nextBoolean());\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          @Override\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=newSize(\"+newSize+\")\", size >= newSize);\n      size = newSize;\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4208ed8e426ae5f75a41d8b4ae53f4587e413061","date":1580475454,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = TEST_NIGHTLY ? 8 : 2;\n    final int keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap(random().nextBoolean());\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          @Override\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=newSize(\"+newSize+\")\", size >= newSize);\n      size = newSize;\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory(\"testConcurrentHashMap\"));\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap(random().nextBoolean());\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random().nextLong());\n        exec.execute(new Runnable() {\n          @Override\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(5)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                case 4:\n                  // check iterator still working\n                  for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n                    assertNotNull(it.next());\n                  }\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      int newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=newSize(\"+newSize+\")\", size >= newSize);\n      size = newSize;\n      Thread.sleep(100L);\n      int c = 0;\n      for (Iterator<Object> it = map.keyIterator(); it.hasNext();) {\n        assertNotNull(it.next());\n        c++;\n      }\n      newSize = map.size();\n      assertTrue(\"previousSize(\"+size+\")>=iteratorSize(\"+c+\")\", size >= c);\n      assertTrue(\"iteratorSize(\"+c+\")>=newSize(\"+newSize+\")\", c >= newSize);\n      size = newSize;\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a8363efa169b169f300a07252db8fdec6ebfe48f","7530de27b87b961b51f01bd1299b7004d46e8823"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["702ef053ffa12d6bc4fecda3ebf4fd0e897177be"],"702ef053ffa12d6bc4fecda3ebf4fd0e897177be":["7530de27b87b961b51f01bd1299b7004d46e8823"],"a8363efa169b169f300a07252db8fdec6ebfe48f":["24acb08412c25718ab57aac08306395faa2cd933"],"24acb08412c25718ab57aac08306395faa2cd933":["1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["fe33227f6805edab2036cbb80645cc4e2d1fa424","24acb08412c25718ab57aac08306395faa2cd933"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","e721522f9692a64e877e34a4467f58dbeba866eb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e721522f9692a64e877e34a4467f58dbeba866eb":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7530de27b87b961b51f01bd1299b7004d46e8823":["a8363efa169b169f300a07252db8fdec6ebfe48f"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["e721522f9692a64e877e34a4467f58dbeba866eb","24acb08412c25718ab57aac08306395faa2cd933"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"1c8719b2c0b382be11f5b193b6fc14bc310e906b":["e721522f9692a64e877e34a4467f58dbeba866eb"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"702ef053ffa12d6bc4fecda3ebf4fd0e897177be":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a8363efa169b169f300a07252db8fdec6ebfe48f":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"24acb08412c25718ab57aac08306395faa2cd933":["a8363efa169b169f300a07252db8fdec6ebfe48f","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"e721522f9692a64e877e34a4467f58dbeba866eb":["fe33227f6805edab2036cbb80645cc4e2d1fa424","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["fe33227f6805edab2036cbb80645cc4e2d1fa424","e721522f9692a64e877e34a4467f58dbeba866eb"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","702ef053ffa12d6bc4fecda3ebf4fd0e897177be"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":[],"1c8719b2c0b382be11f5b193b6fc14bc310e906b":["24acb08412c25718ab57aac08306395faa2cd933"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}