{"path":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testFieldExistsQueries().mjava","commits":[{"id":"0c81907bd971f786e378654d32b80da32b0e950d","date":1578330742,"type":0,"author":"Houston Putman","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testFieldExistsQueries().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testFieldExistsQueries() throws SyntaxError {\n    SolrQueryRequest req = req();\n    IndexSchema indexSchema = h.getCore().getLatestSchema();\n    String[] fieldSuffix = new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\", \"tdt\",\n        \"pi\", \"pf\", \"pd\", \"pl\", \"pdt\",\n        \"i\", \"f\", \"d\", \"l\", \"dt\", \"s\", \"b\",\n        \"is\", \"fs\", \"ds\", \"ls\", \"dts\", \"ss\", \"bs\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\", \"dt_dv\", \"s_dv\", \"b_dv\",\n        \"is_dv\", \"fs_dv\", \"ds_dv\", \"ls_dv\", \"dts_dv\", \"ss_dv\", \"bs_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\", \"dt_dvo\",\n        \"t\"\n    };\n    String[] existenceQueries = new String[] {\n        \"*\", \"[* TO *]\"\n    };\n\n    for (String existenceQuery : existenceQueries) {\n      for (String suffix : fieldSuffix) {\n        String field = \"foo_\" + suffix;\n        String query = field + \":\" + existenceQuery;\n        QParser qParser = QParser.getParser(query, req);\n        if (indexSchema.getField(field).hasDocValues()) {\n          assertTrue(\"Field has docValues, so existence query \\\"\" + query + \"\\\" should return DocValuesFieldExistsQuery\", qParser.getQuery() instanceof DocValuesFieldExistsQuery);\n        } else {\n          assertFalse(\"Field doesn't have docValues, so existence query \\\"\" + query + \"\\\" should not return DocValuesFieldExistsQuery\", qParser.getQuery() instanceof DocValuesFieldExistsQuery);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca62564055241632cd20d65b5ecb8c8e93bd60c4","date":1578383112,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testFieldExistsQueries().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testFieldExistsQueries() throws SyntaxError {\n    SolrQueryRequest req = req();\n    IndexSchema indexSchema = h.getCore().getLatestSchema();\n    String[] fieldSuffix = new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\", \"tdt\",\n        \"pi\", \"pf\", \"pd\", \"pl\", \"pdt\",\n        \"i\", \"f\", \"d\", \"l\", \"dt\", \"s\", \"b\",\n        \"is\", \"fs\", \"ds\", \"ls\", \"dts\", \"ss\", \"bs\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\", \"dt_dv\", \"s_dv\", \"b_dv\",\n        \"is_dv\", \"fs_dv\", \"ds_dv\", \"ls_dv\", \"dts_dv\", \"ss_dv\", \"bs_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\", \"dt_dvo\",\n        \"t\"\n    };\n    String[] existenceQueries = new String[] {\n        \"*\", \"[* TO *]\"\n    };\n\n    for (String existenceQuery : existenceQueries) {\n      for (String suffix : fieldSuffix) {\n        String field = \"foo_\" + suffix;\n        String query = field + \":\" + existenceQuery;\n        QParser qParser = QParser.getParser(query, req);\n        if (indexSchema.getField(field).hasDocValues()) {\n          assertTrue(\"Field has docValues, so existence query \\\"\" + query + \"\\\" should return DocValuesFieldExistsQuery\", qParser.getQuery() instanceof DocValuesFieldExistsQuery);\n        } else {\n          assertFalse(\"Field doesn't have docValues, so existence query \\\"\" + query + \"\\\" should not return DocValuesFieldExistsQuery\", qParser.getQuery() instanceof DocValuesFieldExistsQuery);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8381df1a98f2a399bf06d747fc8cea1b2a17ae38","date":1578526395,"type":4,"author":"Houston Putman","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testFieldExistsQueries().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testFieldExistsQueries() throws SyntaxError {\n    SolrQueryRequest req = req();\n    IndexSchema indexSchema = h.getCore().getLatestSchema();\n    String[] fieldSuffix = new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\", \"tdt\",\n        \"pi\", \"pf\", \"pd\", \"pl\", \"pdt\",\n        \"i\", \"f\", \"d\", \"l\", \"dt\", \"s\", \"b\",\n        \"is\", \"fs\", \"ds\", \"ls\", \"dts\", \"ss\", \"bs\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\", \"dt_dv\", \"s_dv\", \"b_dv\",\n        \"is_dv\", \"fs_dv\", \"ds_dv\", \"ls_dv\", \"dts_dv\", \"ss_dv\", \"bs_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\", \"dt_dvo\",\n        \"t\"\n    };\n    String[] existenceQueries = new String[] {\n        \"*\", \"[* TO *]\"\n    };\n\n    for (String existenceQuery : existenceQueries) {\n      for (String suffix : fieldSuffix) {\n        String field = \"foo_\" + suffix;\n        String query = field + \":\" + existenceQuery;\n        QParser qParser = QParser.getParser(query, req);\n        if (indexSchema.getField(field).hasDocValues()) {\n          assertTrue(\"Field has docValues, so existence query \\\"\" + query + \"\\\" should return DocValuesFieldExistsQuery\", qParser.getQuery() instanceof DocValuesFieldExistsQuery);\n        } else {\n          assertFalse(\"Field doesn't have docValues, so existence query \\\"\" + query + \"\\\" should not return DocValuesFieldExistsQuery\", qParser.getQuery() instanceof DocValuesFieldExistsQuery);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da93834e39ce341a13e42b611d0a83bd3114bba","date":1578567362,"type":4,"author":"Dawid Weiss","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testFieldExistsQueries().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testFieldExistsQueries() throws SyntaxError {\n    SolrQueryRequest req = req();\n    IndexSchema indexSchema = h.getCore().getLatestSchema();\n    String[] fieldSuffix = new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\", \"tdt\",\n        \"pi\", \"pf\", \"pd\", \"pl\", \"pdt\",\n        \"i\", \"f\", \"d\", \"l\", \"dt\", \"s\", \"b\",\n        \"is\", \"fs\", \"ds\", \"ls\", \"dts\", \"ss\", \"bs\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\", \"dt_dv\", \"s_dv\", \"b_dv\",\n        \"is_dv\", \"fs_dv\", \"ds_dv\", \"ls_dv\", \"dts_dv\", \"ss_dv\", \"bs_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\", \"dt_dvo\",\n        \"t\"\n    };\n    String[] existenceQueries = new String[] {\n        \"*\", \"[* TO *]\"\n    };\n\n    for (String existenceQuery : existenceQueries) {\n      for (String suffix : fieldSuffix) {\n        String field = \"foo_\" + suffix;\n        String query = field + \":\" + existenceQuery;\n        QParser qParser = QParser.getParser(query, req);\n        if (indexSchema.getField(field).hasDocValues()) {\n          assertTrue(\"Field has docValues, so existence query \\\"\" + query + \"\\\" should return DocValuesFieldExistsQuery\", qParser.getQuery() instanceof DocValuesFieldExistsQuery);\n        } else {\n          assertFalse(\"Field doesn't have docValues, so existence query \\\"\" + query + \"\\\" should not return DocValuesFieldExistsQuery\", qParser.getQuery() instanceof DocValuesFieldExistsQuery);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c7ba457c7f2595139254fab54362be336c5c355","date":1579734055,"type":0,"author":"Houston Putman","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testFieldExistsQueries().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testFieldExistsQueries() throws SyntaxError {\n    SolrQueryRequest req = req();\n    String[] fieldSuffix = new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\", \"tdt\",\n        \"pi\", \"pf\", \"pd\", \"pl\", \"pdt\",\n        \"i\", \"f\", \"d\", \"l\", \"dt\", \"s\", \"b\",\n        \"is\", \"fs\", \"ds\", \"ls\", \"dts\", \"ss\", \"bs\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\", \"dt_dv\", \"s_dv\", \"b_dv\",\n        \"is_dv\", \"fs_dv\", \"ds_dv\", \"ls_dv\", \"dts_dv\", \"ss_dv\", \"bs_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\", \"dt_dvo\",\n        \"t\",\n        \"t_on\", \"b_norms\", \"s_norms\", \"dt_norms\", \"i_norms\", \"l_norms\", \"f_norms\", \"d_norms\"\n    };\n    String[] existenceQueries = new String[] {\n        \"*\", \"[* TO *]\"\n    };\n\n    for (String existenceQuery : existenceQueries) {\n      for (String suffix : fieldSuffix) {\n        IndexSchema indexSchema = h.getCore().getLatestSchema();\n        String field = \"foo_\" + suffix;\n        String query = field + \":\" + existenceQuery;\n        QParser qParser = QParser.getParser(query, req);\n        Query createdQuery = qParser.getQuery();\n        SchemaField schemaField = indexSchema.getField(field);\n\n        // Test float & double realNumber queries differently\n        if (\"[* TO *]\".equals(existenceQuery) && (schemaField.getType().getNumberType() == NumberType.DOUBLE || schemaField.getType().getNumberType() == NumberType.FLOAT)) {\n          assertFalse(\"For float and double fields \\\"\" + query + \"\\\" is not an existence query, so the query returned should not be a DocValuesFieldExistsQuery.\", createdQuery instanceof DocValuesFieldExistsQuery);\n          assertFalse(\"For float and double fields \\\"\" + query + \"\\\" is not an existence query, so the query returned should not be a NormsFieldExistsQuery.\", createdQuery instanceof NormsFieldExistsQuery);\n          assertFalse(\"For float and double fields \\\"\" + query + \"\\\" is not an existence query, so NaN should not be matched via a ConstantScoreQuery.\", createdQuery instanceof ConstantScoreQuery);\n          assertFalse(\"For float and double fields\\\"\" + query + \"\\\" is not an existence query, so NaN should not be matched via a BooleanQuery (NaN and [* TO *]).\", createdQuery instanceof BooleanQuery);\n        } else {\n          if (schemaField.hasDocValues()) {\n            assertTrue(\"Field has docValues, so existence query \\\"\" + query + \"\\\" should return DocValuesFieldExistsQuery\", createdQuery instanceof DocValuesFieldExistsQuery);\n          } else if (!schemaField.omitNorms() && !schemaField.getType().isPointField()) { //TODO: Remove !isPointField() for SOLR-14199\n            assertTrue(\"Field has norms and no docValues, so existence query \\\"\" + query + \"\\\" should return NormsFieldExistsQuery\", createdQuery instanceof NormsFieldExistsQuery);\n          } else if (schemaField.getType().getNumberType() == NumberType.DOUBLE || schemaField.getType().getNumberType() == NumberType.FLOAT) {\n            assertTrue(\"PointField with NaN values must include \\\"exists or NaN\\\" if the field doesn't have norms or docValues: \\\"\" + query + \"\\\".\", createdQuery instanceof ConstantScoreQuery);\n            assertTrue(\"PointField with NaN values must include \\\"exists or NaN\\\" if the field doesn't have norms or docValues: \\\"\" + query + \"\\\".\", ((ConstantScoreQuery)createdQuery).getQuery() instanceof BooleanQuery);\n            assertEquals(\"PointField with NaN values must include \\\"exists or NaN\\\" if the field doesn't have norms or docValues: \\\"\" + query + \"\\\". This boolean query must be an OR.\", 1, ((BooleanQuery)((ConstantScoreQuery)createdQuery).getQuery()).getMinimumNumberShouldMatch());\n            assertEquals(\"PointField with NaN values must include \\\"exists or NaN\\\" if the field doesn't have norms or docValues: \\\"\" + query + \"\\\". This boolean query must have 2 clauses.\", 2, ((BooleanQuery)((ConstantScoreQuery)createdQuery).getQuery()).clauses().size());\n          } else {\n            assertFalse(\"Field doesn't have docValues, so existence query \\\"\" + query + \"\\\" should not return DocValuesFieldExistsQuery\", createdQuery instanceof DocValuesFieldExistsQuery);\n            assertFalse(\"Field doesn't have norms, so existence query \\\"\" + query + \"\\\" should not return NormsFieldExistsQuery\", createdQuery instanceof NormsFieldExistsQuery);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8381df1a98f2a399bf06d747fc8cea1b2a17ae38":["0c81907bd971f786e378654d32b80da32b0e950d"],"0c81907bd971f786e378654d32b80da32b0e950d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1da93834e39ce341a13e42b611d0a83bd3114bba":["ca62564055241632cd20d65b5ecb8c8e93bd60c4","8381df1a98f2a399bf06d747fc8cea1b2a17ae38"],"5c7ba457c7f2595139254fab54362be336c5c355":["8381df1a98f2a399bf06d747fc8cea1b2a17ae38"],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0c81907bd971f786e378654d32b80da32b0e950d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5c7ba457c7f2595139254fab54362be336c5c355"]},"commit2Childs":{"8381df1a98f2a399bf06d747fc8cea1b2a17ae38":["1da93834e39ce341a13e42b611d0a83bd3114bba","5c7ba457c7f2595139254fab54362be336c5c355"],"0c81907bd971f786e378654d32b80da32b0e950d":["8381df1a98f2a399bf06d747fc8cea1b2a17ae38","ca62564055241632cd20d65b5ecb8c8e93bd60c4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0c81907bd971f786e378654d32b80da32b0e950d","ca62564055241632cd20d65b5ecb8c8e93bd60c4"],"1da93834e39ce341a13e42b611d0a83bd3114bba":[],"5c7ba457c7f2595139254fab54362be336c5c355":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":["1da93834e39ce341a13e42b611d0a83bd3114bba"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1da93834e39ce341a13e42b611d0a83bd3114bba","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}