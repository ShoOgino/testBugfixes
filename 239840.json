{"path":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#toSVG(Object...).mjava","commits":[{"id":"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2","date":1460953142,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#toSVG(Object...).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Returns svg of polygon for debugging. \n   * <p>\n   * You can pass any number of objects:\n   * Polygon: polygon with optional holes\n   * Polygon[]: arrays of polygons for convenience\n   * Rectangle: for a box\n   * double[2]: as latitude,longitude for a point\n   * <p>\n   * At least one object must be a polygon. The viewBox is formed around all polygons\n   * found in the arguments.\n   */\n  public static String toSVG(Object ...objects) {\n    List<Object> flattened = new ArrayList<>();\n    for (Object o : objects) {\n      if (o instanceof Polygon[]) {\n        flattened.addAll(Arrays.asList((Polygon[]) o));\n      } else {\n        flattened.add(o);\n      }\n    }\n    // first compute bounding area of all the objects\n    double minLat = Double.POSITIVE_INFINITY;\n    double maxLat = Double.NEGATIVE_INFINITY;\n    double minLon = Double.POSITIVE_INFINITY;\n    double maxLon = Double.NEGATIVE_INFINITY;\n    for (Object o : flattened) {\n      final Rectangle r;\n      if (o instanceof Polygon) {\n        r = Rectangle.fromPolygon(new Polygon[] { (Polygon) o });\n        minLat = Math.min(minLat, r.minLat);\n        maxLat = Math.max(maxLat, r.maxLat);\n        minLon = Math.min(minLon, r.minLon);\n        maxLon = Math.max(maxLon, r.maxLon);\n      }\n    }\n    if (Double.isFinite(minLat) == false || Double.isFinite(maxLat) == false ||\n        Double.isFinite(minLon) == false || Double.isFinite(maxLon) == false) {\n      throw new IllegalArgumentException(\"you must pass at least one polygon\");\n    }\n    \n    // add some additional padding so we can really see what happens on the edges too\n    double xpadding = (maxLon - minLon) / 64;\n    double ypadding = (maxLat - minLat) / 64;\n    // expand points to be this large\n    double pointX = xpadding * 0.1;\n    double pointY = ypadding * 0.1;\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"640\\\" width=\\\"480\\\" viewBox=\\\"\");\n    sb.append(minLon - xpadding)\n      .append(\" \")\n      .append(90 - maxLat - ypadding)\n      .append(\" \")\n      .append(maxLon - minLon + (2*xpadding))\n      .append(\" \")\n      .append(maxLat - minLat + (2*ypadding));\n    sb.append(\"\\\">\\n\");\n\n    // encode each object\n    for (Object o : flattened) {\n      // tostring\n      if (o instanceof double[]) {\n        double point[] = (double[]) o;\n        sb.append(\"<!-- point: \");\n        sb.append(point[0] + \",\" + point[1]);\n        sb.append(\" -->\\n\");\n      } else {\n        sb.append(\"<!-- \" + o.getClass().getSimpleName() + \": \\n\");\n        sb.append(o.toString());\n        sb.append(\"\\n-->\\n\");\n      }\n      final Polygon gon;\n      final String style;\n      final String opacity;\n      if (o instanceof Rectangle) {\n        gon = boxPolygon((Rectangle) o);\n        style = \"fill:lightskyblue;stroke:black;stroke-width:0.2%;stroke-dasharray:0.5%,1%;\";\n        opacity = \"0.3\";\n      } else if (o instanceof double[]) {\n        double point[] = (double[]) o;\n        gon = boxPolygon(new Rectangle(Math.max(-90, point[0]-pointY), \n                                      Math.min(90, point[0]+pointY), \n                                      Math.max(-180, point[1]-pointX), \n                                      Math.min(180, point[1]+pointX)));\n        style = \"fill:red;stroke:red;stroke-width:0.1%;\";\n        opacity = \"0.7\";\n      } else {\n        gon = (Polygon) o;\n        style = \"fill:lawngreen;stroke:black;stroke-width:0.3%;\";\n        opacity = \"0.5\";\n      }\n      // polygon\n      double polyLats[] = gon.getPolyLats();\n      double polyLons[] = gon.getPolyLons();\n      sb.append(\"<polygon fill-opacity=\\\"\" + opacity + \"\\\" points=\\\"\");\n      for (int i = 0; i < polyLats.length; i++) {\n        if (i > 0) {\n          sb.append(\" \");\n        }\n        sb.append(polyLons[i])\n        .append(\",\")\n        .append(90 - polyLats[i]);\n      }\n      sb.append(\"\\\" style=\\\"\" + style + \"\\\"/>\\n\");\n      for (Polygon hole : gon.getHoles()) {\n        double holeLats[] = hole.getPolyLats();\n        double holeLons[] = hole.getPolyLons();\n        sb.append(\"<polygon points=\\\"\");\n        for (int i = 0; i < holeLats.length; i++) {\n          if (i > 0) {\n            sb.append(\" \");\n          }\n          sb.append(holeLons[i])\n          .append(\",\")\n          .append(90 - holeLats[i]);\n        }\n        sb.append(\"\\\" style=\\\"fill:lightgray\\\"/>\\n\");\n      }\n    }\n    sb.append(\"</svg>\\n\");\n    return sb.toString();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"713122036535651642e6d4fe57ce12b449e18473","date":1461000510,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#toSVG(Object...).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Returns svg of polygon for debugging. \n   * <p>\n   * You can pass any number of objects:\n   * Polygon: polygon with optional holes\n   * Polygon[]: arrays of polygons for convenience\n   * Rectangle: for a box\n   * double[2]: as latitude,longitude for a point\n   * <p>\n   * At least one object must be a polygon. The viewBox is formed around all polygons\n   * found in the arguments.\n   */\n  public static String toSVG(Object ...objects) {\n    List<Object> flattened = new ArrayList<>();\n    for (Object o : objects) {\n      if (o instanceof Polygon[]) {\n        flattened.addAll(Arrays.asList((Polygon[]) o));\n      } else {\n        flattened.add(o);\n      }\n    }\n    // first compute bounding area of all the objects\n    double minLat = Double.POSITIVE_INFINITY;\n    double maxLat = Double.NEGATIVE_INFINITY;\n    double minLon = Double.POSITIVE_INFINITY;\n    double maxLon = Double.NEGATIVE_INFINITY;\n    for (Object o : flattened) {\n      final Rectangle r;\n      if (o instanceof Polygon) {\n        r = Rectangle.fromPolygon(new Polygon[] { (Polygon) o });\n        minLat = Math.min(minLat, r.minLat);\n        maxLat = Math.max(maxLat, r.maxLat);\n        minLon = Math.min(minLon, r.minLon);\n        maxLon = Math.max(maxLon, r.maxLon);\n      }\n    }\n    if (Double.isFinite(minLat) == false || Double.isFinite(maxLat) == false ||\n        Double.isFinite(minLon) == false || Double.isFinite(maxLon) == false) {\n      throw new IllegalArgumentException(\"you must pass at least one polygon\");\n    }\n    \n    // add some additional padding so we can really see what happens on the edges too\n    double xpadding = (maxLon - minLon) / 64;\n    double ypadding = (maxLat - minLat) / 64;\n    // expand points to be this large\n    double pointX = xpadding * 0.1;\n    double pointY = ypadding * 0.1;\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"640\\\" width=\\\"480\\\" viewBox=\\\"\");\n    sb.append(minLon - xpadding)\n      .append(\" \")\n      .append(90 - maxLat - ypadding)\n      .append(\" \")\n      .append(maxLon - minLon + (2*xpadding))\n      .append(\" \")\n      .append(maxLat - minLat + (2*ypadding));\n    sb.append(\"\\\">\\n\");\n\n    // encode each object\n    for (Object o : flattened) {\n      // tostring\n      if (o instanceof double[]) {\n        double point[] = (double[]) o;\n        sb.append(\"<!-- point: \");\n        sb.append(point[0] + \",\" + point[1]);\n        sb.append(\" -->\\n\");\n      } else {\n        sb.append(\"<!-- \" + o.getClass().getSimpleName() + \": \\n\");\n        sb.append(o.toString());\n        sb.append(\"\\n-->\\n\");\n      }\n      final Polygon gon;\n      final String style;\n      final String opacity;\n      if (o instanceof Rectangle) {\n        gon = boxPolygon((Rectangle) o);\n        style = \"fill:lightskyblue;stroke:black;stroke-width:0.2%;stroke-dasharray:0.5%,1%;\";\n        opacity = \"0.3\";\n      } else if (o instanceof double[]) {\n        double point[] = (double[]) o;\n        gon = boxPolygon(new Rectangle(Math.max(-90, point[0]-pointY), \n                                      Math.min(90, point[0]+pointY), \n                                      Math.max(-180, point[1]-pointX), \n                                      Math.min(180, point[1]+pointX)));\n        style = \"fill:red;stroke:red;stroke-width:0.1%;\";\n        opacity = \"0.7\";\n      } else {\n        gon = (Polygon) o;\n        style = \"fill:lawngreen;stroke:black;stroke-width:0.3%;\";\n        opacity = \"0.5\";\n      }\n      // polygon\n      double polyLats[] = gon.getPolyLats();\n      double polyLons[] = gon.getPolyLons();\n      sb.append(\"<polygon fill-opacity=\\\"\" + opacity + \"\\\" points=\\\"\");\n      for (int i = 0; i < polyLats.length; i++) {\n        if (i > 0) {\n          sb.append(\" \");\n        }\n        sb.append(polyLons[i])\n        .append(\",\")\n        .append(90 - polyLats[i]);\n      }\n      sb.append(\"\\\" style=\\\"\" + style + \"\\\"/>\\n\");\n      for (Polygon hole : gon.getHoles()) {\n        double holeLats[] = hole.getPolyLats();\n        double holeLons[] = hole.getPolyLons();\n        sb.append(\"<polygon points=\\\"\");\n        for (int i = 0; i < holeLats.length; i++) {\n          if (i > 0) {\n            sb.append(\" \");\n          }\n          sb.append(holeLons[i])\n          .append(\",\")\n          .append(90 - holeLats[i]);\n        }\n        sb.append(\"\\\" style=\\\"fill:lightgray\\\"/>\\n\");\n      }\n    }\n    sb.append(\"</svg>\\n\");\n    return sb.toString();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ffe681f212e5073c69955b4ad22946794c84940","date":1560182863,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#toSVG(Object...).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#toSVG(Object...).mjava","sourceNew":"  /** \n   * Returns svg of polygon for debugging. \n   * <p>\n   * You can pass any number of objects:\n   * Polygon: polygon with optional holes\n   * Polygon[]: arrays of polygons for convenience\n   * Rectangle: for a box\n   * double[2]: as latitude,longitude for a point\n   * <p>\n   * At least one object must be a polygon. The viewBox is formed around all polygons\n   * found in the arguments.\n   */\n  public static String toSVG(Object ...objects) {\n    List<Object> flattened = new ArrayList<>();\n    for (Object o : objects) {\n      if (o instanceof Polygon[]) {\n        flattened.addAll(Arrays.asList((Polygon[]) o));\n      } else {\n        flattened.add(o);\n      }\n    }\n    // first compute bounding area of all the objects\n    double minLat = Double.POSITIVE_INFINITY;\n    double maxLat = Double.NEGATIVE_INFINITY;\n    double minLon = Double.POSITIVE_INFINITY;\n    double maxLon = Double.NEGATIVE_INFINITY;\n    for (Object o : flattened) {\n      final Rectangle r;\n      if (o instanceof Polygon) {\n        r = Rectangle.fromPolygon(new Polygon[] { (Polygon) o });\n        minLat = Math.min(minLat, r.minLat);\n        maxLat = Math.max(maxLat, r.maxLat);\n        minLon = Math.min(minLon, r.minLon);\n        maxLon = Math.max(maxLon, r.maxLon);\n      }\n    }\n    if (Double.isFinite(minLat) == false || Double.isFinite(maxLat) == false ||\n        Double.isFinite(minLon) == false || Double.isFinite(maxLon) == false) {\n      throw new IllegalArgumentException(\"you must pass at least one polygon\");\n    }\n    \n    // add some additional padding so we can really see what happens on the edges too\n    double xpadding = (maxLon - minLon) / 64;\n    double ypadding = (maxLat - minLat) / 64;\n    // expand points to be this large\n    double pointX = xpadding * 0.1;\n    double pointY = ypadding * 0.1;\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"640\\\" width=\\\"480\\\" viewBox=\\\"\");\n    sb.append(minLon - xpadding)\n      .append(\" \")\n      .append(90 - maxLat - ypadding)\n      .append(\" \")\n      .append(maxLon - minLon + (2*xpadding))\n      .append(\" \")\n      .append(maxLat - minLat + (2*ypadding));\n    sb.append(\"\\\">\\n\");\n\n    // encode each object\n    for (Object o : flattened) {\n      // tostring\n      if (o instanceof double[]) {\n        double point[] = (double[]) o;\n        sb.append(\"<!-- point: \");\n        sb.append(point[0]).append(',').append(point[1]);\n        sb.append(\" -->\\n\");\n      } else {\n        sb.append(\"<!-- \").append(o.getClass().getSimpleName()).append(\": \\n\");\n        sb.append(o.toString());\n        sb.append(\"\\n-->\\n\");\n      }\n      final Polygon gon;\n      final String style;\n      final String opacity;\n      if (o instanceof Rectangle) {\n        gon = boxPolygon((Rectangle) o);\n        style = \"fill:lightskyblue;stroke:black;stroke-width:0.2%;stroke-dasharray:0.5%,1%;\";\n        opacity = \"0.3\";\n      } else if (o instanceof double[]) {\n        double point[] = (double[]) o;\n        gon = boxPolygon(new Rectangle(Math.max(-90, point[0]-pointY), \n                                      Math.min(90, point[0]+pointY), \n                                      Math.max(-180, point[1]-pointX), \n                                      Math.min(180, point[1]+pointX)));\n        style = \"fill:red;stroke:red;stroke-width:0.1%;\";\n        opacity = \"0.7\";\n      } else {\n        gon = (Polygon) o;\n        style = \"fill:lawngreen;stroke:black;stroke-width:0.3%;\";\n        opacity = \"0.5\";\n      }\n      // polygon\n      double polyLats[] = gon.getPolyLats();\n      double polyLons[] = gon.getPolyLons();\n      sb.append(\"<polygon fill-opacity=\\\"\").append(opacity).append(\"\\\" points=\\\"\");\n      for (int i = 0; i < polyLats.length; i++) {\n        if (i > 0) {\n          sb.append(\" \");\n        }\n        sb.append(polyLons[i])\n        .append(\",\")\n        .append(90 - polyLats[i]);\n      }\n      sb.append(\"\\\" style=\\\"\").append(style).append(\"\\\"/>\\n\");\n      for (Polygon hole : gon.getHoles()) {\n        double holeLats[] = hole.getPolyLats();\n        double holeLons[] = hole.getPolyLons();\n        sb.append(\"<polygon points=\\\"\");\n        for (int i = 0; i < holeLats.length; i++) {\n          if (i > 0) {\n            sb.append(\" \");\n          }\n          sb.append(holeLons[i])\n          .append(\",\")\n          .append(90 - holeLats[i]);\n        }\n        sb.append(\"\\\" style=\\\"fill:lightgray\\\"/>\\n\");\n      }\n    }\n    sb.append(\"</svg>\\n\");\n    return sb.toString();\n  }\n\n","sourceOld":"  /** \n   * Returns svg of polygon for debugging. \n   * <p>\n   * You can pass any number of objects:\n   * Polygon: polygon with optional holes\n   * Polygon[]: arrays of polygons for convenience\n   * Rectangle: for a box\n   * double[2]: as latitude,longitude for a point\n   * <p>\n   * At least one object must be a polygon. The viewBox is formed around all polygons\n   * found in the arguments.\n   */\n  public static String toSVG(Object ...objects) {\n    List<Object> flattened = new ArrayList<>();\n    for (Object o : objects) {\n      if (o instanceof Polygon[]) {\n        flattened.addAll(Arrays.asList((Polygon[]) o));\n      } else {\n        flattened.add(o);\n      }\n    }\n    // first compute bounding area of all the objects\n    double minLat = Double.POSITIVE_INFINITY;\n    double maxLat = Double.NEGATIVE_INFINITY;\n    double minLon = Double.POSITIVE_INFINITY;\n    double maxLon = Double.NEGATIVE_INFINITY;\n    for (Object o : flattened) {\n      final Rectangle r;\n      if (o instanceof Polygon) {\n        r = Rectangle.fromPolygon(new Polygon[] { (Polygon) o });\n        minLat = Math.min(minLat, r.minLat);\n        maxLat = Math.max(maxLat, r.maxLat);\n        minLon = Math.min(minLon, r.minLon);\n        maxLon = Math.max(maxLon, r.maxLon);\n      }\n    }\n    if (Double.isFinite(minLat) == false || Double.isFinite(maxLat) == false ||\n        Double.isFinite(minLon) == false || Double.isFinite(maxLon) == false) {\n      throw new IllegalArgumentException(\"you must pass at least one polygon\");\n    }\n    \n    // add some additional padding so we can really see what happens on the edges too\n    double xpadding = (maxLon - minLon) / 64;\n    double ypadding = (maxLat - minLat) / 64;\n    // expand points to be this large\n    double pointX = xpadding * 0.1;\n    double pointY = ypadding * 0.1;\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"640\\\" width=\\\"480\\\" viewBox=\\\"\");\n    sb.append(minLon - xpadding)\n      .append(\" \")\n      .append(90 - maxLat - ypadding)\n      .append(\" \")\n      .append(maxLon - minLon + (2*xpadding))\n      .append(\" \")\n      .append(maxLat - minLat + (2*ypadding));\n    sb.append(\"\\\">\\n\");\n\n    // encode each object\n    for (Object o : flattened) {\n      // tostring\n      if (o instanceof double[]) {\n        double point[] = (double[]) o;\n        sb.append(\"<!-- point: \");\n        sb.append(point[0] + \",\" + point[1]);\n        sb.append(\" -->\\n\");\n      } else {\n        sb.append(\"<!-- \" + o.getClass().getSimpleName() + \": \\n\");\n        sb.append(o.toString());\n        sb.append(\"\\n-->\\n\");\n      }\n      final Polygon gon;\n      final String style;\n      final String opacity;\n      if (o instanceof Rectangle) {\n        gon = boxPolygon((Rectangle) o);\n        style = \"fill:lightskyblue;stroke:black;stroke-width:0.2%;stroke-dasharray:0.5%,1%;\";\n        opacity = \"0.3\";\n      } else if (o instanceof double[]) {\n        double point[] = (double[]) o;\n        gon = boxPolygon(new Rectangle(Math.max(-90, point[0]-pointY), \n                                      Math.min(90, point[0]+pointY), \n                                      Math.max(-180, point[1]-pointX), \n                                      Math.min(180, point[1]+pointX)));\n        style = \"fill:red;stroke:red;stroke-width:0.1%;\";\n        opacity = \"0.7\";\n      } else {\n        gon = (Polygon) o;\n        style = \"fill:lawngreen;stroke:black;stroke-width:0.3%;\";\n        opacity = \"0.5\";\n      }\n      // polygon\n      double polyLats[] = gon.getPolyLats();\n      double polyLons[] = gon.getPolyLons();\n      sb.append(\"<polygon fill-opacity=\\\"\" + opacity + \"\\\" points=\\\"\");\n      for (int i = 0; i < polyLats.length; i++) {\n        if (i > 0) {\n          sb.append(\" \");\n        }\n        sb.append(polyLons[i])\n        .append(\",\")\n        .append(90 - polyLats[i]);\n      }\n      sb.append(\"\\\" style=\\\"\" + style + \"\\\"/>\\n\");\n      for (Polygon hole : gon.getHoles()) {\n        double holeLats[] = hole.getPolyLats();\n        double holeLons[] = hole.getPolyLons();\n        sb.append(\"<polygon points=\\\"\");\n        for (int i = 0; i < holeLats.length; i++) {\n          if (i > 0) {\n            sb.append(\" \");\n          }\n          sb.append(holeLons[i])\n          .append(\",\")\n          .append(90 - holeLats[i]);\n        }\n        sb.append(\"\\\" style=\\\"fill:lightgray\\\"/>\\n\");\n      }\n    }\n    sb.append(\"</svg>\\n\");\n    return sb.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2ffe681f212e5073c69955b4ad22946794c84940":["713122036535651642e6d4fe57ce12b449e18473"],"713122036535651642e6d4fe57ce12b449e18473":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2ffe681f212e5073c69955b4ad22946794c84940"]},"commit2Childs":{"2ffe681f212e5073c69955b4ad22946794c84940":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"713122036535651642e6d4fe57ce12b449e18473":["2ffe681f212e5073c69955b4ad22946794c84940"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["713122036535651642e6d4fe57ce12b449e18473","3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2"],"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2":["713122036535651642e6d4fe57ce12b449e18473"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}