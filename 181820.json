{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec317d5d3de749e12abcc9e6f976d765638fe9e2","date":1454411397,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","sourceNew":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n      // TODO: this is test code specific!!\n      message(\"setCurrentInfos: marker count: \" + searcher.count(new TermQuery(new Term(\"marker\", \"marker\"))) + \" version=\" + infos.getVersion() + \" searcher=\" + searcher);\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","sourceOld":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n      // TODO: this is test code specific!!\n      message(\"setCurrentInfos: marker count: \" + searcher.count(new TermQuery(new Term(\"marker\", \"marker\"))) + \" version=\" + infos.getVersion() + \" searcher=\" + searcher);\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c99ce0aa95120025213296d8d1ebf6164566dd49","date":1504272254,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","sourceNew":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","sourceOld":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n      // TODO: this is test code specific!!\n      message(\"setCurrentInfos: marker count: \" + searcher.count(new TermQuery(new Term(\"marker\", \"marker\"))) + \" version=\" + infos.getVersion() + \" searcher=\" + searcher);\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","sourceNew":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","sourceOld":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n      // TODO: this is test code specific!!\n      message(\"setCurrentInfos: marker count: \" + searcher.count(new TermQuery(new Term(\"marker\", \"marker\"))) + \" version=\" + infos.getVersion() + \" searcher=\" + searcher);\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b21283ed01203901a7257aa4b7f0a0899c86e56e","date":1504689720,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","sourceNew":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","sourceOld":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n      // TODO: this is test code specific!!\n      message(\"setCurrentInfos: marker count: \" + searcher.count(new TermQuery(new Term(\"marker\", \"marker\"))) + \" version=\" + infos.getVersion() + \" searcher=\" + searcher);\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","sourceNew":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","sourceOld":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n      // TODO: this is test code specific!!\n      message(\"setCurrentInfos: marker count: \" + searcher.count(new TermQuery(new Term(\"marker\", \"marker\"))) + \" version=\" + infos.getVersion() + \" searcher=\" + searcher);\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44a0b9495f3e7949bb11f82b854c2f1bd1a9f57a","date":1509618078,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","sourceNew":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null: \"file \\\"\" + fileName + \"\\\" is missing metadata\";\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","sourceOld":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null;\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"409da428f28953cf35fddd5c9ff5c7e4f5439863","date":1547556145,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","sourceNew":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos.\n    ByteBuffersDataOutput buffer = new ByteBuffersDataOutput();\n    try (ByteBuffersIndexOutput tmpIndexOutput = new ByteBuffersIndexOutput(buffer, \"temporary\", \"temporary\")) {\n      infos.write(dir, tmpIndexOutput);\n    }\n    byte[] infosBytes = buffer.toArrayCopy();\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null: \"file \\\"\" + fileName + \"\\\" is missing metadata\";\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","sourceOld":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos:\n    RAMOutputStream out = new RAMOutputStream(new RAMFile(), true);\n    infos.write(dir, out);\n    byte[] infosBytes = new byte[(int) out.getFilePointer()];\n    out.writeTo(infosBytes, 0);\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null: \"file \\\"\" + fileName + \"\\\" is missing metadata\";\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14654be3f7a82c9a3c52169e365baa55bfe64f66","date":1587212697,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#setCurrentInfos(Set[String]).mjava","sourceNew":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos.\n    ByteBuffersDataOutput buffer = new ByteBuffersDataOutput();\n    try (ByteBuffersIndexOutput tmpIndexOutput = new ByteBuffersIndexOutput(buffer, \"temporary\", \"temporary\")) {\n      infos.write(tmpIndexOutput);\n    }\n    byte[] infosBytes = buffer.toArrayCopy();\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null: \"file \\\"\" + fileName + \"\\\" is missing metadata\";\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","sourceOld":"  /** Steals incoming infos refCount; returns true if there were changes. */\n  private synchronized boolean setCurrentInfos(Set<String> completedMergeFiles) throws IOException {\n\n    IndexSearcher searcher = null;\n    SegmentInfos infos;\n    try {\n      searcher = mgr.acquire();\n      infos = ((StandardDirectoryReader) searcher.getIndexReader()).getSegmentInfos();\n    } finally {\n      if (searcher != null) {\n        mgr.release(searcher);\n      }\n    }\n    if (curInfos != null && infos.getVersion() == curInfos.getVersion()) {\n      // no change\n      message(\"top: skip switch to infos: version=\" + infos.getVersion() + \" is unchanged: \" + infos.toString());\n      return false;\n    }\n\n    SegmentInfos oldInfos = curInfos;\n    writer.incRefDeleter(infos);\n    curInfos = infos;\n    if (oldInfos != null) {\n      writer.decRefDeleter(oldInfos);\n    }\n\n    message(\"top: switch to infos=\" + infos.toString() + \" version=\" + infos.getVersion());\n\n    // Serialize the SegmentInfos.\n    ByteBuffersDataOutput buffer = new ByteBuffersDataOutput();\n    try (ByteBuffersIndexOutput tmpIndexOutput = new ByteBuffersIndexOutput(buffer, \"temporary\", \"temporary\")) {\n      infos.write(dir, tmpIndexOutput);\n    }\n    byte[] infosBytes = buffer.toArrayCopy();\n\n    Map<String,FileMetaData> filesMetaData = new HashMap<String,FileMetaData>();\n    for(SegmentCommitInfo info : infos) {\n      for(String fileName : info.files()) {\n        FileMetaData metaData = readLocalFileMetaData(fileName);\n        // NOTE: we hold a refCount on this infos, so this file better exist:\n        assert metaData != null: \"file \\\"\" + fileName + \"\\\" is missing metadata\";\n        assert filesMetaData.containsKey(fileName) == false;\n        filesMetaData.put(fileName, metaData);\n      }\n    }\n\n    lastFileMetaData = Collections.unmodifiableMap(filesMetaData);\n\n    message(\"top: set copyState primaryGen=\" + primaryGen + \" version=\" + infos.getVersion() + \" files=\" + filesMetaData.keySet());\n    copyState = new CopyState(lastFileMetaData,\n                              infos.getVersion(), infos.getGeneration(), infosBytes, completedMergeFiles,\n                              primaryGen, curInfos);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["68496c2200e559fb7802f7575427b7a482659afb","c99ce0aa95120025213296d8d1ebf6164566dd49"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["44a0b9495f3e7949bb11f82b854c2f1bd1a9f57a"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["68496c2200e559fb7802f7575427b7a482659afb","b21283ed01203901a7257aa4b7f0a0899c86e56e"],"c99ce0aa95120025213296d8d1ebf6164566dd49":["68496c2200e559fb7802f7575427b7a482659afb"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["68496c2200e559fb7802f7575427b7a482659afb","c99ce0aa95120025213296d8d1ebf6164566dd49"],"14654be3f7a82c9a3c52169e365baa55bfe64f66":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"44a0b9495f3e7949bb11f82b854c2f1bd1a9f57a":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["14654be3f7a82c9a3c52169e365baa55bfe64f66"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["14654be3f7a82c9a3c52169e365baa55bfe64f66"],"c99ce0aa95120025213296d8d1ebf6164566dd49":["b21283ed01203901a7257aa4b7f0a0899c86e56e","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["44a0b9495f3e7949bb11f82b854c2f1bd1a9f57a"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"14654be3f7a82c9a3c52169e365baa55bfe64f66":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["68496c2200e559fb7802f7575427b7a482659afb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["b21283ed01203901a7257aa4b7f0a0899c86e56e","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","c99ce0aa95120025213296d8d1ebf6164566dd49","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"44a0b9495f3e7949bb11f82b854c2f1bd1a9f57a":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}