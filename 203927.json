{"path":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomPlaneTest#testPlaneThreePointsAccuracy().mjava","commits":[{"id":"6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1","date":1518533584,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomPlaneTest#testPlaneThreePointsAccuracy().mjava","pathOld":"/dev/null","sourceNew":"  @Ignore\n  @Test\n  @Repeat(iterations = 10)\n  public void testPlaneThreePointsAccuracy() {\n    PlanetModel planetModel = randomPlanetModel();\n    for (int i= 0; i < 1000; i++) {\n      GeoPoint point1 = randomGeoPoint(planetModel);\n      double dist = random().nextDouble() * Math.PI - Vector.MINIMUM_ANGULAR_RESOLUTION;\n      double bearing = random().nextDouble() * 2 * Math.PI;\n      GeoPoint point2 = planetModel.surfacePointOnBearing(point1, dist, bearing );\n      dist = random().nextDouble() * Vector.MINIMUM_ANGULAR_RESOLUTION + Vector.MINIMUM_ANGULAR_RESOLUTION;\n      bearing = random().nextDouble() * 2 * Math.PI;\n      GeoPoint point3 = planetModel.surfacePointOnBearing(point1, dist, bearing );\n      GeoPoint check = randomGeoPoint(planetModel);\n      SidedPlane plane  = SidedPlane.constructNormalizedThreePointSidedPlane(check, point1, point2, point3);\n      String msg = planetModel + \" point 1: \" + point1 + \", point 2: \" + point2 + \", point 3: \" + point3 + \" , check: \" + check;\n      if (plane == null) {\n        fail(msg);\n      }\n      assertTrue(plane.evaluate(check) + \" \" + msg, plane.isWithin(check));\n      assertTrue(plane.evaluate(point1) + \" \" +msg, plane.isWithin(point3));\n      assertTrue(plane.evaluate(point2) + \" \" +msg, plane.isWithin(point2));\n      assertTrue(plane.evaluate(point3) + \" \" +msg, plane.isWithin(point1));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["566f5a2735bf9ff5bc8467c9cdfba990e135ecae"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3","date":1518535873,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomPlaneTest#testPlaneThreePointsAccuracy().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomPlaneTest#testPlaneThreePointsAccuracy().mjava","sourceNew":"  @Test\n  @Repeat(iterations = 10)\n  public void testPlaneThreePointsAccuracy() {\n    PlanetModel planetModel = randomPlanetModel();\n    for (int i= 0; i < 1000; i++) {\n      GeoPoint point1 = randomGeoPoint(planetModel);\n      double dist = random().nextDouble() * Math.PI - Vector.MINIMUM_ANGULAR_RESOLUTION;\n      double bearing = random().nextDouble() * 2 * Math.PI;\n      GeoPoint point2 = planetModel.surfacePointOnBearing(point1, dist, bearing );\n      dist = random().nextDouble() * Vector.MINIMUM_ANGULAR_RESOLUTION + Vector.MINIMUM_ANGULAR_RESOLUTION;\n      bearing = random().nextDouble() * 2 * Math.PI;\n      GeoPoint point3 = planetModel.surfacePointOnBearing(point1, dist, bearing );\n      GeoPoint check = randomGeoPoint(planetModel);\n      SidedPlane plane  = SidedPlane.constructNormalizedThreePointSidedPlane(check, point1, point2, point3);\n      String msg = planetModel + \" point 1: \" + point1 + \", point 2: \" + point2 + \", point 3: \" + point3 + \" , check: \" + check;\n      if (plane == null) {\n        fail(msg);\n      }\n      assertTrue(plane.evaluate(check) + \" \" + msg, plane.isWithin(check));\n      assertTrue(plane.evaluate(point1) + \" \" +msg, plane.isWithin(point3));\n      assertTrue(plane.evaluate(point2) + \" \" +msg, plane.isWithin(point2));\n      assertTrue(plane.evaluate(point3) + \" \" +msg, plane.isWithin(point1));\n    }\n  }\n\n","sourceOld":"  @Ignore\n  @Test\n  @Repeat(iterations = 10)\n  public void testPlaneThreePointsAccuracy() {\n    PlanetModel planetModel = randomPlanetModel();\n    for (int i= 0; i < 1000; i++) {\n      GeoPoint point1 = randomGeoPoint(planetModel);\n      double dist = random().nextDouble() * Math.PI - Vector.MINIMUM_ANGULAR_RESOLUTION;\n      double bearing = random().nextDouble() * 2 * Math.PI;\n      GeoPoint point2 = planetModel.surfacePointOnBearing(point1, dist, bearing );\n      dist = random().nextDouble() * Vector.MINIMUM_ANGULAR_RESOLUTION + Vector.MINIMUM_ANGULAR_RESOLUTION;\n      bearing = random().nextDouble() * 2 * Math.PI;\n      GeoPoint point3 = planetModel.surfacePointOnBearing(point1, dist, bearing );\n      GeoPoint check = randomGeoPoint(planetModel);\n      SidedPlane plane  = SidedPlane.constructNormalizedThreePointSidedPlane(check, point1, point2, point3);\n      String msg = planetModel + \" point 1: \" + point1 + \", point 2: \" + point2 + \", point 3: \" + point3 + \" , check: \" + check;\n      if (plane == null) {\n        fail(msg);\n      }\n      assertTrue(plane.evaluate(check) + \" \" + msg, plane.isWithin(check));\n      assertTrue(plane.evaluate(point1) + \" \" +msg, plane.isWithin(point3));\n      assertTrue(plane.evaluate(point2) + \" \" +msg, plane.isWithin(point2));\n      assertTrue(plane.evaluate(point3) + \" \" +msg, plane.isWithin(point1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"566f5a2735bf9ff5bc8467c9cdfba990e135ecae","date":1518559218,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomPlaneTest#testPlaneThreePointsAccuracy().mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomPlaneTest#testPlaneThreePointsAccuracy().mjava","sourceNew":"  @Test\n  @Repeat(iterations = 10)\n  public void testPlaneThreePointsAccuracy() {\n    PlanetModel planetModel = randomPlanetModel();\n    for (int i= 0; i < 1000; i++) {\n      GeoPoint point1 = randomGeoPoint(planetModel);\n      double dist = random().nextDouble() * Math.PI - Vector.MINIMUM_ANGULAR_RESOLUTION;\n      double bearing = random().nextDouble() * 2 * Math.PI;\n      GeoPoint point2 = planetModel.surfacePointOnBearing(point1, dist, bearing );\n      dist = random().nextDouble() * Vector.MINIMUM_ANGULAR_RESOLUTION + Vector.MINIMUM_ANGULAR_RESOLUTION;\n      bearing = random().nextDouble() * 2 * Math.PI;\n      GeoPoint point3 = planetModel.surfacePointOnBearing(point1, dist, bearing );\n      GeoPoint check = randomGeoPoint(planetModel);\n      SidedPlane plane  = SidedPlane.constructNormalizedThreePointSidedPlane(check, point1, point2, point3);\n      String msg = planetModel + \" point 1: \" + point1 + \", point 2: \" + point2 + \", point 3: \" + point3 + \" , check: \" + check;\n      if (plane == null) {\n        fail(msg);\n      }\n      // This is not expected\n      //assertTrue(plane.evaluate(check) + \" \" + msg, plane.isWithin(check));\n      assertTrue(plane.evaluate(point1) + \" \" +msg, plane.isWithin(point1));\n      assertTrue(plane.evaluate(point2) + \" \" +msg, plane.isWithin(point2));\n      assertTrue(plane.evaluate(point3) + \" \" +msg, plane.isWithin(point3));\n    }\n  }\n\n","sourceOld":"  @Test\n  @Repeat(iterations = 10)\n  public void testPlaneThreePointsAccuracy() {\n    PlanetModel planetModel = randomPlanetModel();\n    for (int i= 0; i < 1000; i++) {\n      GeoPoint point1 = randomGeoPoint(planetModel);\n      double dist = random().nextDouble() * Math.PI - Vector.MINIMUM_ANGULAR_RESOLUTION;\n      double bearing = random().nextDouble() * 2 * Math.PI;\n      GeoPoint point2 = planetModel.surfacePointOnBearing(point1, dist, bearing );\n      dist = random().nextDouble() * Vector.MINIMUM_ANGULAR_RESOLUTION + Vector.MINIMUM_ANGULAR_RESOLUTION;\n      bearing = random().nextDouble() * 2 * Math.PI;\n      GeoPoint point3 = planetModel.surfacePointOnBearing(point1, dist, bearing );\n      GeoPoint check = randomGeoPoint(planetModel);\n      SidedPlane plane  = SidedPlane.constructNormalizedThreePointSidedPlane(check, point1, point2, point3);\n      String msg = planetModel + \" point 1: \" + point1 + \", point 2: \" + point2 + \", point 3: \" + point3 + \" , check: \" + check;\n      if (plane == null) {\n        fail(msg);\n      }\n      assertTrue(plane.evaluate(check) + \" \" + msg, plane.isWithin(check));\n      assertTrue(plane.evaluate(point1) + \" \" +msg, plane.isWithin(point3));\n      assertTrue(plane.evaluate(point2) + \" \" +msg, plane.isWithin(point2));\n      assertTrue(plane.evaluate(point3) + \" \" +msg, plane.isWithin(point1));\n    }\n  }\n\n","bugFix":["6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"566f5a2735bf9ff5bc8467c9cdfba990e135ecae":["6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3":["6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1"],"6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["566f5a2735bf9ff5bc8467c9cdfba990e135ecae"]},"commit2Childs":{"566f5a2735bf9ff5bc8467c9cdfba990e135ecae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1"],"6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3":["566f5a2735bf9ff5bc8467c9cdfba990e135ecae"],"6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1":["6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}