{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/CopyOneFile#visit().mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/CopyOneFile#visit().mjava","pathOld":"/dev/null","sourceNew":"  /** Copy another chunk of bytes, returning true once the copy is done */\n  public boolean visit() throws IOException {\n    // Copy up to 640 KB per visit:\n    for(int i=0;i<10;i++) {\n      long bytesLeft = bytesToCopy - bytesCopied;\n      if (bytesLeft == 0) {\n        long checksum = out.getChecksum();\n        if (checksum != metaData.checksum) {\n          // Bits flipped during copy!\n          dest.message(\"file \" + tmpName + \": checksum mismatch after copy (bits flipped during network copy?) after-copy checksum=\" + checksum + \" vs expected=\" + metaData.checksum + \"; cancel job\");\n          throw new IOException(\"file \" + name + \": checksum mismatch after file copy\");\n        }\n\n        // Paranoia: make sure the primary node is not smoking crack, by somehow sending us an already corrupted file whose checksum (in its\n        // footer) disagrees with reality:\n        long actualChecksumIn = in.readLong();\n        if (actualChecksumIn != checksum) {\n          dest.message(\"file \" + tmpName + \": checksum claimed by primary disagrees with the file's footer: claimed checksum=\" + checksum + \" vs actual=\" + actualChecksumIn);\n          throw new IOException(\"file \" + name + \": checksum mismatch after file copy\");\n        }\n        out.writeLong(checksum);\n        close();\n\n        if (Node.VERBOSE_FILES) {\n          dest.message(String.format(Locale.ROOT, \"file %s: done copying [%s, %.3fms]\",\n                                     name,\n                                     Node.bytesToString(metaData.length),\n                                     (System.nanoTime() - copyStartNS)/1000000.0));\n        }\n\n        return true;\n      }\n\n      int toCopy = (int) Math.min(bytesLeft, buffer.length);\n      in.readBytes(buffer, 0, toCopy);\n      out.writeBytes(buffer, 0, toCopy);\n\n      // TODO: rsync will fsync a range of the file; maybe we should do that here for large files in case we crash/killed\n      bytesCopied += toCopy;\n    }\n\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/CopyOneFile#visit().mjava","pathOld":"/dev/null","sourceNew":"  /** Copy another chunk of bytes, returning true once the copy is done */\n  public boolean visit() throws IOException {\n    // Copy up to 640 KB per visit:\n    for(int i=0;i<10;i++) {\n      long bytesLeft = bytesToCopy - bytesCopied;\n      if (bytesLeft == 0) {\n        long checksum = out.getChecksum();\n        if (checksum != metaData.checksum) {\n          // Bits flipped during copy!\n          dest.message(\"file \" + tmpName + \": checksum mismatch after copy (bits flipped during network copy?) after-copy checksum=\" + checksum + \" vs expected=\" + metaData.checksum + \"; cancel job\");\n          throw new IOException(\"file \" + name + \": checksum mismatch after file copy\");\n        }\n\n        // Paranoia: make sure the primary node is not smoking crack, by somehow sending us an already corrupted file whose checksum (in its\n        // footer) disagrees with reality:\n        long actualChecksumIn = in.readLong();\n        if (actualChecksumIn != checksum) {\n          dest.message(\"file \" + tmpName + \": checksum claimed by primary disagrees with the file's footer: claimed checksum=\" + checksum + \" vs actual=\" + actualChecksumIn);\n          throw new IOException(\"file \" + name + \": checksum mismatch after file copy\");\n        }\n        out.writeLong(checksum);\n        close();\n\n        if (Node.VERBOSE_FILES) {\n          dest.message(String.format(Locale.ROOT, \"file %s: done copying [%s, %.3fms]\",\n                                     name,\n                                     Node.bytesToString(metaData.length),\n                                     (System.nanoTime() - copyStartNS)/1000000.0));\n        }\n\n        return true;\n      }\n\n      int toCopy = (int) Math.min(bytesLeft, buffer.length);\n      in.readBytes(buffer, 0, toCopy);\n      out.writeBytes(buffer, 0, toCopy);\n\n      // TODO: rsync will fsync a range of the file; maybe we should do that here for large files in case we crash/killed\n      bytesCopied += toCopy;\n    }\n\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8cfd1df435f04d4287925cca73cf22120f723892","date":1493925365,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/CopyOneFile#visit().mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/CopyOneFile#visit().mjava","sourceNew":"  /** Copy another chunk of bytes, returning true once the copy is done */\n  public boolean visit() throws IOException {\n    // Copy up to 640 KB per visit:\n    for(int i=0;i<10;i++) {\n      long bytesLeft = bytesToCopy - bytesCopied;\n      if (bytesLeft == 0) {\n        long checksum = out.getChecksum();\n        if (checksum != metaData.checksum) {\n          // Bits flipped during copy!\n          dest.message(\"file \" + tmpName + \": checksum mismatch after copy (bits flipped during network copy?) after-copy checksum=\" + checksum + \" vs expected=\" + metaData.checksum + \"; cancel job\");\n          throw new IOException(\"file \" + name + \": checksum mismatch after file copy\");\n        }\n\n        // Paranoia: make sure the primary node is not smoking crack, by somehow sending us an already corrupted file whose checksum (in its\n        // footer) disagrees with reality:\n        long actualChecksumIn = in.readLong();\n        if (actualChecksumIn != checksum) {\n          dest.message(\"file \" + tmpName + \": checksum claimed by primary disagrees with the file's footer: claimed checksum=\" + checksum + \" vs actual=\" + actualChecksumIn);\n          throw new IOException(\"file \" + name + \": checksum mismatch after file copy\");\n        }\n        out.writeLong(checksum);\n        bytesCopied += Long.BYTES;\n        close();\n\n        if (Node.VERBOSE_FILES) {\n          dest.message(String.format(Locale.ROOT, \"file %s: done copying [%s, %.3fms]\",\n                                     name,\n                                     Node.bytesToString(metaData.length),\n                                     (System.nanoTime() - copyStartNS)/1000000.0));\n        }\n\n        return true;\n      }\n\n      int toCopy = (int) Math.min(bytesLeft, buffer.length);\n      in.readBytes(buffer, 0, toCopy);\n      out.writeBytes(buffer, 0, toCopy);\n\n      // TODO: rsync will fsync a range of the file; maybe we should do that here for large files in case we crash/killed\n      bytesCopied += toCopy;\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /** Copy another chunk of bytes, returning true once the copy is done */\n  public boolean visit() throws IOException {\n    // Copy up to 640 KB per visit:\n    for(int i=0;i<10;i++) {\n      long bytesLeft = bytesToCopy - bytesCopied;\n      if (bytesLeft == 0) {\n        long checksum = out.getChecksum();\n        if (checksum != metaData.checksum) {\n          // Bits flipped during copy!\n          dest.message(\"file \" + tmpName + \": checksum mismatch after copy (bits flipped during network copy?) after-copy checksum=\" + checksum + \" vs expected=\" + metaData.checksum + \"; cancel job\");\n          throw new IOException(\"file \" + name + \": checksum mismatch after file copy\");\n        }\n\n        // Paranoia: make sure the primary node is not smoking crack, by somehow sending us an already corrupted file whose checksum (in its\n        // footer) disagrees with reality:\n        long actualChecksumIn = in.readLong();\n        if (actualChecksumIn != checksum) {\n          dest.message(\"file \" + tmpName + \": checksum claimed by primary disagrees with the file's footer: claimed checksum=\" + checksum + \" vs actual=\" + actualChecksumIn);\n          throw new IOException(\"file \" + name + \": checksum mismatch after file copy\");\n        }\n        out.writeLong(checksum);\n        close();\n\n        if (Node.VERBOSE_FILES) {\n          dest.message(String.format(Locale.ROOT, \"file %s: done copying [%s, %.3fms]\",\n                                     name,\n                                     Node.bytesToString(metaData.length),\n                                     (System.nanoTime() - copyStartNS)/1000000.0));\n        }\n\n        return true;\n      }\n\n      int toCopy = (int) Math.min(bytesLeft, buffer.length);\n      in.readBytes(buffer, 0, toCopy);\n      out.writeBytes(buffer, 0, toCopy);\n\n      // TODO: rsync will fsync a range of the file; maybe we should do that here for large files in case we crash/killed\n      bytesCopied += toCopy;\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/CopyOneFile#visit().mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/CopyOneFile#visit().mjava","sourceNew":"  /** Copy another chunk of bytes, returning true once the copy is done */\n  public boolean visit() throws IOException {\n    // Copy up to 640 KB per visit:\n    for(int i=0;i<10;i++) {\n      long bytesLeft = bytesToCopy - bytesCopied;\n      if (bytesLeft == 0) {\n        long checksum = out.getChecksum();\n        if (checksum != metaData.checksum) {\n          // Bits flipped during copy!\n          dest.message(\"file \" + tmpName + \": checksum mismatch after copy (bits flipped during network copy?) after-copy checksum=\" + checksum + \" vs expected=\" + metaData.checksum + \"; cancel job\");\n          throw new IOException(\"file \" + name + \": checksum mismatch after file copy\");\n        }\n\n        // Paranoia: make sure the primary node is not smoking crack, by somehow sending us an already corrupted file whose checksum (in its\n        // footer) disagrees with reality:\n        long actualChecksumIn = in.readLong();\n        if (actualChecksumIn != checksum) {\n          dest.message(\"file \" + tmpName + \": checksum claimed by primary disagrees with the file's footer: claimed checksum=\" + checksum + \" vs actual=\" + actualChecksumIn);\n          throw new IOException(\"file \" + name + \": checksum mismatch after file copy\");\n        }\n        out.writeLong(checksum);\n        bytesCopied += Long.BYTES;\n        close();\n\n        if (Node.VERBOSE_FILES) {\n          dest.message(String.format(Locale.ROOT, \"file %s: done copying [%s, %.3fms]\",\n                                     name,\n                                     Node.bytesToString(metaData.length),\n                                     (System.nanoTime() - copyStartNS)/1000000.0));\n        }\n\n        return true;\n      }\n\n      int toCopy = (int) Math.min(bytesLeft, buffer.length);\n      in.readBytes(buffer, 0, toCopy);\n      out.writeBytes(buffer, 0, toCopy);\n\n      // TODO: rsync will fsync a range of the file; maybe we should do that here for large files in case we crash/killed\n      bytesCopied += toCopy;\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /** Copy another chunk of bytes, returning true once the copy is done */\n  public boolean visit() throws IOException {\n    // Copy up to 640 KB per visit:\n    for(int i=0;i<10;i++) {\n      long bytesLeft = bytesToCopy - bytesCopied;\n      if (bytesLeft == 0) {\n        long checksum = out.getChecksum();\n        if (checksum != metaData.checksum) {\n          // Bits flipped during copy!\n          dest.message(\"file \" + tmpName + \": checksum mismatch after copy (bits flipped during network copy?) after-copy checksum=\" + checksum + \" vs expected=\" + metaData.checksum + \"; cancel job\");\n          throw new IOException(\"file \" + name + \": checksum mismatch after file copy\");\n        }\n\n        // Paranoia: make sure the primary node is not smoking crack, by somehow sending us an already corrupted file whose checksum (in its\n        // footer) disagrees with reality:\n        long actualChecksumIn = in.readLong();\n        if (actualChecksumIn != checksum) {\n          dest.message(\"file \" + tmpName + \": checksum claimed by primary disagrees with the file's footer: claimed checksum=\" + checksum + \" vs actual=\" + actualChecksumIn);\n          throw new IOException(\"file \" + name + \": checksum mismatch after file copy\");\n        }\n        out.writeLong(checksum);\n        close();\n\n        if (Node.VERBOSE_FILES) {\n          dest.message(String.format(Locale.ROOT, \"file %s: done copying [%s, %.3fms]\",\n                                     name,\n                                     Node.bytesToString(metaData.length),\n                                     (System.nanoTime() - copyStartNS)/1000000.0));\n        }\n\n        return true;\n      }\n\n      int toCopy = (int) Math.min(bytesLeft, buffer.length);\n      in.readBytes(buffer, 0, toCopy);\n      out.writeBytes(buffer, 0, toCopy);\n\n      // TODO: rsync will fsync a range of the file; maybe we should do that here for large files in case we crash/killed\n      bytesCopied += toCopy;\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8cfd1df435f04d4287925cca73cf22120f723892":["68496c2200e559fb7802f7575427b7a482659afb"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["68496c2200e559fb7802f7575427b7a482659afb","8cfd1df435f04d4287925cca73cf22120f723892"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8cfd1df435f04d4287925cca73cf22120f723892"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"8cfd1df435f04d4287925cca73cf22120f723892":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["8cfd1df435f04d4287925cca73cf22120f723892","e9017cf144952056066919f1ebc7897ff9bd71b1"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}