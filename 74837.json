{"path":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","commits":[{"id":"6935b9b8d197501fcc418760f4da3088ffb0ed3e","date":1082575124,"type":0,"author":"Tim Jones","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n\n      // pass these methods through to enclosed query's weight\n      public float getValue() { return weight.getValue(); }\n      public float sumOfSquaredWeights() throws IOException { return weight.sumOfSquaredWeights(); }\n      public void normalize (float v) { weight.normalize(v); }\n      public Explanation explain (IndexReader ir, int i) throws IOException { return weight.explain (ir, i); }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a scorer that overrides the enclosed query's score if\n      // the given hit has been filtered out.\n      public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer (indexReader);\n        final BitSet bitset = filter.bits (indexReader);\n        return new Scorer (query.getSimilarity (searcher)) {\n\n          // pass these methods through to the enclosed scorer\n          public boolean next() throws IOException { return scorer.next(); }\n          public int doc() { return scorer.doc(); }\n          public boolean skipTo (int i) throws IOException { return scorer.skipTo(i); }\n\n          // if the document has been filtered out, set score to 0.0\n          public float score() throws IOException {\n            return (bitset.get(scorer.doc())) ? scorer.score() : 0.0f;\n          }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain (i);\n            if (bitset.get(i))\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n            else\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e04c0eb17ea72fec84603b9f7f83738d935a8e5e","e04c0eb17ea72fec84603b9f7f83738d935a8e5e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"402061809f3a4629ea0c449e33e9f94a9772f3c3","date":1113967712,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n\n      // pass these methods through to enclosed query's weight\n      public float getValue() { return weight.getValue(); }\n      public float sumOfSquaredWeights() throws IOException { return weight.sumOfSquaredWeights(); }\n      public void normalize (float v) { weight.normalize(v); }\n      public Explanation explain (IndexReader ir, int i) throws IOException { return weight.explain (ir, i); }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a scorer that overrides the enclosed query's score if\n      // the given hit has been filtered out.\n      public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer (indexReader);\n        final BitSet bitset = filter.bits (indexReader);\n        return new Scorer (similarity) {\n\n          // pass these methods through to the enclosed scorer\n          public boolean next() throws IOException { return scorer.next(); }\n          public int doc() { return scorer.doc(); }\n          public boolean skipTo (int i) throws IOException { return scorer.skipTo(i); }\n\n          // if the document has been filtered out, set score to 0.0\n          public float score() throws IOException {\n            return (bitset.get(scorer.doc())) ? scorer.score() : 0.0f;\n          }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain (i);\n            if (bitset.get(i))\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n            else\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n\n      // pass these methods through to enclosed query's weight\n      public float getValue() { return weight.getValue(); }\n      public float sumOfSquaredWeights() throws IOException { return weight.sumOfSquaredWeights(); }\n      public void normalize (float v) { weight.normalize(v); }\n      public Explanation explain (IndexReader ir, int i) throws IOException { return weight.explain (ir, i); }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a scorer that overrides the enclosed query's score if\n      // the given hit has been filtered out.\n      public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer (indexReader);\n        final BitSet bitset = filter.bits (indexReader);\n        return new Scorer (query.getSimilarity (searcher)) {\n\n          // pass these methods through to the enclosed scorer\n          public boolean next() throws IOException { return scorer.next(); }\n          public int doc() { return scorer.doc(); }\n          public boolean skipTo (int i) throws IOException { return scorer.skipTo(i); }\n\n          // if the document has been filtered out, set score to 0.0\n          public float score() throws IOException {\n            return (bitset.get(scorer.doc())) ? scorer.score() : 0.0f;\n          }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain (i);\n            if (bitset.get(i))\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n            else\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b596f2a26314452d516ce909093895a93ed522bc","date":1141779568,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n\n      // pass these methods through to enclosed query's weight\n      public float getValue() { return weight.getValue(); }\n      public float sumOfSquaredWeights() throws IOException { return weight.sumOfSquaredWeights(); }\n      public void normalize (float v) { weight.normalize(v); }\n      public Explanation explain (IndexReader ir, int i) throws IOException { return weight.explain (ir, i); }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n       public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer (indexReader);\n        final BitSet bitset = filter.bits (indexReader);\n        return new Scorer (similarity) {\n\n          public boolean next() throws IOException {\n            do {\n              if (! scorer.next()) {\n                return false;\n              }\n            } while (! bitset.get(scorer.doc()));\n            /* When skipTo() is allowed on scorer it should be used here\n             * in combination with bitset.nextSetBit(...)\n             * See the while loop in skipTo() below.\n             */\n            return true;\n          }\n          public int doc() { return scorer.doc(); }\n\n          public boolean skipTo(int i) throws IOException {\n            if (! scorer.skipTo(i)) {\n              return false;\n            }\n            while (! bitset.get(scorer.doc())) {\n              int nextFiltered = bitset.nextSetBit(scorer.doc() + 1);\n              if (nextFiltered == -1) {\n                return false;\n              } else if (! scorer.skipTo(nextFiltered)) {\n                return false;\n              }\n            }\n            return true;\n           }\n\n          public float score() throws IOException { return scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain (i);\n            if (bitset.get(i))\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n            else\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n\n      // pass these methods through to enclosed query's weight\n      public float getValue() { return weight.getValue(); }\n      public float sumOfSquaredWeights() throws IOException { return weight.sumOfSquaredWeights(); }\n      public void normalize (float v) { weight.normalize(v); }\n      public Explanation explain (IndexReader ir, int i) throws IOException { return weight.explain (ir, i); }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a scorer that overrides the enclosed query's score if\n      // the given hit has been filtered out.\n      public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer (indexReader);\n        final BitSet bitset = filter.bits (indexReader);\n        return new Scorer (similarity) {\n\n          // pass these methods through to the enclosed scorer\n          public boolean next() throws IOException { return scorer.next(); }\n          public int doc() { return scorer.doc(); }\n          public boolean skipTo (int i) throws IOException { return scorer.skipTo(i); }\n\n          // if the document has been filtered out, set score to 0.0\n          public float score() throws IOException {\n            return (bitset.get(scorer.doc())) ? scorer.score() : 0.0f;\n          }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain (i);\n            if (bitset.get(i))\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n            else\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["e04c0eb17ea72fec84603b9f7f83738d935a8e5e","e04c0eb17ea72fec84603b9f7f83738d935a8e5e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a53ba34cf04e8d72c7d4c4bd297d32206a25c05","date":1150765993,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n\n      // pass these methods through to enclosed query's weight\n      public float getValue() { return weight.getValue(); }\n      public float sumOfSquaredWeights() throws IOException { return weight.sumOfSquaredWeights(); }\n      public void normalize (float v) { weight.normalize(v); }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        Filter f = FilteredQuery.this.filter;\n        BitSet matches = f.bits(ir);\n        if (matches.get(i))\n          return inner;\n        Explanation result = new Explanation\n          (0.0f, \"failure to match filter: \" + f.toString());\n        result.addDetail(inner);\n        return result;\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n       public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer (indexReader);\n        final BitSet bitset = filter.bits (indexReader);\n        return new Scorer (similarity) {\n\n          public boolean next() throws IOException {\n            do {\n              if (! scorer.next()) {\n                return false;\n              }\n            } while (! bitset.get(scorer.doc()));\n            /* When skipTo() is allowed on scorer it should be used here\n             * in combination with bitset.nextSetBit(...)\n             * See the while loop in skipTo() below.\n             */\n            return true;\n          }\n          public int doc() { return scorer.doc(); }\n\n          public boolean skipTo(int i) throws IOException {\n            if (! scorer.skipTo(i)) {\n              return false;\n            }\n            while (! bitset.get(scorer.doc())) {\n              int nextFiltered = bitset.nextSetBit(scorer.doc() + 1);\n              if (nextFiltered == -1) {\n                return false;\n              } else if (! scorer.skipTo(nextFiltered)) {\n                return false;\n              }\n            }\n            return true;\n           }\n\n          public float score() throws IOException { return scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain (i);\n            if (bitset.get(i))\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n            else\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n\n      // pass these methods through to enclosed query's weight\n      public float getValue() { return weight.getValue(); }\n      public float sumOfSquaredWeights() throws IOException { return weight.sumOfSquaredWeights(); }\n      public void normalize (float v) { weight.normalize(v); }\n      public Explanation explain (IndexReader ir, int i) throws IOException { return weight.explain (ir, i); }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n       public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer (indexReader);\n        final BitSet bitset = filter.bits (indexReader);\n        return new Scorer (similarity) {\n\n          public boolean next() throws IOException {\n            do {\n              if (! scorer.next()) {\n                return false;\n              }\n            } while (! bitset.get(scorer.doc()));\n            /* When skipTo() is allowed on scorer it should be used here\n             * in combination with bitset.nextSetBit(...)\n             * See the while loop in skipTo() below.\n             */\n            return true;\n          }\n          public int doc() { return scorer.doc(); }\n\n          public boolean skipTo(int i) throws IOException {\n            if (! scorer.skipTo(i)) {\n              return false;\n            }\n            while (! bitset.get(scorer.doc())) {\n              int nextFiltered = bitset.nextSetBit(scorer.doc() + 1);\n              if (nextFiltered == -1) {\n                return false;\n              } else if (! scorer.skipTo(nextFiltered)) {\n                return false;\n              }\n            }\n            return true;\n           }\n\n          public float score() throws IOException { return scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain (i);\n            if (bitset.get(i))\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n            else\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e04c0eb17ea72fec84603b9f7f83738d935a8e5e","date":1180566565,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        inner.setValue(getBoost() * inner.getValue());\n        Filter f = FilteredQuery.this.filter;\n        BitSet matches = f.bits(ir);\n        if (matches.get(i))\n          return inner;\n        Explanation result = new Explanation\n          (0.0f, \"failure to match filter: \" + f.toString());\n        result.addDetail(inner);\n        return result;\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n       public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer (indexReader);\n        final BitSet bitset = filter.bits (indexReader);\n        return new Scorer (similarity) {\n\n          public boolean next() throws IOException {\n            do {\n              if (! scorer.next()) {\n                return false;\n              }\n            } while (! bitset.get(scorer.doc()));\n            /* When skipTo() is allowed on scorer it should be used here\n             * in combination with bitset.nextSetBit(...)\n             * See the while loop in skipTo() below.\n             */\n            return true;\n          }\n          public int doc() { return scorer.doc(); }\n\n          public boolean skipTo(int i) throws IOException {\n            if (! scorer.skipTo(i)) {\n              return false;\n            }\n            while (! bitset.get(scorer.doc())) {\n              int nextFiltered = bitset.nextSetBit(scorer.doc() + 1);\n              if (nextFiltered == -1) {\n                return false;\n              } else if (! scorer.skipTo(nextFiltered)) {\n                return false;\n              }\n            }\n            return true;\n           }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain (i);\n            exp.setValue(getBoost() * exp.getValue());\n            \n            if (bitset.get(i))\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n            else\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n\n      // pass these methods through to enclosed query's weight\n      public float getValue() { return weight.getValue(); }\n      public float sumOfSquaredWeights() throws IOException { return weight.sumOfSquaredWeights(); }\n      public void normalize (float v) { weight.normalize(v); }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        Filter f = FilteredQuery.this.filter;\n        BitSet matches = f.bits(ir);\n        if (matches.get(i))\n          return inner;\n        Explanation result = new Explanation\n          (0.0f, \"failure to match filter: \" + f.toString());\n        result.addDetail(inner);\n        return result;\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n       public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer (indexReader);\n        final BitSet bitset = filter.bits (indexReader);\n        return new Scorer (similarity) {\n\n          public boolean next() throws IOException {\n            do {\n              if (! scorer.next()) {\n                return false;\n              }\n            } while (! bitset.get(scorer.doc()));\n            /* When skipTo() is allowed on scorer it should be used here\n             * in combination with bitset.nextSetBit(...)\n             * See the while loop in skipTo() below.\n             */\n            return true;\n          }\n          public int doc() { return scorer.doc(); }\n\n          public boolean skipTo(int i) throws IOException {\n            if (! scorer.skipTo(i)) {\n              return false;\n            }\n            while (! bitset.get(scorer.doc())) {\n              int nextFiltered = bitset.nextSetBit(scorer.doc() + 1);\n              if (nextFiltered == -1) {\n                return false;\n              } else if (! scorer.skipTo(nextFiltered)) {\n                return false;\n              }\n            }\n            return true;\n           }\n\n          public float score() throws IOException { return scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain (i);\n            if (bitset.get(i))\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n            else\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":["6935b9b8d197501fcc418760f4da3088ffb0ed3e","b596f2a26314452d516ce909093895a93ed522bc"],"bugIntro":["0e60b4907a1867e066f425a450d96e4297dfa973","0e60b4907a1867e066f425a450d96e4297dfa973"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e60b4907a1867e066f425a450d96e4297dfa973","date":1180989666,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        BitSet matches = f.bits(ir);\n        if (matches.get(i))\n          return inner;\n        Explanation result = new Explanation\n          (0.0f, \"failure to match filter: \" + f.toString());\n        result.addDetail(inner);\n        return result;\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n       public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer (indexReader);\n        final BitSet bitset = filter.bits (indexReader);\n        return new Scorer (similarity) {\n\n          public boolean next() throws IOException {\n            do {\n              if (! scorer.next()) {\n                return false;\n              }\n            } while (! bitset.get(scorer.doc()));\n            /* When skipTo() is allowed on scorer it should be used here\n             * in combination with bitset.nextSetBit(...)\n             * See the while loop in skipTo() below.\n             */\n            return true;\n          }\n          public int doc() { return scorer.doc(); }\n\n          public boolean skipTo(int i) throws IOException {\n            if (! scorer.skipTo(i)) {\n              return false;\n            }\n            while (! bitset.get(scorer.doc())) {\n              int nextFiltered = bitset.nextSetBit(scorer.doc() + 1);\n              if (nextFiltered == -1) {\n                return false;\n              } else if (! scorer.skipTo(nextFiltered)) {\n                return false;\n              }\n            }\n            return true;\n           }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain (i);\n            exp.setValue(getBoost() * exp.getValue());\n            \n            if (bitset.get(i))\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n            else\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        inner.setValue(getBoost() * inner.getValue());\n        Filter f = FilteredQuery.this.filter;\n        BitSet matches = f.bits(ir);\n        if (matches.get(i))\n          return inner;\n        Explanation result = new Explanation\n          (0.0f, \"failure to match filter: \" + f.toString());\n        result.addDetail(inner);\n        return result;\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n       public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer (indexReader);\n        final BitSet bitset = filter.bits (indexReader);\n        return new Scorer (similarity) {\n\n          public boolean next() throws IOException {\n            do {\n              if (! scorer.next()) {\n                return false;\n              }\n            } while (! bitset.get(scorer.doc()));\n            /* When skipTo() is allowed on scorer it should be used here\n             * in combination with bitset.nextSetBit(...)\n             * See the while loop in skipTo() below.\n             */\n            return true;\n          }\n          public int doc() { return scorer.doc(); }\n\n          public boolean skipTo(int i) throws IOException {\n            if (! scorer.skipTo(i)) {\n              return false;\n            }\n            while (! bitset.get(scorer.doc())) {\n              int nextFiltered = bitset.nextSetBit(scorer.doc() + 1);\n              if (nextFiltered == -1) {\n                return false;\n              } else if (! scorer.skipTo(nextFiltered)) {\n                return false;\n              }\n            }\n            return true;\n           }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain (i);\n            exp.setValue(getBoost() * exp.getValue());\n            \n            if (bitset.get(i))\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n            else\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":["e04c0eb17ea72fec84603b9f7f83738d935a8e5e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"52ce7e961a8217faac8128e3c8fe67819eefdde9","date":1201979043,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSetIterator docIdSetIterator = f.getDocIdSet(ir).iterator();\n        if (docIdSetIterator.skipTo(i) && (docIdSetIterator.doc() == i)) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n       public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer(indexReader);\n        final DocIdSetIterator docIdSetIterator = filter.getDocIdSet(indexReader).iterator();\n\n        return new Scorer(similarity) {\n\n          private boolean advanceToCommon() throws IOException {\n            while (scorer.doc() != docIdSetIterator.doc()) {\n              if (scorer.doc() < docIdSetIterator.doc()) {\n                if (!scorer.skipTo(docIdSetIterator.doc())) {\n                  return false;\n                }\n              } else if (!docIdSetIterator.skipTo(scorer.doc())) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          public boolean next() throws IOException {\n            return docIdSetIterator.next() && scorer.next() && advanceToCommon();\n          }\n\n          public int doc() { return scorer.doc(); }\n\n          public boolean skipTo(int i) throws IOException {\n            return docIdSetIterator.skipTo(i)\n                && scorer.skipTo(docIdSetIterator.doc())\n                && advanceToCommon();\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.skipTo(i) && (docIdSetIterator.doc() == i)) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        BitSet matches = f.bits(ir);\n        if (matches.get(i))\n          return inner;\n        Explanation result = new Explanation\n          (0.0f, \"failure to match filter: \" + f.toString());\n        result.addDetail(inner);\n        return result;\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n       public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer (indexReader);\n        final BitSet bitset = filter.bits (indexReader);\n        return new Scorer (similarity) {\n\n          public boolean next() throws IOException {\n            do {\n              if (! scorer.next()) {\n                return false;\n              }\n            } while (! bitset.get(scorer.doc()));\n            /* When skipTo() is allowed on scorer it should be used here\n             * in combination with bitset.nextSetBit(...)\n             * See the while loop in skipTo() below.\n             */\n            return true;\n          }\n          public int doc() { return scorer.doc(); }\n\n          public boolean skipTo(int i) throws IOException {\n            if (! scorer.skipTo(i)) {\n              return false;\n            }\n            while (! bitset.get(scorer.doc())) {\n              int nextFiltered = bitset.nextSetBit(scorer.doc() + 1);\n              if (nextFiltered == -1) {\n                return false;\n              } else if (! scorer.skipTo(nextFiltered)) {\n                return false;\n              }\n            }\n            return true;\n           }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain (i);\n            exp.setValue(getBoost() * exp.getValue());\n            \n            if (bitset.get(i))\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n            else\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30a558487f2298c2c19ceca9103c1b6865d64708","date":1244393921,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSetIterator docIdSetIterator = f.getDocIdSet(ir).iterator();\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer(indexReader);\n        final DocIdSetIterator docIdSetIterator = filter.getDocIdSet(indexReader).iterator();\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() { return scorer.doc(); }\n          public int docID() { return doc; }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int i) throws IOException {\n            return advance(i) != NO_MORE_DOCS;\n          }\n          \n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.advance(i) == i) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSetIterator docIdSetIterator = f.getDocIdSet(ir).iterator();\n        if (docIdSetIterator.skipTo(i) && (docIdSetIterator.doc() == i)) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n       public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer(indexReader);\n        final DocIdSetIterator docIdSetIterator = filter.getDocIdSet(indexReader).iterator();\n\n        return new Scorer(similarity) {\n\n          private boolean advanceToCommon() throws IOException {\n            while (scorer.doc() != docIdSetIterator.doc()) {\n              if (scorer.doc() < docIdSetIterator.doc()) {\n                if (!scorer.skipTo(docIdSetIterator.doc())) {\n                  return false;\n                }\n              } else if (!docIdSetIterator.skipTo(scorer.doc())) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          public boolean next() throws IOException {\n            return docIdSetIterator.next() && scorer.next() && advanceToCommon();\n          }\n\n          public int doc() { return scorer.doc(); }\n\n          public boolean skipTo(int i) throws IOException {\n            return docIdSetIterator.skipTo(i)\n                && scorer.skipTo(docIdSetIterator.doc())\n                && advanceToCommon();\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.skipTo(i) && (docIdSetIterator.doc() == i)) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"052fac7830290bd38a04cddee1a121ee07656b56","date":1245780702,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createQueryWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  public QueryWeight createQueryWeight(final Searcher searcher) throws IOException {\n    final QueryWeight weight = query.createQueryWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new QueryWeight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSetIterator docIdSetIterator = f.getDocIdSet(ir).iterator();\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, scoreDocsInOrder, false);\n        final DocIdSetIterator docIdSetIterator = filter.getDocIdSet(indexReader).iterator();\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() { return scorer.doc(); }\n          public int docID() { return doc; }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int i) throws IOException {\n            return advance(i) != NO_MORE_DOCS;\n          }\n          \n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.advance(i) == i) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  protected Weight createWeight (final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSetIterator docIdSetIterator = f.getDocIdSet(ir).iterator();\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      public Scorer scorer (IndexReader indexReader) throws IOException {\n        final Scorer scorer = weight.scorer(indexReader);\n        final DocIdSetIterator docIdSetIterator = filter.getDocIdSet(indexReader).iterator();\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() { return scorer.doc(); }\n          public int docID() { return doc; }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int i) throws IOException {\n            return advance(i) != NO_MORE_DOCS;\n          }\n          \n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.advance(i) == i) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe941135bdfc28c81e20b4d21422f8726af34925","date":1250040150,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createQueryWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (Searcher searcher, IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (searcher, ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, scoreDocsInOrder, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() { return scorer.doc(); }\n          public int docID() { return doc; }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int i) throws IOException {\n            return advance(i) != NO_MORE_DOCS;\n          }\n          \n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.advance(i) == i) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  public QueryWeight createQueryWeight(final Searcher searcher) throws IOException {\n    final QueryWeight weight = query.createQueryWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new QueryWeight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, scoreDocsInOrder, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() { return scorer.doc(); }\n          public int docID() { return doc; }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int i) throws IOException {\n            return advance(i) != NO_MORE_DOCS;\n          }\n          \n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.advance(i) == i) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"231941d2cb96b9752e839c311391096d90470db8","date":1251116803,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, scoreDocsInOrder, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() { return scorer.doc(); }\n          public int docID() { return doc; }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int i) throws IOException {\n            return advance(i) != NO_MORE_DOCS;\n          }\n          \n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.advance(i) == i) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (Searcher searcher, IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (searcher, ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, scoreDocsInOrder, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() { return scorer.doc(); }\n          public int docID() { return doc; }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int i) throws IOException {\n            return advance(i) != NO_MORE_DOCS;\n          }\n          \n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.advance(i) == i) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":["fe941135bdfc28c81e20b4d21422f8726af34925"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b23454c4f141b0d4ece274dc96a37f7ed99b4b8","date":1251237349,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() { return scorer.doc(); }\n          public int docID() { return doc; }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int i) throws IOException {\n            return advance(i) != NO_MORE_DOCS;\n          }\n          \n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.advance(i) == i) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, scoreDocsInOrder, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() { return scorer.doc(); }\n          public int docID() { return doc; }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int i) throws IOException {\n            return advance(i) != NO_MORE_DOCS;\n          }\n          \n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.advance(i) == i) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"438aef2dc00a23f2716882753fe225fbce4cfbfc","date":1255281460,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          public int docID() { return doc; }\n          \n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.advance(i) == i) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          /** @deprecated use {@link #nextDoc()} instead. */\n          public boolean next() throws IOException {\n            return nextDoc() != NO_MORE_DOCS;\n          }\n\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          /** @deprecated use {@link #docID()} instead. */\n          public int doc() { return scorer.doc(); }\n          public int docID() { return doc; }\n          \n          /** @deprecated use {@link #advance(int)} instead. */\n          public boolean skipTo(int i) throws IOException {\n            return advance(i) != NO_MORE_DOCS;\n          }\n          \n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.advance(i) == i) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"486cfd5a3f7481938475c113415d896f7a74a4a9","date":1256682581,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      public float getValue() { return value; }\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          public int docID() { return doc; }\n          \n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n\n          // add an explanation about whether the document was filtered\n          public Explanation explain (int i) throws IOException {\n            Explanation exp = scorer.explain(i);\n            \n            if (docIdSetIterator.advance(i) == i) {\n              exp.setDescription (\"allowed by filter: \"+exp.getDescription());\n              exp.setValue(getBoost() * exp.getValue());\n            } else {\n              exp.setDescription (\"removed by filter: \"+exp.getDescription());\n              exp.setValue(0.0f);\n            }\n            return exp;\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a9e385641d717e641408d8fbbc62be8fc766357","date":1256746606,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","pathOld":"src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b596f2a26314452d516ce909093895a93ed522bc":["402061809f3a4629ea0c449e33e9f94a9772f3c3"],"8a9e385641d717e641408d8fbbc62be8fc766357":["486cfd5a3f7481938475c113415d896f7a74a4a9"],"231941d2cb96b9752e839c311391096d90470db8":["fe941135bdfc28c81e20b4d21422f8726af34925"],"fe941135bdfc28c81e20b4d21422f8726af34925":["052fac7830290bd38a04cddee1a121ee07656b56"],"e04c0eb17ea72fec84603b9f7f83738d935a8e5e":["7a53ba34cf04e8d72c7d4c4bd297d32206a25c05"],"0e60b4907a1867e066f425a450d96e4297dfa973":["e04c0eb17ea72fec84603b9f7f83738d935a8e5e"],"6935b9b8d197501fcc418760f4da3088ffb0ed3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"486cfd5a3f7481938475c113415d896f7a74a4a9":["438aef2dc00a23f2716882753fe225fbce4cfbfc"],"30a558487f2298c2c19ceca9103c1b6865d64708":["52ce7e961a8217faac8128e3c8fe67819eefdde9"],"438aef2dc00a23f2716882753fe225fbce4cfbfc":["7b23454c4f141b0d4ece274dc96a37f7ed99b4b8"],"7a53ba34cf04e8d72c7d4c4bd297d32206a25c05":["b596f2a26314452d516ce909093895a93ed522bc"],"402061809f3a4629ea0c449e33e9f94a9772f3c3":["6935b9b8d197501fcc418760f4da3088ffb0ed3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7b23454c4f141b0d4ece274dc96a37f7ed99b4b8":["231941d2cb96b9752e839c311391096d90470db8"],"52ce7e961a8217faac8128e3c8fe67819eefdde9":["0e60b4907a1867e066f425a450d96e4297dfa973"],"052fac7830290bd38a04cddee1a121ee07656b56":["30a558487f2298c2c19ceca9103c1b6865d64708"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["8a9e385641d717e641408d8fbbc62be8fc766357"]},"commit2Childs":{"b596f2a26314452d516ce909093895a93ed522bc":["7a53ba34cf04e8d72c7d4c4bd297d32206a25c05"],"8a9e385641d717e641408d8fbbc62be8fc766357":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"231941d2cb96b9752e839c311391096d90470db8":["7b23454c4f141b0d4ece274dc96a37f7ed99b4b8"],"fe941135bdfc28c81e20b4d21422f8726af34925":["231941d2cb96b9752e839c311391096d90470db8"],"e04c0eb17ea72fec84603b9f7f83738d935a8e5e":["0e60b4907a1867e066f425a450d96e4297dfa973"],"0e60b4907a1867e066f425a450d96e4297dfa973":["52ce7e961a8217faac8128e3c8fe67819eefdde9"],"6935b9b8d197501fcc418760f4da3088ffb0ed3e":["402061809f3a4629ea0c449e33e9f94a9772f3c3"],"486cfd5a3f7481938475c113415d896f7a74a4a9":["8a9e385641d717e641408d8fbbc62be8fc766357"],"30a558487f2298c2c19ceca9103c1b6865d64708":["052fac7830290bd38a04cddee1a121ee07656b56"],"438aef2dc00a23f2716882753fe225fbce4cfbfc":["486cfd5a3f7481938475c113415d896f7a74a4a9"],"402061809f3a4629ea0c449e33e9f94a9772f3c3":["b596f2a26314452d516ce909093895a93ed522bc"],"7a53ba34cf04e8d72c7d4c4bd297d32206a25c05":["e04c0eb17ea72fec84603b9f7f83738d935a8e5e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6935b9b8d197501fcc418760f4da3088ffb0ed3e"],"7b23454c4f141b0d4ece274dc96a37f7ed99b4b8":["438aef2dc00a23f2716882753fe225fbce4cfbfc"],"52ce7e961a8217faac8128e3c8fe67819eefdde9":["30a558487f2298c2c19ceca9103c1b6865d64708"],"052fac7830290bd38a04cddee1a121ee07656b56":["fe941135bdfc28c81e20b4d21422f8726af34925"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}