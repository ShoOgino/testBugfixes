{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#getCollectionProperties(String,long).mjava","commits":[{"id":"ad04daa4b07fab11f19bb17a8b556b0dde898d7f","date":1560262372,"type":0,"author":"Gus Heck","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#getCollectionProperties(String,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Get and cache collection properties for a given collection. If the collection is watched, or still cached\n   * simply return it from the cache, otherwise fetch it directly from zookeeper and retain the value for at\n   * least cacheForMillis milliseconds. Cached properties are watched in zookeeper and updated automatically.\n   * This version of {@code getCollectionProperties} should be used when properties need to be consulted\n   * frequently in the absence of an active {@link CollectionPropsWatcher}.\n   *\n   * @param collection The collection for which properties are desired\n   * @param cacheForMillis The minimum number of milliseconds to maintain a cache for the specified collection's\n   *                       properties. Setting a {@code CollectionPropsWatcher} will override this value and retain\n   *                       the cache for the life of the watcher. A lack of changes in zookeeper may allow the\n   *                       caching to remain for a greater duration up to the cycle time of {@link CacheCleaner}.\n   *                       Passing zero for this value will explicitly remove the cached copy if and only if it is\n   *                       due to expire and no watch exists. Any positive value will extend the expiration time\n   *                       if required.\n   * @return a map representing the key/value properties for the collection.\n   */\n  public Map<String, String> getCollectionProperties(final String collection, long cacheForMillis) {\n    synchronized (watchedCollectionProps) { // making decisions based on the result of a get...\n      Watcher watcher = null;\n      if (cacheForMillis > 0) {\n        watcher = collectionPropsWatchers.compute(collection,\n            (c, w) -> w == null ? new PropsWatcher(c, cacheForMillis) : w.renew(cacheForMillis));\n      }\n      VersionedCollectionProps vprops = watchedCollectionProps.get(collection);\n      boolean haveUnexpiredProps = vprops != null && vprops.cacheUntilNs > System.nanoTime();\n      long untilNs = System.nanoTime() + TimeUnit.NANOSECONDS.convert(cacheForMillis, TimeUnit.MILLISECONDS);\n      Map<String, String> properties;\n      if (haveUnexpiredProps) {\n        properties = vprops.props;\n        vprops.cacheUntilNs = Math.max(vprops.cacheUntilNs, untilNs);\n      } else {\n        try {\n          VersionedCollectionProps vcp = fetchCollectionProperties(collection, watcher);\n          properties = vcp.props;\n          if (cacheForMillis > 0) {\n            vcp.cacheUntilNs = untilNs;\n            watchedCollectionProps.put(collection,vcp);\n          } else {\n            // we're synchronized on watchedCollectionProps and we can only get here if we have found an expired\n            // vprops above, so it is safe to remove the cached value and let the GC free up some mem a bit sooner.\n            if (!collectionPropsObservers.containsKey(collection)) {\n              watchedCollectionProps.remove(collection);\n            }\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Error reading collection properties\", SolrZkClient.checkInterrupted(e));\n        }\n      }\n      return properties;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#getCollectionProperties(String,long).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#getCollectionProperties(String,long).mjava","sourceNew":"  /**\n   * Get and cache collection properties for a given collection. If the collection is watched, or still cached\n   * simply return it from the cache, otherwise fetch it directly from zookeeper and retain the value for at\n   * least cacheForMillis milliseconds. Cached properties are watched in zookeeper and updated automatically.\n   * This version of {@code getCollectionProperties} should be used when properties need to be consulted\n   * frequently in the absence of an active {@link CollectionPropsWatcher}.\n   *\n   * @param collection     The collection for which properties are desired\n   * @param cacheForMillis The minimum number of milliseconds to maintain a cache for the specified collection's\n   *                       properties. Setting a {@code CollectionPropsWatcher} will override this value and retain\n   *                       the cache for the life of the watcher. A lack of changes in zookeeper may allow the\n   *                       caching to remain for a greater duration up to the cycle time of {@link CacheCleaner}.\n   *                       Passing zero for this value will explicitly remove the cached copy if and only if it is\n   *                       due to expire and no watch exists. Any positive value will extend the expiration time\n   *                       if required.\n   * @return a map representing the key/value properties for the collection.\n   */\n  public Map<String, String> getCollectionProperties(final String collection, long cacheForMillis) {\n    synchronized (watchedCollectionProps) { // making decisions based on the result of a get...\n      Watcher watcher = null;\n      if (cacheForMillis > 0) {\n        watcher = collectionPropsWatchers.compute(collection,\n            (c, w) -> w == null ? new PropsWatcher(c, cacheForMillis) : w.renew(cacheForMillis));\n      }\n      VersionedCollectionProps vprops = watchedCollectionProps.get(collection);\n      boolean haveUnexpiredProps = vprops != null && vprops.cacheUntilNs > System.nanoTime();\n      long untilNs = System.nanoTime() + TimeUnit.NANOSECONDS.convert(cacheForMillis, TimeUnit.MILLISECONDS);\n      Map<String, String> properties;\n      if (haveUnexpiredProps) {\n        properties = vprops.props;\n        vprops.cacheUntilNs = Math.max(vprops.cacheUntilNs, untilNs);\n      } else {\n        try {\n          VersionedCollectionProps vcp = fetchCollectionProperties(collection, watcher);\n          properties = vcp.props;\n          if (cacheForMillis > 0) {\n            vcp.cacheUntilNs = untilNs;\n            watchedCollectionProps.put(collection, vcp);\n          } else {\n            // we're synchronized on watchedCollectionProps and we can only get here if we have found an expired\n            // vprops above, so it is safe to remove the cached value and let the GC free up some mem a bit sooner.\n            if (!collectionPropsObservers.containsKey(collection)) {\n              watchedCollectionProps.remove(collection);\n            }\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Error reading collection properties\", SolrZkClient.checkInterrupted(e));\n        }\n      }\n      return properties;\n    }\n  }\n\n","sourceOld":"  /**\n   * Get and cache collection properties for a given collection. If the collection is watched, or still cached\n   * simply return it from the cache, otherwise fetch it directly from zookeeper and retain the value for at\n   * least cacheForMillis milliseconds. Cached properties are watched in zookeeper and updated automatically.\n   * This version of {@code getCollectionProperties} should be used when properties need to be consulted\n   * frequently in the absence of an active {@link CollectionPropsWatcher}.\n   *\n   * @param collection The collection for which properties are desired\n   * @param cacheForMillis The minimum number of milliseconds to maintain a cache for the specified collection's\n   *                       properties. Setting a {@code CollectionPropsWatcher} will override this value and retain\n   *                       the cache for the life of the watcher. A lack of changes in zookeeper may allow the\n   *                       caching to remain for a greater duration up to the cycle time of {@link CacheCleaner}.\n   *                       Passing zero for this value will explicitly remove the cached copy if and only if it is\n   *                       due to expire and no watch exists. Any positive value will extend the expiration time\n   *                       if required.\n   * @return a map representing the key/value properties for the collection.\n   */\n  public Map<String, String> getCollectionProperties(final String collection, long cacheForMillis) {\n    synchronized (watchedCollectionProps) { // making decisions based on the result of a get...\n      Watcher watcher = null;\n      if (cacheForMillis > 0) {\n        watcher = collectionPropsWatchers.compute(collection,\n            (c, w) -> w == null ? new PropsWatcher(c, cacheForMillis) : w.renew(cacheForMillis));\n      }\n      VersionedCollectionProps vprops = watchedCollectionProps.get(collection);\n      boolean haveUnexpiredProps = vprops != null && vprops.cacheUntilNs > System.nanoTime();\n      long untilNs = System.nanoTime() + TimeUnit.NANOSECONDS.convert(cacheForMillis, TimeUnit.MILLISECONDS);\n      Map<String, String> properties;\n      if (haveUnexpiredProps) {\n        properties = vprops.props;\n        vprops.cacheUntilNs = Math.max(vprops.cacheUntilNs, untilNs);\n      } else {\n        try {\n          VersionedCollectionProps vcp = fetchCollectionProperties(collection, watcher);\n          properties = vcp.props;\n          if (cacheForMillis > 0) {\n            vcp.cacheUntilNs = untilNs;\n            watchedCollectionProps.put(collection,vcp);\n          } else {\n            // we're synchronized on watchedCollectionProps and we can only get here if we have found an expired\n            // vprops above, so it is safe to remove the cached value and let the GC free up some mem a bit sooner.\n            if (!collectionPropsObservers.containsKey(collection)) {\n              watchedCollectionProps.remove(collection);\n            }\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Error reading collection properties\", SolrZkClient.checkInterrupted(e));\n        }\n      }\n      return properties;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2668c99990e4c94a78bac005aa682b7c5986d23a":["ad04daa4b07fab11f19bb17a8b556b0dde898d7f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad04daa4b07fab11f19bb17a8b556b0dde898d7f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2668c99990e4c94a78bac005aa682b7c5986d23a"]},"commit2Childs":{"2668c99990e4c94a78bac005aa682b7c5986d23a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ad04daa4b07fab11f19bb17a8b556b0dde898d7f"],"ad04daa4b07fab11f19bb17a8b556b0dde898d7f":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}