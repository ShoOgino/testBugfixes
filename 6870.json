{"path":"lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","pathOld":"lucene/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","sourceNew":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      public char charAt(int i) { return longTestString.charAt(i); }\n      public int length() { return longTestString.length(); }\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      @Override\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","sourceOld":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      public char charAt(int i) { return longTestString.charAt(i); }\n      public int length() { return longTestString.length(); }\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      @Override\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","sourceNew":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      @Override\n      public char charAt(int i) { return longTestString.charAt(i); }\n      @Override\n      public int length() { return longTestString.length(); }\n      @Override\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      @Override\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","sourceOld":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      public char charAt(int i) { return longTestString.charAt(i); }\n      public int length() { return longTestString.length(); }\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      @Override\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","sourceNew":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      @Override\n      public char charAt(int i) { return longTestString.charAt(i); }\n      @Override\n      public int length() { return longTestString.length(); }\n      @Override\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      @Override\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","sourceOld":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      public char charAt(int i) { return longTestString.charAt(i); }\n      public int length() { return longTestString.length(); }\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      @Override\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","7530de27b87b961b51f01bd1299b7004d46e8823"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7530de27b87b961b51f01bd1299b7004d46e8823"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}