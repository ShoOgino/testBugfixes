{"path":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int,int).mjava","commits":[{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","sourceNew":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dataDimensionCount, int indexDimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from index options=\" + this.indexOptions + \" to inconsistent index options=\" + indexOptions);\n      }\n    }\n\n    if (this.pointDataDimensionCount == 0 && dataDimensionCount != 0) {\n      this.pointDataDimensionCount = dataDimensionCount;\n      this.pointIndexDimensionCount = indexDimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    } else if (dataDimensionCount != 0 && (this.pointDataDimensionCount != dataDimensionCount || this.pointIndexDimensionCount != indexDimensionCount || this.pointNumBytes != dimensionNumBytes)) {\n      throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from points dataDimensionCount=\" + this.pointDataDimensionCount + \", indexDimensionCount=\" + this.pointIndexDimensionCount + \", numBytes=\" + this.pointNumBytes + \" to inconsistent dataDimensionCount=\" + dataDimensionCount +\", indexDimensionCount=\" + indexDimensionCount + \", numBytes=\" + dimensionNumBytes);\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","sourceOld":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from index options=\" + this.indexOptions + \" to inconsistent index options=\" + indexOptions);\n      }\n    }\n\n    if (this.pointDimensionCount == 0 && dimensionCount != 0) {\n      this.pointDimensionCount = dimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    } else if (dimensionCount != 0 && (this.pointDimensionCount != dimensionCount || this.pointNumBytes != dimensionNumBytes)) {\n      throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from points dimensionCount=\" + this.pointDimensionCount + \", numBytes=\" + this.pointNumBytes + \" to inconsistent dimensionCount=\" + dimensionCount + \", numBytes=\" + dimensionNumBytes);\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1dbcafacd03baeb0f18199de611a1619606073c5","date":1546559081,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,Map[String,String],int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int,int).mjava","sourceNew":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              Map<String, String> attributes, int dataDimensionCount, int indexDimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from index options=\" + this.indexOptions + \" to inconsistent index options=\" + indexOptions);\n      }\n    }\n\n    if (this.pointDataDimensionCount == 0 && dataDimensionCount != 0) {\n      this.pointDataDimensionCount = dataDimensionCount;\n      this.pointIndexDimensionCount = indexDimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    } else if (dataDimensionCount != 0 && (this.pointDataDimensionCount != dataDimensionCount || this.pointIndexDimensionCount != indexDimensionCount || this.pointNumBytes != dimensionNumBytes)) {\n      throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from points dataDimensionCount=\" + this.pointDataDimensionCount + \", indexDimensionCount=\" + this.pointIndexDimensionCount + \", numBytes=\" + this.pointNumBytes + \" to inconsistent dataDimensionCount=\" + dataDimensionCount +\", indexDimensionCount=\" + indexDimensionCount + \", numBytes=\" + dimensionNumBytes);\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    if (attributes != null) {\n      this.attributes.putAll(attributes);\n    }\n    assert checkConsistency();\n  }\n\n","sourceOld":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dataDimensionCount, int indexDimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from index options=\" + this.indexOptions + \" to inconsistent index options=\" + indexOptions);\n      }\n    }\n\n    if (this.pointDataDimensionCount == 0 && dataDimensionCount != 0) {\n      this.pointDataDimensionCount = dataDimensionCount;\n      this.pointIndexDimensionCount = indexDimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    } else if (dataDimensionCount != 0 && (this.pointDataDimensionCount != dataDimensionCount || this.pointIndexDimensionCount != indexDimensionCount || this.pointNumBytes != dimensionNumBytes)) {\n      throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from points dataDimensionCount=\" + this.pointDataDimensionCount + \", indexDimensionCount=\" + this.pointIndexDimensionCount + \", numBytes=\" + this.pointNumBytes + \" to inconsistent dataDimensionCount=\" + dataDimensionCount +\", indexDimensionCount=\" + indexDimensionCount + \", numBytes=\" + dimensionNumBytes);\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1dbcafacd03baeb0f18199de611a1619606073c5":["f6652c943595e92c187ee904c382863013eae28f"],"f6652c943595e92c187ee904c382863013eae28f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1dbcafacd03baeb0f18199de611a1619606073c5"]},"commit2Childs":{"1dbcafacd03baeb0f18199de611a1619606073c5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["1dbcafacd03baeb0f18199de611a1619606073c5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f6652c943595e92c187ee904c382863013eae28f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}