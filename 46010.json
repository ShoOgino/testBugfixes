{"path":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/net/URLNormalizer#normalizePath(String).mjava","commits":[{"id":"52314eea0c72dd5a9f46988a9ac714c7ef1dcc37","date":1024322413,"type":0,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/net/URLNormalizer#normalizePath(String).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Description of the Method\n     *\n     * @param path             Description of the Parameter\n     * @return                 Description of the Return Value\n     * @exception IOException  Description of the Exception\n     */\n    protected static String normalizePath(String path)\n        throws IOException\n    {\n        // rule 1: if the path is empty, return \"/\"\n        if (path.length() == 0)\n        {\n            return \"/\";\n        }\n\n        // Finite State Machine to convert characters to lowercase, remove \"//\" and \"/./\"\n        // and make sure that all characters are escaped in a uniform way, i.e.\n        // {\" \", \"+\", \"%20\"} -> \"%20\"\n\n        StringBuffer w = new StringBuffer((int) (path.length() * 1.5));\n\n        int status = NP_CHAR;\n\n        int pos = 0;\n        int length = path.length();\n        char savedChar = '?';\n        int hexChar = '?';\n        int pathPos = -1;    // position of last \"/\"\n        int questionPos = -1; // assert length >0\n        boolean isInQuery = false;  // question mark reached?\n\n        while (pos < length)\n        {\n            char c = path.charAt(pos++);\n            try\n            {\n                switch (status)\n                {\n                    case NP_SLASH:\n                        if (c == '/')\n                        {\n                            // ignore subsequent slashes\n                        }\n                        else if (c == '.')\n                        {\n                            status = NP_POINT;\n                        }\n                        else if (c == '%')\n                        {\n                            status = NP_PERCENT;\n                        }\n                        else\n                        {\n                            pos--;\n                            status = NP_CHAR;\n                        }\n                        break;\n                    case NP_POINT:\n                        if (c == '/')\n                        {\n                            // ignore\n                        }\n                        else if (c == '.')\n                        {\n                            // ignore; this shouldn't happen\n                        }\n                        else\n                        {\n                            w.append('.');\n                            pos--;\n                            status = NP_SLASH;\n                        }\n                        break;\n                    case NP_PERCENT:\n                        if (c >= '0' && c <= '9')\n                        {\n                            hexChar = (c - '0') << 4;\n                        }\n                        else if (c >= 'a' && c <= 'f')\n                        {\n                            hexChar = (c - 'a' + 10) << 4;\n                        }\n                        else if (c >= 'A' && c <= 'F')\n                        {\n                            hexChar = (c - 'A' + 10) << 4;\n                        }\n                        else\n                        {\n                            w.append(charMap['%']);\n                            w.append(charMap[c]);\n                            break;\n                        }\n                        savedChar = c;\n                        status = NP_HEX;\n                        break;\n                    case NP_HEX:\n                        if (c >= '0' && c <= '9')\n                        {\n                            hexChar |= (c - '0');\n                        }\n                        else if (c >= 'a' && c <= 'f')\n                        {\n                            hexChar |= (c - 'a' + 10);\n                        }\n                        else if (c >= 'A' && c <= 'F')\n                        {\n                            hexChar |= (c - 'A' + 10);\n                        }\n                        else\n                        {\n                            w.append(charMap['%']);\n                            w.append(charMap[savedChar]);\n                            w.append(charMap[c]);\n                            break;\n                        }\n                        w.append(charMap[hexChar]);\n                        status = NP_CHAR;\n                        break;\n                    case NP_CHAR:\n                        switch (c)\n                        {\n                            case '%':\n                                status = NP_PERCENT;\n                                break;\n                            case '/':\n                                if(!isInQuery)\n                                {\n                                    w.append(c);\n                                    pathPos = w.length(); // points to the char. after \"/\"\n                                    status = NP_SLASH;\n                                }\n                                else\n                                {\n                                    w.append(charMap[c]);\n                                }\n                                break;\n                            case '?':\n                                if(!isInQuery)\n                                {\n                                    if(pathPos == -1)\n                                    {\n                                        w.append('/');\n                                        pathPos = w.length();\n                                    }\n                                    questionPos = w.length(); // points to the char at \"?\"\n                                    isInQuery = true;\n                                }\n                                else\n                                {\n                                    w.append(charMap[c]);\n                                    break;\n                                }\n                            case '&':\n                            case ';':\n                            case '@':\n                            //case ':':\n                            case '=':\n                                w.append(c);\n                                break;\n                            case '+':\n                                w.append(\"%20\");\n                                break;\n                            default:\n                                w.append(charMap[c]);\n                                break;\n                        }\n                }\n\n            }\n            catch (ArrayIndexOutOfBoundsException e)\n            {\n                // we encountered a unicode character >= 0x00ff\n                // write UTF-8 to distinguish it from other characters\n                // note that this does NOT lead to a pure UTF-8 URL since we\n                // write 0x80 <= c <= 0xff as one-byte strings\n                /*\n                 *  if (ch <= 0x007f) {\t\t// other ASCII\n                 *  sbuf.append(hex[ch]);\n                 *  } else\n                 */\n                // note that we ignore the case that we receive \"%\" + unicode + c\n                // (status = NP_HEX + Exception when writing savedchar); in that case\n                // only the second character is written. we consider this to be very\n                // unlikely\n\n                // see http://www.w3.org/International/O-URL-code.html\n                if (c <= 0x07FF)\n                {\n                    // non-ASCII <= 0x7FF\n                    w.append(charMap[0xc0 | (c >> 6)]);\n                    w.append(charMap[0x80 | (c & 0x3F)]);\n                }\n                else\n                {\n                    // 0x7FF < c <= 0xFFFF\n                    w.append(charMap[0xe0 | (c >> 12)]);\n                    w.append(charMap[0x80 | ((c >> 6) & 0x3F)]);\n                    w.append(charMap[0x80 | (c & 0x3F)]);\n                }\n            }\n        }\n\n        // rule 3: delete index.* or default.*\n\n        if(questionPos == -1) // no query\n        {\n            questionPos = w.length();\n        }\n        else\n        {\n            if(questionPos == w.length()-1)\n            {\n                // empty query. assert questionPos > 0\n                w.deleteCharAt(questionPos);\n            }\n        }\n        if(pathPos == -1) // no query\n        {\n            pathPos = 0;\n        }\n        if(questionPos > pathPos)\n        {\n            String file = w.substring(pathPos, questionPos);\n            {\n                //System.out.println(\"file: \" + file);\n                if(file.startsWith(\"index.\") || file.startsWith(\"default.\"))\n                {\n                    w.delete(pathPos, questionPos); // delete default page to avoid ambiguities\n                }\n            }\n        }\n        return w.toString();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"afc16d717d9ed1a8e45371668ca6de674164d624","date":1103345442,"type":4,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"/dev/null","pathOld":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/net/URLNormalizer#normalizePath(String).mjava","sourceNew":null,"sourceOld":"    /**\n     * Description of the Method\n     *\n     * @param path             Description of the Parameter\n     * @return                 Description of the Return Value\n     * @exception IOException  Description of the Exception\n     */\n    protected static String normalizePath(String path)\n        throws IOException\n    {\n        // rule 1: if the path is empty, return \"/\"\n        if (path.length() == 0)\n        {\n            return \"/\";\n        }\n\n        // Finite State Machine to convert characters to lowercase, remove \"//\" and \"/./\"\n        // and make sure that all characters are escaped in a uniform way, i.e.\n        // {\" \", \"+\", \"%20\"} -> \"%20\"\n\n        StringBuffer w = new StringBuffer((int) (path.length() * 1.5));\n\n        int status = NP_CHAR;\n\n        int pos = 0;\n        int length = path.length();\n        char savedChar = '?';\n        int hexChar = '?';\n        int pathPos = -1;    // position of last \"/\"\n        int questionPos = -1; // assert length >0\n        boolean isInQuery = false;  // question mark reached?\n\n        while (pos < length)\n        {\n            char c = path.charAt(pos++);\n            try\n            {\n                switch (status)\n                {\n                    case NP_SLASH:\n                        if (c == '/')\n                        {\n                            // ignore subsequent slashes\n                        }\n                        else if (c == '.')\n                        {\n                            status = NP_POINT;\n                        }\n                        else if (c == '%')\n                        {\n                            status = NP_PERCENT;\n                        }\n                        else\n                        {\n                            pos--;\n                            status = NP_CHAR;\n                        }\n                        break;\n                    case NP_POINT:\n                        if (c == '/')\n                        {\n                            // ignore\n                        }\n                        else if (c == '.')\n                        {\n                            // ignore; this shouldn't happen\n                        }\n                        else\n                        {\n                            w.append('.');\n                            pos--;\n                            status = NP_SLASH;\n                        }\n                        break;\n                    case NP_PERCENT:\n                        if (c >= '0' && c <= '9')\n                        {\n                            hexChar = (c - '0') << 4;\n                        }\n                        else if (c >= 'a' && c <= 'f')\n                        {\n                            hexChar = (c - 'a' + 10) << 4;\n                        }\n                        else if (c >= 'A' && c <= 'F')\n                        {\n                            hexChar = (c - 'A' + 10) << 4;\n                        }\n                        else\n                        {\n                            w.append(charMap['%']);\n                            w.append(charMap[c]);\n                            break;\n                        }\n                        savedChar = c;\n                        status = NP_HEX;\n                        break;\n                    case NP_HEX:\n                        if (c >= '0' && c <= '9')\n                        {\n                            hexChar |= (c - '0');\n                        }\n                        else if (c >= 'a' && c <= 'f')\n                        {\n                            hexChar |= (c - 'a' + 10);\n                        }\n                        else if (c >= 'A' && c <= 'F')\n                        {\n                            hexChar |= (c - 'A' + 10);\n                        }\n                        else\n                        {\n                            w.append(charMap['%']);\n                            w.append(charMap[savedChar]);\n                            w.append(charMap[c]);\n                            break;\n                        }\n                        w.append(charMap[hexChar]);\n                        status = NP_CHAR;\n                        break;\n                    case NP_CHAR:\n                        switch (c)\n                        {\n                            case '%':\n                                status = NP_PERCENT;\n                                break;\n                            case '/':\n                                if(!isInQuery)\n                                {\n                                    w.append(c);\n                                    pathPos = w.length(); // points to the char. after \"/\"\n                                    status = NP_SLASH;\n                                }\n                                else\n                                {\n                                    w.append(charMap[c]);\n                                }\n                                break;\n                            case '?':\n                                if(!isInQuery)\n                                {\n                                    if(pathPos == -1)\n                                    {\n                                        w.append('/');\n                                        pathPos = w.length();\n                                    }\n                                    questionPos = w.length(); // points to the char at \"?\"\n                                    isInQuery = true;\n                                }\n                                else\n                                {\n                                    w.append(charMap[c]);\n                                    break;\n                                }\n                            case '&':\n                            case ';':\n                            case '@':\n                            //case ':':\n                            case '=':\n                                w.append(c);\n                                break;\n                            case '+':\n                                w.append(\"%20\");\n                                break;\n                            default:\n                                w.append(charMap[c]);\n                                break;\n                        }\n                }\n\n            }\n            catch (ArrayIndexOutOfBoundsException e)\n            {\n                // we encountered a unicode character >= 0x00ff\n                // write UTF-8 to distinguish it from other characters\n                // note that this does NOT lead to a pure UTF-8 URL since we\n                // write 0x80 <= c <= 0xff as one-byte strings\n                /*\n                 *  if (ch <= 0x007f) {\t\t// other ASCII\n                 *  sbuf.append(hex[ch]);\n                 *  } else\n                 */\n                // note that we ignore the case that we receive \"%\" + unicode + c\n                // (status = NP_HEX + Exception when writing savedchar); in that case\n                // only the second character is written. we consider this to be very\n                // unlikely\n\n                // see http://www.w3.org/International/O-URL-code.html\n                if (c <= 0x07FF)\n                {\n                    // non-ASCII <= 0x7FF\n                    w.append(charMap[0xc0 | (c >> 6)]);\n                    w.append(charMap[0x80 | (c & 0x3F)]);\n                }\n                else\n                {\n                    // 0x7FF < c <= 0xFFFF\n                    w.append(charMap[0xe0 | (c >> 12)]);\n                    w.append(charMap[0x80 | ((c >> 6) & 0x3F)]);\n                    w.append(charMap[0x80 | (c & 0x3F)]);\n                }\n            }\n        }\n\n        // rule 3: delete index.* or default.*\n\n        if(questionPos == -1) // no query\n        {\n            questionPos = w.length();\n        }\n        else\n        {\n            if(questionPos == w.length()-1)\n            {\n                // empty query. assert questionPos > 0\n                w.deleteCharAt(questionPos);\n            }\n        }\n        if(pathPos == -1) // no query\n        {\n            pathPos = 0;\n        }\n        if(questionPos > pathPos)\n        {\n            String file = w.substring(pathPos, questionPos);\n            {\n                //System.out.println(\"file: \" + file);\n                if(file.startsWith(\"index.\") || file.startsWith(\"default.\"))\n                {\n                    w.delete(pathPos, questionPos); // delete default page to avoid ambiguities\n                }\n            }\n        }\n        return w.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"52314eea0c72dd5a9f46988a9ac714c7ef1dcc37":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"afc16d717d9ed1a8e45371668ca6de674164d624":["52314eea0c72dd5a9f46988a9ac714c7ef1dcc37"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["afc16d717d9ed1a8e45371668ca6de674164d624"]},"commit2Childs":{"52314eea0c72dd5a9f46988a9ac714c7ef1dcc37":["afc16d717d9ed1a8e45371668ca6de674164d624"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["52314eea0c72dd5a9f46988a9ac714c7ef1dcc37"],"afc16d717d9ed1a8e45371668ca6de674164d624":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}