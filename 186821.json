{"path":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","commits":[{"id":"284c1d3c8b19931bf6f312fae7470487f5d9e580","date":1163805527,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","pathOld":"/dev/null","sourceNew":"    public Object run() throws IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try each in sequence.\n\n      while(true) {\n\n        // Method 1: list the directory and use the highest\n        // segments_N file.  This method works well as long\n        // as there is no stale caching on the directory\n        // contents:\n        String[] files = null;\n\n        if (0 == method) {\n          if (directory != null) {\n            files = directory.list();\n          } else {\n            files = fileDirectory.list();\n          }\n\n          gen = getCurrentSegmentGeneration(files);\n\n          if (gen == -1) {\n            String s = \"\";\n            for(int i=0;i<files.length;i++) {\n              s += \" \" + files[i];\n            }\n            throw new FileNotFoundException(\"no segments* file found: files:\" + s);\n          }\n        }\n\n        // Method 2 (fallback if Method 1 isn't reliable):\n        // if the directory listing seems to be stale, then\n        // try loading the \"segments.gen\" file.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n            \n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n            if (genInput != null) {\n\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    if (gen0 > gen) {\n                      message(\"fallback to '\" + IndexFileNames.SEGMENTS_GEN + \"' check: now try generation \" + gen0 + \" > \" + gen);\n                      gen = gen0;\n                    }\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n        }\n\n        // Method 3 (fallback if Methods 2 & 3 are not\n        // reliabel): since both directory cache and file\n        // contents cache seem to be stale, just advance the\n        // generation.\n        if (2 == method || (1 == method && lastGen == gen && retry)) {\n\n          method = 2;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead incremenent gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d54c7739bfe85d68f0352823cd70c10c619fad38","daaba12f8cbc8a402310a4c4d0ee3fe71f67b051","1b54a9bc667895a2095a886184bf69a3179e63df","67006a60923e2124212d3baa0d29b444bcbd8373","3684d734ad9d0aedf6df8bb52de49b2c363f0353"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"456085dd95f2d3ba5147f6c0d9824098520c263f","date":1166179761,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","sourceNew":"    public Object run() throws IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try each in sequence.\n\n      while(true) {\n\n        // Method 1: list the directory and use the highest\n        // segments_N file.  This method works well as long\n        // as there is no stale caching on the directory\n        // contents:\n        String[] files = null;\n\n        if (0 == method) {\n          if (directory != null) {\n            files = directory.list();\n          } else {\n            files = fileDirectory.list();\n          }\n\n          gen = getCurrentSegmentGeneration(files);\n\n          if (gen == -1) {\n            String s = \"\";\n            for(int i=0;i<files.length;i++) {\n              s += \" \" + files[i];\n            }\n            throw new FileNotFoundException(\"no segments* file found: files:\" + s);\n          }\n        }\n\n        // Method 2 (fallback if Method 1 isn't reliable):\n        // if the directory listing seems to be stale, then\n        // try loading the \"segments.gen\" file.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n            \n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n            if (genInput != null) {\n\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    if (gen0 > gen) {\n                      message(\"fallback to '\" + IndexFileNames.SEGMENTS_GEN + \"' check: now try generation \" + gen0 + \" > \" + gen);\n                      gen = gen0;\n                    }\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n        }\n\n        // Method 3 (fallback if Methods 2 & 3 are not\n        // reliable): since both directory cache and file\n        // contents cache seem to be stale, just advance the\n        // generation.\n        if (2 == method || (1 == method && lastGen == gen && retry)) {\n\n          method = 2;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead incremenent gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run() throws IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try each in sequence.\n\n      while(true) {\n\n        // Method 1: list the directory and use the highest\n        // segments_N file.  This method works well as long\n        // as there is no stale caching on the directory\n        // contents:\n        String[] files = null;\n\n        if (0 == method) {\n          if (directory != null) {\n            files = directory.list();\n          } else {\n            files = fileDirectory.list();\n          }\n\n          gen = getCurrentSegmentGeneration(files);\n\n          if (gen == -1) {\n            String s = \"\";\n            for(int i=0;i<files.length;i++) {\n              s += \" \" + files[i];\n            }\n            throw new FileNotFoundException(\"no segments* file found: files:\" + s);\n          }\n        }\n\n        // Method 2 (fallback if Method 1 isn't reliable):\n        // if the directory listing seems to be stale, then\n        // try loading the \"segments.gen\" file.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n            \n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n            if (genInput != null) {\n\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    if (gen0 > gen) {\n                      message(\"fallback to '\" + IndexFileNames.SEGMENTS_GEN + \"' check: now try generation \" + gen0 + \" > \" + gen);\n                      gen = gen0;\n                    }\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n        }\n\n        // Method 3 (fallback if Methods 2 & 3 are not\n        // reliabel): since both directory cache and file\n        // contents cache seem to be stale, just advance the\n        // generation.\n        if (2 == method || (1 == method && lastGen == gen && retry)) {\n\n          method = 2;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead incremenent gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["67006a60923e2124212d3baa0d29b444bcbd8373"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eeefd99c477417e5c7c574228461ebafe92469d4","date":1166460329,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","sourceNew":"    public Object run() throws IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try each in sequence.\n\n      while(true) {\n\n        // Method 1: list the directory and use the highest\n        // segments_N file.  This method works well as long\n        // as there is no stale caching on the directory\n        // contents:\n        String[] files = null;\n\n        if (0 == method) {\n          if (directory != null) {\n            files = directory.list();\n          } else {\n            files = fileDirectory.list();\n          }\n\n          gen = getCurrentSegmentGeneration(files);\n\n          if (gen == -1) {\n            String s = \"\";\n            for(int i=0;i<files.length;i++) {\n              s += \" \" + files[i];\n            }\n            throw new FileNotFoundException(\"no segments* file found: files:\" + s);\n          }\n        }\n\n        // Method 2 (fallback if Method 1 isn't reliable):\n        // if the directory listing seems to be stale, then\n        // try loading the \"segments.gen\" file.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n            \n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n            if (genInput != null) {\n\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    if (gen0 > gen) {\n                      message(\"fallback to '\" + IndexFileNames.SEGMENTS_GEN + \"' check: now try generation \" + gen0 + \" > \" + gen);\n                      gen = gen0;\n                    }\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n        }\n\n        // Method 3 (fallback if Methods 2 & 3 are not\n        // reliable): since both directory cache and file\n        // contents cache seem to be stale, just advance the\n        // generation.\n        if (2 == method || (1 == method && lastGen == gen && retry)) {\n\n          method = 2;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run() throws IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try each in sequence.\n\n      while(true) {\n\n        // Method 1: list the directory and use the highest\n        // segments_N file.  This method works well as long\n        // as there is no stale caching on the directory\n        // contents:\n        String[] files = null;\n\n        if (0 == method) {\n          if (directory != null) {\n            files = directory.list();\n          } else {\n            files = fileDirectory.list();\n          }\n\n          gen = getCurrentSegmentGeneration(files);\n\n          if (gen == -1) {\n            String s = \"\";\n            for(int i=0;i<files.length;i++) {\n              s += \" \" + files[i];\n            }\n            throw new FileNotFoundException(\"no segments* file found: files:\" + s);\n          }\n        }\n\n        // Method 2 (fallback if Method 1 isn't reliable):\n        // if the directory listing seems to be stale, then\n        // try loading the \"segments.gen\" file.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n            \n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n            if (genInput != null) {\n\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    if (gen0 > gen) {\n                      message(\"fallback to '\" + IndexFileNames.SEGMENTS_GEN + \"' check: now try generation \" + gen0 + \" > \" + gen);\n                      gen = gen0;\n                    }\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n        }\n\n        // Method 3 (fallback if Methods 2 & 3 are not\n        // reliable): since both directory cache and file\n        // contents cache seem to be stale, just advance the\n        // generation.\n        if (2 == method || (1 == method && lastGen == gen && retry)) {\n\n          method = 2;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead incremenent gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b54a9bc667895a2095a886184bf69a3179e63df","date":1172088096,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","sourceNew":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try each in sequence.\n\n      while(true) {\n\n        // Method 1: list the directory and use the highest\n        // segments_N file.  This method works well as long\n        // as there is no stale caching on the directory\n        // contents:\n        String[] files = null;\n\n        if (0 == method) {\n          if (directory != null) {\n            files = directory.list();\n          } else {\n            files = fileDirectory.list();\n          }\n\n          gen = getCurrentSegmentGeneration(files);\n\n          if (gen == -1) {\n            String s = \"\";\n            for(int i=0;i<files.length;i++) {\n              s += \" \" + files[i];\n            }\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Method 2 (fallback if Method 1 isn't reliable):\n        // if the directory listing seems to be stale, then\n        // try loading the \"segments.gen\" file.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n            \n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n            if (genInput != null) {\n\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    if (gen0 > gen) {\n                      message(\"fallback to '\" + IndexFileNames.SEGMENTS_GEN + \"' check: now try generation \" + gen0 + \" > \" + gen);\n                      gen = gen0;\n                    }\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n        }\n\n        // Method 3 (fallback if Methods 2 & 3 are not\n        // reliable): since both directory cache and file\n        // contents cache seem to be stale, just advance the\n        // generation.\n        if (2 == method || (1 == method && lastGen == gen && retry)) {\n\n          method = 2;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run() throws IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try each in sequence.\n\n      while(true) {\n\n        // Method 1: list the directory and use the highest\n        // segments_N file.  This method works well as long\n        // as there is no stale caching on the directory\n        // contents:\n        String[] files = null;\n\n        if (0 == method) {\n          if (directory != null) {\n            files = directory.list();\n          } else {\n            files = fileDirectory.list();\n          }\n\n          gen = getCurrentSegmentGeneration(files);\n\n          if (gen == -1) {\n            String s = \"\";\n            for(int i=0;i<files.length;i++) {\n              s += \" \" + files[i];\n            }\n            throw new FileNotFoundException(\"no segments* file found: files:\" + s);\n          }\n        }\n\n        // Method 2 (fallback if Method 1 isn't reliable):\n        // if the directory listing seems to be stale, then\n        // try loading the \"segments.gen\" file.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n            \n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n            if (genInput != null) {\n\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    if (gen0 > gen) {\n                      message(\"fallback to '\" + IndexFileNames.SEGMENTS_GEN + \"' check: now try generation \" + gen0 + \" > \" + gen);\n                      gen = gen0;\n                    }\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n        }\n\n        // Method 3 (fallback if Methods 2 & 3 are not\n        // reliable): since both directory cache and file\n        // contents cache seem to be stale, just advance the\n        // generation.\n        if (2 == method || (1 == method && lastGen == gen && retry)) {\n\n          method = 2;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","67006a60923e2124212d3baa0d29b444bcbd8373"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4755ae1e745961fcdde166cfbfe292a42597cd64","date":1173257158,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","sourceNew":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try each in sequence.\n\n      while(true) {\n\n        // Method 1: list the directory and use the highest\n        // segments_N file.  This method works well as long\n        // as there is no stale caching on the directory\n        // contents:\n        String[] files = null;\n\n        if (0 == method) {\n          if (directory != null) {\n            files = directory.list();\n          } else {\n            files = fileDirectory.list();\n          }\n\n          if (files == null) {\n            throw new FileNotFoundException(\"no segments* file found in directory \" + directory + \": list() returned null\");\n          }\n\n          gen = getCurrentSegmentGeneration(files);\n\n          if (gen == -1) {\n            String s = \"\";\n            for(int i=0;i<files.length;i++) {\n              s += \" \" + files[i];\n            }\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Method 2 (fallback if Method 1 isn't reliable):\n        // if the directory listing seems to be stale, then\n        // try loading the \"segments.gen\" file.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n            \n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n            if (genInput != null) {\n\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    if (gen0 > gen) {\n                      message(\"fallback to '\" + IndexFileNames.SEGMENTS_GEN + \"' check: now try generation \" + gen0 + \" > \" + gen);\n                      gen = gen0;\n                    }\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n        }\n\n        // Method 3 (fallback if Methods 2 & 3 are not\n        // reliable): since both directory cache and file\n        // contents cache seem to be stale, just advance the\n        // generation.\n        if (2 == method || (1 == method && lastGen == gen && retry)) {\n\n          method = 2;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try each in sequence.\n\n      while(true) {\n\n        // Method 1: list the directory and use the highest\n        // segments_N file.  This method works well as long\n        // as there is no stale caching on the directory\n        // contents:\n        String[] files = null;\n\n        if (0 == method) {\n          if (directory != null) {\n            files = directory.list();\n          } else {\n            files = fileDirectory.list();\n          }\n\n          gen = getCurrentSegmentGeneration(files);\n\n          if (gen == -1) {\n            String s = \"\";\n            for(int i=0;i<files.length;i++) {\n              s += \" \" + files[i];\n            }\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Method 2 (fallback if Method 1 isn't reliable):\n        // if the directory listing seems to be stale, then\n        // try loading the \"segments.gen\" file.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n            \n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n            if (genInput != null) {\n\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    if (gen0 > gen) {\n                      message(\"fallback to '\" + IndexFileNames.SEGMENTS_GEN + \"' check: now try generation \" + gen0 + \" > \" + gen);\n                      gen = gen0;\n                    }\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n        }\n\n        // Method 3 (fallback if Methods 2 & 3 are not\n        // reliable): since both directory cache and file\n        // contents cache seem to be stale, just advance the\n        // generation.\n        if (2 == method || (1 == method && lastGen == gen && retry)) {\n\n          method = 2;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["daaba12f8cbc8a402310a4c4d0ee3fe71f67b051","67006a60923e2124212d3baa0d29b444bcbd8373"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"daaba12f8cbc8a402310a4c4d0ee3fe71f67b051","date":1173376751,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","sourceNew":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try each in sequence.\n\n      while(true) {\n\n        // Method 1: list the directory and use the highest\n        // segments_N file.  This method works well as long\n        // as there is no stale caching on the directory\n        // contents:\n        String[] files = null;\n\n        if (0 == method) {\n          if (directory != null) {\n            files = directory.list();\n            if (files == null)\n              throw new FileNotFoundException(\"cannot read directory \" + directory + \": list() returned null\");\n          } else {\n            files = fileDirectory.list();\n            if (files == null)\n              throw new FileNotFoundException(\"cannot read directory \" + fileDirectory + \": list() returned null\");\n          }\n\n          gen = getCurrentSegmentGeneration(files);\n\n          if (gen == -1) {\n            String s = \"\";\n            for(int i=0;i<files.length;i++) {\n              s += \" \" + files[i];\n            }\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Method 2 (fallback if Method 1 isn't reliable):\n        // if the directory listing seems to be stale, then\n        // try loading the \"segments.gen\" file.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n            \n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n            if (genInput != null) {\n\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    if (gen0 > gen) {\n                      message(\"fallback to '\" + IndexFileNames.SEGMENTS_GEN + \"' check: now try generation \" + gen0 + \" > \" + gen);\n                      gen = gen0;\n                    }\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n        }\n\n        // Method 3 (fallback if Methods 2 & 3 are not\n        // reliable): since both directory cache and file\n        // contents cache seem to be stale, just advance the\n        // generation.\n        if (2 == method || (1 == method && lastGen == gen && retry)) {\n\n          method = 2;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try each in sequence.\n\n      while(true) {\n\n        // Method 1: list the directory and use the highest\n        // segments_N file.  This method works well as long\n        // as there is no stale caching on the directory\n        // contents:\n        String[] files = null;\n\n        if (0 == method) {\n          if (directory != null) {\n            files = directory.list();\n          } else {\n            files = fileDirectory.list();\n          }\n\n          if (files == null) {\n            throw new FileNotFoundException(\"no segments* file found in directory \" + directory + \": list() returned null\");\n          }\n\n          gen = getCurrentSegmentGeneration(files);\n\n          if (gen == -1) {\n            String s = \"\";\n            for(int i=0;i<files.length;i++) {\n              s += \" \" + files[i];\n            }\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Method 2 (fallback if Method 1 isn't reliable):\n        // if the directory listing seems to be stale, then\n        // try loading the \"segments.gen\" file.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n            \n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n            if (genInput != null) {\n\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    if (gen0 > gen) {\n                      message(\"fallback to '\" + IndexFileNames.SEGMENTS_GEN + \"' check: now try generation \" + gen0 + \" > \" + gen);\n                      gen = gen0;\n                    }\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n        }\n\n        // Method 3 (fallback if Methods 2 & 3 are not\n        // reliable): since both directory cache and file\n        // contents cache seem to be stale, just advance the\n        // generation.\n        if (2 == method || (1 == method && lastGen == gen && retry)) {\n\n          method = 2;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":["284c1d3c8b19931bf6f312fae7470487f5d9e580","4755ae1e745961fcdde166cfbfe292a42597cd64"],"bugIntro":["67006a60923e2124212d3baa0d29b444bcbd8373"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"67006a60923e2124212d3baa0d29b444bcbd8373","date":1191425052,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","sourceNew":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          if (directory != null)\n            files = directory.list();\n          else\n            files = fileDirectory.list();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n              break;\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n\n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try each in sequence.\n\n      while(true) {\n\n        // Method 1: list the directory and use the highest\n        // segments_N file.  This method works well as long\n        // as there is no stale caching on the directory\n        // contents:\n        String[] files = null;\n\n        if (0 == method) {\n          if (directory != null) {\n            files = directory.list();\n            if (files == null)\n              throw new FileNotFoundException(\"cannot read directory \" + directory + \": list() returned null\");\n          } else {\n            files = fileDirectory.list();\n            if (files == null)\n              throw new FileNotFoundException(\"cannot read directory \" + fileDirectory + \": list() returned null\");\n          }\n\n          gen = getCurrentSegmentGeneration(files);\n\n          if (gen == -1) {\n            String s = \"\";\n            for(int i=0;i<files.length;i++) {\n              s += \" \" + files[i];\n            }\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Method 2 (fallback if Method 1 isn't reliable):\n        // if the directory listing seems to be stale, then\n        // try loading the \"segments.gen\" file.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n            \n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n            if (genInput != null) {\n\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    if (gen0 > gen) {\n                      message(\"fallback to '\" + IndexFileNames.SEGMENTS_GEN + \"' check: now try generation \" + gen0 + \" > \" + gen);\n                      gen = gen0;\n                    }\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n        }\n\n        // Method 3 (fallback if Methods 2 & 3 are not\n        // reliable): since both directory cache and file\n        // contents cache seem to be stale, just advance the\n        // generation.\n        if (2 == method || (1 == method && lastGen == gen && retry)) {\n\n          method = 2;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":["284c1d3c8b19931bf6f312fae7470487f5d9e580","4755ae1e745961fcdde166cfbfe292a42597cd64","456085dd95f2d3ba5147f6c0d9824098520c263f","1b54a9bc667895a2095a886184bf69a3179e63df","daaba12f8cbc8a402310a4c4d0ee3fe71f67b051"],"bugIntro":["3684d734ad9d0aedf6df8bb52de49b2c363f0353"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3684d734ad9d0aedf6df8bb52de49b2c363f0353","date":1197022391,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","sourceNew":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          if (directory != null)\n            files = directory.list();\n          else\n            files = fileDirectory.list();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          if (directory != null) {\n            for(int i=0;i<defaultGenFileRetryCount;i++) {\n              IndexInput genInput = null;\n              try {\n                genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n              } catch (FileNotFoundException e) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n                break;\n              } catch (IOException e) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n\n              if (genInput != null) {\n                try {\n                  int version = genInput.readInt();\n                  if (version == FORMAT_LOCKLESS) {\n                    long gen0 = genInput.readLong();\n                    long gen1 = genInput.readLong();\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                    if (gen0 == gen1) {\n                      // The file is consistent.\n                      genB = gen0;\n                      break;\n                    }\n                  }\n                } catch (IOException err2) {\n                  // will retry\n                } finally {\n                  genInput.close();\n                }\n              }\n              try {\n                Thread.sleep(defaultGenFileRetryPauseMsec);\n              } catch (InterruptedException e) {\n                // will retry\n              }\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            if (directory != null)\n              prevExists = directory.fileExists(prevSegmentFileName);\n            else\n              prevExists = new File(fileDirectory, prevSegmentFileName).exists();\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          if (directory != null)\n            files = directory.list();\n          else\n            files = fileDirectory.list();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n              break;\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n\n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException e) {\n              // will retry\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n            \n            if (directory.fileExists(prevSegmentFileName)) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":["284c1d3c8b19931bf6f312fae7470487f5d9e580","67006a60923e2124212d3baa0d29b444bcbd8373"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e82780afe6097066eb5befb86e9432f077667e3d","date":1202756169,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","sourceNew":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          if (directory != null)\n            files = directory.list();\n          else\n            files = fileDirectory.list();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          if (directory != null) {\n            for(int i=0;i<defaultGenFileRetryCount;i++) {\n              IndexInput genInput = null;\n              try {\n                genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n              } catch (FileNotFoundException e) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n                break;\n              } catch (IOException e) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n\n              if (genInput != null) {\n                try {\n                  int version = genInput.readInt();\n                  if (version == FORMAT_LOCKLESS) {\n                    long gen0 = genInput.readLong();\n                    long gen1 = genInput.readLong();\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                    if (gen0 == gen1) {\n                      // The file is consistent.\n                      genB = gen0;\n                      break;\n                    }\n                  }\n                } catch (IOException err2) {\n                  // will retry\n                } finally {\n                  genInput.close();\n                }\n              }\n              try {\n                Thread.sleep(defaultGenFileRetryPauseMsec);\n              } catch (InterruptedException e) {\n                // will retry\n              }\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            if (directory != null)\n              prevExists = directory.fileExists(prevSegmentFileName);\n            else\n              prevExists = new File(fileDirectory, prevSegmentFileName).exists();\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          if (directory != null)\n            files = directory.list();\n          else\n            files = fileDirectory.list();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          if (directory != null) {\n            for(int i=0;i<defaultGenFileRetryCount;i++) {\n              IndexInput genInput = null;\n              try {\n                genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n              } catch (FileNotFoundException e) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n                break;\n              } catch (IOException e) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n\n              if (genInput != null) {\n                try {\n                  int version = genInput.readInt();\n                  if (version == FORMAT_LOCKLESS) {\n                    long gen0 = genInput.readLong();\n                    long gen1 = genInput.readLong();\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                    if (gen0 == gen1) {\n                      // The file is consistent.\n                      genB = gen0;\n                      break;\n                    }\n                  }\n                } catch (IOException err2) {\n                  // will retry\n                } finally {\n                  genInput.close();\n                }\n              }\n              try {\n                Thread.sleep(defaultGenFileRetryPauseMsec);\n              } catch (InterruptedException e) {\n                // will retry\n              }\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            if (directory != null)\n              prevExists = directory.fileExists(prevSegmentFileName);\n            else\n              prevExists = new File(fileDirectory, prevSegmentFileName).exists();\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d54c7739bfe85d68f0352823cd70c10c619fad38","date":1228496593,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","sourceNew":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          if (directory != null)\n            files = directory.listAll();\n          else\n            files = FSDirectory.listAll(fileDirectory);\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          if (directory != null) {\n            for(int i=0;i<defaultGenFileRetryCount;i++) {\n              IndexInput genInput = null;\n              try {\n                genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n              } catch (FileNotFoundException e) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n                break;\n              } catch (IOException e) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n\n              if (genInput != null) {\n                try {\n                  int version = genInput.readInt();\n                  if (version == FORMAT_LOCKLESS) {\n                    long gen0 = genInput.readLong();\n                    long gen1 = genInput.readLong();\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                    if (gen0 == gen1) {\n                      // The file is consistent.\n                      genB = gen0;\n                      break;\n                    }\n                  }\n                } catch (IOException err2) {\n                  // will retry\n                } finally {\n                  genInput.close();\n                }\n              }\n              try {\n                Thread.sleep(defaultGenFileRetryPauseMsec);\n              } catch (InterruptedException e) {\n                // will retry\n              }\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            if (directory != null)\n              prevExists = directory.fileExists(prevSegmentFileName);\n            else\n              prevExists = new File(fileDirectory, prevSegmentFileName).exists();\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          if (directory != null)\n            files = directory.list();\n          else\n            files = fileDirectory.list();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          if (directory != null) {\n            for(int i=0;i<defaultGenFileRetryCount;i++) {\n              IndexInput genInput = null;\n              try {\n                genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n              } catch (FileNotFoundException e) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n                break;\n              } catch (IOException e) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n\n              if (genInput != null) {\n                try {\n                  int version = genInput.readInt();\n                  if (version == FORMAT_LOCKLESS) {\n                    long gen0 = genInput.readLong();\n                    long gen1 = genInput.readLong();\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                    if (gen0 == gen1) {\n                      // The file is consistent.\n                      genB = gen0;\n                      break;\n                    }\n                  }\n                } catch (IOException err2) {\n                  // will retry\n                } finally {\n                  genInput.close();\n                }\n              }\n              try {\n                Thread.sleep(defaultGenFileRetryPauseMsec);\n              } catch (InterruptedException e) {\n                // will retry\n              }\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            if (directory != null)\n              prevExists = directory.fileExists(prevSegmentFileName);\n            else\n              prevExists = new File(fileDirectory, prevSegmentFileName).exists();\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba7fd1181f778e9954547e8e6a47587ebf08e3fb","date":1238267455,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","sourceNew":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          if (directory != null)\n            files = directory.listAll();\n          else\n            files = FSDirectory.listAll(fileDirectory);\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          if (directory != null) {\n            for(int i=0;i<defaultGenFileRetryCount;i++) {\n              IndexInput genInput = null;\n              try {\n                genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n              } catch (FileNotFoundException e) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n                break;\n              } catch (IOException e) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n\n              if (genInput != null) {\n                try {\n                  int version = genInput.readInt();\n                  if (version == FORMAT_LOCKLESS) {\n                    long gen0 = genInput.readLong();\n                    long gen1 = genInput.readLong();\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                    if (gen0 == gen1) {\n                      // The file is consistent.\n                      genB = gen0;\n                      break;\n                    }\n                  }\n                } catch (IOException err2) {\n                  // will retry\n                } finally {\n                  genInput.close();\n                }\n              }\n              try {\n                Thread.sleep(defaultGenFileRetryPauseMsec);\n              } catch (InterruptedException ie) {\n                // In 3.0 we will change this to throw\n                // InterruptedException instead\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(ie);\n              }\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            if (directory != null)\n              prevExists = directory.fileExists(prevSegmentFileName);\n            else\n              prevExists = new File(fileDirectory, prevSegmentFileName).exists();\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          if (directory != null)\n            files = directory.listAll();\n          else\n            files = FSDirectory.listAll(fileDirectory);\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          if (directory != null) {\n            for(int i=0;i<defaultGenFileRetryCount;i++) {\n              IndexInput genInput = null;\n              try {\n                genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n              } catch (FileNotFoundException e) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n                break;\n              } catch (IOException e) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n\n              if (genInput != null) {\n                try {\n                  int version = genInput.readInt();\n                  if (version == FORMAT_LOCKLESS) {\n                    long gen0 = genInput.readLong();\n                    long gen1 = genInput.readLong();\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                    if (gen0 == gen1) {\n                      // The file is consistent.\n                      genB = gen0;\n                      break;\n                    }\n                  }\n                } catch (IOException err2) {\n                  // will retry\n                } finally {\n                  genInput.close();\n                }\n              }\n              try {\n                Thread.sleep(defaultGenFileRetryPauseMsec);\n              } catch (InterruptedException e) {\n                // will retry\n              }\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            if (directory != null)\n              prevExists = directory.fileExists(prevSegmentFileName);\n            else\n              prevExists = new File(fileDirectory, prevSegmentFileName).exists();\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1","date":1244392278,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","sourceNew":"    public Object run() throws CorruptIndexException, IOException {\n      return run(null);\n    }\n\n","sourceOld":"    public Object run() throws CorruptIndexException, IOException {\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          if (directory != null)\n            files = directory.listAll();\n          else\n            files = FSDirectory.listAll(fileDirectory);\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          if (directory != null) {\n            for(int i=0;i<defaultGenFileRetryCount;i++) {\n              IndexInput genInput = null;\n              try {\n                genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n              } catch (FileNotFoundException e) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n                break;\n              } catch (IOException e) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n\n              if (genInput != null) {\n                try {\n                  int version = genInput.readInt();\n                  if (version == FORMAT_LOCKLESS) {\n                    long gen0 = genInput.readLong();\n                    long gen1 = genInput.readLong();\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                    if (gen0 == gen1) {\n                      // The file is consistent.\n                      genB = gen0;\n                      break;\n                    }\n                  }\n                } catch (IOException err2) {\n                  // will retry\n                } finally {\n                  genInput.close();\n                }\n              }\n              try {\n                Thread.sleep(defaultGenFileRetryPauseMsec);\n              } catch (InterruptedException ie) {\n                // In 3.0 we will change this to throw\n                // InterruptedException instead\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(ie);\n              }\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            if (directory != null)\n              prevExists = directory.fileExists(prevSegmentFileName);\n            else\n              prevExists = new File(fileDirectory, prevSegmentFileName).exists();\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run().mjava","sourceNew":"    public Object run() throws CorruptIndexException, IOException {\n      return run(null);\n    }\n\n","sourceOld":"    public Object run() throws CorruptIndexException, IOException {\n      return run(null);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"daaba12f8cbc8a402310a4c4d0ee3fe71f67b051":["4755ae1e745961fcdde166cfbfe292a42597cd64"],"1b54a9bc667895a2095a886184bf69a3179e63df":["eeefd99c477417e5c7c574228461ebafe92469d4"],"67006a60923e2124212d3baa0d29b444bcbd8373":["daaba12f8cbc8a402310a4c4d0ee3fe71f67b051"],"456085dd95f2d3ba5147f6c0d9824098520c263f":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["d54c7739bfe85d68f0352823cd70c10c619fad38"],"d54c7739bfe85d68f0352823cd70c10c619fad38":["e82780afe6097066eb5befb86e9432f077667e3d"],"eeefd99c477417e5c7c574228461ebafe92469d4":["456085dd95f2d3ba5147f6c0d9824098520c263f"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e82780afe6097066eb5befb86e9432f077667e3d":["3684d734ad9d0aedf6df8bb52de49b2c363f0353"],"3684d734ad9d0aedf6df8bb52de49b2c363f0353":["67006a60923e2124212d3baa0d29b444bcbd8373"],"4755ae1e745961fcdde166cfbfe292a42597cd64":["1b54a9bc667895a2095a886184bf69a3179e63df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"]},"commit2Childs":{"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"daaba12f8cbc8a402310a4c4d0ee3fe71f67b051":["67006a60923e2124212d3baa0d29b444bcbd8373"],"1b54a9bc667895a2095a886184bf69a3179e63df":["4755ae1e745961fcdde166cfbfe292a42597cd64"],"67006a60923e2124212d3baa0d29b444bcbd8373":["3684d734ad9d0aedf6df8bb52de49b2c363f0353"],"456085dd95f2d3ba5147f6c0d9824098520c263f":["eeefd99c477417e5c7c574228461ebafe92469d4"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"d54c7739bfe85d68f0352823cd70c10c619fad38":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"eeefd99c477417e5c7c574228461ebafe92469d4":["1b54a9bc667895a2095a886184bf69a3179e63df"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["456085dd95f2d3ba5147f6c0d9824098520c263f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"e82780afe6097066eb5befb86e9432f077667e3d":["d54c7739bfe85d68f0352823cd70c10c619fad38"],"3684d734ad9d0aedf6df8bb52de49b2c363f0353":["e82780afe6097066eb5befb86e9432f077667e3d"],"4755ae1e745961fcdde166cfbfe292a42597cd64":["daaba12f8cbc8a402310a4c4d0ee3fe71f67b051"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}