{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","sourceNew":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    if (classmap == null)\n      return transitions[state * points.length + getCharClass(c)];\n    else\n      return transitions[state * points.length + classmap[c]];\n  }\n\n","sourceOld":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    if (classmap == null)\n      return transitions[state * points.length + getCharClass(c)];\n    else\n      return transitions[state * points.length + classmap[c]];\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","sourceNew":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    //System.out.println(\"  step state=\" + state + \" c=\" + c + \" points.length=\" + points.length + \" transitions.len=\" + transitions.length);\n    if (classmap == null) {\n      return transitions[state * points.length + getCharClass(c)];\n    } else {\n      //System.out.println(\"    classmap[c]=\" + classmap[c]);\n      return transitions[state * points.length + classmap[c]];\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    if (classmap == null)\n      return transitions[state * points.length + getCharClass(c)];\n    else\n      return transitions[state * points.length + classmap[c]];\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dece2a6aa33295eda8cfdd44c17b30f2b5a68cd1","date":1403000163,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","sourceNew":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    if (classmap == null) {\n      return transitions[state * points.length + getCharClass(c)];\n    } else {\n      return transitions[state * points.length + classmap[c]];\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    //System.out.println(\"  step state=\" + state + \" c=\" + c + \" points.length=\" + points.length + \" transitions.len=\" + transitions.length);\n    if (classmap == null) {\n      return transitions[state * points.length + getCharClass(c)];\n    } else {\n      //System.out.println(\"    classmap[c]=\" + classmap[c]);\n      return transitions[state * points.length + classmap[c]];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","sourceNew":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    if (classmap == null) {\n      return transitions[state * points.length + getCharClass(c)];\n    } else {\n      return transitions[state * points.length + classmap[c]];\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    if (classmap == null)\n      return transitions[state * points.length + getCharClass(c)];\n    else\n      return transitions[state * points.length + classmap[c]];\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ddee54b1c3df60fd6198e3aa64c78038a1be8df","date":1487008231,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","sourceNew":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    assert c < alphabetSize;\n    if (c >= classmap.length) {\n      return transitions[state * points.length + getCharClass(c)];\n    } else {\n      return transitions[state * points.length + classmap[c]];\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    if (classmap == null) {\n      return transitions[state * points.length + getCharClass(c)];\n    } else {\n      return transitions[state * points.length + classmap[c]];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"022a4de90e0479b604264ca9c2e134c996454ab3","date":1487118265,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","sourceNew":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    assert c < alphabetSize;\n    if (c >= classmap.length) {\n      return transitions[state * points.length + getCharClass(c)];\n    } else {\n      return transitions[state * points.length + classmap[c]];\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    if (classmap == null) {\n      return transitions[state * points.length + getCharClass(c)];\n    } else {\n      return transitions[state * points.length + classmap[c]];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96","date":1487122334,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","sourceNew":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    if (classmap == null) {\n      return transitions[state * points.length + getCharClass(c)];\n    } else {\n      return transitions[state * points.length + classmap[c]];\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    assert c < alphabetSize;\n    if (c >= classmap.length) {\n      return transitions[state * points.length + getCharClass(c)];\n    } else {\n      return transitions[state * points.length + classmap[c]];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"897b06b1364bd1f658a8be7591e43f0851458e7f","date":1487123008,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RunAutomaton#step(int,int).mjava","sourceNew":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    assert c < alphabetSize;\n    if (c >= classmap.length) {\n      return transitions[state * points.length + getCharClass(c)];\n    } else {\n      return transitions[state * points.length + classmap[c]];\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns the state obtained by reading the given char from the given state.\n   * Returns -1 if not obtaining any such state. (If the original\n   * <code>Automaton</code> had no dead states, -1 is returned here if and only\n   * if a dead state is entered in an equivalent automaton with a total\n   * transition function.)\n   */\n  public final int step(int state, int c) {\n    if (classmap == null) {\n      return transitions[state * points.length + getCharClass(c)];\n    } else {\n      return transitions[state * points.length + classmap[c]];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["022a4de90e0479b604264ca9c2e134c996454ab3"],"dece2a6aa33295eda8cfdd44c17b30f2b5a68cd1":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"022a4de90e0479b604264ca9c2e134c996454ab3":["5c84485629d80d203608e8975a1139de9933cc38","5ddee54b1c3df60fd6198e3aa64c78038a1be8df"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5c84485629d80d203608e8975a1139de9933cc38":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","dece2a6aa33295eda8cfdd44c17b30f2b5a68cd1"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"5ddee54b1c3df60fd6198e3aa64c78038a1be8df":["5c84485629d80d203608e8975a1139de9933cc38"]},"commit2Childs":{"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"022a4de90e0479b604264ca9c2e134c996454ab3":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"dece2a6aa33295eda8cfdd44c17b30f2b5a68cd1":["5c84485629d80d203608e8975a1139de9933cc38"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5c84485629d80d203608e8975a1139de9933cc38","ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"5c84485629d80d203608e8975a1139de9933cc38":["022a4de90e0479b604264ca9c2e134c996454ab3","5ddee54b1c3df60fd6198e3aa64c78038a1be8df"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["dece2a6aa33295eda8cfdd44c17b30f2b5a68cd1"],"5ddee54b1c3df60fd6198e3aa64c78038a1be8df":["022a4de90e0479b604264ca9c2e134c996454ab3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}