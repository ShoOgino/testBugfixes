{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/GeoPointTestUtil#surpriseMePolygon(Double,Double).mjava","commits":[{"id":"3c5537ea5dd595f2987618e9086f4fae5736a8dc","date":1460385370,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/GeoPointTestUtil#surpriseMePolygon(Double,Double).mjava","pathOld":"/dev/null","sourceNew":"  private static Polygon surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8df1bb848bfc3f850b512206ae511c0494997931","date":1465581187,"type":4,"author":"Nicholas Knize","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/GeoPointTestUtil#surpriseMePolygon(Double,Double).mjava","sourceNew":null,"sourceOld":"  private static Polygon surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/GeoPointTestUtil#surpriseMePolygon(Double,Double).mjava","sourceNew":null,"sourceOld":"  private static Polygon surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new Polygon(latsArray, lonsArray);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8df1bb848bfc3f850b512206ae511c0494997931":["3c5537ea5dd595f2987618e9086f4fae5736a8dc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3c5537ea5dd595f2987618e9086f4fae5736a8dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3c5537ea5dd595f2987618e9086f4fae5736a8dc","8df1bb848bfc3f850b512206ae511c0494997931"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8df1bb848bfc3f850b512206ae511c0494997931"]},"commit2Childs":{"8df1bb848bfc3f850b512206ae511c0494997931":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3c5537ea5dd595f2987618e9086f4fae5736a8dc"],"3c5537ea5dd595f2987618e9086f4fae5736a8dc":["8df1bb848bfc3f850b512206ae511c0494997931","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}