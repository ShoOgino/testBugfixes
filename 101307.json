{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","sourceNew":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted && input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n      exhausted = true;\n    }\n    return newTarget;\n\t}\n\n","sourceOld":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted && input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n      exhausted = true;\n    }\n    return newTarget;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","sourceNew":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted && input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n      exhausted = true;\n    }\n    return newTarget;\n  }\n\n","sourceOld":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted && input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n      exhausted = true;\n    }\n    return newTarget;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fec40a4bb4fb8565560f443818a3ae4c42b8b2f","date":1379435196,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","sourceNew":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted) {\n      if (input.incrementToken()) {\n        if (null == target) {\n          newTarget = new InputWindowToken(cloneAttributes());\n        } else {\n          this.copyTo(target.attSource);\n        }\n        if (posIncrAtt.getPositionIncrement() > 1) {\n          // Each output shingle must contain at least one input token, \n          // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n          numFillerTokensToInsert = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n          // Save the current token as the next input stream token\n          if (null == nextInputStreamToken) {\n            nextInputStreamToken = cloneAttributes();\n          } else {\n            this.copyTo(nextInputStreamToken);\n          }\n          isNextInputStreamToken = true;\n          // A filler token occupies no space\n          newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n          newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n          newTarget.isFiller = true;\n          --numFillerTokensToInsert;\n        } else {\n          newTarget.isFiller = false;\n        }\n      } else {\n        exhausted = true;\n        input.end();\n        endState = captureState();\n        numFillerTokensToInsert = Math.min(posIncrAtt.getPositionIncrement(), maxShingleSize - 1);\n        if (numFillerTokensToInsert > 0) {\n          nextInputStreamToken = new AttributeSource(getAttributeFactory());\n          nextInputStreamToken.addAttribute(CharTermAttribute.class);\n          OffsetAttribute newOffsetAtt = nextInputStreamToken.addAttribute(OffsetAttribute.class);\n          newOffsetAtt.setOffset(offsetAtt.endOffset(), offsetAtt.endOffset());\n          // Recurse/loop just once:\n          return getNextToken(target);\n        } else {\n          newTarget = null;\n        }\n      }\n    } else {\n      newTarget = null;\n    }\n    return newTarget;\n  }\n\n","sourceOld":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted && input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n      exhausted = true;\n    }\n    return newTarget;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6237bacfd44ad16661121d7d8a604a57f78978e9","date":1391038488,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","sourceNew":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #fillerToken}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(fillerToken, 0, fillerToken.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted) {\n      if (input.incrementToken()) {\n        if (null == target) {\n          newTarget = new InputWindowToken(cloneAttributes());\n        } else {\n          this.copyTo(target.attSource);\n        }\n        if (posIncrAtt.getPositionIncrement() > 1) {\n          // Each output shingle must contain at least one input token, \n          // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n          numFillerTokensToInsert = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n          // Save the current token as the next input stream token\n          if (null == nextInputStreamToken) {\n            nextInputStreamToken = cloneAttributes();\n          } else {\n            this.copyTo(nextInputStreamToken);\n          }\n          isNextInputStreamToken = true;\n          // A filler token occupies no space\n          newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n          newTarget.termAtt.copyBuffer(fillerToken, 0, fillerToken.length);\n          newTarget.isFiller = true;\n          --numFillerTokensToInsert;\n        } else {\n          newTarget.isFiller = false;\n        }\n      } else {\n        exhausted = true;\n        input.end();\n        endState = captureState();\n        numFillerTokensToInsert = Math.min(posIncrAtt.getPositionIncrement(), maxShingleSize - 1);\n        if (numFillerTokensToInsert > 0) {\n          nextInputStreamToken = new AttributeSource(getAttributeFactory());\n          nextInputStreamToken.addAttribute(CharTermAttribute.class);\n          OffsetAttribute newOffsetAtt = nextInputStreamToken.addAttribute(OffsetAttribute.class);\n          newOffsetAtt.setOffset(offsetAtt.endOffset(), offsetAtt.endOffset());\n          // Recurse/loop just once:\n          return getNextToken(target);\n        } else {\n          newTarget = null;\n        }\n      }\n    } else {\n      newTarget = null;\n    }\n    return newTarget;\n  }\n\n","sourceOld":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted) {\n      if (input.incrementToken()) {\n        if (null == target) {\n          newTarget = new InputWindowToken(cloneAttributes());\n        } else {\n          this.copyTo(target.attSource);\n        }\n        if (posIncrAtt.getPositionIncrement() > 1) {\n          // Each output shingle must contain at least one input token, \n          // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n          numFillerTokensToInsert = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n          // Save the current token as the next input stream token\n          if (null == nextInputStreamToken) {\n            nextInputStreamToken = cloneAttributes();\n          } else {\n            this.copyTo(nextInputStreamToken);\n          }\n          isNextInputStreamToken = true;\n          // A filler token occupies no space\n          newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n          newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n          newTarget.isFiller = true;\n          --numFillerTokensToInsert;\n        } else {\n          newTarget.isFiller = false;\n        }\n      } else {\n        exhausted = true;\n        input.end();\n        endState = captureState();\n        numFillerTokensToInsert = Math.min(posIncrAtt.getPositionIncrement(), maxShingleSize - 1);\n        if (numFillerTokensToInsert > 0) {\n          nextInputStreamToken = new AttributeSource(getAttributeFactory());\n          nextInputStreamToken.addAttribute(CharTermAttribute.class);\n          OffsetAttribute newOffsetAtt = nextInputStreamToken.addAttribute(OffsetAttribute.class);\n          newOffsetAtt.setOffset(offsetAtt.endOffset(), offsetAtt.endOffset());\n          // Recurse/loop just once:\n          return getNextToken(target);\n        } else {\n          newTarget = null;\n        }\n      }\n    } else {\n      newTarget = null;\n    }\n    return newTarget;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","sourceNew":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement &gt; 1</code>,\n   * <code>positionIncrement - 1</code> {@link #fillerToken}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(fillerToken, 0, fillerToken.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted) {\n      if (input.incrementToken()) {\n        if (null == target) {\n          newTarget = new InputWindowToken(cloneAttributes());\n        } else {\n          this.copyTo(target.attSource);\n        }\n        if (posIncrAtt.getPositionIncrement() > 1) {\n          // Each output shingle must contain at least one input token, \n          // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n          numFillerTokensToInsert = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n          // Save the current token as the next input stream token\n          if (null == nextInputStreamToken) {\n            nextInputStreamToken = cloneAttributes();\n          } else {\n            this.copyTo(nextInputStreamToken);\n          }\n          isNextInputStreamToken = true;\n          // A filler token occupies no space\n          newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n          newTarget.termAtt.copyBuffer(fillerToken, 0, fillerToken.length);\n          newTarget.isFiller = true;\n          --numFillerTokensToInsert;\n        } else {\n          newTarget.isFiller = false;\n        }\n      } else {\n        exhausted = true;\n        input.end();\n        endState = captureState();\n        numFillerTokensToInsert = Math.min(posIncrAtt.getPositionIncrement(), maxShingleSize - 1);\n        if (numFillerTokensToInsert > 0) {\n          nextInputStreamToken = new AttributeSource(getAttributeFactory());\n          nextInputStreamToken.addAttribute(CharTermAttribute.class);\n          OffsetAttribute newOffsetAtt = nextInputStreamToken.addAttribute(OffsetAttribute.class);\n          newOffsetAtt.setOffset(offsetAtt.endOffset(), offsetAtt.endOffset());\n          // Recurse/loop just once:\n          return getNextToken(target);\n        } else {\n          newTarget = null;\n        }\n      }\n    } else {\n      newTarget = null;\n    }\n    return newTarget;\n  }\n\n","sourceOld":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #fillerToken}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(fillerToken, 0, fillerToken.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted) {\n      if (input.incrementToken()) {\n        if (null == target) {\n          newTarget = new InputWindowToken(cloneAttributes());\n        } else {\n          this.copyTo(target.attSource);\n        }\n        if (posIncrAtt.getPositionIncrement() > 1) {\n          // Each output shingle must contain at least one input token, \n          // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n          numFillerTokensToInsert = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n          // Save the current token as the next input stream token\n          if (null == nextInputStreamToken) {\n            nextInputStreamToken = cloneAttributes();\n          } else {\n            this.copyTo(nextInputStreamToken);\n          }\n          isNextInputStreamToken = true;\n          // A filler token occupies no space\n          newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n          newTarget.termAtt.copyBuffer(fillerToken, 0, fillerToken.length);\n          newTarget.isFiller = true;\n          --numFillerTokensToInsert;\n        } else {\n          newTarget.isFiller = false;\n        }\n      } else {\n        exhausted = true;\n        input.end();\n        endState = captureState();\n        numFillerTokensToInsert = Math.min(posIncrAtt.getPositionIncrement(), maxShingleSize - 1);\n        if (numFillerTokensToInsert > 0) {\n          nextInputStreamToken = new AttributeSource(getAttributeFactory());\n          nextInputStreamToken.addAttribute(CharTermAttribute.class);\n          OffsetAttribute newOffsetAtt = nextInputStreamToken.addAttribute(OffsetAttribute.class);\n          newOffsetAtt.setOffset(offsetAtt.endOffset(), offsetAtt.endOffset());\n          // Recurse/loop just once:\n          return getNextToken(target);\n        } else {\n          newTarget = null;\n        }\n      }\n    } else {\n      newTarget = null;\n    }\n    return newTarget;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["6237bacfd44ad16661121d7d8a604a57f78978e9"],"1fec40a4bb4fb8565560f443818a3ae4c42b8b2f":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6237bacfd44ad16661121d7d8a604a57f78978e9":["1fec40a4bb4fb8565560f443818a3ae4c42b8b2f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1fec40a4bb4fb8565560f443818a3ae4c42b8b2f":["6237bacfd44ad16661121d7d8a604a57f78978e9"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"6237bacfd44ad16661121d7d8a604a57f78978e9":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["1fec40a4bb4fb8565560f443818a3ae4c42b8b2f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}