{"path":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#testBigIntNDims().mjava","commits":[{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#testBigIntNDims().mjava","pathOld":"/dev/null","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setCodec(new SimpleTextCodec());\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          BKDUtil.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new DimensionalField(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.QUERY_OUTSIDE_CELL;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.QUERY_CROSSES_CELL;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["71da933d30aea361ccc224d6544c451cbf49916d","71da933d30aea361ccc224d6544c451cbf49916d","71da933d30aea361ccc224d6544c451cbf49916d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1eee4175312c41f89aa23427f9e4edfc00deeaac","date":1446373190,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          BKDUtil.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new DimensionalField(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.QUERY_OUTSIDE_CELL;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.QUERY_CROSSES_CELL;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setCodec(new SimpleTextCodec());\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          BKDUtil.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new DimensionalField(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.QUERY_OUTSIDE_CELL;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.QUERY_CROSSES_CELL;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          BKDUtil.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new DimensionalField(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          BKDUtil.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new DimensionalField(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.QUERY_OUTSIDE_CELL;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.QUERY_CROSSES_CELL;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, DimensionalValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, DimensionalValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new DimensionalBinaryField(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          BKDUtil.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new DimensionalField(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPointValues#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, DimensionalValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, DimensionalValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new DimensionalBinaryField(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["770342641f7b505eaa8dccdc666158bff2419109"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1eee4175312c41f89aa23427f9e4edfc00deeaac":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["1eee4175312c41f89aa23427f9e4edfc00deeaac"],"770342641f7b505eaa8dccdc666158bff2419109":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"]},"commit2Childs":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["1eee4175312c41f89aa23427f9e4edfc00deeaac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"1eee4175312c41f89aa23427f9e4edfc00deeaac":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["770342641f7b505eaa8dccdc666158bff2419109"],"770342641f7b505eaa8dccdc666158bff2419109":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}