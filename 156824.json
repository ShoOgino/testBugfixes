{"path":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","commits":[{"id":"54bb8da55080e4569804e0661b83a3c72cbd8d4d","date":1429691126,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","pathOld":"/dev/null","sourceNew":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    Logger.getLogger(\"org.apache.solr\").setLevel(Level.WARN);\n    final String configName = \"testconfig\";\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    uploadConfig(configDir, configName); // upload config once, to be used by all collections\n    final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n    \n    try {\n      solrClient.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d2d4aa3d1fb1b943012b89067a53974585245197"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2d4aa3d1fb1b943012b89067a53974585245197","date":1432947377,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    // TODO: no idea what this test needs to override the level, but regardless of reason it should\n    // reset when it's done.\n    final Logger logger = Logger.getLogger(\"org.apache.solr\");\n    final Level SAVED_LEVEL = logger.getLevel();\n    try {\n      logger.setLevel(Level.WARN);\n      final String configName = \"testconfig\";\n      final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n      uploadConfig(configDir, configName); // upload config once, to be used by all collections\n      final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n      final AtomicReference<Exception> failure = new AtomicReference<>();\n      final int timeToRunSec = 30;\n      final Thread[] threads = new Thread[2];\n      for (int i = 0; i < threads.length; i++) {\n        final String collectionName = \"collection\" + i;\n        threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName, \n                                                      timeToRunSec, solrClient, failure);\n      }\n    \n      startAll(threads);\n      joinAll(threads);\n    \n      assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n      \n      try {\n        solrClient.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    } finally {\n      logger.setLevel(SAVED_LEVEL);\n    }\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    Logger.getLogger(\"org.apache.solr\").setLevel(Level.WARN);\n    final String configName = \"testconfig\";\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    uploadConfig(configDir, configName); // upload config once, to be used by all collections\n    final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n    \n    try {\n      solrClient.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":["54bb8da55080e4569804e0661b83a3c72cbd8d4d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1a70d04f6bb2fdf51a08d4d2cb919057f29f0b1","date":1437834887,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    uploadConfig(configDir, configName); // upload config once, to be used by all collections\n    final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n\n    try {\n      solrClient.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    // TODO: no idea what this test needs to override the level, but regardless of reason it should\n    // reset when it's done.\n    final Logger logger = Logger.getLogger(\"org.apache.solr\");\n    final Level SAVED_LEVEL = logger.getLevel();\n    try {\n      logger.setLevel(Level.WARN);\n      final String configName = \"testconfig\";\n      final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n      uploadConfig(configDir, configName); // upload config once, to be used by all collections\n      final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n      final AtomicReference<Exception> failure = new AtomicReference<>();\n      final int timeToRunSec = 30;\n      final Thread[] threads = new Thread[2];\n      for (int i = 0; i < threads.length; i++) {\n        final String collectionName = \"collection\" + i;\n        threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName, \n                                                      timeToRunSec, solrClient, failure);\n      }\n    \n      startAll(threads);\n      joinAll(threads);\n    \n      assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n      \n      try {\n        solrClient.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    } finally {\n      logger.setLevel(SAVED_LEVEL);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    uploadConfig(configDir, configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final SolrClient solrClient = getHttpSolrClient(baseUrl);\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n\n    try {\n      solrClient.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    uploadConfig(configDir, configName); // upload config once, to be used by all collections\n    final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n\n    try {\n      solrClient.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    uploadConfig(configDir, configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final SolrClient solrClient = getHttpSolrClient(baseUrl);\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n\n    try {\n      solrClient.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    uploadConfig(configDir, configName); // upload config once, to be used by all collections\n    final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n\n    try {\n      solrClient.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e89a32cc825033ebae8bb9e1c6877c2d9d76749e","date":1476790453,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    uploadConfig(configset(\"configset-2\"), configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final SolrClient solrClient = getHttpSolrClient(baseUrl);\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n\n    try {\n      solrClient.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    uploadConfig(configDir, configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final SolrClient solrClient = getHttpSolrClient(baseUrl);\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n\n    try {\n      solrClient.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    uploadConfig(configset(\"configset-2\"), configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final SolrClient solrClient = getHttpSolrClient(baseUrl);\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n\n    try {\n      solrClient.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    uploadConfig(configDir, configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final SolrClient solrClient = getHttpSolrClient(baseUrl);\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n\n    try {\n      solrClient.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb62399122765831885fcd8484970ba808ac5aaf","date":1485957512,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    uploadConfig(configset(\"configset-2\"), configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final CreateDeleteCollectionThread[] threads = new CreateDeleteCollectionThread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    uploadConfig(configset(\"configset-2\"), configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final SolrClient solrClient = getHttpSolrClient(baseUrl);\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n\n    try {\n      solrClient.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    uploadConfig(configset(\"configset-2\"), configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final CreateDeleteCollectionThread[] threads = new CreateDeleteCollectionThread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    uploadConfig(configset(\"configset-2\"), configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final SolrClient solrClient = getHttpSolrClient(baseUrl);\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n\n    try {\n      solrClient.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    uploadConfig(configset(\"configset-2\"), configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final CreateDeleteCollectionThread[] threads = new CreateDeleteCollectionThread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    uploadConfig(configset(\"configset-2\"), configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final CreateDeleteCollectionThread[] threads = new CreateDeleteCollectionThread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteOverTheSameConfig().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    uploadConfig(configset(\"configset-2\"), configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final CreateDeleteCollectionThread[] threads = new CreateDeleteCollectionThread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteOverTheSameConfig() {\n    final String configName = \"testconfig\";\n    uploadConfig(configset(\"configset-2\"), configName); // upload config once, to be used by all collections\n    final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final CreateDeleteCollectionThread[] threads = new CreateDeleteCollectionThread[2];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, configName,\n                                                    timeToRunSec, solrClient, failure);\n    }\n\n    startAll(threads);\n    joinAll(threads);\n\n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["fb62399122765831885fcd8484970ba808ac5aaf","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"54bb8da55080e4569804e0661b83a3c72cbd8d4d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["c1a70d04f6bb2fdf51a08d4d2cb919057f29f0b1"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fb62399122765831885fcd8484970ba808ac5aaf"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["fb62399122765831885fcd8484970ba808ac5aaf"],"fb62399122765831885fcd8484970ba808ac5aaf":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"d2d4aa3d1fb1b943012b89067a53974585245197":["54bb8da55080e4569804e0661b83a3c72cbd8d4d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["c1a70d04f6bb2fdf51a08d4d2cb919057f29f0b1","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"c1a70d04f6bb2fdf51a08d4d2cb919057f29f0b1":["d2d4aa3d1fb1b943012b89067a53974585245197"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["fb62399122765831885fcd8484970ba808ac5aaf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"54bb8da55080e4569804e0661b83a3c72cbd8d4d":["d2d4aa3d1fb1b943012b89067a53974585245197"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"fb62399122765831885fcd8484970ba808ac5aaf":["b94236357aaa22b76c10629851fe4e376e0cea82","7c3523a0ab04c3002eee3896c75ea5f10f388bcc","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"d2d4aa3d1fb1b943012b89067a53974585245197":["c1a70d04f6bb2fdf51a08d4d2cb919057f29f0b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["54bb8da55080e4569804e0661b83a3c72cbd8d4d"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"c1a70d04f6bb2fdf51a08d4d2cb919057f29f0b1":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}