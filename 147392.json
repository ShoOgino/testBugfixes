{"path":"src/test/org/apache/solr/update/TestCSVLoader#testCSV().mjava","commits":[{"id":"792e3ac628bf4023d53724906c0652abd8e47f01","date":1164770752,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/update/TestCSVLoader#testCSV().mjava","pathOld":"/dev/null","sourceNew":"  public void testCSV() throws Exception {\n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\");\n\n    loadLocal(\"file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73d5718093bde1b338e31bfedb43cc124a84577b","date":1164770950,"type":4,"author":"Yonik Seeley","isMerge":false,"pathNew":"/dev/null","pathOld":"src/test/org/apache/solr/update/TestCSVLoader#testCSV().mjava","sourceNew":null,"sourceOld":"  public void testCSV() throws Exception {\n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\");\n\n    loadLocal(\"file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"792e3ac628bf4023d53724906c0652abd8e47f01":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"73d5718093bde1b338e31bfedb43cc124a84577b":["792e3ac628bf4023d53724906c0652abd8e47f01"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["792e3ac628bf4023d53724906c0652abd8e47f01"],"792e3ac628bf4023d53724906c0652abd8e47f01":["73d5718093bde1b338e31bfedb43cc124a84577b"],"73d5718093bde1b338e31bfedb43cc124a84577b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["73d5718093bde1b338e31bfedb43cc124a84577b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}