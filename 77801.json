{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","commits":[{"id":"a6a5c1c40529f15b445e6720dfde1967e139bff1","date":1535375643,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b87bf1141cacf62ff7b9585470d5bf565b3ccc8","date":1536142210,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc18bc8ea2e2c1e308757ff50671c774438e9f3e","date":1538052583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc201e01d035a7370848d9d2451e0e27ee77df2e","date":1544724144,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"374cde0030d329720d59d1c6336d1089bbcd6fd9","date":1544808129,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d35c84fdef07284c122012ca4000d3b7285a66e","date":1545962630,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  // commented out on: 24-Dec-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  // commented out on: 24-Dec-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudUtil.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudUtil.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  // commented out on: 24-Dec-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  // commented out on: 24-Dec-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Collection ready after {} ms\", CloudUtil.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(1, 2, false, true)));\n    }\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Collection ready after {} ms\", CloudUtil.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(1, 2, false, true)));\n    }\n  }\n\n","sourceOld":"  @Test\n  // commented out on: 24-Dec-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudUtil.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudUtil.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  // commented out on: 24-Dec-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Collection ready after {} ms\", CloudUtil.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(1, 2, false, true)));\n    }\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                @SuppressWarnings({\"rawtypes\"})\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      @SuppressWarnings({\"unchecked\"})\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Collection ready after {} ms\", CloudUtil.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(1, 2, false, true)));\n    }\n  }\n\n","sourceOld":"  @Test\n  // commented out on: 24-Dec-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Collection ready after {} ms\", CloudUtil.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(1, 2, false, true)));\n    }\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Collection ready after {} ms\", CloudUtil.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(1, 2, false, true)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  // commented out on: 24-Dec-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.process(solrClient);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Collection ready after {} ms\", CloudUtil.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(1, 2, false, true)));\n    }\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                @SuppressWarnings({\"rawtypes\"})\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      @SuppressWarnings({\"unchecked\"})\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Collection ready after {} ms\", CloudUtil.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(1, 2, false, true)));\n    }\n  }\n\n","sourceOld":"  @Test\n  // commented out on: 24-Dec-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Collection ready after {} ms\", CloudUtil.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(1, 2, false, true)));\n    }\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                @SuppressWarnings({\"rawtypes\"})\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      @SuppressWarnings({\"unchecked\"})\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Collection ready after {} ms\", CloudUtil.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(1, 2, false, true)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","sourceNew":null,"sourceOld":"  @Test\n  // commented out on: 24-Dec-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.process(solrClient);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Collection ready after {} ms\", CloudUtil.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(1, 2, false, true)));\n    }\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode();\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                @SuppressWarnings({\"rawtypes\"})\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(SIM_TIME_SOURCE.getTimeNs()),\n          Collections.singletonList(sourceNodeName), CollectionParams.CollectionAction.MOVEREPLICA.toLower());\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      @SuppressWarnings({\"unchecked\"})\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Collection ready after {} ms\", CloudUtil.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(1, 2, false, true)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["9b87bf1141cacf62ff7b9585470d5bf565b3ccc8"],"a6a5c1c40529f15b445e6720dfde1967e139bff1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3f504512a03d978990cbff30db0522b354e846db":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"9b87bf1141cacf62ff7b9585470d5bf565b3ccc8":["a6a5c1c40529f15b445e6720dfde1967e139bff1"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"bc201e01d035a7370848d9d2451e0e27ee77df2e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["374cde0030d329720d59d1c6336d1089bbcd6fd9"],"374cde0030d329720d59d1c6336d1089bbcd6fd9":["bc201e01d035a7370848d9d2451e0e27ee77df2e"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a6a5c1c40529f15b445e6720dfde1967e139bff1":["9b87bf1141cacf62ff7b9585470d5bf565b3ccc8"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["bc201e01d035a7370848d9d2451e0e27ee77df2e"],"9b87bf1141cacf62ff7b9585470d5bf565b3ccc8":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["3f504512a03d978990cbff30db0522b354e846db"],"bc201e01d035a7370848d9d2451e0e27ee77df2e":["374cde0030d329720d59d1c6336d1089bbcd6fd9"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"374cde0030d329720d59d1c6336d1089bbcd6fd9":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a6a5c1c40529f15b445e6720dfde1967e139bff1"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}