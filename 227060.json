{"path":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.SortFieldsCompare#SortFieldsCompare(SortField[],int).mjava","commits":[{"id":"0325de99180d346d61d36938843a5c8451fe26ae","date":1447368726,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.SortFieldsCompare#SortFieldsCompare(SortField[],int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Constructs an instance based on the the (raw, un-rewritten) SortFields to be used, \n     * and an initial number of expected groups (will grow as needed).\n     */\n    public SortFieldsCompare(SortField[] sorts, int initNumGroups) throws IOException {\n      this.sorts = sorts;\n      numClauses = sorts.length;\n      fieldComparators = new FieldComparator[numClauses];\n      leafFieldComparators = new LeafFieldComparator[numClauses];\n      reverseMul = new int[numClauses];\n      for (int clause = 0; clause < numClauses; clause++) {\n        SortField sf = sorts[clause];\n        // we only need one slot for every comparator\n        fieldComparators[clause] = sf.getComparator(1, clause);\n        reverseMul[clause] = sf.getReverse() ? -1 : 1;\n      }\n      groupHeadValues = new Object[initNumGroups][];\n      nullGroupValues = new Object[numClauses];\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03e38c6374c23083c93e212a9498ff0a9c255476","date":1484767039,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.SortFieldsCompare#SortFieldsCompare(SortField[],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.SortFieldsCompare#SortFieldsCompare(SortField[],int).mjava","sourceNew":"    /**\n     * Constructs an instance based on the the (raw, un-rewritten) SortFields to be used, \n     * and an initial number of expected groups (will grow as needed).\n     */\n    public SortFieldsCompare(SortField[] sorts, int initNumGroups) {\n      this.sorts = sorts;\n      numClauses = sorts.length;\n      fieldComparators = new FieldComparator[numClauses];\n      leafFieldComparators = new LeafFieldComparator[numClauses];\n      reverseMul = new int[numClauses];\n      for (int clause = 0; clause < numClauses; clause++) {\n        SortField sf = sorts[clause];\n        // we only need one slot for every comparator\n        fieldComparators[clause] = sf.getComparator(1, clause);\n        reverseMul[clause] = sf.getReverse() ? -1 : 1;\n      }\n      groupHeadValues = new Object[initNumGroups][];\n      nullGroupValues = new Object[numClauses];\n    }\n\n","sourceOld":"    /**\n     * Constructs an instance based on the the (raw, un-rewritten) SortFields to be used, \n     * and an initial number of expected groups (will grow as needed).\n     */\n    public SortFieldsCompare(SortField[] sorts, int initNumGroups) throws IOException {\n      this.sorts = sorts;\n      numClauses = sorts.length;\n      fieldComparators = new FieldComparator[numClauses];\n      leafFieldComparators = new LeafFieldComparator[numClauses];\n      reverseMul = new int[numClauses];\n      for (int clause = 0; clause < numClauses; clause++) {\n        SortField sf = sorts[clause];\n        // we only need one slot for every comparator\n        fieldComparators[clause] = sf.getComparator(1, clause);\n        reverseMul[clause] = sf.getReverse() ? -1 : 1;\n      }\n      groupHeadValues = new Object[initNumGroups][];\n      nullGroupValues = new Object[numClauses];\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.SortFieldsCompare#SortFieldsCompare(SortField[],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.SortFieldsCompare#SortFieldsCompare(SortField[],int).mjava","sourceNew":"    /**\n     * Constructs an instance based on the the (raw, un-rewritten) SortFields to be used, \n     * and an initial number of expected groups (will grow as needed).\n     */\n    public SortFieldsCompare(SortField[] sorts, int initNumGroups) {\n      this.sorts = sorts;\n      numClauses = sorts.length;\n      fieldComparators = new FieldComparator[numClauses];\n      leafFieldComparators = new LeafFieldComparator[numClauses];\n      reverseMul = new int[numClauses];\n      for (int clause = 0; clause < numClauses; clause++) {\n        SortField sf = sorts[clause];\n        // we only need one slot for every comparator\n        fieldComparators[clause] = sf.getComparator(1, clause);\n        reverseMul[clause] = sf.getReverse() ? -1 : 1;\n      }\n      groupHeadValues = new Object[initNumGroups][];\n      nullGroupValues = new Object[numClauses];\n    }\n\n","sourceOld":"    /**\n     * Constructs an instance based on the the (raw, un-rewritten) SortFields to be used, \n     * and an initial number of expected groups (will grow as needed).\n     */\n    public SortFieldsCompare(SortField[] sorts, int initNumGroups) throws IOException {\n      this.sorts = sorts;\n      numClauses = sorts.length;\n      fieldComparators = new FieldComparator[numClauses];\n      leafFieldComparators = new LeafFieldComparator[numClauses];\n      reverseMul = new int[numClauses];\n      for (int clause = 0; clause < numClauses; clause++) {\n        SortField sf = sorts[clause];\n        // we only need one slot for every comparator\n        fieldComparators[clause] = sf.getComparator(1, clause);\n        reverseMul[clause] = sf.getReverse() ? -1 : 1;\n      }\n      groupHeadValues = new Object[initNumGroups][];\n      nullGroupValues = new Object[numClauses];\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3575e61fd7df2bbcce8b977a23d3d67aa423ce62","date":1586507050,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.SortFieldsCompare#SortFieldsCompare(SortField[],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.SortFieldsCompare#SortFieldsCompare(SortField[],int).mjava","sourceNew":"    /**\n     * Constructs an instance based on the the (raw, un-rewritten) SortFields to be used,\n     * and an initial number of expected groups (will grow as needed).\n     */\n    public SortFieldsCompare(SortField[] sorts, int initNumGroups) {\n      this.sorts = sorts;\n      numClauses = sorts.length;\n      fieldComparators = new FieldComparator[numClauses];\n      leafFieldComparators = new LeafFieldComparator[numClauses];\n      reverseMul = new int[numClauses];\n      for (int clause = 0; clause < numClauses; clause++) {\n        SortField sf = sorts[clause];\n        // we only need one slot for every comparator\n        fieldComparators[clause] = sf.getComparator(1, clause);\n        reverseMul[clause] = sf.getReverse() ? -1 : 1;\n      }\n      groupHeadValues = new Object[initNumGroups][];\n      nullGroupValues = new Object[numClauses];\n    }\n\n","sourceOld":"    /**\n     * Constructs an instance based on the the (raw, un-rewritten) SortFields to be used, \n     * and an initial number of expected groups (will grow as needed).\n     */\n    public SortFieldsCompare(SortField[] sorts, int initNumGroups) {\n      this.sorts = sorts;\n      numClauses = sorts.length;\n      fieldComparators = new FieldComparator[numClauses];\n      leafFieldComparators = new LeafFieldComparator[numClauses];\n      reverseMul = new int[numClauses];\n      for (int clause = 0; clause < numClauses; clause++) {\n        SortField sf = sorts[clause];\n        // we only need one slot for every comparator\n        fieldComparators[clause] = sf.getComparator(1, clause);\n        reverseMul[clause] = sf.getReverse() ? -1 : 1;\n      }\n      groupHeadValues = new Object[initNumGroups][];\n      nullGroupValues = new Object[numClauses];\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50dfd19525c8d73e856dca6edb64b7aea074037f","date":1591579225,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.SortFieldsCompare#SortFieldsCompare(SortField[],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.SortFieldsCompare#SortFieldsCompare(SortField[],int).mjava","sourceNew":"    /**\n     * Constructs an instance based on the the (raw, un-rewritten) SortFields to be used,\n     * and an initial number of expected groups (will grow as needed).\n     */\n    @SuppressWarnings({\"rawtypes\"})\n    public SortFieldsCompare(SortField[] sorts, int initNumGroups) {\n      this.sorts = sorts;\n      numClauses = sorts.length;\n      fieldComparators = new FieldComparator[numClauses];\n      leafFieldComparators = new LeafFieldComparator[numClauses];\n      reverseMul = new int[numClauses];\n      for (int clause = 0; clause < numClauses; clause++) {\n        SortField sf = sorts[clause];\n        // we only need one slot for every comparator\n        fieldComparators[clause] = sf.getComparator(1, clause);\n        reverseMul[clause] = sf.getReverse() ? -1 : 1;\n      }\n      groupHeadValues = new Object[initNumGroups][];\n      nullGroupValues = new Object[numClauses];\n    }\n\n","sourceOld":"    /**\n     * Constructs an instance based on the the (raw, un-rewritten) SortFields to be used,\n     * and an initial number of expected groups (will grow as needed).\n     */\n    public SortFieldsCompare(SortField[] sorts, int initNumGroups) {\n      this.sorts = sorts;\n      numClauses = sorts.length;\n      fieldComparators = new FieldComparator[numClauses];\n      leafFieldComparators = new LeafFieldComparator[numClauses];\n      reverseMul = new int[numClauses];\n      for (int clause = 0; clause < numClauses; clause++) {\n        SortField sf = sorts[clause];\n        // we only need one slot for every comparator\n        fieldComparators[clause] = sf.getComparator(1, clause);\n        reverseMul[clause] = sf.getReverse() ? -1 : 1;\n      }\n      groupHeadValues = new Object[initNumGroups][];\n      nullGroupValues = new Object[numClauses];\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"50dfd19525c8d73e856dca6edb64b7aea074037f":["3575e61fd7df2bbcce8b977a23d3d67aa423ce62"],"3575e61fd7df2bbcce8b977a23d3d67aa423ce62":["03e38c6374c23083c93e212a9498ff0a9c255476"],"03e38c6374c23083c93e212a9498ff0a9c255476":["0325de99180d346d61d36938843a5c8451fe26ae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0325de99180d346d61d36938843a5c8451fe26ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["0325de99180d346d61d36938843a5c8451fe26ae","03e38c6374c23083c93e212a9498ff0a9c255476"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["50dfd19525c8d73e856dca6edb64b7aea074037f"]},"commit2Childs":{"50dfd19525c8d73e856dca6edb64b7aea074037f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3575e61fd7df2bbcce8b977a23d3d67aa423ce62":["50dfd19525c8d73e856dca6edb64b7aea074037f"],"03e38c6374c23083c93e212a9498ff0a9c255476":["3575e61fd7df2bbcce8b977a23d3d67aa423ce62","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0325de99180d346d61d36938843a5c8451fe26ae"],"0325de99180d346d61d36938843a5c8451fe26ae":["03e38c6374c23083c93e212a9498ff0a9c255476","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}