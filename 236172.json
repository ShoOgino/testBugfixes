{"path":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","commits":[{"id":"389d072b64597cdcf75c2d536aaec3e8afe3393f","date":1427818698,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    long startMs = System.currentTimeMillis();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        Executors.newFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \"could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdownNow();\n    }\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(formatString(\n        \"Took {0} secs to set the property {1} to be of version {2} for collection {3}\",\n        Math.round(diffMs / 1000d), prop, expectedVersion, collection));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fab172655716b96f7e42376116235017a922de3a","date":1427850611,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    long startMs = System.currentTimeMillis();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        Executors.newFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \"could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdownNow();\n    }\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(formatString(\n        \"Took {0} secs to set the property {1} to be of version {2} for collection {3}\",\n        Math.round(diffMs / 1000d), prop, expectedVersion, collection));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb5af3afeddbb803fb785098176e6e177c34261b","date":1428905393,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    long startMs = System.currentTimeMillis();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \"could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownNowAndAwaitTermination(parallelExecutor);\n    }\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(formatString(\n        \"Took {0} secs to set the property {1} to be of version {2} for collection {3}\",\n        Math.round(diffMs / 1000d), prop, expectedVersion, collection));\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    long startMs = System.currentTimeMillis();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        Executors.newFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \"could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdownNow();\n    }\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(formatString(\n        \"Took {0} secs to set the property {1} to be of version {2} for collection {3}\",\n        Math.round(diffMs / 1000d), prop, expectedVersion, collection));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \"could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownNowAndAwaitTermination(parallelExecutor);\n    }\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    long startMs = System.currentTimeMillis();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \"could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownNowAndAwaitTermination(parallelExecutor);\n    }\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(formatString(\n        \"Took {0} secs to set the property {1} to be of version {2} for collection {3}\",\n        Math.round(diffMs / 1000d), prop, expectedVersion, collection));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65bb80df7000cd47101332ac36f23a1aa64526c1","date":1440518409,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \"could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(parallelExecutor);\n    }\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \"could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownNowAndAwaitTermination(parallelExecutor);\n    }\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb50877dc038c021eba3a70999fd1f6ed85001c1","date":1563596432,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForAllReplicasState(String collection,\n                                             ZkController zkController,\n                                             String prop,\n                                             int expectedVersion,\n                                             int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    execInparallel(concurrentTasks, parallelExecutor -> {\n      try {\n        List<String> failedList = executeAll(expectedVersion, maxWaitSecs, concurrentTasks, parallelExecutor);\n        // if any tasks haven't completed within the specified timeout, it's an error\n        if (failedList != null)\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                  failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n      } catch (InterruptedException e) {\n        log.warn(formatString(\n            \"Core  was interrupted . trying to set the property {0} to version {1} to propagate to {2} replicas for collection {3}\",\n            prop, expectedVersion, concurrentTasks.size(), collection));\n        Thread.currentThread().interrupt();\n      }\n    });\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \"could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(parallelExecutor);\n    }\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c44cc06c26e456fe9c215072b79fce30babe3975","date":1570365040,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \"could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(parallelExecutor);\n    }\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForAllReplicasState(String collection,\n                                             ZkController zkController,\n                                             String prop,\n                                             int expectedVersion,\n                                             int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    execInparallel(concurrentTasks, parallelExecutor -> {\n      try {\n        List<String> failedList = executeAll(expectedVersion, maxWaitSecs, concurrentTasks, parallelExecutor);\n        // if any tasks haven't completed within the specified timeout, it's an error\n        if (failedList != null)\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                  failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n      } catch (InterruptedException e) {\n        log.warn(formatString(\n            \"Core  was interrupted . trying to set the property {0} to version {1} to propagate to {2} replicas for collection {3}\",\n            prop, expectedVersion, concurrentTasks.size(), collection));\n        Thread.currentThread().interrupt();\n      }\n    });\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","bugFix":null,"bugIntro":["5fb8cae56bd31a827317dd604b1169743f9475f2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \"could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(parallelExecutor);\n    }\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForAllReplicasState(String collection,\n                                             ZkController zkController,\n                                             String prop,\n                                             int expectedVersion,\n                                             int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    execInparallel(concurrentTasks, parallelExecutor -> {\n      try {\n        List<String> failedList = executeAll(expectedVersion, maxWaitSecs, concurrentTasks, parallelExecutor);\n        // if any tasks haven't completed within the specified timeout, it's an error\n        if (failedList != null)\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                  failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n      } catch (InterruptedException e) {\n        log.warn(formatString(\n            \"Core  was interrupted . trying to set the property {0} to version {1} to propagate to {2} replicas for collection {3}\",\n            prop, expectedVersion, concurrentTasks.size(), collection));\n        Thread.currentThread().interrupt();\n      }\n    });\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5fb8cae56bd31a827317dd604b1169743f9475f2","date":1571413113,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \" could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(parallelExecutor);\n    }\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \"could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(parallelExecutor);\n    }\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","bugFix":["c44cc06c26e456fe9c215072b79fce30babe3975"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new SolrNamedThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \" could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(parallelExecutor);\n    }\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \" could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(parallelExecutor);\n    }\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler#waitForAllReplicasState(String,ZkController,String,int,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    if (log.isInfoEnabled()) {\n      log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n          maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n    }\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new SolrNamedThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core {} could not get the expected version {}\", coreUrl, expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(parallelExecutor);\n    }\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n          timer.getTime(), prop, expectedVersion, collection);\n    }\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  private static void waitForAllReplicasState(String collection,\n                                              ZkController zkController,\n                                              String prop,\n                                              int expectedVersion,\n                                              int maxWaitSecs) {\n    final RTimer timer = new RTimer();\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<PerReplicaCallable> concurrentTasks = new ArrayList<>();\n\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection)) {\n      PerReplicaCallable e = new PerReplicaCallable(coreUrl, prop, expectedVersion, maxWaitSecs);\n      concurrentTasks.add(e);\n    }\n    if (concurrentTasks.isEmpty()) return; // nothing to wait for ...\n\n    log.info(formatString(\"Waiting up to {0} secs for {1} replicas to set the property {2} to be of version {3} for collection {4}\",\n        maxWaitSecs, concurrentTasks.size(), prop, expectedVersion, collection));\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new SolrNamedThreadFactory(\"solrHandlerExecutor\"));\n    try {\n      List<Future<Boolean>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f = 0; f < results.size(); f++) {\n        Boolean success = false;\n        Future<Boolean> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check if it succeeded\n          try {\n            success = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (!success) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \" + coreUrl + \" could not get the expected version \" + expectedVersion);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            formatString(\"{0} out of {1} the property {2} to be of version {3} within {4} seconds! Failed cores: {5}\",\n                failedList.size(), concurrentTasks.size() + 1, prop, expectedVersion, maxWaitSecs, failedList));\n\n    } catch (InterruptedException ie) {\n      log.warn(formatString(\n          \"Core  was interrupted . trying to set the property {1} to version {2} to propagate to {3} replicas for collection {4}\",\n          prop, expectedVersion, concurrentTasks.size(), collection));\n      Thread.currentThread().interrupt();\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(parallelExecutor);\n    }\n\n    log.info(\"Took {}ms to set the property {} to be of version {} for collection {}\",\n        timer.getTime(), prop, expectedVersion, collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"389d072b64597cdcf75c2d536aaec3e8afe3393f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c44cc06c26e456fe9c215072b79fce30babe3975":["fb50877dc038c021eba3a70999fd1f6ed85001c1"],"fb50877dc038c021eba3a70999fd1f6ed85001c1":["65bb80df7000cd47101332ac36f23a1aa64526c1"],"5fb8cae56bd31a827317dd604b1169743f9475f2":["c44cc06c26e456fe9c215072b79fce30babe3975"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"65bb80df7000cd47101332ac36f23a1aa64526c1":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["5fb8cae56bd31a827317dd604b1169743f9475f2"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["cb5af3afeddbb803fb785098176e6e177c34261b"],"fab172655716b96f7e42376116235017a922de3a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","389d072b64597cdcf75c2d536aaec3e8afe3393f"],"cb5af3afeddbb803fb785098176e6e177c34261b":["389d072b64597cdcf75c2d536aaec3e8afe3393f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"b0b597c65628ca9e73913a07e81691f8229bae35":["fb50877dc038c021eba3a70999fd1f6ed85001c1","c44cc06c26e456fe9c215072b79fce30babe3975"]},"commit2Childs":{"389d072b64597cdcf75c2d536aaec3e8afe3393f":["fab172655716b96f7e42376116235017a922de3a","cb5af3afeddbb803fb785098176e6e177c34261b"],"c44cc06c26e456fe9c215072b79fce30babe3975":["5fb8cae56bd31a827317dd604b1169743f9475f2","b0b597c65628ca9e73913a07e81691f8229bae35"],"fb50877dc038c021eba3a70999fd1f6ed85001c1":["c44cc06c26e456fe9c215072b79fce30babe3975","b0b597c65628ca9e73913a07e81691f8229bae35"],"5fb8cae56bd31a827317dd604b1169743f9475f2":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["389d072b64597cdcf75c2d536aaec3e8afe3393f","fab172655716b96f7e42376116235017a922de3a"],"65bb80df7000cd47101332ac36f23a1aa64526c1":["fb50877dc038c021eba3a70999fd1f6ed85001c1"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["65bb80df7000cd47101332ac36f23a1aa64526c1"],"fab172655716b96f7e42376116235017a922de3a":[],"cb5af3afeddbb803fb785098176e6e177c34261b":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["fab172655716b96f7e42376116235017a922de3a","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}