{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","commits":[{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null && req.getPath().startsWith(\"/admin/autoscaling\") ||\n        req.getPath().startsWith(\"/cluster/autoscaling\")) {\n      incrementCount(\"autoscaling\");\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      params.set(CommonParams.PATH, req.getPath());\n      LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n      RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      cw.write(baos);\n      String payload = baos.toString(\"UTF-8\");\n      LOG.trace(\"-- payload: {}\", payload);\n      queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n      queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n      SolrQueryResponse queryResponse = new SolrQueryResponse();\n      autoScalingHandler.handleRequest(queryRequest, queryResponse);\n      if (queryResponse.getException() != null) {\n        throw new IOException(queryResponse.getException());\n      }\n      SolrResponse rsp = new SolrResponseBase();\n      rsp.setResponse(queryResponse.getValues());\n      LOG.trace(\"-- response: {}\", rsp);\n      return rsp;\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      // support only updates to the system collection\n      UpdateRequest ureq = (UpdateRequest)req;\n      if (ureq.getCollection() == null || !ureq.getCollection().equals(CollectionAdminParams.SYSTEM_COLL)) {\n        throw new UnsupportedOperationException(\"Only .system updates are supported but got: \" + req);\n      }\n      List<SolrInputDocument> docs = ureq.getDocuments();\n      if (docs != null) {\n        systemColl.addAll(docs);\n      }\n      return new UpdateResponse();\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.debug(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n              req.getParams().get(CommonAdminParams.ASYNC), results);\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4422b331d00607258b0ed3e43934306e67764aa","date":1513943901,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null && req.getPath().startsWith(\"/admin/autoscaling\") ||\n        req.getPath().startsWith(\"/cluster/autoscaling\")) {\n      incrementCount(\"autoscaling\");\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      params.set(CommonParams.PATH, req.getPath());\n      LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n      RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      cw.write(baos);\n      String payload = baos.toString(\"UTF-8\");\n      LOG.trace(\"-- payload: {}\", payload);\n      queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n      queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n      SolrQueryResponse queryResponse = new SolrQueryResponse();\n      autoScalingHandler.handleRequest(queryRequest, queryResponse);\n      if (queryResponse.getException() != null) {\n        throw new IOException(queryResponse.getException());\n      }\n      SolrResponse rsp = new SolrResponseBase();\n      rsp.setResponse(queryResponse.getValues());\n      LOG.trace(\"-- response: {}\", rsp);\n      return rsp;\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      // support only updates to the system collection\n      UpdateRequest ureq = (UpdateRequest)req;\n      if (ureq.getCollection() == null || !ureq.getCollection().equals(CollectionAdminParams.SYSTEM_COLL)) {\n        throw new UnsupportedOperationException(\"Only .system updates are supported but got: \" + req);\n      }\n      List<SolrInputDocument> docs = ureq.getDocuments();\n      if (docs != null) {\n        systemColl.addAll(docs);\n      }\n      return new UpdateResponse();\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n              req.getParams().get(CommonAdminParams.ASYNC), results);\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null && req.getPath().startsWith(\"/admin/autoscaling\") ||\n        req.getPath().startsWith(\"/cluster/autoscaling\")) {\n      incrementCount(\"autoscaling\");\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      params.set(CommonParams.PATH, req.getPath());\n      LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n      RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      cw.write(baos);\n      String payload = baos.toString(\"UTF-8\");\n      LOG.trace(\"-- payload: {}\", payload);\n      queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n      queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n      SolrQueryResponse queryResponse = new SolrQueryResponse();\n      autoScalingHandler.handleRequest(queryRequest, queryResponse);\n      if (queryResponse.getException() != null) {\n        throw new IOException(queryResponse.getException());\n      }\n      SolrResponse rsp = new SolrResponseBase();\n      rsp.setResponse(queryResponse.getValues());\n      LOG.trace(\"-- response: {}\", rsp);\n      return rsp;\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      // support only updates to the system collection\n      UpdateRequest ureq = (UpdateRequest)req;\n      if (ureq.getCollection() == null || !ureq.getCollection().equals(CollectionAdminParams.SYSTEM_COLL)) {\n        throw new UnsupportedOperationException(\"Only .system updates are supported but got: \" + req);\n      }\n      List<SolrInputDocument> docs = ureq.getDocuments();\n      if (docs != null) {\n        systemColl.addAll(docs);\n      }\n      return new UpdateResponse();\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.debug(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n              req.getParams().get(CommonAdminParams.ASYNC), results);\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c6c0dad4932399aec99b4818086cb1772773916","date":1520515900,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null && req.getPath().startsWith(\"/admin/autoscaling\") ||\n        req.getPath().startsWith(\"/cluster/autoscaling\")) {\n      incrementCount(\"autoscaling\");\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      params.set(CommonParams.PATH, req.getPath());\n      LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n      RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      cw.write(baos);\n      String payload = baos.toString(\"UTF-8\");\n      LOG.trace(\"-- payload: {}\", payload);\n      queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n      queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n      SolrQueryResponse queryResponse = new SolrQueryResponse();\n      autoScalingHandler.handleRequest(queryRequest, queryResponse);\n      if (queryResponse.getException() != null) {\n        LOG.debug(\"-- exception handling request\", queryResponse.getException());\n        throw new IOException(queryResponse.getException());\n      }\n      SolrResponse rsp = new SolrResponseBase();\n      rsp.setResponse(queryResponse.getValues());\n      LOG.trace(\"-- response: {}\", rsp);\n      return rsp;\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      // support only updates to the system collection\n      UpdateRequest ureq = (UpdateRequest)req;\n      if (ureq.getCollection() == null || !ureq.getCollection().equals(CollectionAdminParams.SYSTEM_COLL)) {\n        throw new UnsupportedOperationException(\"Only .system updates are supported but got: \" + req);\n      }\n      List<SolrInputDocument> docs = ureq.getDocuments();\n      if (docs != null) {\n        systemColl.addAll(docs);\n      }\n      return new UpdateResponse();\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n              req.getParams().get(CommonAdminParams.ASYNC), results);\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null && req.getPath().startsWith(\"/admin/autoscaling\") ||\n        req.getPath().startsWith(\"/cluster/autoscaling\")) {\n      incrementCount(\"autoscaling\");\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      params.set(CommonParams.PATH, req.getPath());\n      LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n      RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      cw.write(baos);\n      String payload = baos.toString(\"UTF-8\");\n      LOG.trace(\"-- payload: {}\", payload);\n      queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n      queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n      SolrQueryResponse queryResponse = new SolrQueryResponse();\n      autoScalingHandler.handleRequest(queryRequest, queryResponse);\n      if (queryResponse.getException() != null) {\n        throw new IOException(queryResponse.getException());\n      }\n      SolrResponse rsp = new SolrResponseBase();\n      rsp.setResponse(queryResponse.getValues());\n      LOG.trace(\"-- response: {}\", rsp);\n      return rsp;\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      // support only updates to the system collection\n      UpdateRequest ureq = (UpdateRequest)req;\n      if (ureq.getCollection() == null || !ureq.getCollection().equals(CollectionAdminParams.SYSTEM_COLL)) {\n        throw new UnsupportedOperationException(\"Only .system updates are supported but got: \" + req);\n      }\n      List<SolrInputDocument> docs = ureq.getDocuments();\n      if (docs != null) {\n        systemColl.addAll(docs);\n      }\n      return new UpdateResponse();\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n              req.getParams().get(CommonAdminParams.ASYNC), results);\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1","date":1523453934,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null && req.getPath().startsWith(\"/admin/autoscaling\") ||\n        req.getPath().startsWith(\"/cluster/autoscaling\")) {\n      incrementCount(\"autoscaling\");\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      params.set(CommonParams.PATH, req.getPath());\n      LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n      RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      cw.write(baos);\n      String payload = baos.toString(\"UTF-8\");\n      LOG.trace(\"-- payload: {}\", payload);\n      queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n      queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n      SolrQueryResponse queryResponse = new SolrQueryResponse();\n      autoScalingHandler.handleRequest(queryRequest, queryResponse);\n      if (queryResponse.getException() != null) {\n        LOG.debug(\"-- exception handling request\", queryResponse.getException());\n        throw new IOException(queryResponse.getException());\n      }\n      SolrResponse rsp = new SolrResponseBase();\n      rsp.setResponse(queryResponse.getValues());\n      LOG.trace(\"-- response: {}\", rsp);\n      return rsp;\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      // support only updates to the system collection\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      if (collection != null && !collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        // simulate an update\n        return clusterStateProvider.simUpdate(ureq);\n      } else {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null && req.getPath().startsWith(\"/admin/autoscaling\") ||\n        req.getPath().startsWith(\"/cluster/autoscaling\")) {\n      incrementCount(\"autoscaling\");\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      params.set(CommonParams.PATH, req.getPath());\n      LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n      RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      cw.write(baos);\n      String payload = baos.toString(\"UTF-8\");\n      LOG.trace(\"-- payload: {}\", payload);\n      queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n      queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n      SolrQueryResponse queryResponse = new SolrQueryResponse();\n      autoScalingHandler.handleRequest(queryRequest, queryResponse);\n      if (queryResponse.getException() != null) {\n        LOG.debug(\"-- exception handling request\", queryResponse.getException());\n        throw new IOException(queryResponse.getException());\n      }\n      SolrResponse rsp = new SolrResponseBase();\n      rsp.setResponse(queryResponse.getValues());\n      LOG.trace(\"-- response: {}\", rsp);\n      return rsp;\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      // support only updates to the system collection\n      UpdateRequest ureq = (UpdateRequest)req;\n      if (ureq.getCollection() == null || !ureq.getCollection().equals(CollectionAdminParams.SYSTEM_COLL)) {\n        throw new UnsupportedOperationException(\"Only .system updates are supported but got: \" + req);\n      }\n      List<SolrInputDocument> docs = ureq.getDocuments();\n      if (docs != null) {\n        systemColl.addAll(docs);\n      }\n      return new UpdateResponse();\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n              req.getParams().get(CommonAdminParams.ASYNC), results);\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43345f1452f9510f8aaadae6156fe0c834e7d957","date":1523483670,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null && req.getPath().startsWith(\"/admin/autoscaling\") ||\n        req.getPath().startsWith(\"/cluster/autoscaling\")) {\n      incrementCount(\"autoscaling\");\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      params.set(CommonParams.PATH, req.getPath());\n      LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n      RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      cw.write(baos);\n      String payload = baos.toString(\"UTF-8\");\n      LOG.trace(\"-- payload: {}\", payload);\n      queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n      queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n      SolrQueryResponse queryResponse = new SolrQueryResponse();\n      autoScalingHandler.handleRequest(queryRequest, queryResponse);\n      if (queryResponse.getException() != null) {\n        LOG.debug(\"-- exception handling request\", queryResponse.getException());\n        throw new IOException(queryResponse.getException());\n      }\n      SolrResponse rsp = new SolrResponseBase();\n      rsp.setResponse(queryResponse.getValues());\n      LOG.trace(\"-- response: {}\", rsp);\n      return rsp;\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      // support only updates to the system collection\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      if (collection != null && !collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        // simulate an update\n        return clusterStateProvider.simUpdate(ureq);\n      } else {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null && req.getPath().startsWith(\"/admin/autoscaling\") ||\n        req.getPath().startsWith(\"/cluster/autoscaling\")) {\n      incrementCount(\"autoscaling\");\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      params.set(CommonParams.PATH, req.getPath());\n      LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n      RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      cw.write(baos);\n      String payload = baos.toString(\"UTF-8\");\n      LOG.trace(\"-- payload: {}\", payload);\n      queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n      queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n      SolrQueryResponse queryResponse = new SolrQueryResponse();\n      autoScalingHandler.handleRequest(queryRequest, queryResponse);\n      if (queryResponse.getException() != null) {\n        LOG.debug(\"-- exception handling request\", queryResponse.getException());\n        throw new IOException(queryResponse.getException());\n      }\n      SolrResponse rsp = new SolrResponseBase();\n      rsp.setResponse(queryResponse.getValues());\n      LOG.trace(\"-- response: {}\", rsp);\n      return rsp;\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      // support only updates to the system collection\n      UpdateRequest ureq = (UpdateRequest)req;\n      if (ureq.getCollection() == null || !ureq.getCollection().equals(CollectionAdminParams.SYSTEM_COLL)) {\n        throw new UnsupportedOperationException(\"Only .system updates are supported but got: \" + req);\n      }\n      List<SolrInputDocument> docs = ureq.getDocuments();\n      if (docs != null) {\n        systemColl.addAll(docs);\n      }\n      return new UpdateResponse();\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n              req.getParams().get(CommonAdminParams.ASYNC), results);\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a","date":1527582939,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics/history\") ||\n          req.getPath().startsWith(\"/cluster/metrics/history\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else {\n          incrementCount(\"metricsHistory\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          LOG.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (historyHandler != null) {\n            historyHandler.handleRequest(queryRequest, queryResponse);\n          } else {\n            throw new UnsupportedOperationException(\"must add at least 1 node first\");\n          }\n        }\n        if (queryResponse.getException() != null) {\n          LOG.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        LOG.trace(\"-- response: {}\", rsp);\n        return rsp;\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null && req.getPath().startsWith(\"/admin/autoscaling\") ||\n        req.getPath().startsWith(\"/cluster/autoscaling\")) {\n      incrementCount(\"autoscaling\");\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      params.set(CommonParams.PATH, req.getPath());\n      LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n      RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      cw.write(baos);\n      String payload = baos.toString(\"UTF-8\");\n      LOG.trace(\"-- payload: {}\", payload);\n      queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n      queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n      SolrQueryResponse queryResponse = new SolrQueryResponse();\n      autoScalingHandler.handleRequest(queryRequest, queryResponse);\n      if (queryResponse.getException() != null) {\n        LOG.debug(\"-- exception handling request\", queryResponse.getException());\n        throw new IOException(queryResponse.getException());\n      }\n      SolrResponse rsp = new SolrResponseBase();\n      rsp.setResponse(queryResponse.getValues());\n      LOG.trace(\"-- response: {}\", rsp);\n      return rsp;\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      // support only updates to the system collection\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      if (collection != null && !collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        // simulate an update\n        return clusterStateProvider.simUpdate(ureq);\n      } else {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8f0f2472d437d44ec2144932e1d13fb494e82a3","date":1528403207,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics/history\") ||\n          req.getPath().startsWith(\"/cluster/metrics/history\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else {\n          incrementCount(\"metricsHistory\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          LOG.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (historyHandler != null) {\n            historyHandler.handleRequest(queryRequest, queryResponse);\n          } else {\n            throw new UnsupportedOperationException(\"must add at least 1 node first\");\n          }\n        }\n        if (queryResponse.getException() != null) {\n          LOG.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        LOG.trace(\"-- response: {}\", rsp);\n        return rsp;\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics/history\") ||\n          req.getPath().startsWith(\"/cluster/metrics/history\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else {\n          incrementCount(\"metricsHistory\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          LOG.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (historyHandler != null) {\n            historyHandler.handleRequest(queryRequest, queryResponse);\n          } else {\n            throw new UnsupportedOperationException(\"must add at least 1 node first\");\n          }\n        }\n        if (queryResponse.getException() != null) {\n          LOG.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        LOG.trace(\"-- response: {}\", rsp);\n        return rsp;\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b55cd711a129fb7fc4c3c4672d652149c9a4faa","date":1528813320,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          LOG.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          LOG.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        LOG.trace(\"-- response: {}\", rsp);\n        return rsp;\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics/history\") ||\n          req.getPath().startsWith(\"/cluster/metrics/history\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else {\n          incrementCount(\"metricsHistory\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          LOG.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (historyHandler != null) {\n            historyHandler.handleRequest(queryRequest, queryResponse);\n          } else {\n            throw new UnsupportedOperationException(\"must add at least 1 node first\");\n          }\n        }\n        if (queryResponse.getException() != null) {\n          LOG.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        LOG.trace(\"-- response: {}\", rsp);\n        return rsp;\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          LOG.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          LOG.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        LOG.trace(\"-- response: {}\", rsp);\n        return rsp;\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics/history\") ||\n          req.getPath().startsWith(\"/cluster/metrics/history\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else {\n          incrementCount(\"metricsHistory\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          LOG.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (historyHandler != null) {\n            historyHandler.handleRequest(queryRequest, queryResponse);\n          } else {\n            throw new UnsupportedOperationException(\"must add at least 1 node first\");\n          }\n        }\n        if (queryResponse.getException() != null) {\n          LOG.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        LOG.trace(\"-- response: {}\", rsp);\n        return rsp;\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          LOG.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          LOG.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        LOG.trace(\"-- response: {}\", rsp);\n        return rsp;\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics/history\") ||\n          req.getPath().startsWith(\"/cluster/metrics/history\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else {\n          incrementCount(\"metricsHistory\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          LOG.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (historyHandler != null) {\n            historyHandler.handleRequest(queryRequest, queryResponse);\n          } else {\n            throw new UnsupportedOperationException(\"must add at least 1 node first\");\n          }\n        }\n        if (queryResponse.getException() != null) {\n          LOG.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        LOG.trace(\"-- response: {}\", rsp);\n        return rsp;\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          log.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    LOG.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          LOG.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          LOG.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        LOG.trace(\"-- response: {}\", rsp);\n        return rsp;\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      LOG.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc18bc8ea2e2c1e308757ff50671c774438e9f3e","date":1538052583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          log.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new TreeMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          log.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          systemColl.addAll(docs);\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8254aa20264eb7a88d556bbe0346667937ed9c2a","date":1538494545,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          log.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          log.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new TreeMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aee7536c0dab5f97165523b2077d324095f5518","date":1544481552,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          log.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          log.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simAddNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89948af0461fead48f44ba8fb7866f107ce83f22","date":1545157711,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n          cw.write(baos);\n          String payload = baos.toString(\"UTF-8\");\n          log.trace(\"-- payload: {}\", payload);\n          queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    SolrParams params = req.getParams();\n    String a = params != null ? params.get(CoreAdminParams.ACTION) : null;\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (!(req instanceof CollectionAdminRequest)) {\n      // maybe a V2Request?\n      if (req instanceof V2Request) {\n        Map<String, Object> reqMap = new HashMap<>();\n        ((V2Request)req).toMap(reqMap);\n        String path = (String)reqMap.get(\"path\");\n        if (!path.startsWith(\"/c/\") || path.length() < 4) {\n          throw new UnsupportedOperationException(\"Unsupported V2 request path: \" + reqMap);\n        }\n        Map<String, Object> cmd = (Map<String, Object>)reqMap.get(\"command\");\n        if (cmd.size() != 1) {\n          throw new UnsupportedOperationException(\"Unsupported multi-command V2 request: \" + reqMap);\n        }\n        a = cmd.keySet().iterator().next();\n        params = new ModifiableSolrParams();\n        ((ModifiableSolrParams)params).add(CollectionAdminParams.COLLECTION, path.substring(3));\n        if (req.getParams() != null) {\n          ((ModifiableSolrParams)params).add(req.getParams());\n        }\n        Map<String, Object> reqParams = (Map<String, Object>)cmd.get(a);\n        for (Map.Entry<String, Object> e : reqParams.entrySet()) {\n          ((ModifiableSolrParams)params).add(e.getKey(), e.getValue().toString());\n        }\n        // re-map from v2 to v1 action\n        a = v2v1Mapping.get(a);\n        if (a == null) {\n          throw new UnsupportedOperationException(\"Unsupported V2 request: \" + reqMap);\n        }\n      } else {\n        throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName() + \": \" + req.getPath() + \" \" + req.getParams());\n      }\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), params.toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = params.get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = params.get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(params.get(CommonParams.NAME),\n                params.get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (params.get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, params.get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(params.get(\"node\"), \"nodeRole\", params.get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + params);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + params);\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"1aee7536c0dab5f97165523b2077d324095f5518":["8254aa20264eb7a88d556bbe0346667937ed9c2a"],"8254aa20264eb7a88d556bbe0346667937ed9c2a":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["9c6c0dad4932399aec99b4818086cb1772773916","ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1"],"9c6c0dad4932399aec99b4818086cb1772773916":["a4422b331d00607258b0ed3e43934306e67764aa"],"6b55cd711a129fb7fc4c3c4672d652149c9a4faa":["f8f0f2472d437d44ec2144932e1d13fb494e82a3"],"f8f0f2472d437d44ec2144932e1d13fb494e82a3":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a","6b55cd711a129fb7fc4c3c4672d652149c9a4faa"],"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["9c6c0dad4932399aec99b4818086cb1772773916"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a4422b331d00607258b0ed3e43934306e67764aa":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["89948af0461fead48f44ba8fb7866f107ce83f22"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"89948af0461fead48f44ba8fb7866f107ce83f22":["1aee7536c0dab5f97165523b2077d324095f5518"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["6b55cd711a129fb7fc4c3c4672d652149c9a4faa"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a","6b55cd711a129fb7fc4c3c4672d652149c9a4faa"]},"commit2Childs":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["8254aa20264eb7a88d556bbe0346667937ed9c2a"],"1aee7536c0dab5f97165523b2077d324095f5518":["89948af0461fead48f44ba8fb7866f107ce83f22"],"8254aa20264eb7a88d556bbe0346667937ed9c2a":["1aee7536c0dab5f97165523b2077d324095f5518"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"9c6c0dad4932399aec99b4818086cb1772773916":["43345f1452f9510f8aaadae6156fe0c834e7d957","ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1"],"6b55cd711a129fb7fc4c3c4672d652149c9a4faa":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"f8f0f2472d437d44ec2144932e1d13fb494e82a3":["6b55cd711a129fb7fc4c3c4672d652149c9a4faa"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["f8f0f2472d437d44ec2144932e1d13fb494e82a3","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"a4422b331d00607258b0ed3e43934306e67764aa":["9c6c0dad4932399aec99b4818086cb1772773916"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["a4422b331d00607258b0ed3e43934306e67764aa"],"89948af0461fead48f44ba8fb7866f107ce83f22":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}