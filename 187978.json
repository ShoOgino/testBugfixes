{"path":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","commits":[{"id":"f64b7098768253180859cd8faeae6b1a185b06ed","date":1441223971,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // For the X and Y values, we need a D value, which is the AVERAGE D value\n    // for two planes that pass through the two Z points determined here, for the axis in question.\n    final GeoPoint[] zPoints;\n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel) ||\n      !boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // We need unconstrained values in order to compute D\n        zPoints = findIntersections(planetModel, constructNormalizedZPlane(A,B), NO_BOUNDS, NO_BOUNDS);\n        if (zPoints.length == 0) {\n          // No intersections, so plane never intersects world.\n          //System.err.println(\"  plane never intersects world\");\n          return;\n        }\n        //for (final GeoPoint p : zPoints) {\n        //  System.err.println(\"zPoint: \"+p);\n        //}\n      } else {\n        zPoints = null;\n      }\n    } else {\n      zPoints = null;\n    }\n\n    // Do Z.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n        \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      //System.err.println(\"    computing X bound\");\n      if ((Math.abs(B) >= MINIMUM_RESOLUTION || Math.abs(C) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case.  Compute D.\n        //System.err.println(\"    not degenerate; B=\"+B+\"; C=\"+C);\n        final Plane originPlane = constructNormalizedXPlane(B,C,0.0);\n        double DValue = 0.0;\n        if (zPoints != null) {\n          for (final GeoPoint p : zPoints) {\n            final double zValue = originPlane.evaluate(p);\n            //System.err.println(\"    originPlane.evaluate(zpoint)=\"+zValue);\n            DValue += zValue;\n          }\n          DValue /= (double)zPoints.length;\n        }\n        final Plane normalizedXPlane = constructNormalizedXPlane(B,C,-DValue);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedXPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedXPlane.evaluate(point)=\"+normalizedXPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since b==c==0, any plane including the X axis suffices.\n        //System.err.println(\"      Perpendicular to x\");\n        final GeoPoint[] points = findIntersections(planetModel, normalZPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addXValue(points[0]);\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      //System.err.println(\"    computing Y bound\");\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(C) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case.  Compute D.\n        //System.err.println(\"    not degenerate\");\n        final Plane originPlane = constructNormalizedYPlane(A,C,0.0);\n        double DValue = 0.0;\n        if (zPoints != null) {\n          for (final GeoPoint p : zPoints) {\n            DValue += originPlane.evaluate(p);\n          }\n          DValue /= (double)zPoints.length;\n        }\n        final Plane normalizedYPlane = constructNormalizedYPlane(A,C,-DValue);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedYPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedYPlane.evaluate(point)=\"+normalizedYPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==c==0, any plane including the Y axis suffices.\n        // It doesn't matter that we may discard the point due to bounds, because if there are bounds, we'll have endpoints\n        // that will be tallied separately.\n        //System.err.println(\"      Perpendicular to y\");\n        final GeoPoint[] points = findIntersections(planetModel, normalXPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addYValue(points[0]);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["db12cd131bb09d6eb63c19894fedc4a125bdf63a","d8f71af177fad4bbfdf462d318247e573faac27f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8f71af177fad4bbfdf462d318247e573faac27f","date":1441729530,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      //System.err.println(\"    computing X bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          final double l = r * m + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom0 = 0.5 / m;\n          final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n          addPoint(boundsInfo, bounds, thePoint);\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\"Not x quadratic\");\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          final double l = r * m + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom0 = 0.5 / m;\n          final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n          addPoint(boundsInfo, bounds, thePoint);\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // For the X and Y values, we need a D value, which is the AVERAGE D value\n    // for two planes that pass through the two Z points determined here, for the axis in question.\n    final GeoPoint[] zPoints;\n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel) ||\n      !boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // We need unconstrained values in order to compute D\n        zPoints = findIntersections(planetModel, constructNormalizedZPlane(A,B), NO_BOUNDS, NO_BOUNDS);\n        if (zPoints.length == 0) {\n          // No intersections, so plane never intersects world.\n          //System.err.println(\"  plane never intersects world\");\n          return;\n        }\n        //for (final GeoPoint p : zPoints) {\n        //  System.err.println(\"zPoint: \"+p);\n        //}\n      } else {\n        zPoints = null;\n      }\n    } else {\n      zPoints = null;\n    }\n\n    // Do Z.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n        \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      //System.err.println(\"    computing X bound\");\n      if ((Math.abs(B) >= MINIMUM_RESOLUTION || Math.abs(C) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case.  Compute D.\n        //System.err.println(\"    not degenerate; B=\"+B+\"; C=\"+C);\n        final Plane originPlane = constructNormalizedXPlane(B,C,0.0);\n        double DValue = 0.0;\n        if (zPoints != null) {\n          for (final GeoPoint p : zPoints) {\n            final double zValue = originPlane.evaluate(p);\n            //System.err.println(\"    originPlane.evaluate(zpoint)=\"+zValue);\n            DValue += zValue;\n          }\n          DValue /= (double)zPoints.length;\n        }\n        final Plane normalizedXPlane = constructNormalizedXPlane(B,C,-DValue);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedXPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedXPlane.evaluate(point)=\"+normalizedXPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since b==c==0, any plane including the X axis suffices.\n        //System.err.println(\"      Perpendicular to x\");\n        final GeoPoint[] points = findIntersections(planetModel, normalZPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addXValue(points[0]);\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      //System.err.println(\"    computing Y bound\");\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(C) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case.  Compute D.\n        //System.err.println(\"    not degenerate\");\n        final Plane originPlane = constructNormalizedYPlane(A,C,0.0);\n        double DValue = 0.0;\n        if (zPoints != null) {\n          for (final GeoPoint p : zPoints) {\n            DValue += originPlane.evaluate(p);\n          }\n          DValue /= (double)zPoints.length;\n        }\n        final Plane normalizedYPlane = constructNormalizedYPlane(A,C,-DValue);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedYPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedYPlane.evaluate(point)=\"+normalizedYPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==c==0, any plane including the Y axis suffices.\n        // It doesn't matter that we may discard the point due to bounds, because if there are bounds, we'll have endpoints\n        // that will be tallied separately.\n        //System.err.println(\"      Perpendicular to y\");\n        final GeoPoint[] points = findIntersections(planetModel, normalXPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addYValue(points[0]);\n      }\n    }\n  }\n\n","bugFix":["f64b7098768253180859cd8faeae6b1a185b06ed"],"bugIntro":["db12cd131bb09d6eb63c19894fedc4a125bdf63a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b4e444678504caf66a8060b1d514383aa4feac0c","date":1457399659,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/Plane#recordBounds(PlanetModel,XYZBounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      //System.err.println(\"    computing X bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          final double l = r * m + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom0 = 0.5 / m;\n          final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n          addPoint(boundsInfo, bounds, thePoint);\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\"Not x quadratic\");\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          final double l = r * m + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom0 = 0.5 / m;\n          final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n          addPoint(boundsInfo, bounds, thePoint);\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Accumulate (x,y,z) bounds information for this plane, intersected with the unit sphere.\n   * Updates min/max information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the xyz info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final XYZBounds boundsInfo, final Membership... bounds) {\n    // Basic plan is to do three intersections of the plane and the planet.\n    // For min/max x, we intersect a vertical plane such that y = 0.\n    // For min/max y, we intersect a vertical plane such that x = 0.\n    // For min/max z, we intersect a vertical plane that is chosen to go through the high point of the arc.\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Do Z.  This can be done simply because it is symmetrical.\n    if (!boundsInfo.isSmallestMinZ(planetModel) || !boundsInfo.isLargestMaxZ(planetModel)) {\n      //System.err.println(\"    computing Z bound\");\n      // Compute Z bounds for this arc\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a degenerate case\n        //System.err.println(\"    not degenerate\");\n        final Plane normalizedZPlane = constructNormalizedZPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, normalizedZPlane, bounds, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          assert planetModel.pointOnSurface(point);\n          //System.err.println(\"      Point = \"+point+\"; this.evaluate(point)=\"+this.evaluate(point)+\"; normalizedZPlane.evaluate(point)=\"+normalizedZPlane.evaluate(point));\n          addPoint(boundsInfo, bounds, point);\n        }\n      } else {\n        // Since a==b==0, any plane including the Z axis suffices.\n        //System.err.println(\"      Perpendicular to z\");\n        final GeoPoint[] points = findIntersections(planetModel, normalYPlane, NO_BOUNDS, NO_BOUNDS);\n        boundsInfo.addZValue(points[0]);\n      }\n    }\n\n    // First, compute common subexpressions\n    final double k = 1.0 / ((x*x + y*y)*planetModel.ab*planetModel.ab + z*z*planetModel.c*planetModel.c);\n    final double abSquared = planetModel.ab * planetModel.ab;\n    final double cSquared = planetModel.c * planetModel.c;\n    final double ASquared = A * A;\n    final double BSquared = B * B;\n    final double CSquared = C * C;\n    \n    final double r = 2.0*D*k;\n    final double rSquared = r * r;\n    \n    if (!boundsInfo.isSmallestMinX(planetModel) || !boundsInfo.isLargestMaxX(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = x, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (1,0,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 1 = l*A + m*2x/ab^2\n      // 0 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = ((1 - l*A) * ab^2 ) / (2 * m)\n      // y = (-l*B * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find x from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * (((1 - l*A) * ab^2 ) / (2 * m)) + B * ((-l*B * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * ((1 - l*A) * ab^2 ) + B * (-l*B * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // A * ab^2 - l*A^2* ab^2 - B^2 * l * ab^2 - C^2 * l * c^2 + D * 2 * m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (A * ab^2 + D * 2 * m) = 0\n      // l = (A * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = A * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = A * ab^2 * k + m * 2 * D * k\n      // l = k * (A*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = A*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // (((1 - l*A) * ab^2 ) / (2 * m))^2/ab^2 + ((-l*B * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // ((1 - l*A) * ab^2 )^2/ab^2 + (-l*B * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (1 - l*A)^2 * ab^2 + (-l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // (1 - 2*l*A + l^2*A^2) * ab^2 + l^2*B^2 * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // ab^2 - 2*A*ab^2*l + A^2*ab^2*l^2 + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // ab^2 - 2*A*ab^2*(r*m + q) + A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // ab^2 - 2*A*ab^2*r*m - 2*A*ab^2*q + A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m +\n      //        A^2*ab^2*q^2 + B^2*ab^2*r^2*m^2 + 2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [- 2*A*ab^2*r + 2*A^2*ab^2*r*q + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [ab^2 - 2*A*ab^2*q + A^2*ab^2*q^2 + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n      \n      //System.err.println(\"    computing X bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = A*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = - 2.0*A*abSquared*r + 2.0*ASquared*abSquared*r*q + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = abSquared - 2.0*A*abSquared*q + ASquared*abSquared*qSquared + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n      \n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          final double l = r * m + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom0 = 0.5 / m;\n          final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n          addPoint(boundsInfo, bounds, thePoint);\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = ((1 - l*A) * ab^2 ) / (2 * m)\n          // y = (-l*B * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint((1.0-l1*A) * abSquared * denom1, -l1*B * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint((1.0-l2*A) * abSquared * denom2, -l2*B * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point1: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        //System.err.println(\"Not x quadratic\");\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ((1 - l*A) * ab^2 ) / (2 * m)\n        // y = (-l*B * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint((1.0-l*A) * abSquared * denom0, -l*B * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n    \n    // Do Y\n    if (!boundsInfo.isSmallestMinY(planetModel) || !boundsInfo.isLargestMaxY(planetModel)) {\n      // For min/max x, we need to use lagrange multipliers.\n      //\n      // For this, we need grad(F(x,y,z)) = (dF/dx, dF/dy, dF/dz).\n      //\n      // Minimize and maximize f(x,y,z) = y, with respect to g(x,y,z) = Ax + By + Cz - D and h(x,y,z) = x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1\n      //\n      // grad(f(x,y,z)) = (0,1,0)\n      // grad(g(x,y,z)) = (A,B,C)\n      // grad(h(x,y,z)) = (2x/ab^2,2y/ab^2,2z/c^2)\n      //\n      // Equations we need to simultaneously solve:\n      // \n      // grad(f(x,y,z)) = l * grad(g(x,y,z)) + m * grad(h(x,y,z))\n      // g(x,y,z) = 0\n      // h(x,y,z) = 0\n      // \n      // Equations:\n      // 0 = l*A + m*2x/ab^2\n      // 1 = l*B + m*2y/ab^2\n      // 0 = l*C + m*2z/c^2\n      // Ax + By + Cz + D = 0\n      // x^2/ab^2 + y^2/ab^2 + z^2/c^2 - 1 = 0\n      // \n      // Solve for x,y,z in terms of (l, m):\n      // \n      // x = (-l*A * ab^2 ) / (2 * m)\n      // y = ((1 - l*B) * ab^2) / ( 2 * m)\n      // z = (-l*C * c^2)/ (2 * m)\n      // \n      // Two equations, two unknowns:\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // \n      // and\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // \n      // Simple: solve for l and m, then find y from it.\n      // \n      // (a) Use first equation to find l in terms of m.\n      // \n      // A * ((-l*A * ab^2 ) / (2 * m)) + B * (((1 - l*B) * ab^2) / ( 2 * m)) + C * ((-l*C * c^2)/ (2 * m)) + D = 0\n      // A * (-l*A * ab^2 ) + B * ((1-l*B) * ab^2) + C * (-l*C * c^2) + D * 2 * m = 0\n      // -A^2*l*ab^2 + B*ab^2 - l*B^2*ab^2 - C^2*l*c^2 + D*2*m = 0\n      // - l *(A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + (B * ab^2 + D * 2 * m) = 0\n      // l = (B * ab^2 + D * 2 * m) / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // l = B * ab^2 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2) + m * 2 * D / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // For convenience:\n      // \n      // k = 1.0 / (A^2* ab^2 + B^2 * ab^2 + C^2 * c^2)\n      // \n      // Then:\n      // \n      // l = B * ab^2 * k + m * 2 * D * k\n      // l = k * (B*ab^2 + m*2*D)\n      //\n      // For further convenience:\n      //\n      // q = B*ab^2*k\n      // r = 2*D*k\n      //\n      // l = (r*m + q)\n      // l^2 = (r^2 * m^2 + 2*r*m*q + q^2)\n      // \n      // (b) Simplify the second equation before substitution\n      // \n      // ((-l*A * ab^2 ) / (2 * m))^2/ab^2 + (((1 - l*B) * ab^2) / ( 2 * m))^2/ab^2 + ((-l*C * c^2)/ (2 * m))^2/c^2 - 1 = 0\n      // (-l*A * ab^2 )^2/ab^2 + ((1 - l*B) * ab^2)^2/ab^2 + (-l*C * c^2)^2/c^2 = 4 * m^2\n      // (-l*A)^2 * ab^2 + (1 - l*B)^2 * ab^2 + (-l*C)^2 * c^2 = 4 * m^2\n      // l^2*A^2 * ab^2 + (1 - 2*l*B + l^2*B^2) * ab^2 + l^2*C^2 * c^2 = 4 * m^2\n      // A^2*ab^2*l^2 + ab^2 - 2*B*ab^2*l + B^2*ab^2*l^2 + C^2*c^2*l^2 - 4*m^2 = 0\n      // \n      // (c) Substitute for l, l^2\n      //\n      // A^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + ab^2 - 2*B*ab^2*(r*m + q) + B^2*ab^2*(r^2 * m^2 + 2*r*m*q + q^2) + C^2*c^2*(r^2 * m^2 + 2*r*m*q + q^2) - 4*m^2 = 0\n      // A^2*ab^2*r^2*m^2 + 2*A^2*ab^2*r*q*m + A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*r*m - 2*B*ab^2*q + B^2*ab^2*r^2*m^2 +\n      //    2*B^2*ab^2*r*q*m + B^2*ab^2*q^2 + C^2*c^2*r^2*m^2 + 2*C^2*c^2*r*q*m + C^2*c^2*q^2 - 4*m^2 = 0\n      //\n      // (d) Group\n      //\n      // m^2 * [A^2*ab^2*r^2 + B^2*ab^2*r^2 + C^2*c^2*r^2 - 4] +\n      // m * [2*A^2*ab^2*r*q - 2*B*ab^2*r + 2*B^2*ab^2*r*q + 2*C^2*c^2*r*q] +\n      // [A^2*ab^2*q^2 + ab^2 - 2*B*ab^2*q + B^2*ab^2*q^2 + C^2*c^2*q^2]  =  0\n\n      //System.err.println(\"    computing Y bound\");\n      \n      // Useful subexpressions for this bound\n      final double q = B*abSquared*k;\n      final double qSquared = q * q;\n\n      // Quadratic equation\n      final double a = ASquared*abSquared*rSquared + BSquared*abSquared*rSquared + CSquared*cSquared*rSquared - 4.0;\n      final double b = 2.0*ASquared*abSquared*r*q - 2.0*B*abSquared*r + 2.0*BSquared*abSquared*r*q + 2.0*CSquared*cSquared*r*q;\n      final double c = ASquared*abSquared*qSquared + abSquared - 2.0*B*abSquared*q + BSquared*abSquared*qSquared + CSquared*cSquared*qSquared;\n\n      if (Math.abs(a) >= MINIMUM_RESOLUTION_SQUARED) {\n        final double sqrtTerm = b*b - 4.0*a*c;\n        if (Math.abs(sqrtTerm) < MINIMUM_RESOLUTION_SQUARED) {\n          // One solution\n          final double m = -b / (2.0 * a);\n          final double l = r * m + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom0 = 0.5 / m;\n          final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n          addPoint(boundsInfo, bounds, thePoint);\n        } else if (sqrtTerm > 0.0) {\n          // Two solutions\n          final double sqrtResult = Math.sqrt(sqrtTerm);\n          final double commonDenom = 0.5/a;\n          final double m1 = (-b + sqrtResult) * commonDenom;\n          assert Math.abs(a * m1 * m1 + b * m1 + c) < MINIMUM_RESOLUTION;\n          final double m2 = (-b - sqrtResult) * commonDenom;\n          assert Math.abs(a * m2 * m2 + b * m2 + c) < MINIMUM_RESOLUTION;\n          final double l1 = r * m1 + q;\n          final double l2 = r * m2 + q;\n          // x = (-l*A * ab^2 ) / (2 * m)\n          // y = ((1.0-l*B) * ab^2) / ( 2 * m)\n          // z = (-l*C * c^2)/ (2 * m)\n          final double denom1 = 0.5 / m1;\n          final double denom2 = 0.5 / m2;\n          final GeoPoint thePoint1 = new GeoPoint(-l1*A * abSquared * denom1, (1.0-l1*B) * abSquared * denom1, -l1*C * cSquared * denom1);\n          final GeoPoint thePoint2 = new GeoPoint(-l2*A * abSquared * denom2, (1.0-l2*B) * abSquared * denom2, -l2*C * cSquared * denom2);\n          //Math is not quite accurate enough for this\n          //assert planetModel.pointOnSurface(thePoint1): \"Point1: \"+thePoint1+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint1.x*thePoint1.x*planetModel.inverseAb*planetModel.inverseAb + thePoint1.y*thePoint1.y*planetModel.inverseAb*planetModel.inverseAb + thePoint1.z*thePoint1.z*planetModel.inverseC*planetModel.inverseC);\n          //assert planetModel.pointOnSurface(thePoint2): \"Point2: \"+thePoint2+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n          //  (thePoint2.x*thePoint2.x*planetModel.inverseAb*planetModel.inverseAb + thePoint2.y*thePoint2.y*planetModel.inverseAb*planetModel.inverseAb + thePoint2.z*thePoint2.z*planetModel.inverseC*planetModel.inverseC);\n          //assert evaluateIsZero(thePoint1): \"Evaluation of point1: \"+evaluate(thePoint1);\n          //assert evaluateIsZero(thePoint2): \"Evaluation of point2: \"+evaluate(thePoint2);\n          addPoint(boundsInfo, bounds, thePoint1);\n          addPoint(boundsInfo, bounds, thePoint2);\n        } else {\n          // No solutions\n        }\n      } else if (Math.abs(b) > MINIMUM_RESOLUTION_SQUARED) {\n        // a = 0, so m = - c / b\n        final double m = -c / b;\n        final double l = r * m + q;\n        // x = ( -l*A * ab^2 ) / (2 * m)\n        // y = ((1-l*B) * ab^2) / ( 2 * m)\n        // z = (-l*C * c^2)/ (2 * m)\n        final double denom0 = 0.5 / m;\n        final GeoPoint thePoint = new GeoPoint(-l*A * abSquared * denom0, (1.0-l*B) * abSquared * denom0, -l*C * cSquared * denom0);\n        //Math is not quite accurate enough for this\n        //assert planetModel.pointOnSurface(thePoint): \"Point: \"+thePoint+\"; Planetmodel=\"+planetModel+\"; A=\"+A+\" B=\"+B+\" C=\"+C+\" D=\"+D+\" planetfcn=\"+\n        //  (thePoint.x*thePoint.x*planetModel.inverseAb*planetModel.inverseAb + thePoint.y*thePoint.y*planetModel.inverseAb*planetModel.inverseAb + thePoint.z*thePoint.z*planetModel.inverseC*planetModel.inverseC);\n        //assert evaluateIsZero(thePoint): \"Evaluation of point: \"+evaluate(thePoint);\n        addPoint(boundsInfo, bounds, thePoint);\n      } else {\n        // Something went very wrong; a = b = 0\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"d8f71af177fad4bbfdf462d318247e573faac27f":["f64b7098768253180859cd8faeae6b1a185b06ed"],"f64b7098768253180859cd8faeae6b1a185b06ed":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b4e444678504caf66a8060b1d514383aa4feac0c":["d8f71af177fad4bbfdf462d318247e573faac27f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b4e444678504caf66a8060b1d514383aa4feac0c"]},"commit2Childs":{"d8f71af177fad4bbfdf462d318247e573faac27f":["b4e444678504caf66a8060b1d514383aa4feac0c"],"f64b7098768253180859cd8faeae6b1a185b06ed":["d8f71af177fad4bbfdf462d318247e573faac27f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f64b7098768253180859cd8faeae6b1a185b06ed"],"b4e444678504caf66a8060b1d514383aa4feac0c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}